<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Cbor.CBORObject</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>PeterO.Cbor.CBORObject</h1>

<h2>PeterO.Cbor.CBORObject</h2>

<pre>public sealed class CBORObject :
    System.IEquatable,
    System.IComparable
</pre>

<p>Represents an object in Concise Binary Object Representation (CBOR) and contains methods for reading and writing CBOR data. CBOR is defined in RFC 7049.</p>

<p><b>Converting CBOR objects</b></p>

<p>There are many ways to get a CBOR object, including from bytes, objects, streams and JSON, as described below.</p>

<p><b>To and from byte arrays:</b>The CBORObject.DecodeFromBytes method converts a byte array in CBOR ormat to a CBOR object. The EncodeToBytes method converts a CBOR object o its corresponding byte array in CBOR format.</p>

<p><b>To and from data streams:</b>The CBORObject.Write methods write many kinds of objects to a data tream, including numbers, CBOR objects, strings, and arrays of numbers nd strings. The CBORObject.Read method reads a CBOR object from a data tream.</p>

<p><b>To and from other objects:</b>The <code>CBORObject.FromObject
</code> method converts many kinds of objects to a CBOR object, including umbers, strings, and arrays and maps of numbers and strings. Methods ike AsDouble, AsByte, and AsString convert a CBOR object to different ypes of object. The <code>CBORObject.ToObject
</code> method converts a CBOR object to an object of a given type; for xample, a CBOR array to a native <code>List
</code> (or <code>ArrayList
</code> in Java), or a CBOR integer to an <code>int
</code> or <code>long
</code> .</p>

<p><b>To and from JSON:</b>This class also doubles as a reader and writer of JavaScript Object otation (JSON). The CBORObject.FromJSONString method converts JSON to a BOR object, and the ToJSONString method converts a CBOR object to a SON string.</p>

<p>In addition, the CBORObject.WriteJSON method writes many kinds of objects as JSON to a data stream, including numbers, CBOR objects, strings, and arrays of numbers and strings. The CBORObject.Read method reads a CBOR object from a JSON data stream.</p>

<p><b>Comparison Considerations:</b></p>

<p>Instances of CBORObject should not be compared for equality using the &quot;==&quot; operator; it&#39;s possible to create two CBOR objects with the same value but not the same reference. (The &quot;==&quot; operator might only check if each side of the operator is the same instance.)</p>

<p>This class&#39;s natural ordering (under the CompareTo method) is not consistent with the Equals method. This means that two values that compare as equal under the CompareTo method might not be equal under the Equals method. This is important to consider especially if an application wants to compare numbers, since the CBOR number type supports numbers of different formats, such as big integers, rational numbers, and arbitrary-precision decimal numbers.</p>

<p>Another consideration is that two values that are otherwise equal may have different tags. To strip the tags from a CBOR object before comparing, use the <code>Untag
</code> method.</p>

<p>To compare two numbers, the CompareToIgnoreTags or CompareTo method should be used. Which method to use depends on whether two equal values should still be considered equal if they have different tags.</p>

<p>Although this class is inconsistent with the Equals method, it is safe to use CBORObject instances as hash keys as long as all of the keys are untagged text strings (which means GetTags returns an empty array and the Type property, or &quot;getType()&quot; in Java, returns TextString). This is because the natural ordering of these instances is consistent with the Equals method.</p>

<p><b>Thread Safety:</b></p>

<p>CBOR objects that are numbers, &quot;simple values&quot;, and text strings are immutable (their values can&#39;t be changed), so they are inherently safe for use by multiple threads.</p>

<p>CBOR objects that are arrays, maps, and byte strings are mutable, but this class doesn&#39;t attempt to synchronize reads and writes to those objects by multiple threads, so those objects are not thread safe without such synchronization.</p>

<p>One kind of CBOR object is called a map, or a list of key-value pairs. Keys can be any kind of CBOR object, including numbers, strings, arrays, and maps. However, text strings are the most suitable to use as keys; other kinds of CBOR object are much better used as map values instead, keeping in mind that some of them are not thread safe without synchronizing reads and writes to them.</p>

<p>To find the type of a CBOR object, call its Type property (or &quot;getType()&quot; in Java). The return value can be Number, Boolean, SimpleValue, or TextString for immutable CBOR objects, and Array, Map, or ByteString for mutable CBOR objects.</p>

<p><b>Nesting Depth:</b></p>

<p>The DecodeFromBytes and Read methods can only read objects with a limited maximum depth of arrays and maps nested within other arrays and maps. The code sets this maximum depth to 500 (allowing more than enough nesting for most purposes), but it&#39;s possible that stack overflows in some runtimes might lower the effective maximum nesting depth. When the nesting depth goes above 500, the DecodeFromBytes and Read methods throw a CBORException.</p>

<p>The ReadJSON and FromJSONString methods currently have nesting depths of 1000.</p>

<h3>Member Summary</h3>

<ul>
<li><code><a href="#Abs">Abs()</a></code> - Gets this object&#39;s absolute value.</li>
<li><code><a href="#Add_PeterO_Cbor_CBORObject">Add(PeterO.Cbor.CBORObject)</a></code> -  Adds a new object to the end of this array.</li>
<li><code><a href="#Add_object">Add(object)</a></code> -  Converts an object to a CBOR object and adds it to the end of this array.</li>
<li><code><a href="#Add_object_object">Add(object, object)</a></code> -  Adds a new key and its value to this CBOR map, or adds the value if the key doesn&#39;t exist.</li>
<li><code><a href="#Addition_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject">Addition(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Finds the sum of two CBOR numbers.</li>
<li><code><a href="#AsBoolean">AsBoolean()</a></code> - Returns false if this object is False, Null, or Undefined; otherwise,true.</li>
<li><code><a href="#AsByte">AsByte()</a></code> - Converts this object to a byte (0 to 255).</li>
<li><code><a href="#AsDecimal">AsDecimal()</a></code> - Converts this object to a .</li>
<li><code><a href="#AsDouble">AsDouble()</a></code> - Converts this object to a 64-bit floating point number.</li>
<li><code><a href="#AsEDecimal">AsEDecimal()</a></code> - Converts this object to a decimal number.</li>
<li><code><a href="#AsEFloat">AsEFloat()</a></code> - Converts this object to an arbitrary-precision binary floating point number.</li>
<li><code><a href="#AsEInteger">AsEInteger()</a></code> - Converts this object to an arbitrary-precision integer.</li>
<li><code><a href="#AsERational">AsERational()</a></code> - Converts this object to a rational number.</li>
<li><code><a href="#AsInt16">AsInt16()</a></code> - Converts this object to a 16-bit signed integer.</li>
<li><code><a href="#AsInt32">AsInt32()</a></code> - Converts this object to a 32-bit signed integer.</li>
<li><code><a href="#AsInt64">AsInt64()</a></code> - Converts this object to a 64-bit signed integer.</li>
<li><code><a href="#AsSByte">AsSByte()</a></code> - Converts this object to an 8-bit signed integer.</li>
<li><code><a href="#AsSingle">AsSingle()</a></code> - Converts this object to a 32-bit floating point number.</li>
<li><code><a href="#AsString">AsString()</a></code> - Gets the value of this object as a text string.</li>
<li><code><a href="#AsUInt16">AsUInt16()</a></code> - Converts this object to a 16-bit unsigned integer.</li>
<li><code><a href="#AsUInt32">AsUInt32()</a></code> - Converts this object to a 32-bit unsigned integer.</li>
<li><code><a href="#AsUInt64">AsUInt64()</a></code> - Converts this object to a 64-bit unsigned integer.</li>
<li><code><a href="#CanFitInDouble">CanFitInDouble()</a></code> - Returns whether this object&#39;s value can be converted to a 64-bit floating point number without its value being rounded to another numerical value.</li>
<li><code><a href="#CanFitInInt32">CanFitInInt32()</a></code> - Returns whether this object&#39;s numerical value is an integer, is -(2^31) or greater, and is less than 2^31.</li>
<li><code><a href="#CanFitInInt64">CanFitInInt64()</a></code> - Returns whether this object&#39;s numerical value is an integer, is -(2^63) or greater, and is less than 2^63.</li>
<li><code><a href="#CanFitInSingle">CanFitInSingle()</a></code> - Returns whether this object&#39;s value can be converted to a 32-bit floating point number without its value being rounded to another numerical value.</li>
<li><code><a href="#CanTruncatedIntFitInInt32">CanTruncatedIntFitInInt32()</a></code> - Returns whether this object&#39;s value, truncated to an integer, would be -(2^31) or greater, and less than 2^31.</li>
<li><code><a href="#CanTruncatedIntFitInInt64">CanTruncatedIntFitInInt64()</a></code> - Returns whether this object&#39;s value, truncated to an integer, would be -(2^63) or greater, and less than 2^63.</li>
<li><code><a href="#Clear">Clear()</a></code> - Removes all items from this CBOR array or all keys and values from this CBOR map.</li>
<li><code><a href="#CompareToIgnoreTags_PeterO_Cbor_CBORObject">CompareToIgnoreTags(PeterO.Cbor.CBORObject)</a></code> - Compares this object and another CBOR object, ignoring the tags they have, if any.</li>
<li><code><a href="#CompareTo_PeterO_Cbor_CBORObject">CompareTo(PeterO.Cbor.CBORObject)</a></code> - Compares two CBOR objects.</li>
<li><code><a href="#ContainsKey_PeterO_Cbor_CBORObject">ContainsKey(PeterO.Cbor.CBORObject)</a></code> - Determines whether a value of the given key exists in this object.</li>
<li><code><a href="#ContainsKey_object">ContainsKey(object)</a></code> - Determines whether a value of the given key exists in this object.</li>
<li><code><a href="#ContainsKey_string">ContainsKey(string)</a></code> - Determines whether a value of the given key exists in this object.</li>
<li><code><a href="#Count">Count</a></code> - Gets the number of keys in this map, or the number of items in this array, or 0 if this item is neither an array nor a map.</li>
<li><code><a href="#DecodeFromBytes_byte">DecodeFromBytes(byte[])</a></code> -  Generates a CBOR object from an array of CBOR-encoded bytes.</li>
<li><code><a href="#DecodeFromBytes_byte_PeterO_Cbor_CBOREncodeOptions">DecodeFromBytes(byte[], PeterO.Cbor.CBOREncodeOptions)</a></code> - Generates a CBOR object from an array of CBOR-encoded bytes, using the givenCBOREncodeOptions object to control the decoding process.</li>
<li><code><a href="#Divide_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject">Divide(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Divides a CBORObject object by the value of a CBORObject object.</li>
<li><code><a href="#EncodeToBytes">EncodeToBytes()</a></code> -  Writes the binary representation of this CBOR object and returns a byte array of that representation.</li>
<li><code><a href="#EncodeToBytes_PeterO_Cbor_CBOREncodeOptions">EncodeToBytes(PeterO.Cbor.CBOREncodeOptions)</a></code> - Writes the binary representation of this CBOR object and returns a byte array of that representation, using the specified options for encoding the object to CBOR format.</li>
<li><code><a href="#Equals_PeterO_Cbor_CBORObject">Equals(PeterO.Cbor.CBORObject)</a></code> - Compares the equality of two CBOR objects.</li>
<li><code><a href="#Equals_object">Equals(object)</a></code> - Determines whether this object and another object are equal and have the same type.</li>
<li><code><a href="#False">public static readonly PeterO.Cbor.CBORObject False;</a></code> - Represents the value false.</li>
<li><code><a href="#FromJSONString_string">FromJSONString(string)</a></code> -  Generates a CBOR object from a text string in JavaScript Object Notation (JSON) format.</li>
<li><code><a href="#FromJSONString_string_PeterO_Cbor_CBOREncodeOptions">FromJSONString(string, PeterO.Cbor.CBOREncodeOptions)</a></code> - Generates a CBOR object from a text string in JavaScript Object Notation (JSON) format, using the specified options to control the decoding process.</li>
<li><code><a href="#FromObjectAndTag_object_PeterO_Numbers_EInteger">FromObjectAndTag(object, PeterO.Numbers.EInteger)</a></code> - Generates a CBOR object from an arbitrary object and gives the resulting object a tag.</li>
<li><code><a href="#FromObjectAndTag_object_int">FromObjectAndTag(object, int)</a></code> - Generates a CBOR object from an arbitrary object and gives the resulting object a tag.</li>
<li><code><a href="#FromObjectAndTag_object_ulong">FromObjectAndTag(object, ulong)</a></code> - Generates a CBOR object from an arbitrary object and gives the resulting object a tag.</li>
<li><code><a href="#FromObject_PeterO_Cbor_CBORObject">FromObject(PeterO.Cbor.CBORObject)</a></code> - Generates a CBOR object from a CBOR object.</li>
<li><code><a href="#FromObject_PeterO_Numbers_EDecimal">FromObject(PeterO.Numbers.EDecimal)</a></code> - Generates a CBOR object from a decimal number.</li>
<li><code><a href="#FromObject_PeterO_Numbers_EFloat">FromObject(PeterO.Numbers.EFloat)</a></code> - Generates a CBOR object from an arbitrary-precision binary floating-point number.</li>
<li><code><a href="#FromObject_PeterO_Numbers_EInteger">FromObject(PeterO.Numbers.EInteger)</a></code> - Generates a CBOR object from an arbitrary-precision integer.</li>
<li><code><a href="#FromObject_PeterO_Numbers_ERational">FromObject(PeterO.Numbers.ERational)</a></code> - Generates a CBOR object from a rational number.</li>
<li><code><a href="#FromObject_System_Decimal">FromObject(System.Decimal)</a></code> - Converts a .</li>
<li><code><a href="#FromObject_bool">FromObject(bool)</a></code> - Returns the CBOR true value or false value, depending on &quot;value&quot;.</li>
<li><code><a href="#FromObject_byte">FromObject(byte)</a></code> - Generates a CBOR object from a byte (0 to 255).</li>
<li><code><a href="#FromObject_double">FromObject(double)</a></code> - Generates a CBOR object from a 64-bit floating-point number.</li>
<li><code><a href="#FromObject_float">FromObject(float)</a></code> - Generates a CBOR object from a 32-bit floating-point number.</li>
<li><code><a href="#FromObject_int">FromObject(int)</a></code> - Generates a CBOR object from a 32-bit signed integer.</li>
<li><code><a href="#FromObject_long">FromObject(long)</a></code> - Generates a CBOR object from a 64-bit signed integer.</li>
<li><code><a href="#FromObject_object">FromObject(object)</a></code> - Generates a CBORObject from an arbitrary object.</li>
<li><code><a href="#FromObject_object_PeterO_Cbor_CBORTypeMapper">FromObject(object, PeterO.Cbor.CBORTypeMapper)</a></code> - Generates a CBORObject from an arbitrary object.</li>
<li><code><a href="#FromObject_object_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions">FromObject(object, PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)</a></code> -  Generates a CBORObject from an arbitrary object, using the given options to control how certain objects are converted to CBOR objects.</li>
<li><code><a href="#FromObject_object_PeterO_Cbor_PODOptions">FromObject(object, PeterO.Cbor.PODOptions)</a></code> - Generates a CBORObject from an arbitrary object.</li>
<li><code><a href="#FromObject_sbyte">FromObject(sbyte)</a></code> - Converts a signed 8-bit integer to a CBOR object.</li>
<li><code><a href="#FromObject_short">FromObject(short)</a></code> - Generates a CBOR object from a 16-bit signed integer.</li>
<li><code><a href="#FromObject_string">FromObject(string)</a></code> - Generates a CBOR object from a text string.</li>
<li><code><a href="#FromObject_uint">FromObject(uint)</a></code> - Converts a 32-bit unsigned integer to a CBOR object.</li>
<li><code><a href="#FromObject_ulong">FromObject(ulong)</a></code> - Converts a 64-bit unsigned integer to a CBOR object.</li>
<li><code><a href="#FromObject_ushort">FromObject(ushort)</a></code> - Converts a 16-bit unsigned integer to a CBOR object.</li>
<li><code><a href="#FromSimpleValue_int">FromSimpleValue(int)</a></code> - Creates a CBOR object from a simple value number.</li>
<li><code><a href="#GetAllTags">GetAllTags()</a></code> - Gets a list of all tags, from outermost to innermost.</li>
<li><code><a href="#GetByteString">GetByteString()</a></code> - Gets the backing byte array used in this CBOR object, if this object is a byte string, without copying the data to a new byte array.</li>
<li><code><a href="#GetHashCode">GetHashCode()</a></code> - Calculates the hash code of this object.</li>
<li><code><a href="#GetOrDefault_object_PeterO_Cbor_CBORObject">GetOrDefault(object, PeterO.Cbor.CBORObject)</a></code> - Gets the value of a CBOR object by integer index in this array or by CBOR object key in this map, or a default value if that value is not found.</li>
<li><code><a href="#HasMostOuterTag_PeterO_Numbers_EInteger">HasMostOuterTag(PeterO.Numbers.EInteger)</a></code> - Returns whether this object has an outermost tag and that tag is of the given number.</li>
<li><code><a href="#HasMostOuterTag_int">HasMostOuterTag(int)</a></code> - Returns whether this object has an outermost tag and that tag is of the given number.</li>
<li><code><a href="#HasTag_PeterO_Numbers_EInteger">HasTag(PeterO.Numbers.EInteger)</a></code> - Returns whether this object has a tag of the given number.</li>
<li><code><a href="#HasTag_int">HasTag(int)</a></code> - Returns whether this object has a tag of the given number.</li>
<li><code><a href="#Insert_int_object">Insert(int, object)</a></code> - Inserts an object at the specified position in this CBOR array.</li>
<li><code><a href="#IsFalse">IsFalse</a></code> - Gets a value indicating whether this value is a CBOR false value.</li>
<li><code><a href="#IsFinite">IsFinite</a></code> - Gets a value indicating whether this CBOR object represents a finite number.</li>
<li><code><a href="#IsInfinity">IsInfinity()</a></code> - Gets a value indicating whether this CBOR object represents infinity.</li>
<li><code><a href="#IsIntegral">IsIntegral</a></code> - Gets a value indicating whether this object represents an integer number, that is, a number without a fractional part.</li>
<li><code><a href="#IsNaN">IsNaN()</a></code> - Gets a value indicating whether this CBOR object represents a not-a-number value (as opposed to whether this object&#39;s type is not a number type).</li>
<li><code><a href="#IsNegative">IsNegative</a></code> - Gets a value indicating whether this object is a negative number.</li>
<li><code><a href="#IsNegativeInfinity">IsNegativeInfinity()</a></code> - Gets a value indicating whether this CBOR object represents negative infinity.</li>
<li><code><a href="#IsNull">IsNull</a></code> - Gets a value indicating whether this value is a CBOR null value.</li>
<li><code><a href="#IsPositiveInfinity">IsPositiveInfinity()</a></code> - Gets a value indicating whether this CBOR object represents positive infinity.</li>
<li><code><a href="#IsTagged">IsTagged</a></code> - Gets a value indicating whether this data item has at least one tag.</li>
<li><code><a href="#IsTrue">IsTrue</a></code> - Gets a value indicating whether this value is a CBOR true value.</li>
<li><code><a href="#IsUndefined">IsUndefined</a></code> - Gets a value indicating whether this value is a CBOR undefined value.</li>
<li><code><a href="#IsZero">IsZero</a></code> - Gets a value indicating whether this object&#39;s value equals 0.</li>
<li><code><a href="#Keys">Keys</a></code> - Gets a collection of the keys of this CBOR object in an undefined order.</li>
<li><code><a href="#MostInnerTag">MostInnerTag</a></code> - Gets the last defined tag for this CBOR data item, or -1 if the item is untagged.</li>
<li><code><a href="#MostOuterTag">MostOuterTag</a></code> - Gets the outermost tag for this CBOR data item, or -1 if the item is untagged.</li>
<li><code><a href="#Multiply_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject">Multiply(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Multiplies two CBOR numbers.</li>
<li><code><a href="#NaN">public static readonly PeterO.Cbor.CBORObject NaN;</a></code> - A not-a-number value.</li>
<li><code><a href="#Negate">Negate()</a></code> - Gets this object&#39;s value with the sign reversed.</li>
<li><code><a href="#NegativeInfinity">public static readonly PeterO.Cbor.CBORObject NegativeInfinity;</a></code> - The value negative infinity.</li>
<li><code><a href="#NewArray">NewArray()</a></code> - Creates a new empty CBOR array.</li>
<li><code><a href="#NewMap">NewMap()</a></code> - Creates a new empty CBOR map.</li>
<li><code><a href="#Null">public static readonly PeterO.Cbor.CBORObject Null;</a></code> - Represents the value null.</li>
<li><code><a href="#PositiveInfinity">public static readonly PeterO.Cbor.CBORObject PositiveInfinity;</a></code> - The value positive infinity.</li>
<li><code><a href="#ReadJSON_System_IO_Stream">ReadJSON(System.IO.Stream)</a></code> - Generates a CBOR object from a data stream in JavaScript Object Notation (JSON) format.</li>
<li><code><a href="#ReadJSON_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions">ReadJSON(System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)</a></code> - Generates a CBOR object from a data stream in JavaScript Object Notation (JSON) format, using the specified options to control the decoding process.</li>
<li><code><a href="#Read_System_IO_Stream">Read(System.IO.Stream)</a></code> -  Reads an object in CBOR format from a data stream.</li>
<li><code><a href="#Read_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions">Read(System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)</a></code> - Reads an object in CBOR format from a data stream, using the specified options to control the decoding process.</li>
<li><code><a href="#Remainder_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject">Remainder(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Finds the remainder that results when a CBORObject object is divided by the value of a CBORObject object.</li>
<li><code><a href="#RemoveAt_int">RemoveAt(int)</a></code> - Removes the item at the given index of this CBOR array.</li>
<li><code><a href="#Remove_PeterO_Cbor_CBORObject">Remove(PeterO.Cbor.CBORObject)</a></code> - If this object is an array, removes the first instance of the specified item from the array.</li>
<li><code><a href="#Remove_object">Remove(object)</a></code> - If this object is an array, removes the first instance of the specified item (once converted to a CBOR object) from the array.</li>
<li><code><a href="#Set_object_object">Set(object, object)</a></code> - Maps an object to a key in this CBOR map, or adds the value if the key doesn&#39;t exist.</li>
<li><code><a href="#Sign">Sign</a></code> - Gets this value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</li>
<li><code><a href="#SimpleValue">SimpleValue</a></code> - Gets the simple value ID of this object, or -1 if this object is not a simple value (including if the value is a floating-point number).</li>
<li><code><a href="#Subtract_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject">Subtract(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Finds the difference between two CBOR number objects.</li>
<li><code><a href="#ToJSONString">ToJSONString()</a></code> - Converts this object to a string in JavaScript Object Notation (JSON) format.</li>
<li><code><a href="#ToJSONString_PeterO_Cbor_JSONOptions">ToJSONString(PeterO.Cbor.JSONOptions)</a></code> - Converts this object to a string in JavaScript Object Notation (JSON) format, using the specified options to control the encoding process.</li>
<li><code><a href="#ToObject_System_Type">ToObject(System.Type)</a></code> - Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToObject_System_Type_PeterO_Cbor_CBORTypeMapper">ToObject(System.Type, PeterO.Cbor.CBORTypeMapper)</a></code> - Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToObject_System_Type_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions">ToObject(System.Type, PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)</a></code> -  Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToObject_System_Type_PeterO_Cbor_PODOptions">ToObject(System.Type, PeterO.Cbor.PODOptions)</a></code> - Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToObject_T">ToObject&lt;T&gt;()</a></code> -  Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToObject_T_PeterO_Cbor_CBORTypeMapper">ToObject&lt;T&gt;(PeterO.Cbor.CBORTypeMapper)</a></code> -  Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToObject_T_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions">ToObject&lt;T&gt;(PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)</a></code> -  Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToObject_T_PeterO_Cbor_PODOptions">ToObject&lt;T&gt;(PeterO.Cbor.PODOptions)</a></code> -  Converts this CBOR object to an object of an arbitrary type.</li>
<li><code><a href="#ToString">ToString()</a></code> - Returns this CBOR object in string form.</li>
<li><code><a href="#True">public static readonly PeterO.Cbor.CBORObject True;</a></code> - Represents the value true.</li>
<li><code><a href="#Type">Type</a></code> - Gets the general data type of this CBOR object.</li>
<li><code><a href="#Undefined">public static readonly PeterO.Cbor.CBORObject Undefined;</a></code> - Represents the value undefined.</li>
<li><code><a href="#Untag">Untag()</a></code> - Gets an object with the same value as this one but without the tags it has, if any.</li>
<li><code><a href="#UntagOne">UntagOne()</a></code> - Gets an object with the same value as this one but without this object&#39;s outermost tag, if any.</li>
<li><code><a href="#Values">Values</a></code> - Gets a collection of the values of this CBOR object, if it&#39;s a map or an array.</li>
<li><code><a href="#WriteJSONTo_System_IO_Stream">WriteJSONTo(System.IO.Stream)</a></code> - Converts this object to a string in JavaScript Object Notation (JSON) format, as in the ToJSONString method, and writes that string to a data stream in UTF-8.</li>
<li><code><a href="#WriteJSONTo_System_IO_Stream_PeterO_Cbor_JSONOptions">WriteJSONTo(System.IO.Stream, PeterO.Cbor.JSONOptions)</a></code> - Converts this object to a string in JavaScript Object Notation (JSON) format, as in the ToJSONString method, and writes that string to a data stream in UTF-8, using the given JSON options to control the encoding process.</li>
<li><code><a href="#WriteJSON_object_System_IO_Stream">WriteJSON(object, System.IO.Stream)</a></code> - Converts an arbitrary object to a string in JavaScript Object Notation (JSON) format, as in the ToJSONString method, and writes that string to a data stream in UTF-8.</li>
<li><code><a href="#WriteTo_System_IO_Stream">WriteTo(System.IO.Stream)</a></code> -  Writes this CBOR object to a data stream.</li>
<li><code><a href="#WriteTo_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions">WriteTo(System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)</a></code> - Writes this CBOR object to a data stream, using the specified options for encoding the data to CBOR format.</li>
<li><code><a href="#WriteValue_System_IO_Stream_int_PeterO_Numbers_EInteger">WriteValue(System.IO.Stream, int, PeterO.Numbers.EInteger)</a></code> - Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as an arbitrary-precision integer.</li>
<li><code><a href="#WriteValue_System_IO_Stream_int_int">WriteValue(System.IO.Stream, int, int)</a></code> - Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 32-bit signed integer.</li>
<li><code><a href="#WriteValue_System_IO_Stream_int_long">WriteValue(System.IO.Stream, int, long)</a></code> - Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 64-bit signed integer.</li>
<li><code><a href="#WriteValue_System_IO_Stream_int_uint">WriteValue(System.IO.Stream, int, uint)</a></code> - Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 32-bit unsigned integer.</li>
<li><code><a href="#WriteValue_System_IO_Stream_int_ulong">WriteValue(System.IO.Stream, int, ulong)</a></code> - Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 64-bit unsigned integer.</li>
<li><code><a href="#Write_PeterO_Cbor_CBORObject_System_IO_Stream">Write(PeterO.Cbor.CBORObject, System.IO.Stream)</a></code> - Writes a CBOR object to a CBOR data stream.</li>
<li><code><a href="#Write_PeterO_Numbers_EDecimal_System_IO_Stream">Write(PeterO.Numbers.EDecimal, System.IO.Stream)</a></code> - Writes a decimal floating-point number in CBOR format to a data stream, as follows:If the value is null, writes the byte 0xF6.</li>
<li><code><a href="#Write_PeterO_Numbers_EFloat_System_IO_Stream">Write(PeterO.Numbers.EFloat, System.IO.Stream)</a></code> - Writes a binary floating-point number in CBOR format to a data stream as follows:If the value is null, writes the byte 0xF6.</li>
<li><code><a href="#Write_PeterO_Numbers_EInteger_System_IO_Stream">Write(PeterO.Numbers.EInteger, System.IO.Stream)</a></code> - Writes a big integer in CBOR format to a data stream.</li>
<li><code><a href="#Write_PeterO_Numbers_ERational_System_IO_Stream">Write(PeterO.Numbers.ERational, System.IO.Stream)</a></code> - Writes a rational number in CBOR format to a data stream.</li>
<li><code><a href="#Write_bool_System_IO_Stream">Write(bool, System.IO.Stream)</a></code> - Writes a Boolean value in CBOR format to a data stream.</li>
<li><code><a href="#Write_byte_System_IO_Stream">Write(byte, System.IO.Stream)</a></code> - Writes a byte (0 to 255) in CBOR format to a data stream.</li>
<li><code><a href="#Write_double_System_IO_Stream">Write(double, System.IO.Stream)</a></code> - Writes a 64-bit floating-point number in CBOR format to a data stream.</li>
<li><code><a href="#Write_float_System_IO_Stream">Write(float, System.IO.Stream)</a></code> - Writes a 32-bit floating-point number in CBOR format to a data stream.</li>
<li><code><a href="#Write_int_System_IO_Stream">Write(int, System.IO.Stream)</a></code> - Writes a 32-bit signed integer in CBOR format to a data stream.</li>
<li><code><a href="#Write_long_System_IO_Stream">Write(long, System.IO.Stream)</a></code> - Writes a 64-bit signed integer in CBOR format to a data stream.</li>
<li><code><a href="#Write_object_System_IO_Stream">Write(object, System.IO.Stream)</a></code> -  Writes a CBOR object to a CBOR data stream.</li>
<li><code><a href="#Write_object_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions">Write(object, System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)</a></code> - Writes an arbitrary object to a CBOR data stream, using the specified options for controlling how the object is encoded to CBOR data format.</li>
<li><code><a href="#Write_sbyte_System_IO_Stream">Write(sbyte, System.IO.Stream)</a></code> - Writes an 8-bit signed integer in CBOR format to a data stream.</li>
<li><code><a href="#Write_short_System_IO_Stream">Write(short, System.IO.Stream)</a></code> - Writes a 16-bit signed integer in CBOR format to a data stream.</li>
<li><code><a href="#Write_string_System_IO_Stream">Write(string, System.IO.Stream)</a></code> -  Writes a string in CBOR format to a data stream.</li>
<li><code><a href="#Write_string_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions">Write(string, System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)</a></code> - Writes a string in CBOR format to a data stream, using the given options to control the encoding process.</li>
<li><code><a href="#Write_uint_System_IO_Stream">Write(uint, System.IO.Stream)</a></code> - Writes a 32-bit unsigned integer in CBOR format to a data stream.</li>
<li><code><a href="#Write_ulong_System_IO_Stream">Write(ulong, System.IO.Stream)</a></code> - Writes a 64-bit unsigned integer in CBOR format to a data stream.</li>
<li><code><a href="#Write_ushort_System_IO_Stream">Write(ushort, System.IO.Stream)</a></code> - Writes a 16-bit unsigned integer in CBOR format to a data stream.</li>
<li><code><a href="#Zero">public static readonly PeterO.Cbor.CBORObject Zero;</a></code> - Gets a CBOR object for the number zero.</li>
<li><code><a href="#op_Addition">PeterO.Cbor.CBORObject operator +(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Adds two CBOR objects and returns their result.</li>
<li><code><a href="#op_Division">PeterO.Cbor.CBORObject operator /(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Divides a CBORObject object by the value of a CBORObject object.</li>
<li><code><a href="#op_Modulus">PeterO.Cbor.CBORObject operator %(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Finds the remainder that results when a CBORObject object is divided by the value of a CBORObject object.</li>
<li><code><a href="#op_Multiply">PeterO.Cbor.CBORObject operator *(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Multiplies a CBORObject object by the value of a CBORObject object.</li>
<li><code><a href="#op_Subtraction">PeterO.Cbor.CBORObject operator -(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)</a></code> - Subtracts a CBORObject object from a CBORObject object.</li>
</ul>

<p><a id="False"></a></p>

<h3>False</h3>

<pre>public static readonly PeterO.Cbor.CBORObject False;
</pre>

<p>Represents the value false.</p>

<p><a id="NaN"></a></p>

<h3>NaN</h3>

<pre>public static readonly PeterO.Cbor.CBORObject NaN;
</pre>

<p>A not-a-number value.</p>

<p><a id="NegativeInfinity"></a></p>

<h3>NegativeInfinity</h3>

<pre>public static readonly PeterO.Cbor.CBORObject NegativeInfinity;
</pre>

<p>The value negative infinity.</p>

<p><a id="Null"></a></p>

<h3>Null</h3>

<pre>public static readonly PeterO.Cbor.CBORObject Null;
</pre>

<p>Represents the value null.</p>

<p><a id="PositiveInfinity"></a></p>

<h3>PositiveInfinity</h3>

<pre>public static readonly PeterO.Cbor.CBORObject PositiveInfinity;
</pre>

<p>The value positive infinity.</p>

<p><a id="True"></a></p>

<h3>True</h3>

<pre>public static readonly PeterO.Cbor.CBORObject True;
</pre>

<p>Represents the value true.</p>

<p><a id="Undefined"></a></p>

<h3>Undefined</h3>

<pre>public static readonly PeterO.Cbor.CBORObject Undefined;
</pre>

<p>Represents the value undefined.</p>

<p><a id="Zero"></a></p>

<h3>Zero</h3>

<pre>public static readonly PeterO.Cbor.CBORObject Zero;
</pre>

<p>Gets a CBOR object for the number zero.</p>

<p><a id="Count"></a></p>

<h3>Count</h3>

<pre>public int Count { get; }
</pre>

<p>Gets the number of keys in this map, or the number of items in this array, or 0 if this item is neither an array nor a map.</p>

<p><b>Returns:</b></p>

<p>The number of keys in this map, or the number of items in this array, or 0 if this item is neither an array nor a map.</p>

<p><a id="IsFalse"></a></p>

<h3>IsFalse</h3>

<pre>public bool IsFalse { get; }
</pre>

<p>Gets a value indicating whether this value is a CBOR false value.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this value is a CBOR false value; otherwise, . <code>false
</code> .</p>

<p><a id="IsFinite"></a></p>

<h3>IsFinite</h3>

<pre>public bool IsFinite { get; }
</pre>

<p>Gets a value indicating whether this CBOR object represents a finite number.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this CBOR object represents a finite number; otherwise, . <code>false
</code> .</p>

<p><a id="IsIntegral"></a></p>

<h3>IsIntegral</h3>

<pre>public bool IsIntegral { get; }
</pre>

<p>Gets a value indicating whether this object represents an integer number, that is, a number without a fractional part. Infinity and not-a-number are not considered integers.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this object represents an integer number, that is, a number without a ractional part; otherwise, . <code>false
</code> .</p>

<p><a id="IsNegative"></a></p>

<h3>IsNegative</h3>

<pre>public bool IsNegative { get; }
</pre>

<p>Gets a value indicating whether this object is a negative number.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this object is a negative number; otherwise, . <code>false
</code> .</p>

<p><a id="IsNull"></a></p>

<h3>IsNull</h3>

<pre>public bool IsNull { get; }
</pre>

<p>Gets a value indicating whether this value is a CBOR null value.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this value is a CBOR null value; otherwise, . <code>false
</code> .</p>

<p><a id="IsTagged"></a></p>

<h3>IsTagged</h3>

<pre>public bool IsTagged { get; }
</pre>

<p>Gets a value indicating whether this data item has at least one tag.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this data item has at least one tag; otherwise, . <code>false
</code> .</p>

<p><a id="IsTrue"></a></p>

<h3>IsTrue</h3>

<pre>public bool IsTrue { get; }
</pre>

<p>Gets a value indicating whether this value is a CBOR true value.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this value is a CBOR true value; otherwise, . <code>false
</code> .</p>

<p><a id="IsUndefined"></a></p>

<h3>IsUndefined</h3>

<pre>public bool IsUndefined { get; }
</pre>

<p>Gets a value indicating whether this value is a CBOR undefined value.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this value is a CBOR undefined value; otherwise, . <code>false
</code> .</p>

<p><a id="IsZero"></a></p>

<h3>IsZero</h3>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this object&#39;s value equals 0.</p>

<p><b>Returns:</b></p>

<p><code>true
</code> If this object&#39;s value equals 0; otherwise, . <code>false
</code> .</p>

<p><a id="Keys"></a></p>

<h3>Keys</h3>

<pre>public System.Collections.Generic.ICollection Keys { get; }
</pre>

<p>Gets a collection of the keys of this CBOR object in an undefined order.</p>

<p><b>Returns:</b></p>

<p>A collection of the keys of this CBOR object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object is not a map.</li>
</ul>

<p><a id="MostInnerTag"></a></p>

<h3>MostInnerTag</h3>

<pre>public PeterO.Numbers.EInteger MostInnerTag { get; }
</pre>

<p>Gets the last defined tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><b>Returns:</b></p>

<p>The last defined tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><a id="MostOuterTag"></a></p>

<h3>MostOuterTag</h3>

<pre>public PeterO.Numbers.EInteger MostOuterTag { get; }
</pre>

<p>Gets the outermost tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><b>Returns:</b></p>

<p>The outermost tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><a id="Sign"></a></p>

<h3>Sign</h3>

<pre>public int Sign { get; }
</pre>

<p>Gets this value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<p><b>Returns:</b></p>

<p>This value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type, including the special not-a-number value (NaN).</li>
</ul>

<p><a id="SimpleValue"></a></p>

<h3>SimpleValue</h3>

<pre>public int SimpleValue { get; }
</pre>

<p>Gets the simple value ID of this object, or -1 if this object is not a simple value (including if the value is a floating-point number).</p>

<p><b>Returns:</b></p>

<p>The simple value ID of this object, or -1 if this object is not a simple value (including if the value is a floating-point number).</p>

<p><a id="Type"></a></p>

<h3>Type</h3>

<pre>public PeterO.Cbor.CBORType Type { get; }
</pre>

<p>Gets the general data type of this CBOR object.</p>

<p><b>Returns:</b></p>

<p>The general data type of this CBOR object.</p>

<p><a id="Values"></a></p>

<h3>Values</h3>

<pre>public System.Collections.Generic.ICollection Values { get; }
</pre>

<p>Gets a collection of the values of this CBOR object, if it&#39;s a map or an array. If this object is a map, returns one value for each key in the map in an undefined order. If this is an array, returns all the values of the array in the order they are listed. (This method can&#39;t be used to get the bytes in a CBOR byte string; for that, use the GetByteString method instead.).</p>

<p><b>Returns:</b></p>

<p>A collection of the values of this CBOR map or array.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object is not a map or an array.</li>
</ul>

<p><a id="Abs"></a></p>

<h3>Abs</h3>

<pre>public PeterO.Cbor.CBORObject Abs();
</pre>

<p>Gets this object&#39;s absolute value.</p>

<p><b>Return Value:</b></p>

<p>This object&#39;s absolute without its negative sign.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type.</li>
</ul>

<p><a id="Add_object_object"></a></p>

<h3>Add</h3>

<pre>public PeterO.Cbor.CBORObject Add(
    object key,
    object valueOb);
</pre>

<p>Adds a new key and its value to this CBOR map, or adds the value if the key doesn&#39;t exist.</p>

<p>NOTE: This method can&#39;t be used to add a tag to an existing CBOR object. To create a CBOR object with a given tag, call the <code>CBORObject.FromObjectAndTag
</code> method and pass the CBOR object and the desired tag number to that ethod.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>key</i>: An object representing the key, which will be converted to a CBORObject. Can be null, in which case this value is converted to CBORObject.Null.</p></li>
<li><p><i>valueOb</i>: An object representing the value, which will be converted to a CBORObject. Can be null, in which case this value is converted to CBORObject.Null.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>This instance.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter <i>key</i>
already exists in this map.</p></li>
<li><p>System.InvalidOperationException:
This object is not a map.</p></li>
<li><p>System.ArgumentException:
The parameter <i>key</i>
or <i>valueOb</i>
has an unsupported type.</p></li>
</ul>

<p><a id="Add_object"></a></p>

<h3>Add</h3>

<pre>public PeterO.Cbor.CBORObject Add(
    object obj);
</pre>

<p>Converts an object to a CBOR object and adds it to the end of this array.</p>

<p>NOTE: This method can&#39;t be used to add a tag to an existing CBOR object. To create a CBOR object with a given tag, call the <code>CBORObject.FromObjectAndTag
</code> method and pass the CBOR object and the desired tag number to that ethod.</p>

<p>The following example creates a CBOR array and adds several CBOR objects, one of which has a custom CBOR tag, to that array. Note the chaining behavior made possible by this method.</p>

<pre>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5)
        .Add(&quot;text string&quot;) .Add(CBORObject.FromObjectAndTag(9999, 1));
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: A CBOR object (or an object convertible to a CBOR object) to add to this CBOR array.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This instance.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This instance is not an array.</p></li>
<li><p>System.ArgumentException:
The type of <i>obj</i>
is not supported.</p></li>
</ul>

<p><a id="Add_PeterO_Cbor_CBORObject"></a></p>

<h3>Add</h3>

<pre>public PeterO.Cbor.CBORObject Add(
    PeterO.Cbor.CBORObject obj);
</pre>

<p>Adds a new object to the end of this array. (Used to throw ArgumentNullException on a null reference, but now converts the null reference to CBORObject.Null, for convenience with the Object overload of this method).</p>

<p>NOTE: This method can&#39;t be used to add a tag to an existing CBOR object. To create a CBOR object with a given tag, call the <code>CBORObject.FromObjectAndTag
</code> method and pass the CBOR object and the desired tag number to that ethod.</p>

<p>The following example creates a CBOR array and adds several CBOR objects, one of which has a custom CBOR tag, to that array. Note the chaining behavior made possible by this method.</p>

<pre>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False)
        .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject(&quot;text
        string&quot;)) .Add(CBORObject.FromObjectAndTag(9999, 1));
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The parameter <i>obj</i>
is a CBOR object.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This instance.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object is not an array.</li>
</ul>

<p><a id="Addition_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject"></a></p>

<h3>Addition</h3>

<pre>public static PeterO.Cbor.CBORObject Addition(
    PeterO.Cbor.CBORObject first,
    PeterO.Cbor.CBORObject second);
</pre>

<p>Finds the sum of two CBOR numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The parameter <i>first</i>
is a CBOR object.</p></li>
<li><p><i>second</i>: The parameter <i>second</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
Either or both operands are not numbers (as opposed to Not-a-Number, NaN).</li>
</ul>

<p><a id="AsBoolean"></a></p>

<h3>AsBoolean</h3>

<pre>public bool AsBoolean();
</pre>

<p>Returns false if this object is False, Null, or Undefined; otherwise,true.</p>

<p><b>Return Value:</b></p>

<p>False if this object is False, Null, or Undefined; otherwise,true.</p>

<p><a id="AsByte"></a></p>

<h3>AsByte</h3>

<pre>public byte AsByte();
</pre>

<p>Converts this object to a byte (0 to 255). Floating point values are truncated to an integer.</p>

<p><b>Return Value:</b></p>

<p>The closest byte-sized integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object&#39;s type is not a number type.</p></li>
<li><p>System.OverflowException:
This object&#39;s value exceeds the range of a byte (would be less than 0 or greater than 255 when truncated to an integer).</p></li>
</ul>

<p><a id="AsDecimal"></a></p>

<h3>AsDecimal</h3>

<pre>public System.Decimal AsDecimal();
</pre>

<p>Converts this object to a .NET decimal.</p>

<p><b>Return Value:</b></p>

<p>The closest big integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object&#39;s type is not a number type.</p></li>
<li><p>System.OverflowException:
This object&#39;s value exceeds the range of a .NET decimal.</p></li>
</ul>

<p><a id="AsDouble"></a></p>

<h3>AsDouble</h3>

<pre>public double AsDouble();
</pre>

<p>Converts this object to a 64-bit floating point number.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit floating point number to this object. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type.</li>
</ul>

<p><a id="AsEDecimal"></a></p>

<h3>AsEDecimal</h3>

<pre>public PeterO.Numbers.EDecimal AsEDecimal();
</pre>

<p>Converts this object to a decimal number.</p>

<p><b>Return Value:</b></p>

<p>A decimal number for this object&#39;s value. If this object is a rational number with a nonterminating decimal expansion, returns a decimal number rounded to 34 digits.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type, including if this object is CBORObject.Null. To check the CBOR object for null before conversion, use the following idiom (originally written in C# for the .NET version): <code>(cbor == null || cbor.IsNull) ? null : cbor.AsEDecimal()
</code> .</li>
</ul>

<p><a id="AsEFloat"></a></p>

<h3>AsEFloat</h3>

<pre>public PeterO.Numbers.EFloat AsEFloat();
</pre>

<p>Converts this object to an arbitrary-precision binary floating point number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision binary floating point number for this object&#39;s value. Note that if this object is a decimal number with a fractional part, the conversion may lose information depending on the number. If this object is a rational number with a nonterminating binary expansion, returns a binary floating-point number rounded to a high but limited precision.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type, including if this object is CBORObject.Null. To check the CBOR object for null before conversion, use the following idiom (originally written in C# for the .NET version): <code>(cbor == null || cbor.IsNull) ? null : cbor.AsEFloat()
</code> .</li>
</ul>

<p><a id="AsEInteger"></a></p>

<h3>AsEInteger</h3>

<pre>public PeterO.Numbers.EInteger AsEInteger();
</pre>

<p>Converts this object to an arbitrary-precision integer. Fractional values are truncated to an integer.</p>

<p><b>Return Value:</b></p>

<p>The closest big integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object&#39;s type is not a number type, including if this object is CBORObject.Null. To check the CBOR object for null before conversion, use the following idiom (originally written in C# for the .NET version): <code>(cbor == null || cbor.IsNull) ? null : cbor.AsEInteger()
</code> .</p></li>
<li><p>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</p></li>
</ul>

<p><a id="AsERational"></a></p>

<h3>AsERational</h3>

<pre>public PeterO.Numbers.ERational AsERational();
</pre>

<p>Converts this object to a rational number.</p>

<p><b>Return Value:</b></p>

<p>A rational number for this object&#39;s value.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type, including if this object is CBORObject.Null. To check the CBOR object for null before conversion, use the following idiom (originally written in C# for the .NET version): <code>(cbor == null || cbor.IsNull) ? null : cbor.AsERational()
</code> .</li>
</ul>

<p><a id="AsInt16"></a></p>

<h3>AsInt16</h3>

<pre>public short AsInt16();
</pre>

<p>Converts this object to a 16-bit signed integer. Floating point values are truncated to an integer.</p>

<p><b>Return Value:</b></p>

<p>The closest 16-bit signed integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object&#39;s type is not a number type.</p></li>
<li><p>System.OverflowException:
This object&#39;s value exceeds the range of a 16-bit signed integer.</p></li>
</ul>

<p><a id="AsInt32"></a></p>

<h3>AsInt32</h3>

<pre>public int AsInt32();
</pre>

<p>Converts this object to a 32-bit signed integer. Non-integer number values are truncated to an integer. (NOTE: To determine whether this method call can succeed, call the<b>CanTruncatedIntFitInInt32</b>method before calling this method. Checking whether this object&#39;s type is <code>CBORType.Number
</code> is not sufficient. See the example.).</p>

<p>The following example code (originally written in C# for the .NET Framework) shows a way to check whether a given CBOR object stores a 32-bit signed integer before getting its value.</p>

<pre>CBORObject obj = CBORObject.FromInt32(99999); if(obj.IsIntegral
        &amp;&amp; obj.CanTruncatedIntFitInInt32()) { // Not an Int32;
        handle the error Console.WriteLine(&quot;Not a 32-bit integer.&quot;); } else
        { Console.WriteLine(&quot;The value is &quot; + obj.AsInt32()); }
</pre>

<p><b>Return Value:</b></p>

<p>The closest 32-bit signed integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object&#39;s type is not a number type.</p></li>
<li><p>System.OverflowException:
This object&#39;s value exceeds the range of a 32-bit signed integer.</p></li>
</ul>

<p><a id="AsInt64"></a></p>

<h3>AsInt64</h3>

<pre>public long AsInt64();
</pre>

<p>Converts this object to a 64-bit signed integer. Non-integer numbers are truncated to an integer. (NOTE: To determine whether this method call can succeed, call the<b>CanTruncatedIntFitInInt64</b>method before calling this method. Checking whether this object&#39;s type is <code>CBORType.Number
</code> is not sufficient. See the example.).</p>

<p>The following example code (originally written in C# for the .NET Framework) shows a way to check whether a given CBOR object stores a 64-bit signed integer before getting its value.</p>

<pre>CBORObject obj = CBORObject.FromInt64(99999); if(obj.IsIntegral
        &amp;&amp; obj.CanTruncatedIntFitInInt64()) { // Not an Int64;
        handle the error Console.WriteLine(&quot;Not a 64-bit integer.&quot;); } else
        { Console.WriteLine(&quot;The value is &quot; + obj.AsInt64()); }
</pre>

<p><b>Return Value:</b></p>

<p>The closest 64-bit signed integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object&#39;s type is not a number type.</p></li>
<li><p>System.OverflowException:
This object&#39;s value exceeds the range of a 64-bit signed integer.</p></li>
</ul>

<p><a id="AsSByte"></a></p>

<h3>AsSByte</h3>

<pre>public sbyte AsSByte();
</pre>

<p>Converts this object to an 8-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>An 8-bit signed integer.</p>

<p><a id="AsSingle"></a></p>

<h3>AsSingle</h3>

<pre>public float AsSingle();
</pre>

<p>Converts this object to a 32-bit floating point number.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit floating point number to this object. The return value can be positive infinity or negative infinity if this object&#39;s value exceeds the range of a 32-bit floating point number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type.</li>
</ul>

<p><a id="AsString"></a></p>

<h3>AsString</h3>

<pre>public string AsString();
</pre>

<p>Gets the value of this object as a text string.</p>

<p><b>Return Value:</b></p>

<p>Gets this object&#39;s string.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a string, including if this object is CBORObject.Null. To check the CBOR object for null before conversion, use the following idiom (originally written in C# for the .NET version): <code>(cbor == null || cbor.IsNull) ? null : cbor.AsString()
</code> .</li>
</ul>

<p><a id="AsUInt16"></a></p>

<h3>AsUInt16</h3>

<pre>public ushort AsUInt16();
</pre>

<p>Converts this object to a 16-bit unsigned integer. The return value will be truncated as necessary.</p>

<p><b>Return Value:</b></p>

<p>A 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is outside the range of a 16-bit unsigned integer.</li>
</ul>

<p><a id="AsUInt32"></a></p>

<h3>AsUInt32</h3>

<pre>public uint AsUInt32();
</pre>

<p>Converts this object to a 32-bit unsigned integer. The return value will be truncated as necessary.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is outside the range of a 32-bit unsigned integer.</li>
</ul>

<p><a id="AsUInt64"></a></p>

<h3>AsUInt64</h3>

<pre>public ulong AsUInt64();
</pre>

<p>Converts this object to a 64-bit unsigned integer. Non-integer values are truncated to an integer.</p>

<p><b>Return Value:</b></p>

<p>The closest big integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object&#39;s type is not a number type.</p></li>
<li><p>System.OverflowException:
This object&#39;s value exceeds the range of a 64-bit unsigned integer.</p></li>
</ul>

<p><a id="CanFitInDouble"></a></p>

<h3>CanFitInDouble</h3>

<pre>public bool CanFitInDouble();
</pre>

<p>Returns whether this object&#39;s value can be converted to a 64-bit floating point number without its value being rounded to another numerical value.</p>

<p><b>Return Value:</b></p>

<p>Whether this object&#39;s value can be converted to a 64-bit floating point number without its value being rounded to another numerical value. Returns true if this is a not-a-number value, even if the value&#39;s diagnostic information can&#39; t fit in a 64-bit floating point number.</p>

<p><a id="CanFitInInt32"></a></p>

<h3>CanFitInInt32</h3>

<pre>public bool CanFitInInt32();
</pre>

<p>Returns whether this object&#39;s numerical value is an integer, is -(2^31) or greater, and is less than 2^31.</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object&#39;s numerical value is an integer, is -(2^31) or greater, nd is less than 2^31; otherwise, <code>false
</code> .</p>

<p><a id="CanFitInInt64"></a></p>

<h3>CanFitInInt64</h3>

<pre>public bool CanFitInInt64();
</pre>

<p>Returns whether this object&#39;s numerical value is an integer, is -(2^63) or greater, and is less than 2^63.</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object&#39;s numerical value is an integer, is -(2^63) or greater, nd is less than 2^63; otherwise, <code>false
</code> .</p>

<p><a id="CanFitInSingle"></a></p>

<h3>CanFitInSingle</h3>

<pre>public bool CanFitInSingle();
</pre>

<p>Returns whether this object&#39;s value can be converted to a 32-bit floating point number without its value being rounded to another numerical value.</p>

<p><b>Return Value:</b></p>

<p>Whether this object&#39;s value can be converted to a 32-bit floating point number without its value being rounded to another numerical value. Returns true if this is a not-a-number value, even if the value&#39;s diagnostic information can&#39; t fit in a 32-bit floating point number.</p>

<p><a id="CanTruncatedIntFitInInt32"></a></p>

<h3>CanTruncatedIntFitInInt32</h3>

<pre>public bool CanTruncatedIntFitInInt32();
</pre>

<p>Returns whether this object&#39;s value, truncated to an integer, would be -(2^31) or greater, and less than 2^31.</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object&#39;s value, truncated to an integer, would be -(2^31) or reater, and less than 2^31; otherwise, <code>false
</code> .</p>

<p><a id="CanTruncatedIntFitInInt64"></a></p>

<h3>CanTruncatedIntFitInInt64</h3>

<pre>public bool CanTruncatedIntFitInInt64();
</pre>

<p>Returns whether this object&#39;s value, truncated to an integer, would be -(2^63) or greater, and less than 2^63.</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object&#39;s value, truncated to an integer, would be -(2^63) or reater, and less than 2^63; otherwise, <code>false
</code> .</p>

<p><a id="Clear"></a></p>

<h3>Clear</h3>

<pre>public void Clear();
</pre>

<p>Removes all items from this CBOR array or all keys and values from this CBOR map.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object is not a CBOR array or CBOR map.</li>
</ul>

<p><a id="CompareTo_PeterO_Cbor_CBORObject"></a></p>

<h3>CompareTo</h3>

<pre>public sealed int CompareTo(
    PeterO.Cbor.CBORObject other);
</pre>

<p>Compares two CBOR objects.In this implementation:</p>

<ul>
<li><p>The null pointer (null reference) is considered less than any other object.</p></li>
<li><p>If either object is true, false, CBORObject.Null, or the undefined value, it is treated as less than the other value. If both objects have one of these four values, then undefined is less than CBORObject.Null, which is less than false, which is less than true.</p></li>
<li><p>If both objects are numbers, their mathematical values are compared. Here, NaN (not-a-number) is considered greater than any number.</p></li>
<li><p>If both objects are simple values other than true, false, CBORObject.Null, and the undefined value, the objects are compared according to their ordinal numbers.</p></li>
<li><p>If both objects are arrays, each element is compared. If one array is shorter than the other and the other array begins with that array (for the purposes of comparison), the shorter array is considered less than the longer array.</p></li>
<li><p>If both objects are strings, compares each string code-point by code-point, as though by the DataUtilities.CodePointCompare method.</p></li>
<li><p>If both objects are maps, compares each map as though each were an array with the sorted keys of that map as the array&#39;s elements. If both maps have the same keys, their values are compared in the order of the sorted keys.</p></li>
<li><p>If each object is a different type, then they are sorted by their type number, in the order given for the CBORType enumeration.</p></li>
<li><p>If each object has different tags and both objects are otherwise equal under this method, each element is compared as though each were an array with that object&#39;s tags listed in order from outermost to innermost.</p></li>
</ul>

<p>This method is not consistent with the Equals method.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: A value to compare with.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Less than 0, if this value is less than the other object; or 0, if both values are equal; or greater than 0, if this value is less than the other object or if the other object is null.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
An internal error occurred.</li>
</ul>

<p><a id="CompareToIgnoreTags_PeterO_Cbor_CBORObject"></a></p>

<h3>CompareToIgnoreTags</h3>

<pre>public int CompareToIgnoreTags(
    PeterO.Cbor.CBORObject other);
</pre>

<p>Compares this object and another CBOR object, ignoring the tags they have, if any. See the CompareTo method for more information on the comparison function.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: A value to compare with.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Less than 0, if this value is less than the other object; or 0, if both values are equal; or greater than 0, if this value is less than the other object or if the other object is null.</p>

<p><a id="ContainsKey_object"></a></p>

<h3>ContainsKey</h3>

<pre>public bool ContainsKey(
    object objKey);
</pre>

<p>Determines whether a value of the given key exists in this object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>objKey</i>: The parameter <i>objKey</i>
is an arbitrary object.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if the given key is found, or false if the given key is not found or this bject is not a map.</p>

<p><a id="ContainsKey_PeterO_Cbor_CBORObject"></a></p>

<h3>ContainsKey</h3>

<pre>public bool ContainsKey(
    PeterO.Cbor.CBORObject key);
</pre>

<p>Determines whether a value of the given key exists in this object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>key</i>: An object that serves as the key. If this is <code>null
</code> , checks for <code>CBORObject.Null
</code> .</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if the given key is found, or false if the given key is not found or this bject is not a map.</p>

<p><a id="ContainsKey_string"></a></p>

<h3>ContainsKey</h3>

<pre>public bool ContainsKey(
    string key);
</pre>

<p>Determines whether a value of the given key exists in this object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>key</i>: A string that serves as the key. If this is <code>null
</code> , checks for <code>CBORObject.Null
</code> .</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if the given key (as a CBOR object) is found, or false if the given key s not found or this object is not a map.</p>

<p><a id="DecodeFromBytes_byte"></a></p>

<h3>DecodeFromBytes</h3>

<pre>public static PeterO.Cbor.CBORObject DecodeFromBytes(
    byte[] data);
</pre>

<p>Generates a CBOR object from an array of CBOR-encoded bytes.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>data</i>: A byte array in which a single CBOR object is encoded.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object decoded from the given byte array.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>PeterO.Cbor.CBORException:
There was an error in reading or parsing the data. This includes cases where not all of the byte array represents a CBOR object. This exception is also thrown if the parameter <i>data</i>
is empty.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>data</i>
is null.</p></li>
</ul>

<p><a id="DecodeFromBytes_byte_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>DecodeFromBytes</h3>

<pre>public static PeterO.Cbor.CBORObject DecodeFromBytes(
    byte[] data,
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Generates a CBOR object from an array of CBOR-encoded bytes, using the given <code>CBOREncodeOptions
</code> object to control the decoding process.</p>

<p>The following example (originally written in C# for the .NET version) implements a method that decodes a text string from a CBOR byte array. It&#39;s successful only if the CBOR object contains an untagged text string.</p>

<pre>private static String DecodeTextString(byte[] bytes){
        if(bytes == null){ throw new
        ArgumentNullException(nameof(mapObj));} if(bytes.Length
        == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f){throw new
        CBORException();} return
        CBORObject.DecodeFromBytes(bytes,
        CBOREncodeOptions.Default).AsString(); }
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>data</i>: A byte array in which a single CBOR object is encoded.</p></li>
<li><p><i>options</i>: The parameter <i>options</i>
is a CBOREncodeOptions object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object decoded from the given byte array.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>PeterO.Cbor.CBORException:
There was an error in reading or parsing the data. This includes cases where not all of the byte array represents a CBOR object. This exception is also thrown if the parameter <i>data</i>
is empty.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>data</i>
is null.</p></li>
</ul>

<p><a id="Divide_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject"></a></p>

<h3>Divide</h3>

<pre>public static PeterO.Cbor.CBORObject Divide(
    PeterO.Cbor.CBORObject first,
    PeterO.Cbor.CBORObject second);
</pre>

<p>Divides a CBORObject object by the value of a CBORObject object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The parameter <i>first</i>
is a CBOR object.</p></li>
<li><p><i>second</i>: The parameter <i>second</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><a id="EncodeToBytes_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>EncodeToBytes</h3>

<pre>public byte[] EncodeToBytes(
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Writes the binary representation of this CBOR object and returns a byte array of that representation, using the specified options for encoding the object to CBOR format. For the CTAP2 canonical ordering, which is useful for implementing Web Authentication, call this method as follows: <code>EncodeToBytes(new CBOREncodeOptions(false, false, true))
</code></p>

<p><b>Parameters:</b></p>

<ul>
<li><i>options</i>: Options for encoding the data to CBOR.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A byte array in CBOR format.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>options</i>
is null.</li>
</ul>

<p><a id="EncodeToBytes"></a></p>

<h3>EncodeToBytes</h3>

<pre>public byte[] EncodeToBytes();
</pre>

<p>Writes the binary representation of this CBOR object and returns a byte array of that representation. If the CBOR object contains CBOR maps, or is a CBOR map itself, the keys to the map are written out to the byte array in an undefined order. The example code given in<strong>PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)</strong>can be used to write out certain keys of a CBOR map in a given order. or the CTAP2 canonical ordering, which is useful for implementing Web uthentication, call <code>EncodeToBytes(new CBOREncodeOptions(false,false,true))
</code> rather than this method.</p>

<p><b>Return Value:</b></p>

<p>A byte array in CBOR format.</p>

<p><a id="Equals_object"></a></p>

<h3>Equals</h3>

<pre>public override bool Equals(
    object obj);
</pre>

<p>Determines whether this object and another object are equal and have the same type. Not-a-number values can be considered equal by this method.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The parameter <i>obj</i>
is an arbitrary object.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if the objects are equal; otherwise, <code>false
</code> .</p>

<p><a id="Equals_PeterO_Cbor_CBORObject"></a></p>

<h3>Equals</h3>

<pre>public sealed bool Equals(
    PeterO.Cbor.CBORObject other);
</pre>

<p>Compares the equality of two CBOR objects. Not-a-number values can be considered equal by this method.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: The object to compare.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if the objects are equal; otherwise, <code>false
</code> .</p>

<p><a id="FromJSONString_string"></a></p>

<h3>FromJSONString</h3>

<pre>public static PeterO.Cbor.CBORObject FromJSONString(
    string str);
</pre>

<p>Generates a CBOR object from a text string in JavaScript Object Notation (JSON) format.</p>

<p>If a JSON object has duplicate keys, a CBORException is thrown. This is a change in version 4.0.</p>

<p>Note that if a CBOR object is converted to JSON with <code>ToJSONString
</code> , then the JSON is converted back to CBOR with this method, the new BOR object will not necessarily be the same as the old CBOR object, specially if the old CBOR object uses data types not supported in JSON, uch as integers in map keys.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>str</i>: A string in JSON format. The entire string must contain a single JSON object and not multiple objects. The string may not begin with a byte-order mark (U+FEFF).</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>str</i>
is null.</p></li>
<li><p>PeterO.Cbor.CBORException:
The string is not in JSON format.</p></li>
</ul>

<p><a id="FromJSONString_string_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>FromJSONString</h3>

<pre>public static PeterO.Cbor.CBORObject FromJSONString(
    string str,
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Generates a CBOR object from a text string in JavaScript Object Notation (JSON) format, using the specified options to control the decoding process.Note that if a CBOR object is converted to JSON with <code>ToJSONString
</code> , then the JSON is converted back to CBOR with this method, the new BOR object will not necessarily be the same as the old CBOR object, specially if the old CBOR object uses data types not supported in JSON, uch as integers in map keys.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A string in JSON format. The entire string must contain a single JSON object and not multiple objects. The string may not begin with a byte-order mark (U+FEFF).</p></li>
<li><p><i>options</i>: Specifies options to control the decoding process.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>str</i>
or <i>options</i>
is null.</p></li>
<li><p>PeterO.Cbor.CBORException:
The string is not in JSON format.</p></li>
</ul>

<p><a id="FromObject_bool"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    bool value);
</pre>

<p>Returns the CBOR true value or false value, depending on &quot;value&quot;.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: Either True or False.</li>
</ul>

<p><b>Return Value:</b></p>

<p>CBORObject.True if value is true; otherwise CBORObject.False.</p>

<p><a id="FromObject_byte"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    byte value);
</pre>

<p>Generates a CBOR object from a byte (0 to 255).</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a byte (from 0 to 255).</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_byte"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    byte[] bytes);
</pre>

<p>Generates a CBOR object from a byte array. The byte array is copied to a new byte array. (This method can&#39;t be used to decode CBOR data from a byte array; for that, use the DecodeFromBytes method instead.).</p>

<p>The following example encodes a text string to a UTF-8 byte array, then uses the array to create a CBOR byte string object. It is not recommended to use <code>Encoding.UTF8.GetBytes
</code> in .NET, or the <code>getBytes()
</code> method in Java to do this. For instance, <code>getBytes()
</code> encodes text strings in a default (so not fixed) character encoding, hich can be undesirable. Instead, use the <code>DataUtilities.GetUtf8Bytes
</code> method to convert text strings to UTF-8.</p>

<pre>/* true does character replacement of invalid UTF-8; false throws an
        exception on invalid UTF-8 */ byte[] bytes = DataUtilities.GetUtf8Bytes(
        textString, true); CBORObject cbor = CBORObject.FromBytes(bytes);
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><i>bytes</i>: A byte array. Can be null.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR byte string object where each byte of the given byte array is copied to a new array, or CBORObject.Null if the value is null.</p>

<p><a id="FromObject_double"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    double value);
</pre>

<p>Generates a CBOR object from a 64-bit floating-point number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a 64-bit floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_float"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    float value);
</pre>

<p>Generates a CBOR object from a 32-bit floating-point number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a 32-bit floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_int"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    int value);
</pre>

<p>Generates a CBOR object from a 32-bit signed integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_int"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    int[] array);
</pre>

<p>Generates a CBOR object from an array of 32-bit integers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>array</i>: An array of 32-bit integers.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR array object where each element of the given array is copied to a new array, or CBORObject.Null if the value is null.</p>

<p><a id="FromObject_long"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    long value);
</pre>

<p>Generates a CBOR object from a 64-bit signed integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_long"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    long[] array);
</pre>

<p>Generates a CBOR object from an array of 64-bit integers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>array</i>: An array of 64-bit integers.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR array object where each element of the given array is copied to a new array, or CBORObject.Null if the value is null.</p>

<p><a id="FromObject_object"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    object obj);
</pre>

<p>Generates a CBORObject from an arbitrary object. See the overload of this method that takes CBORTypeMapper and PODOptions arguments.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The parameter <i>obj</i>
is an arbitrary object.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object corresponding to the given object. Returns CBORObject.Null if the object is null.</p>

<p><a id="FromObject_object_PeterO_Cbor_CBORTypeMapper"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    object obj,
    PeterO.Cbor.CBORTypeMapper mapper);
</pre>

<p>Generates a CBORObject from an arbitrary object. See the overload of this method that takes CBORTypeMapper and PODOptions arguments.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>obj</i>: The parameter <i>obj</i>
is an arbitrary object.</p></li>
<li><p><i>mapper</i>: An object containing optional converters to convert objects of certain types to CBOR objects.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object corresponding to the given object. Returns CBORObject.Null if the object is null.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>mapper</i>
is null.</li>
</ul>

<p><a id="FromObject_object_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    object obj,
    PeterO.Cbor.CBORTypeMapper mapper,
    PeterO.Cbor.PODOptions options);
</pre>

<p>Generates a CBORObject from an arbitrary object, using the given options to control how certain objects are converted to CBOR objects. The following cases are checked in the logical order given (rather than the strict order in which they are implemented by this library):</p>

<ul>
<li><p><code>null
</code> is converted to <code>CBORObject.Null
</code> .</p></li>
<li><p>A <code>CBORObject
</code> is returned as itself.</p></li>
<li><p>If the object is of a type corresponding to a type converter mentioned in the <i>mapper</i>
parameter, that converter will be used to convert the object to a BOR object. Type converters can be used to override the default onversion behavior of almost any object.</p></li>
<li><p>A <code>char
</code> is converted to an integer (from 0 through 65535), and returns a CBOR bject of that integer. (This is a change in version 4.0 from previous ersions, which converted <code>char
</code> , except surrogate code points from 0xd800 through 0xdfff, into ingle-character text strings.)</p></li>
<li><p>A <code>bool
</code> ( <code>boolean
</code> in Java) is converted to <code>CBORObject.True
</code> or <code>CBORObject.False
</code> .</p></li>
<li><p>A <code>byte
</code> is converted to a CBOR integer from 0 through 255.</p></li>
<li><p>A primitive integer type ( <code>int
</code> , <code>short
</code> , <code>long
</code> , as well as <code>sbyte
</code> , <code>ushort
</code> , <code>uint
</code> , and <code>ulong
</code> in .NET) is converted to the corresponding CBOR integer.</p></li>
<li><p>A primitive floating-point type ( <code>float
</code> , <code>double
</code> , as well as <code>decimal
</code> in .NET) is converted to the corresponding CBOR number.</p></li>
<li><p>A <code>String
</code> is converted to a CBOR text string. To create a CBOR byte string bject from <code>String
</code> , see the example given in<strong>PeterO.Cbor.CBORObject.FromObject(System.Byte[])</strong>.</p></li>
<li><p>A number of type <code>EDecimal
</code> , <code>EFloat
</code> , <code>EInteger
</code> , and <code>ERational
</code> in the<a href="https://www.nuget.org/packages/PeterO.Numbers"> <code>PeterO.Numbers
</code> </a>library (in .NET) or the<a href="https://github.com/peteroupc/numbers-java"> <code>com.github.peteroupc/numbers
</code> </a>artifact (in Java) is converted to the corresponding CBOR number.</p></li>
<li><p>An array other than <code>byte[]
</code> is converted to a CBOR array. In the .NET version, a multidimensional rray is converted to an array of arrays.</p></li>
<li><p>A <code>byte[]
</code> (1-dimensional byte array) is converted to a CBOR byte string; the yte array is copied to a new byte array in this process. (This method an&#39;t be used to decode CBOR data from a byte array; for that, use the<b>DecodeFromBytes</b>method instead.)</p></li>
<li><p>An object implementing IDictionary (Map in Java) is converted to a CBOR map containing the keys and values enumerated.</p></li>
<li><p>An object implementing IEnumerable (Iterable in Java) is converted to a CBOR array containing the items enumerated.</p></li>
<li><p>An enumeration ( <code>Enum
</code> ) object is converted to its<i>underlying value</i>in the .NET version, or the result of its <code>ordinal()
</code> method in the Java version.</p></li>
<li><p>An object of type <code>DateTime
</code> , <code>Uri
</code> , or <code>Guid
</code> ( <code>Date
</code> , <code>URI
</code> , or <code>UUID
</code> , respectively, in Java) will be converted to a tagged CBOR object of he appropriate kind. <code>DateTime
</code> / <code>Date
</code> will be converted to a tag-0 string following the date format used in he Atom syndication format.</p></li>
<li><p>If the object is a type not specially handled above, this method checks the <i>obj</i>
parameter for eligible getters as follows:</p></li>
<li><p>(*) In the .NET version, eligible getters are the public, nonstatic getters of read/write properties (and also those of read-only properties in the case of a compiler-generated type). If a class has two properties of the form &quot;X&quot; and &quot;IsX&quot;, where &quot;X&quot; is any name, or has multiple properties with the same name, those properties are ignored.</p></li>
<li><p>(*) In the Java version, eligible getters are public, nonstatic methods starting with &quot;get&quot; or &quot;is&quot; (either word followed by a character other than a basic digit or lower-case letter, that is, other than &quot;a&quot; to &quot;z&quot; or &quot;0&quot; to &quot;9&quot;), that take no parameters and do not return void, except that methods named &quot;getClass&quot; are not eligible getters. If a class has two otherwise eligible getters of the form &quot;isX&quot; and &quot;getX&quot;, where &quot;X&quot; is the same in both, or two such getters with the same name but different return type, they are not eligible getters.</p></li>
<li><p>Then, the method returns a CBOR map with each eligible getter&#39;s name or property name as each key, and with the corresponding value returned by that getter as that key&#39;s value. Before adding a key-value pair to the map, the key&#39;s name is adjusted according to the rules described in the <a href="PeterO.Cbor.PODOptions.html">PeterO.Cbor.PODOptions</a>documentation. Note that for security reasons, certain types are not upported even if they contain eligible getters.</p></li>
</ul>

<p><b>REMARK:</b>.NET enumeration ( <code>Enum
</code> ) constants could also have been converted to text strings with <code>ToString()
</code> , but that method will return multiple names if the given Enum object s a combination of Enum objects (e.g. if the object is <code>FileAccess.Read | FileAccess.Write
</code> ). More generally, if Enums are converted to text strings, constants rom Enum types with the <code>Flags
</code> attribute, and constants from the same Enum type that share an nderlying value, should not be passed to this method.</p>

<p>REMARK: A certain consistency between .NET and Java and between FromObject and ToObject are sought for version 4.0. It is also hoped that--</p>

<ul>
<li><p>the ToObject method will support deserializing to objects consisting of fields and not getters (&quot;getX()&quot; methods), both in .NET and in Java, and</p></li>
<li><p>both FromObject and ToObject will be better designed, in version 4.0, so that backward-compatible improvements are easier to make.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>obj</i>: An arbitrary object to convert to a CBOR object. <b>NOTE:</b>For security reasons, an application should, whenever possible, not base this parameter on user input or other externally supplied data unless the application limits this parameter&#39;s inputs to types specially handled by this method (such as  <code>int</code> or <code>String
</code> ) and/or to plain-old-data types (POCO or POJO types) within the ontrol of the application. If the plain-old-data type references other ata types, those types should likewise meet either criterion above.</p></li>
<li><p><i>mapper</i>: An object containing optional converters to convert objects of certain types to CBOR objects.</p></li>
<li><p><i>options</i>: An object containing options to control how certain objects are converted to CBOR objects.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object corresponding to the given object. Returns CBORObject.Null if the object is null.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>options</i>
is null.</li>
</ul>

<p><a id="FromObject_object_PeterO_Cbor_PODOptions"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    object obj,
    PeterO.Cbor.PODOptions options);
</pre>

<p>Generates a CBORObject from an arbitrary object. See the overload of this method that takes CBORTypeMapper and PODOptions arguments.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>obj</i>: The parameter <i>obj</i>
is an arbitrary object.</p></li>
<li><p><i>options</i>: An object containing options to control how certain objects are converted to CBOR objects.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object corresponding to the given object. Returns CBORObject.Null if the object is null.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>options</i>
is null.</li>
</ul>

<p><a id="FromObject_PeterO_Cbor_CBORObject"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    PeterO.Cbor.CBORObject value);
</pre>

<p>Generates a CBOR object from a CBOR object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a CBOR object.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Same as.</p>

<p><a id="FromObject_PeterO_Cbor_CBORObject"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    PeterO.Cbor.CBORObject[] array);
</pre>

<p>Generates a CBOR object from an array of CBOR objects.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>array</i>: An array of CBOR objects.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object where each element of the given array is copied to a new array, or CBORObject.Null if the value is null.</p>

<p><a id="FromObject_PeterO_Numbers_EDecimal"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    PeterO.Numbers.EDecimal otherValue);
</pre>

<p>Generates a CBOR object from a decimal number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR number.</p>

<p><a id="FromObject_PeterO_Numbers_EFloat"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    PeterO.Numbers.EFloat bigValue);
</pre>

<p>Generates a CBOR object from an arbitrary-precision binary floating-point number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: An arbitrary-precision binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR number.</p>

<p><a id="FromObject_PeterO_Numbers_EInteger"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    PeterO.Numbers.EInteger bigintValue);
</pre>

<p>Generates a CBOR object from an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigintValue</i>: An arbitrary-precision value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR number.</p>

<p><a id="FromObject_PeterO_Numbers_ERational"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    PeterO.Numbers.ERational bigValue);
</pre>

<p>Generates a CBOR object from a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: A rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR number.</p>

<p><a id="FromObject_sbyte"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    sbyte value);
</pre>

<p>Converts a signed 8-bit integer to a CBOR object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is an 8-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_short"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    short value);
</pre>

<p>Generates a CBOR object from a 16-bit signed integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a 16-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_string"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    string strValue);
</pre>

<p>Generates a CBOR object from a text string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>strValue</i>: A string value. Can be null.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object representing the string, or CBORObject.Null if stringValue is null.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The string contains an unpaired surrogate code point.</li>
</ul>

<p><a id="FromObject_System_Decimal"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    System.Decimal value);
</pre>

<p>Converts a .NET decimal to a CBOR object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: The parameter <i>value</i>
is a Decimal object.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object with the same value as the .NET decimal.</p>

<p><a id="FromObject_uint"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    uint value);
</pre>

<p>Converts a 32-bit unsigned integer to a CBOR object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: A 32-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_ulong"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    ulong value);
</pre>

<p>Converts a 64-bit unsigned integer to a CBOR object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: A 64-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObject_ushort"></a></p>

<h3>FromObject</h3>

<pre>public static PeterO.Cbor.CBORObject FromObject(
    ushort value);
</pre>

<p>Converts a 16-bit unsigned integer to a CBOR object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: A 16-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="FromObjectAndTag_object_ulong"></a></p>

<h3>FromObjectAndTag</h3>

<pre>public static PeterO.Cbor.CBORObject FromObjectAndTag(
    object o,
    ulong tag);
</pre>

<p>Generates a CBOR object from an arbitrary object and gives the resulting object a tag.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>o</i>: The parameter <i>o</i>
is an arbitrary object.</p></li>
<li><p><i>tag</i>: A 64-bit integer that specifies a tag number. The tag number 55799 can be used to mark a &quot;self-described CBOR&quot; object. This document does not attempt to list all CBOR tags and their meanings. An up-to-date list can be found at the CBOR Tags registry maintained by the Internet Assigned Numbers Authority (<i>iana.org/assignments/cbor-tags</i>).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object where the object <i>o</i>
is converted to a CBOR object and given the tag <i>tag</i>
.</p>

<p><a id="FromObjectAndTag_object_PeterO_Numbers_EInteger"></a></p>

<h3>FromObjectAndTag</h3>

<pre>public static PeterO.Cbor.CBORObject FromObjectAndTag(
    object valueOb,
    PeterO.Numbers.EInteger bigintTag);
</pre>

<p>Generates a CBOR object from an arbitrary object and gives the resulting object a tag.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>valueOb</i>: An arbitrary object. If the tag number is 2 or 3, this must be a byte string whose bytes represent an integer in little-endian byte order, and the value of the number is 1 minus the integer&#39;s value for tag 3. If the tag number is 4 or 5, this must be an array with two elements: the first must be an integer representing the exponent, and the second must be an integer representing a mantissa.</p></li>
<li><p><i>bigintTag</i>: Tag number. The tag number 55799 can be used to mark a &quot;self-described CBOR&quot; object. This document does not attempt to list all CBOR tags and their meanings. An up-to-date list can be found at the CBOR Tags registry maintained by the Internet Assigned Numbers Authority (<i>iana.org/assignments/cbor-tags</i>).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object where the object <i>valueOb</i>
is converted to a CBOR object and given the tag <i>bigintTag</i>
.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter <i>bigintTag</i>
is less than 0 or greater than 2^64-1, or <i>valueOb</i>
&#39;s type is unsupported.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>bigintTag</i>
is null.</p></li>
</ul>

<p><a id="FromObjectAndTag_object_int"></a></p>

<h3>FromObjectAndTag</h3>

<pre>public static PeterO.Cbor.CBORObject FromObjectAndTag(
    object valueObValue,
    int smallTag);
</pre>

<p>Generates a CBOR object from an arbitrary object and gives the resulting object a tag.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>valueObValue</i>: An arbitrary object. If the tag number is 2 or 3, this must be a byte string whose bytes represent an integer in little-endian byte order, and the value of the number is 1 minus the integer&#39;s value for tag 3. If the tag number is 4 or 5, this must be an array with two elements: the first must be an integer representing the exponent, and the second must be an integer representing a mantissa.</p></li>
<li><p><i>smallTag</i>: A 32-bit integer that specifies a tag number. The tag number 55799 can be used to mark a &quot;self-described CBOR&quot; object. This document does not attempt to list all CBOR tags and their meanings. An up-to-date list can be found at the CBOR Tags registry maintained by the Internet Assigned Numbers Authority (<i>iana.org/assignments/cbor-tags</i>).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object where the object <i>valueObValue</i>
is converted to a CBOR object and given the tag <i>smallTag</i>
.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The parameter <i>smallTag</i>
is less than 0 or <i>valueObValue</i>
&#39;s type is unsupported.</li>
</ul>

<p><a id="FromSimpleValue_int"></a></p>

<h3>FromSimpleValue</h3>

<pre>public static PeterO.Cbor.CBORObject FromSimpleValue(
    int simpleValue);
</pre>

<p>Creates a CBOR object from a simple value number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>simpleValue</i>: The parameter <i>simpleValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The parameter <i>simpleValue</i>
is less than 0, greater than 255, or from 24 through 31.</li>
</ul>

<p><a id="GetAllTags"></a></p>

<h3>GetAllTags</h3>

<pre>public PeterO.Numbers.EInteger[] GetAllTags();
</pre>

<p>Gets a list of all tags, from outermost to innermost.</p>

<p><b>Return Value:</b></p>

<p>An array of tags, or the empty string if this object is untagged.</p>

<p><a id="GetByteString"></a></p>

<h3>GetByteString</h3>

<pre>public byte[] GetByteString();
</pre>

<p>Gets the backing byte array used in this CBOR object, if this object is a byte string, without copying the data to a new byte array. Any changes in the returned array&#39;s contents will be reflected in this CBOR object. Note, though, that the array&#39;s length can&#39;t be changed.</p>

<p><b>Return Value:</b></p>

<p>The byte array held by this CBOR object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object is not a byte string.</li>
</ul>

<p><a id="GetHashCode"></a></p>

<h3>GetHashCode</h3>

<pre>public override int GetHashCode();
</pre>

<p>Calculates the hash code of this object. No application or process IDs are used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit hash code.</p>

<p><a id="GetOrDefault_object_PeterO_Cbor_CBORObject"></a></p>

<h3>GetOrDefault</h3>

<pre>public PeterO.Cbor.CBORObject GetOrDefault(
    object key,
    PeterO.Cbor.CBORObject defaultValue);
</pre>

<p>Gets the value of a CBOR object by integer index in this array or by CBOR object key in this map, or a default value if that value is not found.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>key</i>: An arbitrary object. If this is a CBOR map, this parameter is converted to a CBOR object serving as the key to the map or index to the array, and can be null. If this is a CBOR array, the key must be an integer 0 or greater and less than the size of the array, and may be any object convertible to a CBOR integer.</p></li>
<li><p><i>defaultValue</i>: A value to return if an item with the given key doesn&#39;t exist, or if the CBOR object is an array and the key is not an integer 0 or greater and less than the size of the array.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The CBOR object referred to by index or key in this array or map. If this is a CBOR map, returns null if an item with the given key doesn&#39;t exist.</p>

<p><a id="HasMostOuterTag_int"></a></p>

<h3>HasMostOuterTag</h3>

<pre>public bool HasMostOuterTag(
    int tagValue);
</pre>

<p>Returns whether this object has an outermost tag and that tag is of the given number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>tagValue</i>: The tag number.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object has an outermost tag and that tag is of the given number; therwise, <code>false
</code> .</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The parameter <i>tagValue</i>
is less than 0.</li>
</ul>

<p><a id="HasMostOuterTag_PeterO_Numbers_EInteger"></a></p>

<h3>HasMostOuterTag</h3>

<pre>public bool HasMostOuterTag(
    PeterO.Numbers.EInteger bigTagValue);
</pre>

<p>Returns whether this object has an outermost tag and that tag is of the given number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigTagValue</i>: The tag number.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object has an outermost tag and that tag is of the given number; therwise, <code>false
</code> .</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>bigTagValue</i>
is null.</p></li>
<li><p>System.ArgumentException:
The parameter <i>bigTagValue</i>
is less than 0.</p></li>
</ul>

<p><a id="HasTag_int"></a></p>

<h3>HasTag</h3>

<pre>public bool HasTag(
    int tagValue);
</pre>

<p>Returns whether this object has a tag of the given number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>tagValue</i>: The tag value to search for.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object has a tag of the given number; otherwise, <code>false
</code> .</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter <i>tagValue</i>
is less than 0.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>tagValue</i>
is null.</p></li>
</ul>

<p><a id="HasTag_PeterO_Numbers_EInteger"></a></p>

<h3>HasTag</h3>

<pre>public bool HasTag(
    PeterO.Numbers.EInteger bigTagValue);
</pre>

<p>Returns whether this object has a tag of the given number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigTagValue</i>: The tag value to search for.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this object has a tag of the given number; otherwise, <code>false
</code> .</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>bigTagValue</i>
is null.</p></li>
<li><p>System.ArgumentException:
The parameter <i>bigTagValue</i>
is less than 0.</p></li>
</ul>

<p><a id="Insert_int_object"></a></p>

<h3>Insert</h3>

<pre>public PeterO.Cbor.CBORObject Insert(
    int index,
    object valueOb);
</pre>

<p>Inserts an object at the specified position in this CBOR array.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>index</i>: Zero-based index to insert at.</p></li>
<li><p><i>valueOb</i>: An object representing the value, which will be converted to a CBORObject. Can be null, in which case this value is converted to CBORObject.Null.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>This instance.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object is not an array.</p></li>
<li><p>System.ArgumentException:
The parameter <i>valueOb</i>
has an unsupported type; or <i>index</i>
is not a valid index into this array.</p></li>
</ul>

<p><a id="IsInfinity"></a></p>

<h3>IsInfinity</h3>

<pre>public bool IsInfinity();
</pre>

<p>Gets a value indicating whether this CBOR object represents infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this CBOR object represents infinity; otherwise, <code>false
</code> .</p>

<p><a id="IsNaN"></a></p>

<h3>IsNaN</h3>

<pre>public bool IsNaN();
</pre>

<p>Gets a value indicating whether this CBOR object represents a not-a-number value (as opposed to whether this object&#39;s type is not a number type).</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this CBOR object represents a not-a-number value (as opposed to hether this object&#39;s type is not a number type); otherwise, <code>false
</code> .</p>

<p><a id="IsNegativeInfinity"></a></p>

<h3>IsNegativeInfinity</h3>

<pre>public bool IsNegativeInfinity();
</pre>

<p>Gets a value indicating whether this CBOR object represents negative infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this CBOR object represents negative infinity; otherwise, <code>false
</code> .</p>

<p><a id="IsPositiveInfinity"></a></p>

<h3>IsPositiveInfinity</h3>

<pre>public bool IsPositiveInfinity();
</pre>

<p>Gets a value indicating whether this CBOR object represents positive infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true
</code> if this CBOR object represents positive infinity; otherwise, <code>false
</code> .</p>

<p><a id="Multiply_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject"></a></p>

<h3>Multiply</h3>

<pre>public static PeterO.Cbor.CBORObject Multiply(
    PeterO.Cbor.CBORObject first,
    PeterO.Cbor.CBORObject second);
</pre>

<p>Multiplies two CBOR numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The parameter <i>first</i>
is a CBOR object.</p></li>
<li><p><i>second</i>: The parameter <i>second</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
Either or both operands are not numbers (as opposed to Not-a-Number, NaN).</li>
</ul>

<p><a id="Negate"></a></p>

<h3>Negate</h3>

<pre>public PeterO.Cbor.CBORObject Negate();
</pre>

<p>Gets this object&#39;s value with the sign reversed.</p>

<p><b>Return Value:</b></p>

<p>The reversed-sign form of this number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object&#39;s type is not a number type.</li>
</ul>

<p><a id="NewArray"></a></p>

<h3>NewArray</h3>

<pre>public static PeterO.Cbor.CBORObject NewArray();
</pre>

<p>Creates a new empty CBOR array.</p>

<p><b>Return Value:</b></p>

<p>A new CBOR array.</p>

<p><a id="NewMap"></a></p>

<h3>NewMap</h3>

<pre>public static PeterO.Cbor.CBORObject NewMap();
</pre>

<p>Creates a new empty CBOR map.</p>

<p><b>Return Value:</b></p>

<p>A new CBOR map.</p>

<p><a id="op_Addition"></a></p>

<h3>Operator <code>+</code></h3>

<pre>public static PeterO.Cbor.CBORObject operator +(
    PeterO.Cbor.CBORObject a,
    PeterO.Cbor.CBORObject b);
</pre>

<p>Adds two CBOR objects and returns their result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The parameter <i>a</i>
is a CBOR object.</p></li>
<li><p><i>b</i>: The parameter <i>b</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two objects.</p>

<p><a id="op_Division"></a></p>

<h3>Operator <code>/</code></h3>

<pre>public static PeterO.Cbor.CBORObject operator /(
    PeterO.Cbor.CBORObject a,
    PeterO.Cbor.CBORObject b);
</pre>

<p>Divides a CBORObject object by the value of a CBORObject object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The parameter <i>a</i>
is a CBOR object.</p></li>
<li><p><i>b</i>: The parameter <i>b</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><a id="op_Modulus"></a></p>

<h3>Operator <code>%</code></h3>

<pre>public static PeterO.Cbor.CBORObject operator %(
    PeterO.Cbor.CBORObject a,
    PeterO.Cbor.CBORObject b);
</pre>

<p>Finds the remainder that results when a CBORObject object is divided by the value of a CBORObject object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The parameter <i>a</i>
is a CBOR object.</p></li>
<li><p><i>b</i>: The parameter <i>b</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers.</p>

<p><a id="op_Multiply"></a></p>

<h3>Operator <code>*</code></h3>

<pre>public static PeterO.Cbor.CBORObject operator *(
    PeterO.Cbor.CBORObject a,
    PeterO.Cbor.CBORObject b);
</pre>

<p>Multiplies a CBORObject object by the value of a CBORObject object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The parameter <i>a</i>
is a CBOR object.</p></li>
<li><p><i>b</i>: The parameter <i>b</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers.</p>

<p><a id="op_Subtraction"></a></p>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Cbor.CBORObject operator -(
    PeterO.Cbor.CBORObject a,
    PeterO.Cbor.CBORObject b);
</pre>

<p>Subtracts a CBORObject object from a CBORObject object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The parameter <i>a</i>
is a CBOR object.</p></li>
<li><p><i>b</i>: The parameter <i>b</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><a id="Read_System_IO_Stream"></a></p>

<h3>Read</h3>

<pre>public static PeterO.Cbor.CBORObject Read(
    System.IO.Stream stream);
</pre>

<p>Reads an object in CBOR format from a data stream. This method will read from the stream until the end of the CBOR object is reached or an error occurs, whichever happens first.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>stream</i>: A readable data stream.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object that was read.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>PeterO.Cbor.CBORException:
There was an error in reading or parsing the data.</p></li>
</ul>

<p><a id="Read_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>Read</h3>

<pre>public static PeterO.Cbor.CBORObject Read(
    System.IO.Stream stream,
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Reads an object in CBOR format from a data stream, using the specified options to control the decoding process. This method will read from the stream until the end of the CBOR object is reached or an error occurs, whichever happens first.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>stream</i>: A readable data stream.</p></li>
<li><p><i>options</i>: The parameter <i>options</i>
is a CBOREncodeOptions object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBOR object that was read.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>PeterO.Cbor.CBORException:
There was an error in reading or parsing the data.</p></li>
</ul>

<p><a id="ReadJSON_System_IO_Stream"></a></p>

<h3>ReadJSON</h3>

<pre>public static PeterO.Cbor.CBORObject ReadJSON(
    System.IO.Stream stream);
</pre>

<p>Generates a CBOR object from a data stream in JavaScript Object Notation (JSON) format. The JSON stream may begin with a byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by assuming that the first character read must be a byte-order mark or a nonzero basic character (U+0001 to U+007F). (In previous versions, only UTF-8 was allowed.)If a JSON object has the same key, only the last given value will be used for each duplicated key.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>stream</i>: A readable data stream. The sequence of bytes read from the data stream must contain a single JSON object and not multiple objects.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
<li><p>PeterO.Cbor.CBORException:
The data stream contains invalid encoding or is not in JSON format.</p></li>
</ul>

<p><a id="ReadJSON_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>ReadJSON</h3>

<pre>public static PeterO.Cbor.CBORObject ReadJSON(
    System.IO.Stream stream,
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Generates a CBOR object from a data stream in JavaScript Object Notation (JSON) format, using the specified options to control the decoding process. The JSON stream may begin with a byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by assuming that the first character read must be a byte-order mark or a nonzero basic character (U+0001 to U+007F). (In previous versions, only UTF-8 was allowed.)By default, if a JSON object has the same key, only the last given value will be used for each duplicated key.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>stream</i>: A readable data stream. The sequence of bytes read from the data stream must contain a single JSON object and not multiple objects.</p></li>
<li><p><i>options</i>: The parameter <i>options</i>
is a CBOREncodeOptions object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
<li><p>PeterO.Cbor.CBORException:
The data stream contains invalid encoding or is not in JSON format.</p></li>
</ul>

<p><a id="Remainder_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject"></a></p>

<h3>Remainder</h3>

<pre>public static PeterO.Cbor.CBORObject Remainder(
    PeterO.Cbor.CBORObject first,
    PeterO.Cbor.CBORObject second);
</pre>

<p>Finds the remainder that results when a CBORObject object is divided by the value of a CBORObject object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The parameter <i>first</i>
is a CBOR object.</p></li>
<li><p><i>second</i>: The parameter <i>second</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers.</p>

<p><a id="Remove_object"></a></p>

<h3>Remove</h3>

<pre>public bool Remove(
    object obj);
</pre>

<p>If this object is an array, removes the first instance of the specified item (once converted to a CBOR object) from the array. If this object is a map, removes the item with the given key (once converted to a CBOR object) from the map.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The item or key (once converted to a CBOR object) to remove.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if the item was removed; otherwise, <code>false
</code> .</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>obj</i>
is null (as opposed to CBORObject.Null).</p></li>
<li><p>System.InvalidOperationException:
The object is not an array or map.</p></li>
</ul>

<p><a id="Remove_PeterO_Cbor_CBORObject"></a></p>

<h3>Remove</h3>

<pre>public bool Remove(
    PeterO.Cbor.CBORObject obj);
</pre>

<p>If this object is an array, removes the first instance of the specified item from the array. If this object is a map, removes the item with the given key from the map.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The item or key to remove.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true
</code> if the item was removed; otherwise, <code>false
</code> .</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>obj</i>
is null (as opposed to CBORObject.Null).</p></li>
<li><p>System.InvalidOperationException:
The object is not an array or map.</p></li>
</ul>

<p><a id="RemoveAt_int"></a></p>

<h3>RemoveAt</h3>

<pre>public bool RemoveAt(
    int index);
</pre>

<p>Removes the item at the given index of this CBOR array.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>index</i>: The index, starting at 0, of the item to remove.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Returns &quot;true&quot; if the object was removed. Returns &quot;false&quot; if the given index is less than 0, or is at least as high as the number of items in the array.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.InvalidOperationException:
This object is not a CBOR array.</li>
</ul>

<p><a id="Set_object_object"></a></p>

<h3>Set</h3>

<pre>public PeterO.Cbor.CBORObject Set(
    object key,
    object valueOb);
</pre>

<p>Maps an object to a key in this CBOR map, or adds the value if the key doesn&#39;t exist. If this is a CBOR array, instead sets the value at the given index to the given value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>key</i>: If this instance is a CBOR map, this parameter is an object representing the key, which will be converted to a CBORObject; in this case, this parameter can be null, in which case this value is converted to CBORObject.Null. If this instance is a CBOR array, this parameter must be a 32-bit signed integer ( <code>int
</code> ) identifying the index (starting from 0) of the item to set in the rray.</p></li>
<li><p><i>valueOb</i>: An object representing the value, which will be converted to a CBORObject. Can be null, in which case this value is converted to CBORObject.Null.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>This instance.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.InvalidOperationException:
This object is not a map or an array.</p></li>
<li><p>System.ArgumentException:
The parameter <i>key</i>
or <i>valueOb</i>
has an unsupported type, or this instance is a CBOR array and <i>key</i>
is less than 0, is the size of this array or greater, or is not a 32-bit igned integer ( <code>int
</code> ).</p></li>
</ul>

<p><a id="Subtract_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject"></a></p>

<h3>Subtract</h3>

<pre>public static PeterO.Cbor.CBORObject Subtract(
    PeterO.Cbor.CBORObject first,
    PeterO.Cbor.CBORObject second);
</pre>

<p>Finds the difference between two CBOR number objects.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The parameter <i>first</i>
is a CBOR object.</p></li>
<li><p><i>second</i>: The parameter <i>second</i>
is a CBOR object.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
Either or both operands are not numbers (as opposed to Not-a-Number, NaN).</li>
</ul>

<p><a id="ToJSONString_PeterO_Cbor_JSONOptions"></a></p>

<h3>ToJSONString</h3>

<pre>public string ToJSONString(
    PeterO.Cbor.JSONOptions options);
</pre>

<p>Converts this object to a string in JavaScript Object Notation (JSON) format, using the specified options to control the encoding process. This function works not only with arrays and maps, but also integers, strings, byte arrays, and other JSON data types. Notes:</p>

<ul>
<li><p>If this object contains maps with non-string keys, the keys are converted to JSON strings before writing the map as a JSON string.</p></li>
<li><p>If the CBOR object contains CBOR maps, or is a CBOR map itself, the keys to the map are written out to the JSON string in an undefined order. Map keys other than untagged text strings are converted to JSON strings before writing them out (for example, <code>22(&quot;Test&quot;)
</code> is converted to <code>&quot;Test&quot;
</code> and <code>true
</code> is converted to <code>&quot;true&quot;
</code> ). If, after such conversion, two or more map keys are identical, his method throws a CBORException.</p></li>
<li><p>If a number in the form of an arbitrary-precision binary float has a very high binary exponent, it will be converted to a double before being converted to a JSON string. (The resulting double could overflow to infinity, in which case the arbitrary-precision binary float is converted to null.)</p></li>
<li><p>The string will not begin with a byte-order mark (U+FEFF); RFC 8259 (the JSON specification) forbids placing a byte-order mark at the beginning of a JSON string.</p></li>
<li><p>Byte strings are converted to Base64 URL without whitespace or padding by default (see section 4.1 of RFC 7049). A byte string will instead be converted to traditional base64 without whitespace or padding by default if it has tag 22, or base16 for tag 23. Padding will be included in the Base64 URL or traditional base64 form if<b>Base64Padding</b>in the JSON options is set to<b>true</b>. (To create a CBOR object with a given tag, call the <code>CBORObject.FromObjectAndTag
</code> method and pass the CBOR object and the desired tag number to that ethod.)</p></li>
<li><p>Rational numbers will be converted to their exact form, if possible, otherwise to a high-precision approximation. (The resulting approximation could overflow to infinity, in which case the rational number is converted to null.)</p></li>
<li><p>Simple values other than true and false will be converted to null. (This doesn&#39;t include floating-point numbers.)</p></li>
<li><p>Infinity and not-a-number will be converted to null.</p></li>
</ul>

<p>The example code given below (originally written in C# for the .NET version) can be used to write out certain keys of a CBOR map in a given order to a JSON string.</p>

<pre>/* Generates a JSON string of &#39;mapObj&#39; whose keys are in the order given
        in &#39;keys&#39; . Only keys found in &#39;keys&#39; will be written if they exist in
        &#39;mapObj&#39;. */ private static string KeysToJSONMap(CBORObject mapObj,
        IList&lt;CBORObject&gt; keys){ if (mapObj == null) { throw new
        ArgumentNullException)nameof(mapObj));} if (keys == null) { throw
        new ArgumentNullException)nameof(keys));} if (obj.Type !=
        CBORType.Map) { throw new ArgumentException(&quot;&#39;obj&#39; is not a map.&quot;); }
        StringBuilder builder = new StringBuilder(); var first = true;
        builder.Append(&quot;{&quot;); for (CBORObject key in keys) { if
        (mapObj.ContainsKey(key)) { if (!first) {builder.Append(&quot;, &quot;);} var
        keyString=(key.CBORType == CBORType.String) ? key.AsString() :
        key.ToJSONString(); builder.Append(CBORObject.FromObject(keyString)
        .ToJSONString()) .Append(&quot;:&quot;).Append(mapObj[key].ToJSONString());
        first=false; } } return builder.Append(&quot;}&quot;).ToString(); }
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><i>options</i>: An object containing the options to control writing the CBOR object to JSON.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A text string containing the converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>options</i>
is null.</li>
</ul>

<p><a id="ToJSONString"></a></p>

<h3>ToJSONString</h3>

<pre>public string ToJSONString();
</pre>

<p>Converts this object to a string in JavaScript Object Notation (JSON) format. See the overload to JSONString taking a JSONOptions argument for further information.If the CBOR object contains CBOR maps, or is a CBOR map itself, the keys to the map are written out to the JSON string in an undefined order. Map keys other than untagged text strings are converted to JSON strings before writing them out (for example, <code>22(&quot;Test&quot;)
</code> is converted to <code>&quot;Test&quot;
</code> and <code>true
</code> is converted to <code>&quot;true&quot;
</code> ). If, after such conversion, two or more map keys are identical, this ethod throws a CBORException. The example code given in<strong>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</strong>can be used to write out certain keys of a CBOR map in a given order to JSON string.</p>

<p><b>Return Value:</b></p>

<p>A text string.</p>

<p><a id="ToObject_System_Type"></a></p>

<h3>ToObject</h3>

<pre>public object ToObject(
    System.Type t);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See the documentation for the overload of this method taking a CBORTypeMapper parameter for more information. This method doesn&#39;t use a CBORTypeMapper parameter to restrict which data types are eligible for Plain-Old-Data serialization.</p>

<p>Java offers no easy way to express a generic type, at least none as easy as C#&#39;s <code>typeof
</code> operator. The following example, written in Java, is a way to specify hat the return value will be an ArrayList of String objects.</p>

<pre>Type arrayListString = new ParameterizedType(){ public Type[]
        getActualTypeArguments(){ /* Contains one type parameter, String */
        return new Type[]{ String.class }; } public Type getRawType(){ /* Raw
        type is ArrayList */ return ArrayList.class; } public Type
        getOwnerType(){ return null; } }; ArrayList&lt;String&gt; array =
        (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);
</pre>

<p>By comparison, the C# version is much shorter.</p>

<pre>var array = (List&lt;String&gt;)cborArray.ToObject(
        typeof(List&lt;String&gt;));
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><i>t</i>: The type, class, or interface that this method&#39;s return value will belong to. To express a generic type in Java, see the example.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ) or a plain-old-data type (POCO or POJO type) within the control of the pplication. If the plain-old-data type references other data types, those ypes should likewise meet either criterion above.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.NotSupportedException:
The given type <i>t</i>
, or this object&#39;s CBOR type, is not supported.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>t</i>
is null.</p></li>
<li><p>System.CBORException:
The given object&#39;s nesting is too deep, or another error occurred when serializing the object.</p></li>
</ul>

<p><a id="ToObject_System_Type_PeterO_Cbor_CBORTypeMapper"></a></p>

<h3>ToObject</h3>

<pre>public object ToObject(
    System.Type t,
    PeterO.Cbor.CBORTypeMapper mapper);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See the documentation for the overload of this method taking a CBORTypeMapper and PODOptions parameters parameters for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>t</i>: The type, class, or interface that this method&#39;s return value will belong to. To express a generic type in Java, see the example.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ///) or a plain-old-data type (POCO or POJO type) within the control of he application. If the plain-old-data type references other data types, hose types should likewise meet either criterion above.</p></li>
<li><p><i>mapper</i>: This parameter controls which data types are eligible for Plain-Old-Data deserialization and includes custom converters from CBOR objects to certain data types.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.NotSupportedException:
The given type <i>t</i>
, or this object&#39;s CBOR type, is not supported.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>t</i>
is null.</p></li>
<li><p>System.CBORException:
The given object&#39;s nesting is too deep, or another error occurred when serializing the object.</p></li>
</ul>

<p><a id="ToObject_System_Type_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions"></a></p>

<h3>ToObject</h3>

<pre>public object ToObject(
    System.Type t,
    PeterO.Cbor.CBORTypeMapper mapper,
    PeterO.Cbor.PODOptions options);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. The following cases are checked in the logical order given (rather than the strict order in which they are implemented by this library):</p>

<ul>
<li><p>If the type is <code>CBORObject
</code> , return this object.</p></li>
<li><p>If the given object is <code>CBORObject.Null
</code> (with or without tags), returns <code>null
</code> .</p></li>
<li><p>If the object is of a type corresponding to a type converter mentioned in the <i>mapper</i>
parameter, that converter will be used to convert the CBOR object to n object of the given type. Type converters can be used to override he default conversion behavior of almost any object.</p></li>
<li><p>If the type is <code>object
</code> , return this object.</p></li>
<li><p>If the type is <code>char
</code> , converts single-character CBOR text strings and CBOR integers from through 65535 to a <code>char
</code> object and returns that <code>char
</code> object.</p></li>
<li><p>If the type is <code>bool
</code> ( <code>boolean
</code> in Java), returns the result of AsBoolean.</p></li>
<li><p>If the type is a primitive integer type ( <code>byte
</code> , <code>int
</code> , <code>short
</code> , <code>long
</code> , as well as <code>sbyte
</code> , <code>ushort
</code> , <code>uint
</code> , and <code>ulong
</code> in .NET) or a primitive floating-point type ( <code>float
</code> , <code>double
</code> , as well as <code>decimal
</code> in .NET), returns the result of the corresponding As* method.</p></li>
<li><p>If the type is <code>String
</code> , returns the result of AsString.</p></li>
<li><p>If the type is <code>EDecimal
</code> , <code>EFloat
</code> , <code>EInteger
</code> , or <code>ERational
</code> in the<a href="https://www.nuget.org/packages/PeterO.Numbers"> <code>PeterO.Numbers
</code> </a>library (in .NET) or the<a href="https://github.com/peteroupc/numbers-java"> <code>com.github.peteroupc/numbers
</code> </a>artifact (in Java), returns the result of the corresponding As* ethod.</p></li>
<li><p>If the type is an enumeration ( <code>Enum
</code> ///) type this CBOR object is a text string or an integer, returns he appropriate enumerated constant. (For example, if <code>MyEnum
</code> includes an entry for <code>MyValue
</code> , this method will return <code>MyEnum.MyValue
</code> if the CBOR object represents <code>&quot;MyValue&quot;
</code> or the underlying value for <code>MyEnum.MyValue
</code> .)<b>Note:</b>If an integer is converted to a .NET Enum constant, and that integer s shared by more than one constant of the same type, it is undefined hich constant from among them is returned. (For example, if <code>MyEnum.Zero = 0
</code> and <code>MyEnum.Null = 0
</code> , converting 0 to <code>MyEnum
</code> may return either <code>MyEnum.Zero
</code> or <code>MyEnum.Null
</code> .) As a result, .NET Enum types with constants that share an nderlying value should not be passed to this method.</p></li>
<li><p>If the type is <code>byte[]
</code> (a one-dimensional byte array) and this CBOR object is a byte string, eturns a byte array which this CBOR byte string&#39;s data will be copied o. (This method can&#39;t be used to encode CBOR data to a byte array; or that, use the EncodeToBytes method instead.)</p></li>
<li><p>If the type is a one-dimensional or multidimensional array type and this CBOR object is an array, returns an array containing the items in this CBOR object.</p></li>
<li><p>If the type is List or the generic or non-generic IList, ICollection, or IEnumerable, (or ArrayList, List, Collection, or Iterable in Java), and if this CBOR object is an array, returns an object conforming to the type, class, or interface passed to this method, where the object will contain all items in this CBOR array.</p></li>
<li><p>If the type is Dictionary or the generic or non-generic IDictionary (or HashMap or Map in Java), and if this CBOR object is a map, returns an object conforming to the type, class, or interface passed to this method, where the object will contain all keys and values in this CBOR map.</p></li>
<li><p>If the type is an enumeration constant (&quot;enum&quot;), and this CBOR object is an integer or text string, returns the enumeration constant with the given number or name, respectively. (Enumeration constants made up of multiple enumeration constants, as allowed by .NET, can only be matched by number this way.)</p></li>
<li><p>If the type is <code>DateTime
</code> (or <code>Date
</code> in Java) , returns a date/time object if the CBOR object&#39;s outermost ag is 0 or 1. For tag 1, this method treats the CBOR object as a umber of seconds since the start of 1970, which is based on the POSIX efinition of &quot;seconds since the Epoch&quot;, a definition that does not ount leap seconds. In this method, this number of seconds assumes the se of a proleptic Gregorian calendar, in which the rules regarding he number of days in each month and which years are leap years are he same for all years as they were in 1970 (including without regard o transitions from other calendars to the Gregorian). For tag 1, CBOR bjects that express infinity or not-a-number (NaN) are treated as nvalid by this method.</p></li>
<li><p>If the type is <code>Uri
</code> (or <code>URI
</code> in Java), returns a URI object if possible.</p></li>
<li><p>If the type is <code>Guid
</code> (or <code>UUID
</code> in Java), returns a UUID object if possible.</p></li>
<li><p>Plain-Old-Data deserialization: If the object is a type not specially handled above, the type includes a zero-argument constructor (default or not), this CBOR object is a CBOR map, and the &quot;mapper&quot; parameter allows this type to be eligible for Plain-Old-Data deserialization, then this method checks the given type for eligible setters as follows:</p></li>
<li><p>(*) In the .NET version, eligible setters are the public, nonstatic setters of properties with a public, nonstatic getter. If a class has two properties of the form &quot;X&quot; and &quot;IsX&quot;, where &quot;X&quot; is any name, or has multiple properties with the same name, those properties are ignored.</p></li>
<li><p>(*) In the Java version, eligible setters are public, nonstatic methods starting with &quot;set&quot; followed by a character other than a basic digit or lower-case letter, that is, other than &quot;a&quot; to &quot;z&quot; or &quot;0&quot; to &quot;9&quot;, that take one parameter. The class containing an eligible setter must have a public, nonstatic method with the same name, but starting with &quot;get&quot; or &quot;is&quot; rather than &quot;set&quot;, that takes no parameters and does not return void. (For example, if a class has &quot;public setValue(String)&quot; and &quot;public getValue()&quot;, &quot;setValue&quot; is an eligible setter. However, &quot;setValue()&quot; and &quot;setValue(String, int)&quot; are not eligible setters.) If a class has two or more otherwise eligible setters with the same name, but different parameter type, they are not eligible setters.</p></li>
<li><p>Then, the method creates an object of the given type and invokes each eligible setter with the corresponding value in the CBOR map, if any. Key names in the map are matched to eligible setters according to the rules described in the <a href="PeterO.Cbor.PODOptions.html">PeterO.Cbor.PODOptions</a>documentation. Note that for security reasons, certain types are not upported even if they contain eligible setters.</p></li>
</ul>

<p>REMARK: A certain consistency between .NET and Java and between FromObject and ToObject are sought for version 4.0. It is also hoped that--</p>

<ul>
<li><p>the ToObject method will support deserializing to objects consisting of fields and not getters (&quot;getX()&quot; methods), both in .NET and in Java, and</p></li>
<li><p>both FromObject and ToObject will be better designed, in version 4.0, so that backward-compatible improvements are easier to make.</p></li>
</ul>

<p>Java offers no easy way to express a generic type, at least none as easy as C#&#39;s <code>typeof
</code> operator. The following example, written in Java, is a way to specify hat the return value will be an ArrayList of String objects.</p>

<pre>Type arrayListString = new ParameterizedType() { public Type[]
        getActualTypeArguments() { // Contains one type parameter, String return
        new Type[] { String.class }; } public Type getRawType() { /* Raw type is
        ArrayList */ return ArrayList.class; } public Type getOwnerType() {
        return null; } }; ArrayList&lt;String&gt; array =
        (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);
</pre>

<p>By comparison, the C# version is much shorter.</p>

<pre>var array = (List&lt;String&gt;)cborArray.ToObject(
        typeof(List&lt;String&gt;));
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>t</i>: The type, class, or interface that this method&#39;s return value will belong to. To express a generic type in Java, see the example.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ///) or a plain-old-data type (POCO or POJO type) within the control of he application. If the plain-old-data type references other data types, hose types should likewise meet either criterion above.</p></li>
<li><p><i>mapper</i>: This parameter controls which data types are eligible for Plain-Old-Data deserialization and includes custom converters from CBOR objects to certain data types.</p></li>
<li><p><i>options</i>: Specifies options for controlling deserialization of CBOR objects.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.NotSupportedException:
The given type <i>t</i>
, or this object&#39;s CBOR type, is not supported.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>t</i>
is null.</p></li>
<li><p>System.CBORException:
The given object&#39;s nesting is too deep, or another error occurred when serializing the object.</p></li>
</ul>

<p><a id="ToObject_System_Type_PeterO_Cbor_PODOptions"></a></p>

<h3>ToObject</h3>

<pre>public object ToObject(
    System.Type t,
    PeterO.Cbor.PODOptions options);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See the documentation for the overload of this method taking a CBORTypeMapper and PODOptions parameters for more information. This method (without a CBORTypeMapper parameter) allows all data types not otherwise handled to be eligible for Plain-Old-Data serialization.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>t</i>: The type, class, or interface that this method&#39;s return value will belong to. To express a generic type in Java, see the example.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ///) or a plain-old-data type (POCO or POJO type) within the control of he application. If the plain-old-data type references other data types, hose types should likewise meet either criterion above.</p></li>
<li><p><i>options</i>: Specifies options for controlling deserialization of CBOR objects.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.NotSupportedException:
The given type <i>t</i>
, or this object&#39;s CBOR type, is not supported.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>t</i>
is null.</p></li>
<li><p>System.CBORException:
The given object&#39;s nesting is too deep, or another error occurred when serializing the object.</p></li>
</ul>

<p><a id="ToObject_T_PeterO_Cbor_CBORTypeMapper"></a></p>

<h3>ToObject</h3>

<pre>public T ToObject&lt;T&gt;(
    PeterO.Cbor.CBORTypeMapper mapper);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See<strong>PeterO.Cbor.CBORObject.ToObject(System.Type)</strong>for further information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>mapper</i>: This parameter controls which data types are eligible for Plain-Old-Data deserialization and includes custom converters from CBOR objects to certain data types.</p></li>
<li><p>&lt;T&gt;: The type, class, or interface that this method&#39;s return value will belong o.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ) or a plain-old-data type (POCO type) within the control of the pplication. If the plain-old-data type references other data types, those ypes should likewise meet either criterion above.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.NotSupportedException:
The given type &quot;T&quot;, or this object&#39;s CBOR type, is not supported.</li>
</ul>

<p><a id="ToObject_T_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions"></a></p>

<h3>ToObject</h3>

<pre>public T ToObject&lt;T&gt;(
    PeterO.Cbor.CBORTypeMapper mapper,
    PeterO.Cbor.PODOptions options);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See<strong>PeterO.Cbor.CBORObject.ToObject(System.Type)</strong>for further information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>mapper</i>: This parameter controls which data types are eligible for Plain-Old-Data deserialization and includes custom converters from CBOR objects to certain data types.</p></li>
<li><p><i>options</i>: Specifies options for controlling deserialization of CBOR objects.</p></li>
<li><p>&lt;T&gt;: The type, class, or interface that this method&#39;s return value will belong o.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ) or a plain-old-data type (POCO type) within the control of the pplication. If the plain-old-data type references other data types, those ypes should likewise meet either criterion above.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.NotSupportedException:
The given type &quot;T&quot;, or this object&#39;s CBOR type, is not supported.</li>
</ul>

<p><a id="ToObject_T_PeterO_Cbor_PODOptions"></a></p>

<h3>ToObject</h3>

<pre>public T ToObject&lt;T&gt;(
    PeterO.Cbor.PODOptions options);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See<strong>PeterO.Cbor.CBORObject.ToObject(System.Type)</strong>for further information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>options</i>: Specifies options for controlling deserialization of CBOR objects.</p></li>
<li><p>&lt;T&gt;: The type, class, or interface that this method&#39;s return value will belong o.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ) or a plain-old-data type (POCO type) within the control of the pplication. If the plain-old-data type references other data types, those ypes should likewise meet either criterion above.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.NotSupportedException:
The given type &quot;T&quot;, or this object&#39;s CBOR type, is not supported.</li>
</ul>

<p><a id="ToObject_T"></a></p>

<h3>ToObject</h3>

<pre>public T ToObject&lt;T&gt;();
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See<strong>PeterO.Cbor.CBORObject.ToObject(System.Type)</strong>for further information.</p>

<p><b>Parameters:</b></p>

<ul>
<li>&lt;T&gt;: The type, class, or interface that this method&#39;s return value will belong o.<b>Note:</b>For security reasons, an application should not base this parameter on ser input or other externally supplied data. Whenever possible, this arameter should be either a type specially handled by this method (such s <code>int
</code> or <code>String
</code> ) or a plain-old-data type (POCO type) within the control of the pplication. If the plain-old-data type references other data types, those ypes should likewise meet either criterion above.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.NotSupportedException:
The given type &quot;T&quot;, or this object&#39;s CBOR type, is not supported.</li>
</ul>

<p><a id="ToString"></a></p>

<h3>ToString</h3>

<pre>public override string ToString();
</pre>

<p>Returns this CBOR object in string form. The format is intended to be human-readable, not machine-readable, the format is not intended to be parsed, and the format may change at any time. The returned string is not necessarily in JavaScript Object Notation (JSON); to convert CBOR objects to JSON strings, use the <strong>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</strong>method instead.</p>

<p><b>Return Value:</b></p>

<p>A text representation of this object.</p>

<p><a id="Untag"></a></p>

<h3>Untag</h3>

<pre>public PeterO.Cbor.CBORObject Untag();
</pre>

<p>Gets an object with the same value as this one but without the tags it has, if any. If this object is an array, map, or byte string, the data will not be copied to the returned object, so changes to the returned object will be reflected in this one.</p>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="UntagOne"></a></p>

<h3>UntagOne</h3>

<pre>public PeterO.Cbor.CBORObject UntagOne();
</pre>

<p>Gets an object with the same value as this one but without this object&#39;s outermost tag, if any. If this object is an array, map, or byte string, the data will not be copied to the returned object, so changes to the returned object will be reflected in this one.</p>

<p><b>Return Value:</b></p>

<p>A CBORObject object.</p>

<p><a id="Write_bool_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    bool value,
    System.IO.Stream stream);
</pre>

<p>Writes a Boolean value in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_byte_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    byte value,
    System.IO.Stream stream);
</pre>

<p>Writes a byte (0 to 255) in CBOR format to a data stream. If the value is less than 24, writes that byte. If the value is 25 to 255, writes the byte 24, then this byte&#39;s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_double_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    double value,
    System.IO.Stream stream);
</pre>

<p>Writes a 64-bit floating-point number in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_float_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    float value,
    System.IO.Stream s);
</pre>

<p>Writes a 32-bit floating-point number in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write.</p></li>
<li><p><i>s</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>s</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_int_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    int value,
    System.IO.Stream stream);
</pre>

<p>Writes a 32-bit signed integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_long_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    long value,
    System.IO.Stream stream);
</pre>

<p>Writes a 64-bit signed integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_object_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    object objValue,
    System.IO.Stream output,
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Writes an arbitrary object to a CBOR data stream, using the specified options for controlling how the object is encoded to CBOR data format. If the object is convertible to a CBOR map or a CBOR object that contains CBOR maps, the keys to those maps are written out to the data stream in an undefined order. The example code given in<strong>PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)</strong>can be used to write out certain keys of a CBOR map in a given order. urrently, the following objects are supported:</p>

<ul>
<li><p>Lists of CBORObject.</p></li>
<li><p>Maps of CBORObject. The keys to the map are written out to the data stream in an undefined order.</p></li>
<li><p>Null.</p></li>
<li><p>Byte arrays, which will always be written as definite-length byte strings.</p></li>
<li><p>String objects, which will be written as indefinite-length text strings if their size exceeds a certain threshold (this behavior may change in future versions of this library).</p></li>
<li><p>Any object accepted by the FromObject static methods.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>objValue</i>: The arbitrary object to be serialized. Can be null.</p></li>
<li><p><i>output</i>: A writable data stream.</p></li>
<li><p><i>options</i>: CBOR options for encoding the CBOR object to bytes.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The object&#39;s type is not supported.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>options</i>
or <i>output</i>
is null.</p></li>
</ul>

<p><a id="Write_object_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    object objValue,
    System.IO.Stream stream);
</pre>

<p>Writes a CBOR object to a CBOR data stream. See the three-parameter Write method that takes a CBOREncodeOptions.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>objValue</i>: The parameter <i>objValue</i>
is an arbitrary object.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><a id="Write_PeterO_Cbor_CBORObject_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    PeterO.Cbor.CBORObject value,
    System.IO.Stream stream);
</pre>

<p>Writes a CBOR object to a CBOR data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write. Can be null.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</li>
</ul>

<p><a id="Write_PeterO_Numbers_EDecimal_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    PeterO.Numbers.EDecimal bignum,
    System.IO.Stream stream);
</pre>

<p>Writes a decimal floating-point number in CBOR format to a data stream, as follows:</p>

<ul>
<li><p>If the value is null, writes the byte 0xF6.</p></li>
<li><p>If the value is negative zero, infinity, or NaN, converts the number to a <code>double
</code> and writes that <code>double
</code> . If negative zero should not be written this way, use the Plus ethod to convert the value beforehand.</p></li>
<li><p>If the value has an exponent of zero, writes the value as an unsigned integer or signed integer if the number can fit either type or as a big integer otherwise.</p></li>
<li><p>In all other cases, writes the value as a decimal number.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bignum</i>: The arbitrary-precision decimal number to write. Can be null.</p></li>
<li><p><i>stream</i>: Stream to write to.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_PeterO_Numbers_EFloat_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    PeterO.Numbers.EFloat bignum,
    System.IO.Stream stream);
</pre>

<p>Writes a binary floating-point number in CBOR format to a data stream as follows:</p>

<ul>
<li><p>If the value is null, writes the byte 0xF6.</p></li>
<li><p>If the value is negative zero, infinity, or NaN, converts the number to a <code>double
</code> and writes that <code>double
</code> . If negative zero should not be written this way, use the Plus ethod to convert the value beforehand.</p></li>
<li><p>If the value has an exponent of zero, writes the value as an unsigned integer or signed integer if the number can fit either type or as a big integer otherwise.</p></li>
<li><p>In all other cases, writes the value as a big float.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bignum</i>: An arbitrary-precision binary float.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_PeterO_Numbers_EInteger_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    PeterO.Numbers.EInteger bigint,
    System.IO.Stream stream);
</pre>

<p>Writes a big integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bigint</i>: Big integer to write. Can be null.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_PeterO_Numbers_ERational_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    PeterO.Numbers.ERational rational,
    System.IO.Stream stream);
</pre>

<p>Writes a rational number in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>rational</i>: An arbitrary-precision rational number.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_sbyte_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    sbyte value,
    System.IO.Stream stream);
</pre>

<p>Writes an 8-bit signed integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The parameter <i>value</i>
is an 8-bit signed integer.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><a id="Write_short_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    short value,
    System.IO.Stream stream);
</pre>

<p>Writes a 16-bit signed integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: The value to write.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_string_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    string str,
    System.IO.Stream stream);
</pre>

<p>Writes a string in CBOR format to a data stream. The string will be encoded using indefinite-length encoding if its length exceeds a certain threshold (this behavior may change in future versions of this library).</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: The string to write. Can be null.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_string_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    string str,
    System.IO.Stream stream,
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Writes a string in CBOR format to a data stream, using the given options to control the encoding process.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: The string to write. Can be null.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
<li><p><i>options</i>: Options for encoding the data to CBOR.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="Write_uint_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    uint value,
    System.IO.Stream stream);
</pre>

<p>Writes a 32-bit unsigned integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: A 32-bit unsigned integer.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><a id="Write_ulong_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    ulong value,
    System.IO.Stream stream);
</pre>

<p>Writes a 64-bit unsigned integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: A 64-bit unsigned integer.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</li>
</ul>

<p><a id="Write_ushort_System_IO_Stream"></a></p>

<h3>Write</h3>

<pre>public static void Write(
    ushort value,
    System.IO.Stream stream);
</pre>

<p>Writes a 16-bit unsigned integer in CBOR format to a data stream.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>value</i>: A 16-bit unsigned integer.</p></li>
<li><p><i>stream</i>: A writable data stream.</p></li>
</ul>

<p><a id="WriteJSON_object_System_IO_Stream"></a></p>

<h3>WriteJSON</h3>

<pre>public static void WriteJSON(
    object obj,
    System.IO.Stream outputStream);
</pre>

<p>Converts an arbitrary object to a string in JavaScript Object Notation (JSON) format, as in the ToJSONString method, and writes that string to a data stream in UTF-8. If the object is convertible to a CBOR map, or to a CBOR object that contains CBOR maps, the keys to those maps are written out to the JSON string in an undefined order. The example code given in<strong>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</strong>can be used to write out certain keys of a CBOR map in a given order to a SON string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>obj</i>: The parameter <i>obj</i>
is an arbitrary object.</p></li>
<li><p><i>outputStream</i>: A writable data stream.</p></li>
</ul>

<p><a id="WriteJSONTo_System_IO_Stream"></a></p>

<h3>WriteJSONTo</h3>

<pre>public void WriteJSONTo(
    System.IO.Stream outputStream);
</pre>

<p>Converts this object to a string in JavaScript Object Notation (JSON) format, as in the ToJSONString method, and writes that string to a data stream in UTF-8. If the CBOR object contains CBOR maps, or is a CBOR map, the keys to the map are written out to the JSON string in an undefined order. The example code given in<strong>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</strong>can be used to write out certain keys of a CBOR map in a given order to a SON string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>outputStream</i>: A writable data stream.</li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>outputStream</i>
is null.</p></li>
</ul>

<p><a id="WriteJSONTo_System_IO_Stream_PeterO_Cbor_JSONOptions"></a></p>

<h3>WriteJSONTo</h3>

<pre>public void WriteJSONTo(
    System.IO.Stream outputStream,
    PeterO.Cbor.JSONOptions options);
</pre>

<p>Converts this object to a string in JavaScript Object Notation (JSON) format, as in the ToJSONString method, and writes that string to a data stream in UTF-8, using the given JSON options to control the encoding process. If the CBOR object contains CBOR maps, or is a CBOR map, the keys to the map are written out to the JSON string in an undefined order. The example code given in<strong>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</strong>can be used to write out certain keys of a CBOR map in a given order to a SON string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>outputStream</i>: A writable data stream.</p></li>
<li><p><i>options</i>: An object containing the options to control writing the CBOR object to JSON.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>outputStream</i>
is null.</p></li>
</ul>

<p><a id="WriteTo_System_IO_Stream"></a></p>

<h3>WriteTo</h3>

<pre>public void WriteTo(
    System.IO.Stream stream);
</pre>

<p>Writes this CBOR object to a data stream. If the CBOR object contains CBOR maps, or is a CBOR map, the keys to the map are written out to the data stream in an undefined order. See the examples (written in C# for the .NET version) for ways to write out certain keys of a CBOR map in a given order.</p>

<p>The following example shows a method that writes each key of &#39;mapObj&#39; to &#39;outputStream&#39;, in the order given in &#39;keys&#39;, where &#39;mapObj&#39; is written out in the form of a CBOR<b>definite-length map</b>. Only keys found in &#39;keys&#39; will be written if they exist in &#39;mapObj&#39;.</p>

<pre>private static void WriteKeysToMap(CBORObject mapObj,
        IList&lt;CBORObject&gt; keys, Stream outputStream){ if(mapObj
        == null){ throw new
        ArgumentNullException(nameof(mapObj));} if(keys ==
        null){throw new ArgumentNullException(nameof(keys));}
        if(outputStream == null){throw new
        ArgumentNullException(nameof(outputStream));}
        if(obj.Type!=CBORType.Map){ throw new ArgumentException(&quot;&#39;obj&#39;
        is not a map.&quot;); } int keyCount = 0; for (CBORObject key in keys)
        { if(mapObj.ContainsKey(key)){ keyCount++; } }
        CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in
        keys) { if(mapObj.ContainsKey(key)){
        key.WriteTo(outputStream); mapObj[key].WriteTo(outputStream); }
        } }
</pre>

<p>The following example shows a method that writes each key of &#39;mapObj&#39; to &#39;outputStream&#39;, in the order given in &#39;keys&#39;, where &#39;mapObj&#39; is written out in the form of a CBOR<b>indefinite-length map</b>. Only keys found in &#39;keys&#39; will be written if they exist in &#39;mapObj&#39;.</p>

<pre>private static void WriteKeysToIndefMap(CBORObject mapObj,
        IList&lt;CBORObject&gt; keys, Stream outputStream){ if(mapObj
        == null){ throw new
        ArgumentNullException(nameof(mapObj));} if(keys ==
        null){throw new ArgumentNullException(nameof(keys));}
        if(outputStream == null){throw new
        ArgumentNullException(nameof(outputStream));}
        if(obj.Type!=CBORType.Map){ throw new ArgumentException(&quot;&#39;obj&#39;
        is not a map.&quot;); } outputStream.WriteByte((byte)0xBF); for
        (CBORObject key in keys) { if(mapObj.ContainsKey(key)){
        key.WriteTo(outputStream); mapObj[key].WriteTo(outputStream); }
        } outputStream.WriteByte((byte)0xff); }
</pre>

<p>The following example shows a method that writes out a list of objects to &#39;outputStream&#39; as an<b>indefinite-length CBOR array</b>.</p>

<pre>private static void WriteToIndefArray( IList&lt;object&gt; list,
        Stream outputStream){ if(list == null){ throw new
        ArgumentNullException(nameof(list));} if(outputStream ==
        null){throw new
        ArgumentNullException(nameof(outputStream));}
        outputStream.WriteByte((byte)0x9f); for (object item in list) { new
        CBORObject(item).WriteTo(outputStream); }
        outputStream.WriteByte((byte)0xff); }
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><i>stream</i>: A writable data stream.</li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
</ul>

<p><a id="WriteTo_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions"></a></p>

<h3>WriteTo</h3>

<pre>public void WriteTo(
    System.IO.Stream stream,
    PeterO.Cbor.CBOREncodeOptions options);
</pre>

<p>Writes this CBOR object to a data stream, using the specified options for encoding the data to CBOR format. If the CBOR object contains CBOR maps, or is a CBOR map, the keys to the map are written out to the data stream in an undefined order. The example code given in<strong>PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)</strong>can be used to write out certain keys of a CBOR map in a given order.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>stream</i>: A writable data stream.</p></li>
<li><p><i>options</i>: Options for encoding the data to CBOR.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>stream</i>
is null.</p></li>
<li><p>System.IO.IOException:
An I/O error occurred.</p></li>
<li><p>System.ArgumentException:
Unexpected data type&quot;.</p></li>
</ul>

<p><a id="WriteValue_System_IO_Stream_int_int"></a></p>

<h3>WriteValue</h3>

<pre>public static int WriteValue(
    System.IO.Stream outputStream,
    int majorType,
    int value);
</pre>

<p>Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 32-bit signed integer. This is a low-level method that is useful for implementing custom CBOR encoding methodologies. This method encodes the given major type and value in the shortest form allowed for the major type.</p>

<p>In the following example, an array of three objects is written as CBOR to a data stream.</p>

<pre>CBORObject.WriteValue(stream, 4, 3); /* array, length 3 */
        CBORObject.Write(&quot;hello world&quot;, stream); /* item 1 */
        CBORObject.Write(25, stream); /* item 2 */ CBORObject.Write(false,
        stream); // item 3
</pre>

<p>In the following example, a map consisting of two key-value pairs is written as CBOR to a data stream.</p>

<pre>CBORObject.WriteValue(stream, 5, 2); // map, 2 pairs
        CBORObject.Write(&quot;number&quot;, stream); // key 1 CBORObject.Write(25,
        stream); // value 1 CBORObject.Write(&quot;string&quot;, stream); // key 2
        CBORObject.Write(&quot;hello&quot;, stream); // value 2
</pre>

<p>In the following example (originally written in C# for the .NET Framework version), a text string is written as CBOR to a data stream.</p>

<pre>string str = &quot;hello world&quot;; byte[] bytes =
        DataUtilities.GetUtf8Bytes(str, true); CBORObject.WriteValue(stream, 4,
        bytes.Length); stream.Write(bytes, 0, bytes.Length);
</pre>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>outputStream</i>: A writable data stream.</p></li>
<li><p><i>majorType</i>: The CBOR major type to write. This is a number from 0 through 7 as follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049 for details on these major types.</p></li>
<li><p><i>value</i>: An integer 0 or greater associated with the major type, as follows. 0: integer 0 or greater; 1: the negative integer&#39;s absolute value is 1 plus this number; 2: length in bytes of the byte string; 3: length in bytes of the UTF-8 text string; 4: number of items in the array; 5: number of key-value pairs in the map; 6: tag number; 7: simple value number, which must be in the interval [0, 23] or [32, 255].</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The number of bytes ordered to be written to the data stream.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
Value is from 24 to 31 and major type is 7.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>outputStream</i>
is null.</p></li>
</ul>

<p><a id="WriteValue_System_IO_Stream_int_long"></a></p>

<h3>WriteValue</h3>

<pre>public static int WriteValue(
    System.IO.Stream outputStream,
    int majorType,
    long value);
</pre>

<p>Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 64-bit signed integer. This is a low-level method that is useful for implementing custom CBOR encoding methodologies. This method encodes the given major type and value in the shortest form allowed for the major type.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>outputStream</i>: A writable data stream.</p></li>
<li><p><i>majorType</i>: The CBOR major type to write. This is a number from 0 through 7 as follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049 for details on these major types.</p></li>
<li><p><i>value</i>: An integer 0 or greater associated with the major type, as follows. 0: integer 0 or greater; 1: the negative integer&#39;s absolute value is 1 plus this number; 2: length in bytes of the byte string; 3: length in bytes of the UTF-8 text string; 4: number of items in the array; 5: number of key-value pairs in the map; 6: tag number; 7: simple value number, which must be in the interval [0, 23] or [32, 255].</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The number of bytes ordered to be written to the data stream.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
Value is from 24 to 31 and major type is 7.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>outputStream</i>
is null.</p></li>
</ul>

<p><a id="WriteValue_System_IO_Stream_int_PeterO_Numbers_EInteger"></a></p>

<h3>WriteValue</h3>

<pre>public static int WriteValue(
    System.IO.Stream outputStream,
    int majorType,
    PeterO.Numbers.EInteger bigintValue);
</pre>

<p>Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as an arbitrary-precision integer. This is a low-level method that is useful for implementing custom CBOR encoding methodologies. This method encodes the given major type and value in the shortest form allowed for the major type.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>outputStream</i>: A writable data stream.</p></li>
<li><p><i>majorType</i>: The CBOR major type to write. This is a number from 0 through 7 as follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049 for details on these major types.</p></li>
<li><p><i>bigintValue</i>: An integer 0 or greater associated with the major type, as follows. 0: integer 0 or greater; 1: the negative integer&#39;s absolute value is 1 plus this number; 2: length in bytes of the byte string; 3: length in bytes of the UTF-8 text string; 4: number of items in the array; 5: number of key-value pairs in the map; 6: tag number; 7: simple value number, which must be in the interval [0, 23] or [32, 255]. For major types 0 to 6, this number may not be greater than 2^64 - 1.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The number of bytes ordered to be written to the data stream.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter <i>majorType</i>
is 7 and value is greater than 255.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>outputStream</i>
or <i>bigintValue</i>
is null.</p></li>
</ul>

<p><a id="WriteValue_System_IO_Stream_int_uint"></a></p>

<h3>WriteValue</h3>

<pre>public static int WriteValue(
    System.IO.Stream outputStream,
    int majorType,
    uint value);
</pre>

<p>Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 32-bit unsigned integer. This is a low-level method that is useful for implementing custom CBOR encoding methodologies. This method encodes the given major type and value in the shortest form allowed for the major type.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>outputStream</i>: A writable data stream.</p></li>
<li><p><i>majorType</i>: The CBOR major type to write. This is a number from 0 through 7 as follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049 for details on these major types.</p></li>
<li><p><i>value</i>: An integer 0 or greater associated with the major type, as follows. 0: integer 0 or greater; 1: the negative integer&#39;s absolute value is 1 plus this number; 2: length in bytes of the byte string; 3: length in bytes of the UTF-8 text string; 4: number of items in the array; 5: number of key-value pairs in the map; 6: tag number; 7: simple value number, which must be in the interval [0, 23] or [32, 255].</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The number of bytes ordered to be written to the data stream.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>outputStream</i>
is null.</li>
</ul>

<p><a id="WriteValue_System_IO_Stream_int_ulong"></a></p>

<h3>WriteValue</h3>

<pre>public static int WriteValue(
    System.IO.Stream outputStream,
    int majorType,
    ulong value);
</pre>

<p>Writes a CBOR major type number and an integer 0 or greater associated with it to a data stream, where that integer is passed to this method as a 64-bit unsigned integer. This is a low-level method that is useful for implementing custom CBOR encoding methodologies. This method encodes the given major type and value in the shortest form allowed for the major type.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>outputStream</i>: A writable data stream.</p></li>
<li><p><i>majorType</i>: The CBOR major type to write. This is a number from 0 through 7 as follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049 for details on these major types.</p></li>
<li><p><i>value</i>: An integer 0 or greater associated with the major type, as follows. 0: integer 0 or greater; 1: the negative integer&#39;s absolute value is 1 plus this number; 2: length in bytes of the byte string; 3: length in bytes of the UTF-8 text string; 4: number of items in the array; 5: number of key-value pairs in the map; 6: tag number; 7: simple value number, which must be in the interval [0, 23] or [32, 255].</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The number of bytes ordered to be written to the data stream.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter <i>majorType</i>
is 7 and value is greater than 255.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>outputStream</i>
is null.</p></li>
</ul>

<p><a href="/CBOR/">Back to CBOR start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
