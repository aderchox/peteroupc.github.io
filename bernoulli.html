<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Bernoulli Factory Algorithms</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Bernoulli Factory Algorithms</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page catalogs algorithms to turn coins biased one way into coins biased another way, also known as <em>Bernoulli factories</em>.  Many of them were suggested in (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup>, but without step-by-step instructions in many cases.  This page provides these instructions to help programmers implement the Bernoulli factories they describe.</p>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/bernoulli.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/bernoulli.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.  You are welcome to suggest additional Bernoulli factory algorithms.</strong></p>

<p><a id=About_Bernoulli_Factories></a></p>

<h2>About Bernoulli Factories</h2>

<p>A <em>Bernoulli factory</em> (Keane and O&#39;Brien 1994)<sup><a href="#Note2"><strong>(2)</strong></a></sup> is an algorithm that takes an input coin (a method that returns 1, or heads, with an unknown probability, or 0, or tails, otherwise) and returns 0 or 1 with a probability that depends on the input coin&#39;s probability of heads.  For example, a Bernoulli factory algorithm can take a coin that returns heads with probability &lambda; and produce a coin that returns heads with probability exp(&minus;&lambda;).</p>

<p>A <em>factory function</em> is a function that relates the old probability to the new one.  Its domain is [0, 1] and returns a probability in [0, 1].  There are certain requirements for factory functions.  As shown by Keane and O&#39;Brien (1994)<sup><a href="#Note2"><strong>(2)</strong></a></sup>, a function <em>f</em> can serve as a factory function if and only if <em>f</em>, in the interval [0, 1]&mdash;</p>

<pre>- is continuous everywhere, and
- either returns a constant value in \[0, 1\] everywhere, or returns a value in \[0, 1\] at each of the points 0 and 1 and a value in (0, 1) at each other point.
</pre>

<p>As one example, the function <em>f</em> = 2*p cannot serve as a factory function, since its graph touches 1 somewhere in the open interval (0, 1).</p>

<p>The next section will show algorithms for a number of factory functions, allowing different kinds of probabilities to be simulated from input coins.</p>

<p><a id=Algorithms></a></p>

<h2>Algorithms</h2>

<p>In the following algorithms:</p>

<ul>
<li>&lambda; is the unknown probability of heads of the input coin.</li>
<li>The <strong>SampleGeometricBag</strong> and <strong>URandLess</strong> algorithms are described in my article on <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled uniform random numbers</strong></a>.</li>
<li>The instruction to &quot;generate a uniform random number&quot; can be implemented by creating an empty <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled uniform random number</strong></a> (most accurate) or by generating <code>RNDEXCRANGE(0, 1)</code> or <code>RNDINT(1000)</code> (less accurate).</li>
<li>Where an algorithm says &quot;if <em>a</em> is less than <em>b</em>&quot;, where <em>a</em> and <em>b</em> are uniform random numbers, it means to run the <strong>URandLess</strong> algorithm on the two partially-sampled numbers, or do a less-than operation on <em>a</em> and <em>b</em>, as appropriate.</li>
<li>For best results, the algorithms should be implemented using exact rational arithmetic.</li>
</ul>

<p><strong>Algorithms for exp(&minus;&lambda;)</strong>.</p>

<p>The algorithm in (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup>calls for generating a Poisson(&lambda;) random number and returning 1 if that number is 0, or 0 otherwise.  The Poisson generator in turn involves generating a geometric(&lambda;) random number <em>G</em><sup><a href="#Note3"><strong>(3)</strong></a></sup>, then <em>G</em> uniform random numbers, then returning 1 if all <em>G</em> uniform numbers are sorted, or 0 otherwise.  The algorithm follows.</p>

<ol>
<li>Flip the input coin until the coin returns 0.  Then set <em>G</em> to the number of times the coin returns 1 this way.</li>
<li>If <em>G</em> is 0, return 1.</li>
<li>Generate a uniform random number <em>w</em>, and set <em>i</em> to 1.</li>
<li>While <em>i</em> is less than <em>G</em>:

<ol>
<li>Generate a uniform random number <em>U</em>.</li>
<li>If <em>w</em> is less than <em>U</em>, break out of this loop and go to step 1.</li>
<li>Add 1 to <em>i</em>, and set <em>w</em> to <em>U</em>.</li>
</ol></li>
<li>Return 0.  (<em>G</em> is now a Poisson(&lambda;) random number, but is other than 0.)</li>
</ol>

<p>This algorithm, however, runs very slowly as &lambda; approaches 1.  Here is an alternative version of the algorithm above, which doesn&#39;t generate a geometric random number at the outset.</p>

<ol>
<li>Set <em>k</em> and <em>w</em> each to 0.</li>
<li>Flip the input coin.  If the coin returns 0 and <em>k</em> is 0, return 1.  Otherwise, if the coin returns 0, return 0.</li>
<li>Generate a uniform random number <em>U</em>.</li>
<li>If <em>k</em> &gt; 0 and <em>w</em> is less than <em>U</em>, go to step 1.</li>
<li>Set <em>w</em> to <em>U</em>, add 1 to <em>k</em>, and go to step 2.</li>
</ol>

<p>In turn, this algorithm converges very slowly as &lambda; approaches 0.  Thus:</p>

<ul>
<li>If &lambda; is known to be less than 1/2, use the first algorithm.</li>
<li>If &lambda; is known to be greater than 1/2, use the second algorithm.</li>
</ul>

<p>A third algorithm is uniformly fast everywhere in (0, 1).   It uses the reverse-time martingale approach for alternating series in (Łatuszyński et al. 2009/2011)<sup><a href="#Note4"><strong>(4)</strong></a></sup> and makes use of the fact that exp(1+&lambda;) can be rewritten as&mdash;</p>

<pre>1 - x + x^2/2 - x^3/6 + x^4/24 - ...,
</pre>

<p>which is an alternating series whose coefficients are 1, 1, 1/2!, 1/3!, 1/4!, ..., which satisfy the requirements for this approach because the coefficients are nonincreasing and all 1 or less.  However, the algorithm requires a bit more arithmetic, notably rational division.</p>

<ol>
<li>Set <em>u</em> and <em>w</em> to 1, set <em>l</em> to 0, and set <em>n</em> to 1. (Here, <em>u</em> is set to the first coefficient, 1.)</li>
<li>Create an empty uniform PSRN.</li>
<li>If <em>w</em> is not 0, flip the input coin, multiply <em>w</em> by the result of the flip, then divide <em>w</em> by <em>n</em>.  (This division by <em>n</em> implements the second and later coefficients, that is, the (<em>n</em>+1)th and later coefficients, which consist of 1/(<em>n</em>)!.)</li>
<li>If <em>n</em> is even, set <em>u</em> to <em>l</em> + <em>w</em>.  Otherwise, set <em>l</em> to <em>u</em> + <em>w</em>.</li>
<li>If the PSRN turns out to be less than <em>l</em>, return 1.</li>
<li>If the PSRN turns out to be greater than <em>u</em>, return 0.</li>
<li>Add 1 to <em>n</em> and go to step 3.</li>
</ol>

<p><strong>Algorithm for exp(&lambda;)*(1&minus;&lambda;)</strong>  (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup>:</p>

<ol>
<li>Set <em>k</em> and <em>w</em> each to 0.</li>
<li>Flip the input coin.  If it returns 0, return 1.</li>
<li>Generate a uniform random number <em>U</em>.</li>
<li>If <em>k</em> &gt; 0 and <em>w</em> is less than <em>U</em>, return 0.</li>
<li>Set <em>w</em> to <em>U</em>, add 1 to <em>k</em>, and go to step 2.</li>
</ol>

<p><strong>Algorithm for log(1+&lambda;)</strong>  (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup>:</p>

<ol>
<li>Create an empty uniform partially-sampled random number (PSRN).</li>
<li>Flip the input coin.  If it returns 0, flip the coin again and return the result.</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm with the PSRN.  If it returns 0, flip the input coin and return the result.</li>
<li>Flip the input coin.  If it returns 0, return 0.</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm with the PSRN.  If it returns 0, return 0.</li>
<li>Go to step 2.</li>
</ol>

<p>Alternatively, flip the result of the algorithm for 1 &minus; log(1+&lambda;) below (make it 1 if it&#39;s 0 and vice versa).</p>

<p><strong>Algorithm for 1 &minus; log(1+&lambda;).</strong>  This algorithm uses the reverse-time martingale approach in (Łatuszyński et al. 2009/2011)<sup><a href="#Note4"><strong>(4)</strong></a></sup>.  Here, the alternating series is <code>1 - x + x^2/2 - x^3/3 + ...</code>, whose coefficients are 1, 1, 1/2, 1/3, ....</p>

<ol>
<li>Set <em>u</em> and <em>w</em> to 1, set <em>l</em> to 0, and set <em>n</em> to 1. (Here, <em>u</em> is set to the first coefficient, 1.)</li>
<li>Create an empty uniform PSRN.</li>
<li>If <em>w</em> is not 0, flip the input coin and multiply <em>w</em> by the result of the flip.</li>
<li>If <em>n</em> is even, set <em>u</em> to <em>l</em> + <em>w</em> / <em>n</em>.  Otherwise, set <em>l</em> to <em>u</em> + <em>w</em> / <em>n</em>.  (In each of these cases, the division by <em>n</em> implements the second and later coefficients, that is, the (<em>n</em>+1)th and later coefficients.)</li>
<li>If the PSRN turns out to be less than <em>l</em>, return 1.</li>
<li>If the PSRN turns out to be greater than <em>u</em>, return 0.</li>
<li>Add 1 to <em>n</em> and go to step 3.</li>
</ol>

<p>Alternatively, flip the result of the algorithm for log(1+&lambda;) (make it 1 if it&#39;s 0 and vice versa).</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560v2"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560v2  [math.PR], 2010.</small></p>

<p><small><sup id=Note2>(2)</sup> Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994.</small></p>

<p><small><sup id=Note3>(3)</sup> As used here and in the Flajolet paper, a geometric random number is the number of successes before the first failure, where the success probability is &lambda;.</small></p>

<p><small><sup id=Note4>(4)</sup> Łatuszyński, K., Kosmidis, I.,  Papaspiliopoulos, O., Roberts, G.O., &quot;<a href="https://arxiv.org/abs/0907.4018v2"><strong>Simulating events of unknown probabilities via reverse time martingales</strong></a>&quot;, arXiv:0907.4018v2 [stat.CO], 2009/2011.</small></p>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
