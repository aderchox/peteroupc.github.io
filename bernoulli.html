<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Bernoulli Factory Algorithms</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Bernoulli Factory Algorithms</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page catalogs algorithms to turn coins biased one way into coins biased another way, also known as <em>Bernoulli factories</em>.  Many of them were suggested in (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup>, but without step-by-step instructions in many cases.  This page provides these instructions to help programmers implement the Bernoulli factories they describe.</p>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/bernoulli.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/bernoulli.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.  You are welcome to suggest additional Bernoulli factory algorithms.</strong></p>

<p><a id=About_Bernoulli_Factories></a></p>

<h2>About Bernoulli Factories</h2>

<p>A <em>Bernoulli factory</em> (Keane and O&#39;Brien 1994)<sup><a href="#Note2"><strong>(2)</strong></a></sup> is an algorithm that takes an input coin (a method that returns 1, or heads, with an unknown probability, or 0, or tails, otherwise) and returns 0 or 1 with a probability that depends on the input coin&#39;s probability of heads.  For example, a Bernoulli factory algorithm can take a coin that returns heads with probability &lambda; and produce a coin that returns heads with probability exp(&minus;&lambda;).</p>

<p>A <em>factory function</em> is a function that relates the old probability to the new one.  Its domain is [0, 1] and returns a probability in [0, 1].  There are certain requirements for factory functions.  As shown by Keane and O&#39;Brien (1994)<sup><a href="#Note2"><strong>(2)</strong></a></sup>, a function <em>f</em> can serve as a factory function if and only if <em>f</em>, in the interval [0, 1]&mdash;</p>

<ul>
<li>is continuous everywhere, and</li>
<li>either returns a constant value in [0, 1] everywhere, or returns a value in [0, 1] at each of the points 0 and 1 and a value in (0, 1) at each other point.</li>
</ul>

<p>As one example, the function <em>f</em> = 2*p cannot serve as a factory function, since its graph touches 1 somewhere in the open interval (0, 1).</p>

<p>The next section will show algorithms for a number of factory functions, allowing different kinds of probabilities to be simulated from input coins.</p>

<p><a id=Algorithms></a></p>

<h2>Algorithms</h2>

<p>In the following algorithms:</p>

<ul>
<li>&lambda; is the unknown probability of heads of the input coin.</li>
<li>The <strong>SampleGeometricBag</strong> and <strong>URandLess</strong> algorithms are described in my article on <a href="https://peteroupc.github.io/exporand.html"><strong>uniform partially-sampled random number (PSRN)</strong></a>.</li>
<li>The <code>ZeroOrOne</code> method should be implemented as shown in my article on <a href="https://peteroupc.github.io/randomfunc.html#Boolean_True_False_Conditions"><strong>random sampling methods</strong></a>.</li>
<li>The instruction to &quot;generate a uniform random number&quot; can be implemented by creating an empty <a href="https://peteroupc.github.io/exporand.html"><strong>uniform PSRN</strong></a> (most accurate) or by generating <code>RNDEXCRANGE(0, 1)</code> or <code>RNDINT(1000)</code> (less accurate).</li>
<li>Where an algorithm says &quot;if <em>a</em> is less than <em>b</em>&quot;, where <em>a</em> and <em>b</em> are uniform random numbers, it means to run the <strong>URandLess</strong> algorithm on the two PSRNs, or do a less-than operation on <em>a</em> and <em>b</em>, as appropriate.</li>
<li>For best results, the algorithms should be implemented using exact rational arithmetic (such as <code>Fraction</code> in Python or <code>Rational</code> in Ruby).</li>
</ul>

<p><strong>Algorithms for exp(&minus;&lambda;)</strong>.</p>

<p>The algorithm in (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup> calls for generating a Poisson(&lambda;) random number and returning 1 if that number is 0, or 0 otherwise.  The Poisson generator in turn involves generating a geometric(&lambda;) random number <em>G</em><sup><a href="#Note3"><strong>(3)</strong></a></sup>, then <em>G</em> uniform random numbers, then returning <em>G</em> only if all <em>G</em> uniform numbers are sorted.<sup><a href="#Note4"><strong>(4)</strong></a></sup>  The algorithm follows.</p>

<ol>
<li>Flip the input coin until the coin returns 0.  Then set <em>G</em> to the number of times the coin returns 1 this way.</li>
<li>If <em>G</em> is 0, return 1.</li>
<li>Generate a uniform random number <em>w</em>, and set <em>i</em> to 1.</li>
<li>While <em>i</em> is less than <em>G</em>:

<ol>
<li>Generate a uniform random number <em>U</em>.</li>
<li>If <em>w</em> is less than <em>U</em>, break out of this loop and go to step 1.</li>
<li>Add 1 to <em>i</em>, and set <em>w</em> to <em>U</em>.</li>
</ol></li>
<li>Return 0.  (<em>G</em> is now a Poisson(&lambda;) random number, but is other than 0.)</li>
</ol>

<p>This algorithm, however, runs very slowly as &lambda; approaches 1.</p>

<p>Here is an alternative version of the algorithm above, which doesn&#39;t generate a geometric random number at the outset.</p>

<ol>
<li>Set <em>k</em> and <em>w</em> each to 0.</li>
<li>Flip the input coin.  If the coin returns 0 and <em>k</em> is 0, return 1.  Otherwise, if the coin returns 0, return 0.</li>
<li>Generate a uniform random number <em>U</em>.</li>
<li>If <em>k</em> &gt; 0 and <em>w</em> is less than <em>U</em>, go to step 1.</li>
<li>Set <em>w</em> to <em>U</em>, add 1 to <em>k</em>, and go to step 2.</li>
</ol>

<p>In turn, this algorithm converges very slowly as &lambda; approaches 0.  Thus:</p>

<ul>
<li>If &lambda; is known to be less than 1/2, use the first algorithm.</li>
<li>If &lambda; is known to be greater than 1/2, use the second algorithm.</li>
</ul>

<p>A third algorithm is uniformly fast everywhere in (0, 1).   It uses the reverse-time martingale approach for alternating series in (Łatuszyński et al. 2009/2011)<sup><a href="#Note5"><strong>(5)</strong></a></sup> and makes use of the fact that exp(&minus;&lambda;) can be rewritten as&mdash;</p>

<pre>1 - x + x^2/2 - x^3/6 + x^4/24 - ...,
</pre>

<p>which is an alternating series whose coefficients are 1, 1, 1/2!, 1/3!, 1/4!, ..., which satisfy the requirements for this approach because the coefficients are nonincreasing and all 1 or less.  However, the algorithm requires a bit more arithmetic, notably rational division.</p>

<p>First, the general algorithm for the reverse-time martingale approach (called the <strong>general martingale algorithm</strong> follows:</p>

<ol>
<li>Let <em>c[0]</em>, <em>c[1]</em>, etc. be the first, second, etc. coefficients of the alternating series.  Set <em>u</em> to <em>c[0]</em>, set <em>w</em> to 1, set <em>l</em> to 0, and set <em>n</em> to 1.</li>
<li>Create an empty uniform PSRN.</li>
<li>If <em>w</em> is not 0, flip the input coin and multiply <em>w</em> by the result of the flip.</li>
<li>If <em>n</em> is even, set <em>u</em> to <em>l</em> + <em>w</em> * <em>c[n]</em>.  Otherwise, set <em>l</em> to <em>u</em> + <em>w</em> * <em>c[n]</em>.</li>
<li>Run the <strong>URandLessThanFraction algorithm</strong> on the PSRN and <em>l</em>.  If the algorithm returns 1, return 1.</li>
<li>Run the <strong>URandLessThanFraction algorithm</strong> on the PSRN and <em>u</em>.  If the algorithm returns 0, return 0.</li>
<li>Add 1 to <em>n</em> and go to step 3.</li>
</ol>

<p>For <strong>exp(&minus;&lambda;)</strong>, modify that algorithm as follows for more efficiency:</p>

<ul>
<li>Rather than multiplying by <em>c[n]</em> in step 4, divide <em>w</em> by <em>n</em> in step 3 (after multiplying by the result of the flip).  This is a more efficient way to take account of the factorial in the second and later coefficients.</li>
</ul>

<p><strong>Algorithm for exp(&lambda;)*(1&minus;&lambda;)</strong>  (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup>:</p>

<ol>
<li>Set <em>k</em> and <em>w</em> each to 0.</li>
<li>Flip the input coin.  If it returns 0, return 1.</li>
<li>Generate a uniform random number <em>U</em>.</li>
<li>If <em>k</em> &gt; 0 and <em>w</em> is less than <em>U</em>, return 0.</li>
<li>Set <em>w</em> to <em>U</em>, add 1 to <em>k</em>, and go to step 2.</li>
</ol>

<p><strong>Algorithm for log(1+&lambda;)</strong>  (Flajolet et al., 2010)<sup><a href="#Note1"><strong>(1)</strong></a></sup>:</p>

<ol>
<li>Create an empty uniform PSRN.</li>
<li>Flip the input coin.  If it returns 0, flip the coin again and return the result.</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm with the PSRN.  If it returns 0, flip the input coin and return the result.</li>
<li>Flip the input coin.  If it returns 0, return 0.</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm with the PSRN.  If it returns 0, return 0.</li>
<li>Go to step 2.</li>
</ol>

<p>Alternatively, invert the result of the algorithm for 1 &minus; log(1+&lambda;) below (make it 1 if it&#39;s 0 and vice versa).</p>

<p><strong>Algorithm for 1 &minus; log(1+&lambda;).</strong>  This algorithm uses the reverse-time martingale approach in (Łatuszyński et al. 2009/2011)<sup><a href="#Note5"><strong>(5)</strong></a></sup>.  Here, the alternating series is <code>1 - x + x^2/2 - x^3/3 + ...</code>, whose coefficients are 1, 1, 1/2, 1/3, ....  Follow the general martingale algorithm.</p>

<p>Alternatively, invert the result of the algorithm for log(1+&lambda;) (make it 1 if it&#39;s 0 and vice versa).</p>

<p><strong>Algorithms for 1/(1+&lambda;).</strong></p>

<p>One algorithm is the general martingale algorithm, since when &lambda; is in [0, 1], this function is an alternating series of the form <code>1 - x + x^2 - x^3 + ...</code>, whose coefficients are 1, 1, 1, 1, ....  However, this algorithm converges slowly when &lambda; is very close to 1.</p>

<p>A second algorithm is a special case of the two-coin Bernoulli factory of (Gonçalves et al., 2017)<sup><a href="#Note6"><strong>(6)</strong></a></sup> and is uniformly fast:</p>

<ol>
<li>With probability 1/2, return 1. (For example, generate an unbiased random bit and return 1 if that bit is 1.)</li>
<li>Flip the input coin.  If it returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<p><strong>Algorithm for <em>c</em> * &lambda; * &beta; / (&beta; * (<em>c</em> * &lambda; + <em>d</em> * &mu;) &minus; (&beta; &minus; 1) * (<em>c</em> + <em>d</em>)).</strong>  This is the general two-coin algorithm of (Gonçalves et al., 2017)<sup><a href="#Note6"><strong>(6)</strong></a></sup> and (Vats et al. 2020)<sup><a href="#Note7"><strong>(7)</strong></a></sup>.  It takes two input coins that each output heads (1) with probability &lambda; or &mu;, respectively.  It also takes a parameter &beta;, which is a so-called &quot;portkey&quot; or early rejection parameter (when &beta; = 1, the formula simplifies to <em>c</em> * &lambda; / (<em>c</em> * &lambda; + <em>d</em> * &mu;)).</p>

<ol>
<li>If &beta; is not 1, return 0 with probability 1 &minus; &beta;. (For example, call <code>ZeroOrOne</code> with &beta;&#39;s numerator and denominator and return 0 if that call returns 0.)</li>
<li>With probability <em>c</em> / (<em>c</em> + <em>d</em>), flip the &lambda; input coin.  Otherwise, flip the &mu; input coin.  If the &lambda; input coin returns 1, return 1.  If the &mu; input coin returns 1, return 0.  If the corresponding coin returns 0, go to step 1.</li>
</ol>

<p><strong>Algorithm for <em>c</em> * &lambda; / (<em>c</em> * &lambda; + <em>d</em>)) or (<em>c</em>/<em>d</em>) * &lambda; / (1 + (<em>c</em>/<em>d</em>) * &lambda;)).</strong> This algorithm, also known as the <em>logistic Bernoulli factory</em> (Huber 2016)<sup><a href="#Note8"><strong>(8)</strong></a></sup>, (Morina et al., 2019)<sup><a href="#Note9"><strong>(9)</strong></a></sup>, is a special case of the two-coin algorithm above, but this time uses only one input coin.</p>

<ol>
<li>With probability <em>d</em> / (<em>c</em> + <em>d</em>), return 0.</li>
<li>Flip the input coin.  If the coin returns 1, return 1.  Otherwise, go to step 1.</li>
</ol>

<p>(Note that Huber specifies this Bernoulli factory in terms of a Poisson point process, which seems to require much more randomness on average.)</p>

<p><a id=General_Algorithms></a></p>

<h3>General Algorithms</h3>

<p><strong>Algorithm for the probability generating function.</strong>  Let <em>X</em> be a random number that follows a discrete distribution (one that takes on a countable number of values).  The following algorithm generates heads with probability <strong>E</strong>[&lambda;<sup><em>X</em></sup>], that is, the expected (average) value of &lambda;<sup><em>X</em></sup>.  <strong>E</strong>[&lambda;<sup><em>X</em></sup>] is the distribution&#39;s <em>probability generating function</em>, also known as <em>factorial moment generating function</em> (Dughmi et al. 2017)<sup><a href="#Note10"><strong>(10)</strong></a></sup>.</p>

<ol>
<li>Generate a random number <em>N</em> of the given distribution.</li>
<li>Flip the input coin until the coin returns 0 or the coin is flipped <em>N</em> times.  Return 1 if all the coin flips, including the last, returned 1 (or if <em>N</em> is 0); or return 0 otherwise.</li>
</ol>

<p><strong>URandLessThanFraction algorithm</strong>.  The following helper algorithm is used by some of the algorithms on this page.  It returns 1 if a PSRN turns out to be less than a fraction, <em>frac</em>, which is a number in the interval [0, 1].</p>

<ol>
<li>If <em>frac</em> is 0 or 1, return 0 or 1, respectively. (The case of 1 is a degenerate case since the PSRN could, at least in theory, represent an infinite sequence of ones, making it equal to 1.)</li>
<li>Set <em>pt</em> to 1/<em>base</em>, and set <em>i</em> to 0. (<em>base</em> is the base, or radix, of the PSRN&#39;s digits, such as 2 for binary or 10 for decimal.)</li>
<li>Set <em>d1</em> to the digit at the <em>i</em><sup>th</sup> position (starting from 0) of the uniform PSRN.  If there is no digit there, put a digit chosen uniformly at random at that position and set <em>d1</em> to that digit.</li>
<li>Set <em>d2</em> to floor(<em>frac</em> / <em>pt</em>).  (For example, in base 2, set <em>d2</em> to 0 if <em>frac</em> is less than <em>pt</em>, or 1 otherwise.)</li>
<li>If <em>d1</em> is less than <em>d2</em>, return 1.  If <em>d1</em> is greater than <em>d2</em>, return 0.</li>
<li>If <em>frac</em> &gt;= <em>pt</em>, subtract <em>pt</em> from <em>frac</em>.</li>
<li>Divide <em>pt</em> by <em>base</em>, add 1 to <em>i</em>, and go to step 3.</li>
</ol>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560v2"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560v2  [math.PR], 2010.</small></p>

<p><small><sup id=Note2>(2)</sup> Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994.</small></p>

<p><small><sup id=Note3>(3)</sup> As used here and in the Flajolet paper, a geometric random number is the number of successes before the first failure, where the success probability is &lambda;.</small></p>

<p><small><sup id=Note4>(4)</sup> The Flajolet paper describes what it calls the <em>von Neumann schema</em>, which, given a permutation specification and an input coin, generates a random non-negative integer <em>n</em> with probability equal to (&lambda;<sup><em>n</em></sup> * P(<em>n</em>) / <em>n</em>!) / &Sigma;<sub><em>k</em> = 0, &infin;</sub> (&lambda;<sup><em>k</em></sup> * P(<em>k</em>) / <em>k</em>!), where P(<em>n</em>) is the number of <em>valid</em> permutations of size <em>n</em> (or 1 if <em>n</em> is 0).  Here, the sum in this formula is also known as an <em>exponential generating function</em>.  Effectively, a geometric(&lambda;) random number <em>G</em> is accepted with probability equal to the ratio that P(<em>G</em>) bears to the number of <em>possible</em> permutations of size <em>G</em>, and rejected otherwise.</small></p>

<p><small><sup id=Note5>(5)</sup> Łatuszyński, K., Kosmidis, I.,  Papaspiliopoulos, O., Roberts, G.O., &quot;<a href="https://arxiv.org/abs/0907.4018v2"><strong>Simulating events of unknown probabilities via reverse time martingales</strong></a>&quot;, arXiv:0907.4018v2 [stat.CO], 2009/2011.</small></p>

<p><small><sup id=Note6>(6)</sup> Gonçalves, F. B., Łatuszyński, K. G., Roberts, G. O. (2017).  Exact Monte Carlo likelihood-based inference for jump-diffusion processes.</small></p>

<p><small><sup id=Note7>(7)</sup> Vats, D., Gonçalves, F. B., Łatuszyński, K. G., Roberts, G. O. Efficient Bernoulli factory MCMC for intractable likelihoods, arXiv:2004.07471v1 [stat.CO], 2020.</small></p>

<p><small><sup id=Note8>(8)</sup> Huber, M., &quot;<a href="https://arxiv.org/abs/1507.00843v2"><strong>Optimal linear Bernoulli factories for small mean problems</strong></a>&quot;, arXiv:1507.00843v2 [math.PR], 2016</small></p>

<p><small><sup id=Note9>(9)</sup> Morina, G., Łatuszyński, K., et al., &quot;<a href="https://arxiv.org/abs/1912.09229v1"><strong>From the Bernoulli Factory to a Dice Enterprise via Perfect Sampling of Markov Chains</strong></a>&quot;, arXiv:1912.09229v1 [math.PR], 2019.</small></p>

<p><small><sup id=Note10>(10)</sup> Shaddin Dughmi, Jason D. Hartline, Robert Kleinberg, and Rad Niazadeh. 2017. Bernoulli Factories and Black-Box Reductions in Mechanism Design. In <em>Proceedings of 49th Annual ACM SIGACT Symposium on the Theory of Computing</em>, Montreal, Canada, June 2017 (STOC’17).</small></p>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
