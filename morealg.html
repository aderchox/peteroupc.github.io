<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>More Algorithms for Arbitrary-Precision Sampling</title><meta name="citation_title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="og:title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="og:type" content="article"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>More Algorithms for Arbitrary-Precision Sampling</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>This page contains additional algorithms for arbitrary-precision sampling of continuous distributions, Bernoulli factory algorithms (biased-coin to biased-coin algorithms), and algorithms to simulate irrational probabilities.  These samplers are designed to not rely on floating-point arithmetic.  They may depend on algorithms given in the following pages:</p>

<ul>
<li><a href="https://peteroupc.github.io/exporand.html"><strong>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</strong></a></li>
<li><a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a></li>
</ul>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Bernoulli_Factories_and_Irrational_Probability_Simulation"><strong>Bernoulli Factories and Irrational Probability Simulation</strong></a>

<ul>
<li><a href="#Certain_Numbers_Based_on_the_Golden_Ratio"><strong>Certain Numbers Based on the Golden Ratio</strong></a></li>
<li><a href="#Ratio_of_Lower_Gamma_Functions_gamma__m___n__gamma__m__1"><strong>Ratio of Lower Gamma Functions (&gamma;(<em>m</em>, <em>n</em>)/&gamma;(<em>m</em>, 1)).</strong></a></li>
</ul></li>
<li><a href="#Arbitrary_Precision_Samplers"><strong>Arbitrary-Precision Samplers</strong></a>

<ul>
<li><a href="#Rayleigh_Distribution"><strong>Rayleigh Distribution</strong></a></li>
<li><a href="#Uniform_Distribution_Inside_N_Dimensional_Shapes"><strong>Uniform Distribution Inside N-Dimensional Shapes</strong></a></li>
<li><a href="#Sum_of_Exponential_Random_Numbers"><strong>Sum of Exponential Random Numbers</strong></a></li>
<li><a href="#Hyperbolic_Secant_Distribution"><strong>Hyperbolic Secant Distribution</strong></a></li>
<li><a href="#Mixtures"><strong>Mixtures</strong></a></li>
<li><a href="#Building_an_Arbitrary_Precision_Sampler"><strong>Building an Arbitrary-Precision Sampler</strong></a></li>
<li><a href="#Reciprocal_of_Power_of_Uniform"><strong>Reciprocal of Power of Uniform</strong></a></li>
<li><a href="#Distribution_of__U__1_minus__U"><strong>Distribution of <em>U</em>/(1&minus;<em>U</em>)</strong></a></li>
<li><a href="#Arc_cosine_Distribution"><strong>Arc-cosine Distribution</strong></a></li>
<li><a href="#Logistic_Distribution"><strong>Logistic Distribution</strong></a></li>
</ul></li>
<li><a href="#Requests"><strong>Requests</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Bernoulli_Factories_and_Irrational_Probability_Simulation></a></p>

<h2>Bernoulli Factories and Irrational Probability Simulation</h2>

<p>&nbsp;</p>

<p><a id=Certain_Numbers_Based_on_the_Golden_Ratio></a></p>

<h3>Certain Numbers Based on the Golden Ratio</h3>

<p>The following algorithm given by Fishman and Miller (2013)<sup><a href="#Note1"><strong>(1)</strong></a></sup> finds the continued fraction expansion of certain numbers described as&mdash;</p>

<ul>
<li><em>G</em>(<em>m</em>, <em>&#x2113;</em>) = (<em>m</em> + sqrt(<em>m</em><sup>2</sup> + 4 * <em>&#x2113;</em>))/2<br>&nbsp;&nbsp;&nbsp;&nbsp;or (<em>m</em> &minus; sqrt(<em>m</em><sup>2</sup> + 4 * <em>&#x2113;</em>))/2,</li>
</ul>

<p>whichever results in a real number greater than 1, where <em>m</em> is a positive integer and <em>&#x2113;</em> is either 1 or &minus;1.  In this case, <em>G</em>(1, 1) is the golden ratio.</p>

<p>First, define the following operations:</p>

<ul>
<li><strong>Get the previous and next Fibonacci-based number given <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong>:

<ol>
<li>If <em>k</em> is 0 or less, return an error.</li>
<li>Set <em>g0</em> to 0, <em>g1</em> to 1, <em>x</em> to 0, and <em>y</em> to 0.</li>
<li>Do the following <em>k</em> times: Set <em>y</em> to <em>m</em> * <em>g1</em> + <em>&#x2113;</em> * <em>g0</em>, then set <em>x</em> to <em>g0</em>, then set <em>g0</em> to <em>g1</em>, then set <em>g1</em> to <em>y</em>.</li>
<li>Return <em>x</em> and <em>y</em>, in that order.</li>
</ol></li>
<li><strong>Get the partial denominator given <em>pos</em>, <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong> (this partial denominator is part of the continued fraction expansion found by Fishman and Miller):

<ol>
<li><strong>Get the previous and next Fibonacci-based number given <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong>, call them <em>p</em> and <em>n</em>, respectively.</li>
<li>If <em>&#x2113;</em> is 1 and <em>k</em> is odd, return <em>p</em> + <em>n</em>.</li>
<li>If <em>&#x2113;</em> is &minus;1 and <em>pos</em> is 0, return <em>n</em> &minus; <em>p</em> &minus; 1.</li>
<li>If <em>&#x2113;</em> is 1 and <em>pos</em> is 0, return (<em>n</em> + <em>p</em>) &minus; 1.</li>
<li>If <em>&#x2113;</em> is &minus;1 and <em>pos</em> is even, return <em>n</em> &minus; <em>p</em> &minus; 2. (The paper had an error here; the correction given here was verified by Miller via personal communication.)</li>
<li>If <em>&#x2113;</em> is 1 and <em>pos</em> is even, return (<em>n</em> + <em>p</em>) &minus; 2.</li>
<li>Return 1.</li>
</ol></li>
</ul>

<p>An application of the continued fraction algorithm is the following algorithm that generates 1 with probability <em>G</em>(<em>m</em>, <em>&#x2113;</em>)<sup>&minus;<em>k</em></sup> and 0 otherwise, where <em>k</em> is an integer that is 1 or greater (see &quot;Continued Fractions&quot; in my page on Bernoulli factory algorithms). The algorithm starts with <em>pos</em> = 0, then the following steps are taken:</p>

<ol>
<li><strong>Get the partial denominator given <em>pos</em>, <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong>, call it <em>kp</em>.</li>
<li>With probability <em>kp</em>/(1 + <em>kp</em>), return a number that is 1 with probability 1/<em>kp</em> and 0 otherwise.</li>
<li>Run this algorithm recursively, but with <em>pos</em> = <em>pos</em> + 1.  If the algorithm returns 1, return 0.  Otherwise, go to step 2.</li>
</ol>

<p><a id=Ratio_of_Lower_Gamma_Functions_gamma__m___n__gamma__m__1></a></p>

<h3>Ratio of Lower Gamma Functions (&gamma;(<em>m</em>, <em>n</em>)/&gamma;(<em>m</em>, 1)).</h3>

<ol>
<li>Set <em>ret</em> to the result of <strong>kthsmallest</strong> with the two parameters <em>m</em> and <em>m</em>.</li>
<li>Set <em>k</em> to 1, then set <em>u</em> to point to the same value as <em>ret</em>.</li>
<li>Generate a uniform(0, 1) random number <em>v</em>.</li>
<li>If <em>v</em> is less than <em>u</em>: Set <em>u</em> to <em>v</em>, then add 1 to <em>k</em>, then go to step 3.</li>
<li>If <em>k</em> is odd, return a number that is 1 if <em>ret</em> is less than <em>n</em> and 0 otherwise. (If <em>ret</em> is implemented as a uniform PSRN, this comparison should be done via <strong>URandLessThanReal</strong>.)  If <em>k</em> is even, go to step 1.</li>
</ol>

<p><a id=Arbitrary_Precision_Samplers></a></p>

<h2>Arbitrary-Precision Samplers</h2>

<p><a id=Rayleigh_Distribution></a></p>

<h3>Rayleigh Distribution</h3>

<p>The following is an arbitrary-precision sampler for the Rayleigh distribution with parameter <em>s</em>, which is a rational number greater than 0.</p>

<ol>
<li>Set <em>k</em> to 0, and set <em>y</em> to 2 * <em>s</em> * <em>s</em>.</li>
<li>With probability exp(&minus;(<em>k</em> * 2 + 1)/<em>y</em>), go to step 3.  Otherwise, add 1 to <em>k</em> and repeat this step.  (The probability check should be done with the <strong>exp(&minus;<em>x</em>/<em>y</em>) algorithm</strong> in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, with <em>x</em>/<em>y</em> = (<em>k</em> * 2 + 1)/<em>y</em>.)</li>
<li>(Now we sample the piece located at [<em>k</em>, <em>k</em> + 1).)  Create a positive-sign zero-integer-part uniform PSRN, and create an input coin that returns the result of <strong>SampleGeometricBag</strong> on that uniform PSRN.</li>
<li>Set <em>ky</em> to <em>k</em> * <em>k</em> / <em>y</em>.</li>
<li>(At this point, we simulate exp(&minus;<em>U</em><sup>2</sup>/<em>y</em>), exp(&minus;<em>k</em><sup>2</sup>/<em>y</em>) , exp(&minus;<em>U</em>*<em>k</em>*2/<em>y</em>), as well as a scaled-down version of <em>U</em> + <em>k</em>, where <em>U</em> is the number built up by the uniform PSRN.) Call the <strong>exp(&minus;<em>x</em>/<em>y</em>) algorithm</strong> with <em>x</em>/<em>y</em> = <em>ky</em>, then call the <strong>exp(&minus;(<em>&lambda;</em><sup><em>k</em></sup> * <em>x</em>)) algorithm</strong> using the input coin from step 2, <em>x</em> = 1/<em>y</em>, and <em>k</em> = 2, then call the same algorithm using the same input coin, <em>x</em> = <em>k</em> * 2 / <em>y</em>, and <em>k</em> = 1, then call the <strong>sub-algorithm</strong> given later with the uniform PSRN and <em>k</em> = <em>k</em>.  If all of these calls return 1, the uniform PSRN was accepted.  Otherwise, remove all digits from the uniform PSRN&#39;s fractional part and go to step 4.</li>
<li>If the uniform PSRN, call it <em>ret</em>, was accepted by step 5, set <em>ret</em>&#39;s integer part to <em>k</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), and return <em>ret</em>.</li>
</ol>

<p>The sub-algorithm below simulates a probability equal to (<em>U</em>+<em>k</em>)/<em>base</em><sup><em>z</em></sup>, where <em>U</em> is the number built by the uniform PSRN, <em>base</em> is the base (radix) of digits stored by that PSRN, <em>k</em> is an integer 0 or greater, and <em>z</em> is the number of significant digits in <em>k</em> (for this purpose, <em>z</em> is 0 if <em>k</em> is 0).</p>

<p>For base 2:</p>

<ol>
<li> Set <em>N</em> to 0.</li>
<li> With probability 1/2, go to the next step.  Otherwise, add 1 to <em>N</em> and repeat this step.</li>
<li> If <em>N</em> is less than <em>z</em>, return rem(<em>k</em> / 2<sup><em>z</em> &minus; 1 &minus; <em>N</em></sup>, 2).  (Alternatively, shift <em>k</em> to the right, by <em>z</em> &minus; 1 &minus; <em>N</em> bits, then return <em>k</em> <em>AND</em> 1, where &quot;<em>AND</em>&quot; is a bitwise AND-operation.)</li>
<li> Subtract <em>z</em> from <em>N</em>.  Then, if the item at position <em>N</em> in the uniform PSRN&#39;s fractional part (positions start at 0) is not set to a digit (e.g., 0 or 1 for base 2), set the item at that position to a digit chosen uniformly at random (e.g., either 0 or 1 for base 2), increasing the capacity of the uniform PSRN&#39;s fractional part as necessary.</li>
<li> Return the item at position <em>N</em>.</li>
</ol>

<p>For bases other than 2, such as 10 for decimal, this can be implemented as follows (based on <strong>URandLess</strong>):</p>

<ol>
<li>Set <em>i</em> to 0.</li>
<li>If <em>i</em> is less than <em>z</em>:

<ol>
<li>Set <em>da</em> to rem(<em>k</em> / 2<sup><em>z</em> &minus; 1 &minus; <em>i</em></sup>, <em>base</em>), and set <em>db</em> to a digit chosen uniformly at random (that is, an integer in the interval [0, <em>base</em>)).</li>
<li>Return 1 if <em>da</em> is less than <em>db</em>, or 0 if <em>da</em> is greater than <em>db</em>.</li>
</ol></li>
<li>If <em>i</em> is <em>z</em> or greater:

<ol>
<li>If the digit at position (<em>i</em> &minus; <em>z</em>) in the uniform PSRN&#39;s fractional part is not set, set the item at that position to a digit chosen uniformly at random (positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.).</li>
<li>Set <em>da</em> to the item at that position, and set <em>db</em> to a digit chosen uniformly at random (that is, an integer in the interval [0, <em>base</em>)).</li>
<li>Return 1 if <em>da</em> is less than <em>db</em>, or 0 if <em>da</em> is greater than <em>db</em>.</li>
</ol></li>
<li>Add 1 to <em>i</em> and go to step 3.</li>
</ol>

<p><a id=Uniform_Distribution_Inside_N_Dimensional_Shapes></a></p>

<h3>Uniform Distribution Inside N-Dimensional Shapes</h3>

<p>The following is a general way to describe an arbitrary-precision sampler for generating a point uniformly at random inside a geometric shape located entirely in the hypercube [0, 1]&times;[0, 1]&times;...&times;[0,1] in <em>N</em>-dimensional space, provided the shape&#39;s boundary has zero volume.  Such a description has the following skeleton.</p>

<ol>
<li>Generate <em>N</em> empty PSRNs, with a positive sign, an integer part of 0, and an empty fractional part.  Call the PSRNs <em>p1</em>, <em>p2</em>, ..., <em>pN</em>.</li>
<li>Set <em>S</em> to <em>base</em>, where <em>base</em> is the base of digits to be stored by the PSRNs (such as 2 for binary or 10 for decimal).  Then set <em>N</em> coordinates to 0, call the coordinates <em>c1</em>, <em>c2</em>, ..., <em>cN</em>.  Then set <em>d</em> to 1.</li>
<li>For each coordinate (<em>c1</em>, ..., <em>cN</em>), multiply that coordinate by <em>base</em> and add a digit chosen uniformly at random to that coordinate.</li>
<li>This step uses a function known as <strong>InShape</strong>, which takes the coordinates of a box and returns one of three values: <em>YES</em> if the box is entirely inside the shape; <em>NO</em> if the box is entirely outside the shape; and <em>MAYBE</em> if the box is partly inside and partly outside the shape, or if the function is unsure.  In this step, run <strong>InShape</strong> using the current box, whose coordinates in this case are ((<em>c1</em>/<em>S</em>, <em>c2</em>/<em>S</em>, ..., <em>cN</em>/<em>S</em>), ((<em>c1</em>+1)/<em>S</em>, (<em>c2</em>+1)/<em>S</em>, ..., (<em>cN</em>+1)/<em>S</em>)).  See below for implementation notes for this step.</li>
<li>If the result of <strong>InShape</strong> is <em>YES</em>, then the current box was accepted.  If the box is accepted this way, then at this point, <em>c1</em>, <em>c2</em>, etc., will each store the <em>d</em> digits of a coordinate in the shape, expressed as a number in the interval [0, 1], or more precisely, a range of numbers.  (For example, if <em>base</em> is 10, <em>d</em> is 3, and <em>c1</em> is 342, then the first coordinate is 0.342, or more precisely, a number in the interval [0.342, 0.343].)  In this case, do the following:

<ol>
<li>For each coordinate (<em>c1</em>, ..., <em>cN</em>), transfer that coordinate&#39;s least significant digits to the corresponding PSRN&#39;s fractional part.  The variable <em>d</em> tells how many digits to transfer this way. (For example, if <em>base</em> is 10, <em>d</em> is 3, and <em>c1</em> is 342, set <em>p1</em>&#39;s fractional part to [3, 4, 2].)</li>
<li>For each PSRN (<em>p1</em>, ..., <em>pN</em>), optionally fill that PSRN with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>).</li>
<li>For each PSRN, optionally do the following: With probability 1/2, set that PSRN&#39;s sign to negative. (This will result in a symmetric shape in the corresponding dimension.  This step can be done for some PSRNs and not others.)</li>
<li>Return the PSRNs <em>p1</em>, ..., <em>pN</em>, in that order.</li>
</ol></li>
<li>If the result of <strong>InShape</strong> is <em>NO</em>, then the current box lies outside the shape and is rejected.  In this case, go to step 2.</li>
<li>If the result of <strong>InShape</strong> is <em>MAYBE</em>, it is not known whether the current box lies fully inside the shape, so multiply <em>S</em> by <em>base</em>, then add 1 to <em>d</em>, then go to step 3.</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>See (Li and El Gamal 2016)<sup><a href="#Note2"><strong>(2)</strong></a></sup> and (Oberhoff 2018)<sup><a href="#Note3"><strong>(3)</strong></a></sup> for related work on encoding random points uniformly distributed in a shape.</li>
<li>Rejection sampling on a shape is subject to the &quot;curse of dimensionality&quot;, since typical shapes of high dimension will tend to cover much less volume than their bounding boxes, so that it would take a lot of time on average to accept a high-dimensional box.  Moreover, the more area the shape takes up in the bounding box, the higher the acceptance rate.</li>
<li><p>Implementation notes for step 4:</p>

<ol>
<li><strong>InShape</strong>, as well as the divisions of the coordinates by <em>S</em>, should be implemented using rational arithmetic.  Instead of dividing those coordinates this way, an implementation can pass <em>S</em> as a separate parameter to <strong>InShape</strong>.</li>
<li><p>If the shape in question is convex, and the point (0, 0, ..., 0) is on or inside that shape, <strong>InShape</strong> can return&mdash;</p>

<ul>
<li><em>YES</em> if all the box&#39;s corners are in the shape;</li>
<li><em>NO</em> if none of the box&#39;s corners are in the shape and if the shape&#39;s boundary does not intersect with the box&#39;s boundary; and</li>
<li><em>MAYBE</em> in any other case, or if the function is unsure.</li>
</ul>

<p>In the case of two-dimensional shapes, the shape&#39;s corners are (<em>c1</em>/<em>S</em>, <em>c2</em>/<em>S</em>), ((<em>c1</em>+1)/<em>S</em>, <em>c2</em>/<em>S</em>), (<em>c1</em>,(<em>c2</em>+1)/<em>S</em>), and ((<em>c1</em>+1)/<em>S</em>, (<em>c2</em>+1)/<em>S</em>).</p></li>
<li>If point (0, 0, ..., 0) is on or inside the shape, and the shape is such that every axis-aligned line segment inside the enclosing hypercube crosses the shape at most once, then <strong>InShape</strong> can return&mdash;

<ul>
<li><em>YES</em> if all the box&#39;s corners are in the shape;</li>
<li><em>NO</em> if none of the box&#39;s corners are in the shape; and</li>
<li><em>MAYBE</em> in any other case, or if the function is unsure.</li>
</ul></li>
<li>If <strong>InShape</strong> expresses a shape in the form of a <em>signed distance field</em>, it can return&mdash;

<ul>
<li><em>YES</em> if the signed distance at each of the box&#39;s corners (after dividing their coordinates by <em>S</em>) is less than &minus;&sigma; (where &sigma; is an upper bound for sqrt(<em>N</em>)/(<em>S</em>*2), such as 1/<em>S</em>);</li>
<li><em>NO</em> if the signed distance at each of the box&#39;s corners is greater than &sigma;; and</li>
<li><em>MAYBE</em> in any other case, or if the function is unsure.</li>
</ul></li>
<li><strong>InShape</strong> implementations can also involve a shape&#39;s <em>implicit curve</em> or <em>algebraic curve</em> equation (for closed curves), or its <em>implicit surface</em> equation (for closed surfaces).</li>
</ol></li>
<li>An <strong>InShape</strong> function can implement a set operation (such as a union, intersection, or difference) of several simpler shapes, each with its own <strong>InShape</strong> function.  The final result depends on the shape operation (such as union or intersection) as well as the result returned by each component for a given box (for example, for unions, the final result is <em>YES</em> if any component returns <em>YES</em>; <em>NO</em> if all components return <em>NO</em>; and <em>MAYBE</em> otherwise).</li>
<li>(Devroye 1986, chapter 8, section 3)<sup><a href="#Note4"><strong>(4)</strong></a></sup> describes grid-based methods to optimize random point generation.  In this case, the space is divided into a grid of boxes each with size 1/<em>base</em><sup><em>k</em></sup> in all dimensions; the result of <strong>InShape</strong> is calculated for each such box and that box labeled with the result; all boxes labeled <em>NO</em> are discarded; and the algorithm is modified by adding the following after step 2: &quot;2a. Choose a precalculated box uniformly at random, then set <em>c1</em>, ..., <em>cN</em> to that box&#39;s coordinates, then set <em>d</em> to <em>k</em> and set <em>S</em> to <em>base</em><sup><em>k</em></sup>. If a box labeled <em>YES</em> was chosen, follow the substeps in step 5. If a box labeled <em>MAYBE</em> was chosen, multiply <em>S</em> by <em>base</em> and add 1 to <em>d</em>.&quot; (For example, if <em>base</em> is 10, <em>k</em> is 1, and <em>N</em> is 2, the space could be divided into a 10&times;10 grid, made up of 100 boxes each of size (1/10)&times;(1/10).  Then, <strong>InShape</strong> is precalculated for the box with coordinates ((0, 0), (1, 1)), the box ((0, 1), (1, 2)), and so on [the boxes&#39; coordinates are stored as just given, but <strong>InShape</strong> instead uses those coordinates divided by <em>base</em><sup><em>k</em></sup>, or 10<sup>1</sup> in this case], each such box is labeled with the result, and boxes labeled <em>NO</em> are discarded.  Finally the algorithm above is modified as just given.)</li>
<li>The algorithm can be extended to geometric shapes enclosed in the hyperrectangle [0, <em>d1</em>]&times;[0, <em>d2</em>]&times;...&times;[0,<em>dN</em>], where <em>d1</em>, ..., <em>dN</em> are integers greater than 0, as follows:

<ol>
<li>Add the following sentence at the end of step 2: &quot;For each coordinate (<em>c1</em>, ..., <em>cN</em>), set that coordinate to an integer in [0, <em>dX</em>), chosen uniformly at random, where <em>dX</em> is the coordinate&#39;s corresponding size.&quot;</li>
<li>Add the following sentence at the end of the first substep of step 5: &quot;Then, for each coordinate (<em>c1</em>, ..., <em>cN</em>), set the corresponding PSRN&#39;s integer part to floor(<em>cX</em>/<em>base</em><sup><em>d</em></sup>), where <em>cX</em> is that coordinate.&quot;</li>
</ol></li>
</ul>

<p><strong>Examples:</strong></p>

<ul>
<li>The following example generates a point inside a quarter diamond (centered at (0, ..., 0), &quot;radius&quot; 1): Let <strong>InShape</strong> return <em>YES</em> if ((<em>c1</em>+1) + ... + (<em>cN</em>+1)) &lt; <em>S</em>; <em>NO</em> if (<em>c1</em> + ... + <em>cN</em>) &gt; <em>S</em>; and <em>MAYBE</em> otherwise.  For a full diamond, step 5.3 in the algorithm is done for all <em>N</em> dimensions.</li>
<li>The following example generates a point inside a quarter hypersphere (centered at (0, ..., 0), radius 1): Let <strong>InShape</strong> return <em>YES</em> if ((<em>c1</em>+1)<sup>2</sup> + ... + (<em>cN</em>+1)<sup>2</sup>) &lt; <em>S</em><sup>2</sup>; <em>NO</em> if (<em>c1</em><sup>2</sup> + ... + <em>cN</em><sup>2</sup>) &gt; <em>S</em><sup>2</sup>; and <em>MAYBE</em> otherwise.  For a full hypersphere, step 5.3 in the algorithm is done for all <em>N</em> dimensions.  In the case of a 2-dimensional circle, this algorithm thus adapts the well-known rejection technique of generating X and Y coordinates until X<sup>2</sup>+Y<sup>2</sup> &lt; 1 (e.g., (Devroye 1986, p. 230 et seq.)<sup><a href="#Note4"><strong>(4)</strong></a></sup>).</li>
</ul>
</blockquote>

<p><a id=Sum_of_Exponential_Random_Numbers></a></p>

<h3>Sum of Exponential Random Numbers</h3>

<p>An arbitrary-precision sampler for the sum of <em>n</em> exponential random numbers (also known as the Erlang(<em>n</em>) or gamma(<em>n</em>) distribution) is doable via partially-sampled uniform random numbers, though it is obviously inefficient for large values of <em>n</em>.</p>

<ol>
<li>Generate <em>n</em> uniform PSRNs, and turn each of them into an exponential random number with a rate of 1, using an algorithm that employs rejection from the uniform distribution (such as the von Neumann algorithm or Karney&#39;s improvement to that algorithm (Karney 2014)<sup><a href="#Note5"><strong>(5)</strong></a></sup>).  This algorithm won&#39;t work for exponential PSRNs (e-rands), described in my article on <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers</strong></a>, because the sum of two e-rands may follow a subtly wrong distribution.  By contrast, generating exponential random numbers via rejection from the uniform distribution will allow unsampled digits to be sampled uniformly at random without deviating from the exponential distribution.</li>
<li>Generate the sum of the random numbers generated in step 1 by applying the <a href="https://peteroupc.github.io/exporand.html#Addition_and_Subtraction"><strong>algorithm to add two PSRNs</strong></a> given in another document.</li>
</ol>

<p><a id=Hyperbolic_Secant_Distribution></a></p>

<h3>Hyperbolic Secant Distribution</h3>

<p>The following algorithm adapts the rejection algorithm from p. 472 in (Devroye 1986)<sup><a href="#Note4"><strong>(4)</strong></a></sup> for arbitrary-precision sampling.</p>

<ol>
<li>Generate a uniform PSRN, call it <em>ret</em>, and turn it into an exponential random number with a rate of 1, using an algorithm that employs rejection from the uniform distribution.</li>
<li>Set <em>ip</em> to 1 plus <em>ret</em>&#39;s integer part.</li>
<li>(The rest of the algorithm accepts <em>ret</em> with probability 1/(1+<em>ret</em>).) With probability <em>ip</em>/(1+<em>ip</em>), generate a number that is 1 with probability 1/<em>ip</em> and 0 otherwise.  If that number is 1, <em>ret</em> was accepted, in which case optionally fill it with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then set <em>ret</em>&#39;s sign to positive or negative with equal probability, then return <em>ret</em>.</li>
<li>Call <strong>SampleGeometricBag</strong> on <em>ret</em>&#39;s fractional part (ignore <em>ret</em>&#39;s integer part and sign).  If the call returns 1, go to step 1.  Otherwise, go to step 3.</li>
</ol>

<p><a id=Mixtures></a></p>

<h3>Mixtures</h3>

<p>A <em>mixture</em> involves sampling one of several distributions, where each distribution has a separate probability of being sampled.  In general, an arbitrary-precision sampler is possible if all of the following conditions are met:</p>

<ul>
<li>There is a finite number of distributions to choose from.</li>
<li>The probability of sampling each distribution is a rational number, or it can be expressed as a function for which a <a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli factory algorithm</strong></a> exists.</li>
<li>For each distribution, an arbitrary-precision sampler exists.</li>
</ul>

<p>One example of a mixture is two beta distributions, with separate parameters.  One beta distribution is chosen with probability exp(&minus;3) (a probability for which a Bernoulli factory algorithm exists) and the other is chosen with the opposite probability.  For the two beta distributions, an arbitrary-precision sampling algorithm exists (see my article on <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers</strong></a> for details).</p>

<p><a id=Building_an_Arbitrary_Precision_Sampler></a></p>

<h3>Building an Arbitrary-Precision Sampler</h3>

<p>In many cases, if a continuous distribution&mdash;</p>

<ul>
<li>has a probability density function (PDF), or a function proportional to the PDF, with a known symbolic form,</li>
<li>has a cumulative distribution function (CDF) with a known symbolic form,</li>
<li>takes on only values 0 or greater, and</li>
<li>has a PDF that has an infinite tail to the right, is bounded from above (that is, <em>PDF(0)</em> is other than infinity), and decreases monotonically,</li>
</ul>

<p>it may be possible to describe an arbitrary-precision sampler for that distribution.  Such a description has the following skeleton.</p>

<ol>
<li>With probability <em>A</em>, set <em>intval</em> to 0, then set <em>size</em> to 1, then go to step 4.

<ul>
<li><em>A</em> is calculated as (<em>CDF</em>(1) &minus; <em>CDF</em>(0)) / (1&minus;<em>CDF</em>(0)), where <em>CDF</em> is the distribution&#39;s CDF.  This should be found analytically using a computer algebra system such as SymPy.</li>
<li>The symbolic form of <em>A</em> will help determine which Bernoulli factory algorithm, if any, will simulate the probability; if a Bernoulli factory exists, it should be used.</li>
</ul></li>
<li>Set <em>intval</em> to 1 and set <em>size</em> to 1.</li>
<li>With probability <em>B</em>(<em>size</em>, <em>intval</em>), go to step 4.  Otherwise, add <em>size</em> to <em>intval</em>, then multiply <em>size</em> by 2, then repeat this step.

<ul>
<li>This step chooses an interval beyond 1, and grows this interval by geometric steps, so that an appropriate interval is chosen with the correct probability.</li>
<li>The probability <em>B</em>(<em>size</em>, <em>intval</em>) is the probability that the interval is chosen given that the previous intervals weren&#39;t chosen, and is calculated as (<em>CDF</em>(<em>size</em> + <em>intval</em>) &minus; <em>CDF</em>(<em>intval</em>)) / (1&minus;<em>CDF</em>(<em>intval</em>)).  This should be found analytically using a computer algebra system such as SymPy.</li>
<li>The symbolic form of <em>B</em> will help determine which Bernoulli factory algorithm, if any, will simulate the probability; if a Bernoulli factory exists, it should be used.</li>
</ul></li>
<li>Generate an integer in the interval [<em>intval</em>, <em>intval</em> + <em>size</em>) uniformly at random, call it <em>i</em>.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN, <em>ret</em>.</li>
<li>Create an input coin that calls <strong>SampleGeometricBag</strong> on the PSRN <em>ret</em>.  Run a Bernoulli factory algorithm that simulates the probability <em>C</em>(<em>i</em>, <em>&lambda;</em>), using the input coin (here, <em>&lambda;</em> is the probability built up in <em>ret</em> via <strong>SampleGeometricBag</strong>, and lies in the interval [0, 1]).  If the call returns 0, go to step 4.

<ul>
<li>The probability <em>C</em>(<em>i</em>, <em>&lambda;</em>) is calculated as <em>PDF</em>(<em>i</em> + <em>&lambda;</em>) / <em>M</em>, where <em>PDF</em> is the distribution&#39;s PDF or a function proportional to the PDF, and should be found analytically using a computer algebra system such as SymPy.</li>
<li>In this formula, <em>M</em> is any convenient number in the interval [<em>PDF</em>(<em>intval</em>),  max(1, <em>PDF</em>(<em>intval</em>))], and should be as low as feasible. <em>M</em> serves to ensure that <em>C</em> is as close as feasible to 1 (to improve acceptance rates), but no higher than 1.  The choice of <em>M</em> can vary for each interval (each value of <em>intval</em>, which can only be 0, 1, or a power of 2).  Any such choice for <em>M</em> preserves the algorithm&#39;s correctness because the PDF has to be monotonically decreasing and a new interval isn&#39;t chosen when <em>&lambda;</em> is rejected.</li>
<li>The symbolic form of <em>C</em> will help determine which Bernoulli factory algorithm, if any, will simulate the probability; if a Bernoulli factory exists, it should be used.</li>
</ul></li>
<li>The PSRN <em>ret</em> was accepted, so set <em>ret</em>&#39;s integer part to <em>i</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</li>
</ol>

<p>Examples of algorithms that use this skeleton are the algorithm for the <a href="https://peteroupc.github.io/uniformsum.html"><strong>ratio of two uniform random numbers</strong></a>, the algorithm for the Rayleigh distribution given above, and the algorithm for the reciprocal of power of uniform, given later.</p>

<p>Perhaps the most difficult part of describing an arbitrary-precision sampler with this skeleton is finding the appropriate Bernoulli factory for the probabilities <em>A</em>, <em>B</em>, and <em>C</em>, especially when these probabilities have a non-trivial symbolic form.</p>

<blockquote>
<p><strong>Note:</strong> The algorithm skeleton uses ideas similar to the inversion-rejection method described in (Devroye 1986, ch. 7, sec. 4.6)<sup><a href="#Note4"><strong>(4)</strong></a></sup>; an exception is that instead of generating a uniform random number and comparing it to calculations of a CDF, this algorithm uses conditional probabilities of choosing a given piece, probabilities labeled <em>A</em> and <em>B</em>.  This approach was taken so that the CDF of the distribution in question is never directly calculated in the course of the algorithm, which furthers the goal of sampling with arbitrary precision and without using floating-point arithmetic.</p>
</blockquote>

<p><a id=Reciprocal_of_Power_of_Uniform></a></p>

<h3>Reciprocal of Power of Uniform</h3>

<p>The following algorithm generates a PSRN of the form 1/<em>U</em><sup>1/<em>x</em></sup>, where <em>U</em> is a uniform random number in [0, 1] and <em>x</em> is an integer greater than 0.</p>

<ol>
<li>Set <em>intval</em> to 1 and set <em>size</em> to 1.</li>
<li>With probability (4<sup><em>x</em></sup>&minus;2<sup><em>x</em></sup>)/4<sup><em>x</em></sup>, go to step 3.  Otherwise, add <em>size</em> to <em>intval</em>, then multiply <em>size</em> by 2, then repeat this step.</li>
<li>Generate an integer in the interval [<em>intval</em>, <em>intval</em> + <em>size</em>) uniformly at random, call it <em>i</em>.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN, <em>ret</em>.</li>
<li>Create an input coin that calls <strong>SampleGeometricBag</strong> on the PSRN <em>ret</em>.  Call the <strong>algorithm for <em>d</em><sup><em>k</em></sup> / (<em>c</em> + <em>&lambda;</em>)<sup><em>k</em></sup></strong> in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the input coin, where <em>d</em> = <em>intval</em>, <em>c</em> = <em>i</em>, and <em>k</em> = <em>x</em> + 1 (here, <em>&lambda;</em> is the probability built up in <em>ret</em> via <strong>SampleGeometricBag</strong>, and lies in the interval [0, 1]).  If the call returns 0, go to step 3.</li>
<li>The PSRN <em>ret</em> was accepted, so set <em>ret</em>&#39;s integer part to <em>i</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</li>
</ol>

<p>This algorithm uses the skeleton described earlier in &quot;Building an Arbitrary-Precision Sampler&quot;.  Here, the probabilities <em>A</em>, <em>B</em>,  and <em>C</em> are as follows:</p>

<ul>
<li><em>A</em> = 0, since the random number can&#39;t lie in the interval [0, 1).</li>
<li><em>B</em> = (4<sup><em>x</em></sup>&minus;2<sup><em>x</em></sup>)/4<sup><em>x</em></sup>.</li>
<li><em>C</em> = (<em>x</em>/(<em>i</em> + <em>&lambda;</em>)<sup><em>x</em>+1</sup>) / <em>M</em>.  Ideally, <em>M</em> is either <em>x</em> if <em>intval</em> is 1, or <em>x</em>/<em>intval</em><sup><em>x</em>+1</sup> otherwise.  Thus, the ideal form for <em>C</em> is <em>intval</em><sup><em>x</em>+1</sup>/(<em>i</em>+<em>&lambda;</em>)<sup><em>x</em>+1</sup>.</li>
</ul>

<p><a id=Distribution_of__U__1_minus__U></a></p>

<h3>Distribution of <em>U</em>/(1&minus;<em>U</em>)</h3>

<p>The following algorithm generates a PSRN of the form <em>U</em>/(1&minus;<em>U</em>), where <em>U</em> is a uniform random number in [0, 1].</p>

<ol>
<li>With probability 1/2, set <em>intval</em> to 0, then set <em>size</em> to 1, then go to step 4.</li>
<li>Set <em>intval</em> to 1 and set <em>size</em> to 1.</li>
<li>With probability <em>size</em>/(<em>size</em> + <em>intval</em> + 1), go to step 4.  Otherwise, add <em>size</em> to <em>intval</em>, then multiply <em>size</em> by 2, then repeat this step.</li>
<li>Generate an integer in the interval [<em>intval</em>, <em>intval</em> + <em>size</em>) uniformly at random, call it <em>i</em>.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN, <em>ret</em>.</li>
<li>Create an input coin that calls <strong>SampleGeometricBag</strong> on the PSRN <em>ret</em>.  Call the <strong>algorithm for <em>d</em><sup><em>k</em></sup> / (<em>c</em> + <em>&lambda;</em>)<sup><em>k</em></sup></strong> in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the input coin, where <em>d</em> = <em>intval</em> + 1, <em>c</em> = <em>i</em> + 1, and <em>k</em> = 2 (here, <em>&lambda;</em> is the probability built up in <em>ret</em> via <strong>SampleGeometricBag</strong>, and lies in the interval [0, 1]).  If the call returns 0, go to step 4.</li>
<li>The PSRN <em>ret</em> was accepted, so set <em>ret</em>&#39;s integer part to <em>i</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</li>
</ol>

<p>This algorithm uses the skeleton described earlier in &quot;Building an Arbitrary-Precision Sampler&quot;.  Here, the probabilities <em>A</em>, <em>B</em>,  and <em>C</em> are as follows:</p>

<ul>
<li><em>A</em> = 1/2.</li>
<li><em>B</em> = <em>size</em>/(<em>size</em> + <em>intval</em> + 1).</li>
<li><em>C</em> = (1/(<em>i</em>+<em>&lambda;</em>+1)<sup>2</sup>) / <em>M</em>.  Ideally, <em>M</em> is 1/(<em>intval</em>+1)<sup>2</sup>.  Thus, the ideal form for <em>C</em> is (<em>intval</em>+1)<sup>2</sup>/(<em>i</em>+<em>&lambda;</em>+1)<sup>2</sup>.</li>
</ul>

<p><a id=Arc_cosine_Distribution></a></p>

<h3>Arc-cosine Distribution</h3>

<p>Here we reimplement an example from Devroye&#39;s book <em>Non-Uniform Random Variate Generation</em> (Devroye 1986, pp. 128&ndash;129)<sup><a href="#Note4"><strong>(4)</strong></a></sup></sup>.  The following arbitrary-precision sampler generates a random number from a distribution with the following cumulative distribution function (CDF): <code>1 - cos(pi*x/2).</code>  The random number will be in the interval [0, 1].  Note that the result is the same as applying acos(<em>U</em>)*2/&pi;, where <em>U</em> is a uniform [0, 1] random number, as pointed out by Devroye.  The algorithm follows.</p>

<ol>
<li>Call the <strong>kthsmallest</strong> algorithm with <code>n = 2</code> and <code>k = 2</code>, but without filling it with digits at the last step.  Let <em>ret</em> be the result.</li>
<li>Set <em>m</em> to 1.</li>
<li>Call the <strong>kthsmallest</strong> algorithm with <code>n = 2</code> and <code>k = 2</code>, but without filling it with digits at the last step.  Let <em>u</em> be the result.</li>
<li>With probability 4/(4*<em>m</em>*<em>m</em> + 2*<em>m</em>), call the <strong>URandLess</strong> algorithm with parameters <em>u</em> and <em>ret</em> in that order, and if that call returns 1, call the <strong>algorithm for &pi; / 4</strong>, described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, twice, and if both of these calls return 1, add 1 to <em>m</em> and go to step 3.  (Here, we incorporate an erratum in the algorithm on page 129 of the book.)</li>
<li>If <em>m</em> is odd, optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits  (similarly to <strong>FillGeometricBag</strong>), and return <em>ret</em>.</li>
<li>If <em>m</em> is even, go to step 1.</li>
</ol>

<p>And here is Python code that implements this algorithm.  Note that it uses floating-point arithmetic only at the end, to convert the result to a convenient form, and that it relies on methods from <em>randomgen.py</em> and <em>bernoulli.py</em>.</p>

<pre>def example_4_2_1(rg, bern, precision=53):
    while True:
       ret=rg.kthsmallest_urand(2,2)
       k=1
       while True:
          u=rg.kthsmallest_urand(2,2)
          kden=4*k*k+2*k # erratum incorporated
          if randomgen.urandless(rg,u, ret) and \
             rg.zero_or_one(4, kden)==1 and \
             bern.zero_or_one_pi_div_4()==1 and \
             bern.zero_or_one_pi_div_4()==1:
             k+=1
          elif (k&amp;1)==1:
             return randomgen.urandfill(rg,ret,precision)/(1&lt;&lt;precision)
          else: break
</pre>

<p><a id=Logistic_Distribution></a></p>

<h3>Logistic Distribution</h3>

<p>The following new algorithm generates a random number that follows the logistic distribution.</p>

<ol>
<li>Set <em>k</em> to 0.</li>
<li>(Choose a 1-unit-wide piece of the logistic density.) Run the <strong>algorithm for (1+exp(<em>k</em>))/(1+exp(<em>k</em>+1))</strong> described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;).  If the call returns 0, add 1 to <em>k</em> and repeat this step.  Otherwise, go to step 3.</li>
<li>(The rest of the algorithm samples from the chosen piece.) Generate a uniform(0, 1) random number, call it <em>f</em>.</li>
<li>(Steps 4 through 7 succeed with probability exp(&minus;(<em>f</em>+<em>k</em>))/(1+exp(&minus;(<em>f</em>+<em>k</em>)))<sup>2</sup>.) With probability 1/2, go to step 3.</li>
<li>Run the <strong>algorithm for exp(&minus;<em>k</em>/1)</strong> (described in &quot;Bernoulli Factory Algorithms&quot;), then <strong>sample from the number <em>f</em></strong> (e.g., call <strong>SampleGeometricBag</strong> on <em>f</em> if <em>f</em> is implemented as a uniform PSRN).  If any of these calls returns 0, go to step 4.</li>
<li>With probability 1/2, accept <em>f</em>.  If <em>f</em> is accepted this way, set <em>f</em>&#39;s integer part to <em>k</em>, then optionally fill <em>f</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then set <em>f</em>&#39;s sign to positive or negative with equal probability, then return <em>f</em>.</li>
<li>Run the <strong>algorithm for exp(&minus;<em>k</em>/1)</strong> and <strong>sample from the number <em>f</em></strong> (e.g., call <strong>SampleGeometricBag</strong> on <em>f</em> if <em>f</em> is implemented as a uniform PSRN).  If both calls return 1, go to step 3.  Otherwise, go to step 6.</li>
</ol>

<p><a id=Requests></a></p>

<h2>Requests</h2>

<p>We would like to see new implementations of the following:</p>

<ul>
<li>Algorithms that implement <strong>InShape</strong> for specific curves and surfaces.  Recall that <strong>InShape</strong> determines whether a box lies inside, outside, or partly inside or outside a given curve or surface.</li>
<li>Descriptions of new arbitrary-precision algorithms that use the skeleton given in the section &quot;Building an Arbitrary-Precision Sampler&quot;.</li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<ul>
<li><small><sup id=Note1>(1)</sup> Fishman, D., Miller, S.J., &quot;Closed Form Continued Fraction Expansions of Special Quadratic Irrationals&quot;, ISRN Combinatorics Vol. 2013, Article ID 414623 (2013).</small></li>
<li><small><sup id=Note2>(2)</sup> C.T. Li, A. El Gamal, &quot;<a href="https://arxiv.org/abs/1603.05238v1"><strong>A Universal Coding Scheme for Remote Generation of Continuous Random Variables</strong></a>&quot;, arXiv:1603.05238v1  [cs.IT], 2016</small></li>
<li><small><sup id=Note3>(3)</sup> Oberhoff, Sebastian, &quot;<a href="https://dc.uwm.edu/etd/1888"><strong>Exact Sampling and Prefix Distributions</strong></a>&quot;, <em>Theses and Dissertations</em>, University of Wisconsin Milwaukee, 2018.</small></li>
<li><small><sup id=Note4>(4)</sup> Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</small></li>
<li><small><sup id=Note5>(5)</sup> Karney, C.F.F., &quot;<a href="https://arxiv.org/abs/1303.6257v2"><strong>Sampling exactly from the normal distribution</strong></a>&quot;, arXiv:1303.6257v2  [physics.comp-ph], 2014.</small></li>
</ul>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
