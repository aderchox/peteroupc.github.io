<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Requests and Open Questions</title><meta name="citation_title" content="Requests and Open Questions"><meta name="citation_pdf_url" content="https://peteroupc.github.io/requests.pdf"><meta name="citation_url" content="https://peteroupc.github.io/requests.html"><meta name="citation_date" content="2021/11/07"><meta name="citation_online_date" content="2021/11/07"><meta name="og:title" content="Requests and Open Questions"><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/requests.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Requests and Open Questions"><meta name="author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Requests and Open Questions</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>This page lists questions and issues relating to my articles posted on this site.  Any answers to these questions will greatly improve those articles.  If you can answer any of them, post an issue in the <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a>.</p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Randomization_and_Sampling_Methods"><strong>Randomization and Sampling Methods</strong></a></li>
<li><a href="#Bernoulli_Factory_Algorithms"><strong>Bernoulli Factory Algorithms</strong></a></li>
<li><a href="#Partially_Sampled_Random_Numbers_for_Accurate_Sampling_of_Continuous_Distributions"><strong>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</strong></a></li>
<li><a href="#More_Algorithms_for_Arbitrary_Precision_Sampling"><strong>More Algorithms for Arbitrary-Precision Sampling</strong></a></li>
<li><a href="#Randomized_Estimation_Algorithms"><strong>Randomized Estimation Algorithms</strong></a></li>
<li><a href="#Color_Topics_for_Programmers"><strong>Color Topics for Programmers</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Randomization_and_Sampling_Methods></a></p>

<h2>Randomization and Sampling Methods</h2>

<p><strong>Size Reduction Sought:</strong></p>

<p>Of the articles in this repository, <a href="https://peteroupc.github.io/randomfunc.html"><strong>Randomization and Sampling Methods</strong></a> and <a href="https://peteroupc.github.io/randomnotes.html"><strong>More Random Sampling Methods</strong></a> combined are very long (about 230 KB in size combined).</p>

<p>These articles describe numerous algorithms to generate random variates (from discrete and continuous distributions) as well as perform random sampling with and without replacement, shuffling, geometric sampling, and more, assuming a source of &quot;truly&quot; random numbers is available.</p>

<p>I would like to reduce the size of these articles while maintaining the most relevant algorithms for random variate generation.</p>

<p>Here are my goals for both articles:</p>

<ul>
<li>To shorten the <a href="https://peteroupc.github.io/randomfunc.html#Randomization_with_Real_Numbers"><strong>Randomization with Real Numbers</strong></a> section as much as possible, while still describing the most general (and exact) algorithms possible for sampling real numbers of any distribution.</li>
<li>To put emphasis on algorithms that work with random integers (or, if necessary, rational numbers), rather than random floating-point numbers.</li>
<li>To put emphasis on algorithms that sample a distribution <em>exactly</em>, or at least with a controlled upper bound on the error.  For discussion, see  &quot;<a href="https://peteroupc.github.io/randomnotes.html#Exact_Error_Bounded_and_Approximate_Algorithms"><strong>Exact, Error-Bounded, and Approximate Algorithms</strong></a>&quot;.</li>
<li>To ensure the documents are easy for programmers to understand and implement.</li>
</ul>

<p><a id=Bernoulli_Factory_Algorithms></a></p>

<h2>Bernoulli Factory Algorithms</h2>

<p><a href="https://peteroupc.github.io/bernoulli.html"><strong>https://peteroupc.github.io/bernoulli.html</strong></a></p>

<p>This is a page showing algorithms to turn a coin with an unknown probability of heads into a coin with a different probability of heads, also known as <em>Bernoulli factories</em>.  A <em>factory function</em> is a function that relates the old probability to the new one.  Roughly speaking, a function can be a factory function only if it is the constant 0 or 1, or if it is continuous on its domain and equals neither 0 nor 1 on the open interval (0, 1) (Keane and O&#39;Brien 1994)[^1].</p>

<p>Attention is drawn to the requests and open questions on that page:</p>

<ul>
<li><a href="https://peteroupc.github.io/bernoulli.html#Requests_and_Open_Questions"><strong>https://peteroupc.github.io/bernoulli.html#Requests_and_Open_Questions</strong></a></li>
</ul>

<p>Among other things, they relate to finding polynomial sequences, probabilities, and other mathematical constructions needed to apply certain Bernoulli factories.  These questions are reproduced below.</p>

<ol>
<li><p>What simulations exist that are &quot;relatively simple&quot; and succeed with an irrational probability between 0 and 1? What about &quot;relatively simple&quot; Bernoulli factory algorithms for factory functions?  Here, &quot;relatively simple&quot; means that the algorithm:</p>

<ul>
<li>Should use only uniform random integers (or bits) and integer arithmetic.</li>
<li>Does not use floating-point arithmetic or make direct use of square root or transcendental functions.</li>
<li>Does not calculate base-<em>n</em> expansions directly.</li>
<li>Should not use rational arithmetic or increasingly complex approximations, except as a last resort.</li>
</ul>

<p>See also Flajolet et al. (2010)[^2].  There are many ways to describe the irrational probability or factory function. I seek references to papers or books that describe irrational constants or factory functions in any of the following ways:</p>

<ul>
<li>For irrational constants:

<ul>
<li>Simple <a href="https://peteroupc.github.io/bernoulli.html#Continued_Fractions"><strong>continued fraction</strong></a> expansions.</li>
<li>Closed shapes inside the unit square whose area is an irrational number.  (Includes algorithms that tell whether a box lies inside, outside, or partly inside or outside the shape.)    <a href="https://peteroupc.github.io/morealg.html#pi___4"><strong>Example.</strong></a></li>
<li>Generate a uniform (<em>x</em>, <em>y</em>) point inside a closed shape, then return 1 with probability <em>x</em>.  For what shapes is the expected value of <em>x</em> an irrational number?  <a href="https://peteroupc.github.io/morealg.html#4_3___pi"><strong>Example.</strong></a></li>
<li>Functions that map [0, 1] to [0, 1] whose integral (area under curve) is an irrational number.</li>
</ul></li>
<li>For Bernoulli factory functions:

<ul>
<li>Functions with any of the following series expansions, using rational arithmetic only:

<ul>
<li>Power series where <em>f</em>(0) is 0 and <em>f</em>(1) is rational or vice versa (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Power_Series"><strong>Certain Power Series</strong></a>&quot;).</li>
<li>Series with non-negative terms that can be &quot;tucked&quot; under a discrete probability mass function (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Convex_Combinations"><strong>Convex Combinations</strong></a>&quot;).</li>
<li>Alternating power series whose coefficients are all in the interval [0, 1] and form a nonincreasing sequence (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Power_Series"><strong>Certain Power Series</strong></a>&quot;).</li>
<li>Series with non-negative terms and bounds on the truncation error (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Converging_Series"><strong>Certain Converging Series</strong></a>&quot;).</li>
</ul></li>
<li>A way to compute two sequences of polynomials written in Bernstein form that converge from above and below to a factory function as follows: (a) Each sequence&#39;s polynomials must have coefficients lying in [0, 1], and be of increasing degree; (b) the degree-<em>n</em> polynomials&#39; coefficients must lie at or &quot;inside&quot; those of the previous upper polynomial and the previous lower one (once the polynomials are elevated to degree <em>n</em>).  For a formal statement of these polynomials, see my <a href="https://mathoverflow.net/questions/379858"><strong>question on MathOverflow</strong></a>.<br><br>The <a href="https://peteroupc.github.io/bernsupp.html"><strong>supplemental notes</strong></a> include formulas for computing these polynomials for large classes of factory functions, but none of them ensure a finite expected number of coin flips in general, and it is suspected that a finite number of flips isn&#39;t possible unless the factory function is C<sup>2</sup> continuous (has two or more continuous &quot;slope&quot; functions).  Thus one question is: Given a C<sup>2</sup> continuous factory function, are there practical algorithms for building polynomials described here, where the expected number of coin flips is finite (besides the algorithms in this article or the supplemental notes)?  Examples worth thinking about are sin(<em>&pi;</em>*<em>&lambda;</em>)/2 and sin(2*<em>&pi;</em>*<em>&lambda;</em>)/4 + 1/2.</li>
</ul></li>
</ul></li>
<li><p>Let a permutation class (such as numbers in descending order) and two continuous probability distributions <em>D</em> and <em>E</em> be given.  Consider the following algorithm: Generate a sequence of independent random numbers (where the first is distributed as <em>D</em> and the rest as <em>E</em>) until the sequence no longer follows the permutation class, then return <em>n</em>, which is how many numbers were generated this way minus 1.  In this case:</p>

<ol>
<li>What is the probability that <em>n</em> is returned?</li>
<li>What is the probability that <em>n</em> is odd or even or belongs to a certain class of numbers?</li>
<li>For each <em>x</em>, what is the probability that the first generated number is <em>x</em> or less given that <em>n</em> is odd? ...given that <em>n</em> is even?</li>
</ol>

<p>Obviously, these answers depend on the specific permutation class and/or distributions <em>D</em> and <em>E</em>.  Thus, answers that work only for particular classes and/or distributions are welcome.  See also my Stack Exchange question <a href="https://stats.stackexchange.com/questions/499864/probabilities-arising-from-permutations"><strong>Probabilities arising from permutations</strong></a>.</p></li>
<li>Is there a simpler or faster way to implement the base-2 or natural logarithm of binomial coefficients?  See the example in the section &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Converging_Series"><strong>Certain Converging Series</strong></a>&quot;.</li>
<li><p>Part of the reverse-time martingale algorithm of Łatuszyński et al. (2009/2011)[^3] (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>General Factory Functions</strong></a>&quot;) to simulate a factory function <em>f</em>(<em>&lambda;</em>) is as follows.  For each <em>n</em> starting with 1:</p>

<ol>
<li>Flip the input coin, and compute the <em>n</em><sup>th</sup> upper and lower bounds of <em>f</em> given the number of heads so far, call them <em>L</em> and <em>U</em>.</li>
<li>Compute the (<em>n</em>&minus;1)<sup>th</sup> upper and lower bounds of <em>f</em> given the number of heads so far, call them <em>L&prime;</em> and <em>U&prime;</em>.  (These bounds must be the same regardless of the outcomes of future coin flips, and the interval [<em>L&prime;</em>, <em>U&prime;</em>] must equal or entirely contain the interval [<em>L</em>, <em>U</em>].)</li>
</ol>

<p>These parts of the algorithm appear to work for any two sequences of functions (not just polynomials) that converge to <em>f</em>, where <em>L</em> or <em>L&prime;</em> and <em>U</em> or <em>U&prime;</em> are their lower and upper bound approximations.  The section on general factory functions shows how this algorithm can be implemented for polynomials.  But how do these steps work when the approximating functions (the functions that converge to <em>f</em>) are rational functions whose coefficients are integers? Rational functions whose coefficients are rational numbers? Arbitrary approximating functions?</p></li>
<li>A <em>pushdown automaton</em> is a state machine that holds a stack of symbols.  Mossel and Peres (2005)[^4] investigated which functions (<em>f</em>(<em>&lambda;</em>)) can be simulated by these machines when they&#39;re given an infinite &quot;tape&quot; of flips of a coin that shows heads with probability <em>&lambda;</em>.  They showed that pushdown automata can simulate only <em>algebraic functions</em>, but perhaps not all of them. The question is: What is the exact class of algebraic functions a pushdown automaton can simulate?  Can it simulate the functions min(<em>&lambda;</em>, 1&minus;<em>&lambda;</em>) and <em>&lambda;</em><sup>1/<em>p</em></sup> where <em>p</em>&gt;2 is a prime number?  I have written an <a href="https://peteroupc.github.io/morealg.html#Pushdown_Automata_and_Algebraic_Functions"><strong>article appendix</strong></a> showing my progress, but are there other results on this question?</li>
<li>The following is an open question in Nacu and Peres 2005.  Let <em>J</em> be a closed interval on (0, 1), such as [1/100, 99/100].  Suppose there is an algorithm that takes a coin with unknown probability of heads <em>&lambda;</em> and produces one or more samples of the probability <em>f</em>(<em>&lambda;</em>).  When the probability <em>&lambda;</em> can be any value in <em>J</em>, is it possible for this algorithm to have an expected number of input coin flips per sample that is arbitrarily close to the so-called <em>entropy bound</em>?  The entropy bound is <em>h</em>(<em>f</em>(<em>&lambda;</em>))/<em>h</em>(<em>&lambda;</em>) where <em>h</em>(<em>x</em>) = &minus;<em>x</em>*ln(<em>x</em>)&minus;(1&minus;<em>x</em>)*ln(1&minus;<em>x</em>) is related to the Shannon entropy function.  Does the answer change if the algorithm can also use a separate source of unbiased random bits?  See my section &quot;<a href="https://peteroupc.github.io/bernsupp.html#Multiple_Output_Bernoulli_Factory"><strong>Multiple-Output Bernoulli Factory</strong></a>&quot;.</li>
<li>A factory function <em>f</em>(<em>&lambda;</em>) is <em>strongly simulable</em> if there is an algorithm to toss heads with probability <em>f</em>(<em>&lambda;</em>) using only a coin that shows heads with probability <em>&lambda;</em> and no other randomness.  Keane and O&#39;Brien (1994) showed already that <em>f</em>(<em>&lambda;</em>) is strongly simulable if neither 0 nor 1 is in <em>f</em>&#39;s domain.  It&#39;s also easy to show that if <em>f</em> is strongly simulable, then <em>f</em>(0) and <em>f</em>(1) must each be 0, 1, or undefined.  Is this a <em>sufficient condition</em> to be strongly simulable?  I have written an <a href="https://peteroupc.github.io/bernsupp.html#Which_functions_don_t_require_outside_randomness_to_simulate"><strong>article appendix</strong></a> showing my progress, but are there other results on this question?</li>
</ol>

<p><a id=Partially_Sampled_Random_Numbers_for_Accurate_Sampling_of_Continuous_Distributions></a></p>

<h2>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</h2>

<p><a href="https://peteroupc.github.io/exporand.html"><strong>https://peteroupc.github.io/exporand.html</strong></a></p>

<p>A <em>partially-sampled random number</em> (PSRN) is a data structure holding the initial digits of a random number that is built up digit by digit.</p>

<ul>
<li>The following is an open question on PSRNs.  Doing an arithmetic operation between two PSRNs is akin to doing an interval operation between those PSRNs, since a PSRN is ultimately a random number that lies in an interval.  However, as explained in &quot;<a href="https://peteroupc.github.io/exporand.html#Arithmetic_and_Comparisons_with_PSRNs"><strong>Arithmetic and Comparisons with PSRNs</strong></a>&quot;, the result of the operation is an interval that bounds a random number that is <em>not</em> always uniformly distributed in that interval.  For example, in the case of addition this distribution is triangular with a peak in the middle.  What are the exact distributions of this kind for other interval arithmetic operations, such as division, ln, exp, sin, or other mathematical functions?</li>
</ul>

<p><a id=More_Algorithms_for_Arbitrary_Precision_Sampling></a></p>

<h2>More Algorithms for Arbitrary-Precision Sampling</h2>

<p><a href="https://peteroupc.github.io/morealg.html"><strong>https://peteroupc.github.io/morealg.html</strong></a></p>

<p>This page has more algorithms for sampling using partially-sampled random numbers, as well as more Bernoulli factory algorithms.  The following are requests and open questions for this article.</p>

<ol>
<li>We would like to see new implementations of the following:

<ul>
<li>Algorithms that implement <strong>InShape</strong> for specific closed curves, specific closed surfaces, and specific signed distance functions.  Recall that <strong>InShape</strong> determines whether a box lies inside, outside, or partly inside or outside a given curve or surface.</li>
<li>Descriptions of new arbitrary-precision algorithms that use the skeleton given in the section &quot;Building an Arbitrary-Precision Sampler&quot;.</li>
</ul></li>
<li>The <a href="https://peteroupc.github.io/morealg.html#Appendix"><strong>appendix</strong></a> contains implementation notes for <strong>InShape</strong>, which determines whether a box is outside or partially or fully inside a shape.  However, practical implementations of <strong>InShape</strong> will generally only be able to evaluate a shape pointwise.  What are necessary and/or sufficient conditions that allow an implementation to correctly classify a box just by evaluating the shape pointwise?  See also my related Stack Exchange question: <a href="https://stackoverflow.com/questions/64728693/how-can-we-check-if-an-arbitrary-shape-covers-a-box-partially-fully-or-not-i"><strong>How can we check if an arbitrary shape covers a box (partially, fully, or not) if we can only evaluate the shape pointwise?</strong></a>.</li>
<li>Take a polynomial <em>f</em>(<em>&lambda;</em>) of even degree <em>n</em> of the form choose(<em>n</em>,<em>n</em>/2)*<em>&lambda;</em><sup><em>n</em>/2</sup>*(1&minus;<em>&lambda;</em>)<sup><em>n</em>/2</sup>*<em>k</em>, where <em>k</em> is greater than 1 (thus all <em>f</em>&#39;s Bernstein coefficients are 0 except for the middle one, which equals <em>k</em>).  Suppose <em>f</em>(1/2) lies in the interval (0, 1).  If we do the degree elevation, described in the <a href="https://peteroupc.github.io/morealg.html#Appendix"><strong>appendix</strong></a>, enough times (at least <em>r</em> times), then <em>f</em>&#39;s Bernstein coefficients will all lie in [0, 1].  The question is: how many degree elevations are enough?  A <a href="https://mathoverflow.net/questions/381419/on-the-degree-elevation-needed-to-bring-bernstein-coefficients-to-0-1"><strong>MathOverflow answer</strong></a> showed that <em>r</em> is at least <em>m</em> = (<em>n</em>/<em>f</em>(1/2)<sup>2</sup>)/(1&minus;<em>f</em>(1/2)<sup>2</sup>), but is it true that floor(<em>m</em>)+1 elevations are enough?</li>
<li><p>A <a href="https://peteroupc.github.io/morealg.html#Finite_State_and_Pushdown_Generators"><strong><em>finite-state generator</em></strong></a> is a finite-state machine that generates a real number&#39;s base-2 expansion such as 0.110101100..., driven by flips of a coin.  A <em>pushdown generator</em> is a finite-state generator with a stack of memory.  Both generators produce real numbers with a given probability distribution.  For example, a generator with a loop that outputs 0 or 1 at an equal chance produces a <em>uniform distribution</em>.  The following questions ask what kinds of distributions are possible with these generators.</p>

<ol>
<li>Of the probability distributions that a finite-state generator can generate, what is the exact class of:

<ul>
<li><em>Discrete distributions</em> (those that cover a finite or countably infinite set of values)?</li>
<li><em>Absolutely continuous distributions</em> (those with a probability density function such as the uniform or triangular distribution)?</li>
<li><em>Singular distributions</em> (covering an uncountable but zero-volume set)?</li>
<li>Distributions with <em>continuous</em> density functions?</li>
</ul></li>
<li>Same question as 1, but for pushdown generators.</li>
<li>Of the probability distributions that a pushdown generator can generate, what is the exact class of distributions with piecewise density functions whose pieces have infinitely many &quot;slope&quot; functions?  (The answer is known for finite-state generators.)</li>
</ol></li>
</ol>

<p><a id=Randomized_Estimation_Algorithms></a></p>

<h2>Randomized Estimation Algorithms</h2>

<p><a href="https://peteroupc.github.io/estimation.html"><strong>https://peteroupc.github.io/estimation.html</strong></a></p>

<p>Let <em>X</em> be a stream of random numbers and let <em>f</em>(<em>x</em>) be a known continuous function.</p>

<ol>
<li><p>Is there an algorithm, besides <em>Algorithm C</em> or <em>Algorithm F</em> in the article, that can find <strong>E</strong>[<em>X</em>] (or <em>f</em>(<strong>E</strong>[<em>X</em>])) with either a high probability of a &quot;small&quot; absolute error or one of a &quot;small&quot; relative error, when the distribution of <em>X</em> is unbounded, and additional assumptions on the distribution of <em>X</em> apply, such as&mdash;</p>

<ul>
<li>being unimodal (having one peak) and symmetric (mirrored on each side of the peak), and/or</li>
<li>following a geometric distribution, and/or</li>
<li>having decreasing or nonincreasing probabilities?</li>
</ul>

<p>Notice that merely having finite moments is not enough (Theorem 3.4, Kunsch et al.).  Here, the accuracy tolerances for small error and high probability are user-specified.</p></li>
<li><p>How can <em>Algorithm D</em> or <em>Algorithm E</em> in the article be adapted to discontinuous functions <em>g</em>, so that the algorithm finds <em>g</em>(<strong>E</strong>[<em>X</em>]) with either a high probability of a &quot;small&quot; absolute error or one of a &quot;small&quot; relative error at all points in [0, 1] except at a &quot;negligible&quot; area around <em>g</em>&#39;s discontinuities?  Is it enough to replace <em>g</em> with a continuous function <em>f</em> that equals <em>g</em> everywhere except at that &quot;negligible&quot; area?  Here, the accuracy tolerances for small error, high probability, and &quot;negligible&quot; area are user-specified.</p></li>
<li><p>Is it true that <em>Algorithm F</em> in the article remains valid when the sample size <em>n</em> is ceil(abs(<em>M</em>)/(<em>&delta;</em>*<em>&gamma;</em><sup><em>k</em></sup>)), given that the stream&#39;s distribution is known to have a maximum <em>k</em><sup>th</sup> central absolute moment of <em>M</em>?</p></li>
</ol>

<p><a id=Color_Topics_for_Programmers></a></p>

<h2>Color Topics for Programmers</h2>

<p><a href="https://peteroupc.github.io/colorgen.html"><strong>https://peteroupc.github.io/colorgen.html</strong></a></p>

<p>Should this document cover the following topics, and if so, how?</p>

<ul>
<li>The CAM02 color appearance model.</li>
<li>Color rendering metrics for light sources, including color rendering index (CRI) and the metrics given in TM-30-15 by the Illuminating Engineering Society.</li>
</ul>

<p>Does any of the following exist?</p>

<ul>
<li>A method for performing color calibration and color matching using a smartphone&#39;s camera and, possibly, a color calibration card and/or white balance card, provided that method is not covered by any active patents or pending patent applications.</li>
<li>Reference source code for a method to match a desired color on paper given spectral reflectance curves of the paper and of the inks being used in various concentrations, provided that method is not covered by any active patents or pending patent applications.</li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p>[^1]: Keane, M. S., and O&#39;Brien, G. L., &quot;A Bernoulli factory&quot;, ACM Transactions on Modeling and Computer Simulation 4(2), 1994.</p>

<p>[^2]: Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560  [math.PR], 2010.</p>

<p>[^3]: Łatuszyński, K., Kosmidis, I.,  Papaspiliopoulos, O., Roberts, G.O., &quot;<a href="https://arxiv.org/abs/0907.4018v2"><strong>Simulating events of unknown probabilities via reverse time martingales</strong></a>&quot;, arXiv:0907.4018v2 [stat.CO], 2009/2011.</p>

<p>[^4]: Mossel, Elchanan, and Yuval Peres. New coins from old: computing with unknown bias. Combinatorica, 25(6), pp.707-724.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
