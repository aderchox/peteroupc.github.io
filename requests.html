<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Requests and Open Questions</title><meta name="citation_title" content="Requests and Open Questions"><meta name="citation_pdf_url" content="https://peteroupc.github.io/requests.pdf"><meta name="citation_url" content="https://peteroupc.github.io/requests.html"><meta name="citation_date" content="2021/05/01"><meta name="citation_online_date" content="2021/05/01"><meta name="og:title" content="Requests and Open Questions"><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/requests.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Requests and Open Questions"><meta name="author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Requests and Open Questions</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>This page lists questions and issues relating to my articles posted on this site.  Any answers to these questions will greatly improve those articles.  If you can answer any of them, post an issue in the <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a>.</p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Randomization_and_Sampling_Methods"><strong>Randomization and Sampling Methods</strong></a></li>
<li><a href="#Bernoulli_Factory_Algorithms"><strong>Bernoulli Factory Algorithms</strong></a></li>
<li><a href="#Partially_Sampled_Random_Numbers_for_Accurate_Sampling_of_Continuous_Distributions"><strong>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</strong></a></li>
<li><a href="#More_Algorithms_for_Arbitrary_Precision_Sampling"><strong>More Algorithms for Arbitrary-Precision Sampling</strong></a></li>
<li><a href="#Randomized_Estimation_Algorithms"><strong>Randomized Estimation Algorithms</strong></a></li>
<li><a href="#Color_Topics_for_Programmers"><strong>Color Topics for Programmers</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Randomization_and_Sampling_Methods></a></p>

<h2>Randomization and Sampling Methods</h2>

<p><strong>Size Reduction Sought:</strong></p>

<p>Of the articles in this repository, <a href="https://peteroupc.github.io/randomfunc.html"><strong>Randomization and Sampling Methods</strong></a> and <a href="https://peteroupc.github.io/randomnotes.html"><strong>More Random Sampling Methods</strong></a> combined are very long (about 230 KB in size combined).</p>

<p>These articles describe numerous algorithms to generate random variates (from discrete and continuous distributions) as well as perform random sampling with and without replacement, shuffling, geometric sampling, and more, assuming a source of &quot;truly&quot; random numbers is available.</p>

<p>I would like to reduce the size of these articles while maintaining the most relevant algorithms for random variate generation.</p>

<p>Here are my goals for both articles:</p>

<ul>
<li>To shorten the <a href="https://peteroupc.github.io/randomfunc.html#Randomization_with_Real_Numbers"><strong>Randomization with Real Numbers</strong></a> section as much as possible, while still describing the most general (and exact) algorithms possible for sampling real numbers of any distribution.</li>
<li>To put emphasis on algorithms that work with random integers (or, if necessary, rational numbers), rather than random floating-point numbers.</li>
<li>To put emphasis on algorithms that sample a distribution <em>exactly</em>, or at least with a controlled upper bound on the error.  For discussion, see  &quot;<a href="https://peteroupc.github.io/randomnotes.html#Exact_Error_Bounded_and_Approximate_Algorithms"><strong>Exact, Error-Bounded, and Approximate Algorithms</strong></a>&quot;.</li>
<li>To ensure the documents are easy for programmers to understand and implement.</li>
</ul>

<p><strong>Other questions:</strong></p>

<ul>
<li>Is there any non-trivial use of random fixed-point numbers in any applications, other than uniformly distributed numbers?</li>
</ul>

<p><a id=Bernoulli_Factory_Algorithms></a></p>

<h2>Bernoulli Factory Algorithms</h2>

<p><a href="https://peteroupc.github.io/bernoulli.html"><strong>https://peteroupc.github.io/bernoulli.html</strong></a></p>

<p>This is a page showing algorithms to turn a coin with an unknown probability of heads into a coin with a different probability of heads, also known as <em>Bernoulli factories</em>.  A <em>factory function</em> is a function that relates the old probability to the new one.  Roughly speaking, a function can be a factory function only if it maps the interval [0, 1] to the interval [0, 1], is continuous, and doesn&#39;t touch 0 or 1 except possibly at the endpoints (Keane and O&#39;Brien 1994)<sup><a href="#Note1"><strong>(1)</strong></a></sup>.</p>

<p>Attention is drawn to the requests and open questions on that page:</p>

<ul>
<li><a href="https://peteroupc.github.io/bernoulli.html#Requests_and_Open_Questions"><strong>https://peteroupc.github.io/bernoulli.html#Requests_and_Open_Questions</strong></a></li>
</ul>

<p>Among other things, they relate to finding polynomial sequences, probabilities, and other mathematical constructions needed to apply certain Bernoulli factories.  These questions are reproduced below.</p>

<ol>
<li><p>Let a permutation class (such as numbers in descending order) and two continuous probability distributions <em>D</em> and <em>E</em> be given.  Consider the following algorithm: Generate a sequence of independent random numbers (where the first is distributed as <em>D</em> and the rest as <em>E</em>) until the sequence no longer follows the permutation class, then return <em>n</em>, which is how many numbers were generated this way, minus 1.  In this case:</p>

<ol>
<li>What is the probability that <em>n</em> is returned?</li>
<li>What is the probability that <em>n</em> is odd or even or belongs to a certain class of numbers?</li>
<li>What is the distribution function (CDF) of the first generated number given that <em>n</em> is odd, or that <em>n</em> is even?</li>
</ol>

<p>Obviously, these answers depend on the specific permutation class and/or distributions <em>D</em> and <em>E</em>.  Thus, answers that work only for particular classes and/or distributions are welcome.  See also my Stack Exchange question <a href="https://stats.stackexchange.com/questions/499864/probabilities-arising-from-permutations"><strong>Probabilities arising from permutations</strong></a>.</p></li>
<li><p>I request expressions of mathematical functions that can be expressed in any of the following ways:</p>

<ul>
<li>Series expansions for continuous functions that equal 0 or 1 at the points 0 and 1.</li>
<li>A series expansion with non-negative terms that can be &quot;tucked&quot; under a discrete probability mass function.</li>
<li>Series expansions for alternating power series whose coefficients are all in the interval [0, 1] and form a nonincreasing sequence.</li>
<li>Series expansions with non-negative coefficients and for which bounds on the truncation error are available.</li>
<li>Upper and lower bound approximations that converge to a given constant.  These upper and lower bounds must be nonincreasing or nondecreasing, respectively.</li>
<li>Sequences of approximating functions (such as rational functions) that converge from above and below to a given function.  These sequences must be nonincreasing or nondecreasing, respectively (but the approximating functions themselves need not be).</li>
<li><p>To apply the algorithms for <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory functions</strong></a>, what is needed are two sequences of polynomials written in Bernstein form that converge from above and below to a function as follows: (a) Each sequence&#39;s polynomials must have coefficients lying in [0, 1], and be of increasing degree; (b) the degree-<em>n</em> polynomials&#39; coefficients must lie at or &quot;inside&quot; those of the previous upper polynomial and the previous lower one (once the polynomials are elevated to degree <em>n</em>).  For a formal statement of these polynomials, see my <a href="https://math.stackexchange.com/questions/3904732/what-are-ways-to-compute-polynomials-that-converge-from-above-and-below-to-a-con"><strong>question on Mathematics Stack Exchange</strong></a>. The <a href="https://peteroupc.github.io/bernsupp.html"><strong>supplemental notes</strong></a> include formulas for computing these polynomials for the vast majority of functions likely to occur in practice, but not all of them.</p>

<ul>
<li>Are there Bernoulli Factory functions used in practice that are not covered by the schemes in the section &quot;Approximation Schemes&quot; in the notes, where suitable polynomials that converge to those functions are built?</li>
<li>Are there specific functions (especially those in practical use) for which there are practical and faster formulas for building polynomials that converge to those functions in a manner needed for the Bernoulli factory problem (besides those I list in that section or the main <a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a> article)?  See the formal statement in the Math Stack Exchange question linked below.</li>
</ul>

<p>An intriguing suggestion from Thomas and Blanchet (2012)<sup><a href="#Note2"><strong>(2)</strong></a></sup> is to use multiple pairs of polynomial sequences that converge to <em>f</em>, where each pair is optimized for particular ranges of <em>&lambda;</em>: first flip the input coin several times to get a rough estimate of <em>&lambda;</em>, then choose the pair that&#39;s optimized for the estimated <em>&lambda;</em>, and simulate <em>f</em>(<em>&lambda;</em>) using the chosen polynomials.  The paper gives the example of min(<em>&lambda;</em>, 8/10).  Are there formulas for computing these sequences efficiently, unlike the paper&#39;s approach that requires computing an intersection of a curve with an approximating polynomial, which gets very inefficient as the polynomial&#39;s degree gets large?</p></li>
<li>Simple <a href="https://peteroupc.github.io/bernoulli.html#Continued_Fractions"><strong>continued fractions</strong></a> that express useful constants.</li>
</ul>

<p>All these expressions should not rely on floating-point arithmetic or the direct use of irrational constants (such as <em>&pi;</em> or sqrt(2)), but may rely on rational arithmetic.  For example, a series expansion that <em>directly</em> contains the constant <em>&pi;</em> is not desired; however, a series expansion that converges to a fraction of <em>&pi;</em> is.</p></li>
<li>Is there a simpler or faster way to implement the base-2 or natural logarithm of binomial coefficients?  See the example in the section &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Converging_Series"><strong>Certain Converging Series</strong></a>&quot;.</li>
<li><p>Part of the reverse-time martingale algorithm of Łatuszyński et al. (2009/2011)<sup><a href="#Note3"><strong>(3)</strong></a></sup> (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>General Factory Functions</strong></a>&quot;) to simulate a factory function <em>f</em>(<em>&lambda;</em>) is as follows.  For each <em>n</em> starting with 1:</p>

<ol>
<li>Flip the input coin, and compute the <em>n</em><sup>th</sup> upper and lower bounds of <em>f</em> given the number of heads so far, call them <em>L</em> and <em>U</em>.</li>
<li>Compute the (<em>n</em>&minus;1)<sup>th</sup> upper and lower bounds of <em>f</em> given the number of heads so far, call them <em>L&prime;</em> and <em>U&prime;</em>.  (These bounds must be the same regardless of the outcomes of future coin flips, and the interval [<em>L&prime;</em>, <em>U&prime;</em>] must equal or entirely contain the interval [<em>L</em>, <em>U</em>].)</li>
</ol>

<p>These parts of the algorithm appear to work for any two sequences of functions (not just polynomials) that converge to <em>f</em>, where <em>L</em> or <em>L&prime;</em> and <em>U</em> or <em>U&prime;</em> are their lower and upper bound approximations.  The section on general factory functions shows how this algorithm can be implemented for polynomials.  Specifically:</p>

<ol>
<li>Given the number of heads <em>H</em><sub><em>n</em></sub>, <em>L</em> is the <em>H</em><sub>n</sub> Bernstein coefficient of the <em>n</em><sup>th</sup> lower approximating polynomial, and <em>U</em> is that of the corresponding upper polynomial.</li>
<li><em>L&prime;</em> is the <em>H</em><sub>n</sub><sup>th</sup> Bernstein coefficient of the (<em>n</em>&minus;1)<sup>th</sup> lower approximating polynomial, and <em>U&prime;</em> is that of the corresponding upper polynomial, after elevating both polynomials to degree <em>n</em>.</li>
</ol>

<p>But how do these steps work when the approximating functions (the functions that converge to <em>f</em>) are rational functions with integer coefficients? Rational functions with rational coefficients? Arbitrary approximating functions?</p></li>
<li>According to (Mossel and Peres 2005)<sup><a href="#Note4"><strong>(4)</strong></a></sup>, a pushdown automaton can take a coin with unknown probability of heads of <em>&lambda;</em> and turn it into a coin with probability of heads of <em>f</em>(<em>&lambda;</em>) only if <em>f</em> is a factory function and can be a solution of a polynomial system with rational coefficients. (See &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Algebraic_Functions"><strong>Certain Algebraic Functions</strong></a>&quot;.)  Are there any results showing whether the converse is true; namely, can a pushdown automaton simulate <em>any</em> <em>f</em> of this kind?  Note that this question is not quite the same as the question of which algebraic functions can be simulated by a context-free grammar (either in general or restricted to those of a certain ambiguity and/or alphabet size), and is not quite the same as the question of which <em>probability generating functions</em> can be simulated by context-free grammars or pushdown automata, although answers to those questions would be nice.  (See also Icard 2019<sup><a href="#Note5"><strong>(5)</strong></a></sup>.  Answering this question might involve ideas from analytic combinatorics; e.g., see the recent works of Cyril Banderier and colleagues.)</li>
</ol>

<p><a id=Partially_Sampled_Random_Numbers_for_Accurate_Sampling_of_Continuous_Distributions></a></p>

<h2>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</h2>

<p><a href="https://peteroupc.github.io/exporand.html"><strong>https://peteroupc.github.io/exporand.html</strong></a></p>

<p>A <em>partially-sampled random number</em> (PSRN) is a data structure holding the initial digits of a random number that is built up digit by digit.  The following is an open question on PSRNs.</p>

<p>Doing an arithmetic operation between two PSRNs is akin to doing an interval operation between those PSRNs, since a PSRN is ultimately a random number that lies in an interval.  However, as explained in &quot;<a href="https://peteroupc.github.io/exporand.html#Arithmetic_and_Comparisons_with_PSRNs"><strong>Arithmetic and Comparisons with PSRNs</strong></a>&quot;, the result of the operation is an interval that bounds a random number that is <em>not</em> always uniformly distributed in that interval.  For example, in the case of addition this distribution is triangular with a peak in the middle, and in the case of multiplication this distribution resembles a trapezoid.  What are the exact distributions of this kind for other interval arithmetic operations, such as division, ln, exp, sin, or other mathematical functions?</p>

<p><a id=More_Algorithms_for_Arbitrary_Precision_Sampling></a></p>

<h2>More Algorithms for Arbitrary-Precision Sampling</h2>

<p><a href="https://peteroupc.github.io/morealg.html"><strong>https://peteroupc.github.io/morealg.html</strong></a></p>

<p>This page has more algorithms for sampling using partially-sampled random numbers, as well as more Bernoulli factory algorithms.  The following are requests and open questions for this article.</p>

<ol>
<li>We would like to see new implementations of the following:

<ul>
<li>Algorithms that implement <strong>InShape</strong> for specific closed curves, specific closed surfaces, and specific signed distance functions.  Recall that <strong>InShape</strong> determines whether a box lies inside, outside, or partly inside or outside a given curve or surface.</li>
<li>Descriptions of new arbitrary-precision algorithms that use the skeleton given in the section &quot;Building an Arbitrary-Precision Sampler&quot;.</li>
</ul></li>
<li>The <a href="https://peteroupc.github.io/morealg.html#Appendix"><strong>appendix</strong></a> contains implementation notes for <strong>InShape</strong>, which determines whether a box is outside or partially or fully inside a shape.  However, practical implementations of <strong>InShape</strong> will generally only be able to evaluate a shape pointwise.  What are necessary and/or sufficient conditions that allow an implementation to correctly classify a box just by evaluating the shape pointwise?  See also my related Stack Exchange question: <a href="https://stackoverflow.com/questions/64728693/how-can-we-check-if-an-arbitrary-shape-covers-a-box-partially-fully-or-not-i"><strong>How can we check if an arbitrary shape covers a box (partially, fully, or not) if we can only evaluate the shape pointwise?</strong></a>.</li>
<li>Take a polynomial <em>f</em>(<em>&lambda;</em>) of even degree <em>n</em> of the form choose(<em>n</em>,<em>n</em>/2)*<em>&lambda;</em><sup><em>n</em>/2</sup>*(1&minus;<em>&lambda;</em>)<sup><em>n</em>/2</sup>*<em>k</em>, where <em>k</em> is greater than 1 (thus all <em>f</em>&#39;s Bernstein coefficients are 0 except for the middle one, which equals <em>k</em>).  Suppose <em>f</em>(1/2) lies in the interval (0, 1).  If we do the degree elevation, described in the <a href="https://peteroupc.github.io/morealg.html#Appendix"><strong>appendix</strong></a>, enough times (at least <em>r</em> times), then <em>f</em>&#39;s Bernstein coefficients will all lie in [0, 1].  The question is: how many degree elevations are enough?  A <a href="https://mathoverflow.net/questions/381419/on-the-degree-elevation-needed-to-bring-bernstein-coefficients-to-0-1"><strong>MathOverflow answer</strong></a> showed that <em>r</em> is at least <em>m</em> = (<em>n</em>/<em>f</em>(1/2)<sup>2</sup>)/(1&minus;<em>f</em>(1/2)<sup>2</sup>), but is it true that floor(<em>m</em>)+1 elevations are enough?</li>
</ol>

<p><a id=Randomized_Estimation_Algorithms></a></p>

<h2>Randomized Estimation Algorithms</h2>

<p><a href="https://peteroupc.github.io/estimation.html"><strong>https://peteroupc.github.io/estimation.html</strong></a></p>

<p>There is one request on randomized estimation:</p>

<p>Assume we have an <em>oracle</em>, or &quot;black box&quot;, that produces independent random numbers <em>X</em> with a known minimum and maximum, but an unknown mean (average).  Given this oracle and possibly a second source of randomness (such as unbiased random bits), are there results that give an algorithm that approximates <em>f</em>(<strong>E</strong>[<em>X</em>]) with a user-specified error bound, ideally using as few samples from the oracle as possible?  Here, <em>f</em> is a known function belonging to a given class of functions, and <strong>E</strong>[<em>X</em>] is the true mean of the oracle&#39;s numbers.</p>

<p>The algorithm should&mdash;</p>

<ul>
<li>ensure the expected (absolute) error and/or mean squared error is within a user-specified error tolerance (<em>&epsilon;</em>), or if that is not possible,</li>
<li>return an estimate that is within a user-specified tolerance (<em>&epsilon;</em>) on the absolute error or relative error with probability greater than 1 minus <em>&delta;</em>, where <em>&delta;</em> is user-specified.</li>
</ul>

<p>The classes of functions <em>f</em> that are of interest are:</p>

<ul>
<li>C1: Continuous functions that map [0, 1] to [0, 1] and are polynomially bounded (meaning that <em>f</em>(<em>x</em>) and 1&minus;<em>f</em>(<em>x</em>) are both bounded from below by min(<em>x</em><sup><em>n</em></sup>, (1&minus;<em>x</em>)<sup><em>n</em></sup>) for some integer <em>n</em>) (Keane and O&#39;Brien 1994)<sup><a href="#Note1"><strong>(1)</strong></a></sup>.</li>
<li>C2: Continuous functions that map [0, 1] to [0, 1] and are not necessarily polynomially bounded.</li>
<li>C3: Piecewise continuous functions that map [0, 1] to [0, 1].</li>
</ul>

<p>Note the following:</p>

<ul>
<li>The value the algorithm should approximate is <em>f</em>(<strong>E</strong>[<em>X</em>]), not <strong>E</strong>[<em>f</em>(<em>X</em>)], which is different in general.  But algorithms for <strong>E</strong>[<em>f</em>(<em>X</em>)] are welcome in case it&#39;s more difficult.</li>
<li>The Gamma Bernoulli Approximation scheme (Huber 2017)<sup><a href="#Note6"><strong>(6)</strong></a></sup> as well as the Kunsch algorithm (Kunsch et al. 2019)<sup><a href="#Note7"><strong>(7)</strong></a></sup> both estimate the mean of <em>X</em> (<strong>E</strong>[<em>X</em>]), rather than a function of that mean (<em>f</em>(<strong>E</strong>[<em>X</em>])), as this request asks.</li>
<li>Some algorithms produce unbiased estimates of <em>f</em>(<strong>E</strong>[<em>X</em>]), but not with a user-specified error, as this request asks (Jacob and Thiery 2015)<sup><a href="#Note8"><strong>(8)</strong></a></sup>.</li>
<li>Algorithms like the one being asked for here are especially useful because they can help build so-called &quot;<a href="https://peteroupc.github.io/bernsupp.html#Approximate_Bernoulli_Factories"><strong>approximate Bernoulli factories</strong></a>&quot;, or algorithms that approximately sample the probability <em>f</em>(<em>&lambda;</em>) given a coin with probability of heads of <em>&lambda;</em>.   In this case, <em>X</em> should follow the Bernoulli distribution.</li>
<li>It is suspected that the algorithm&#39;s performance will depend on the &quot;smoothness&quot; of <em>f</em>(<em>X</em>) (see also (Holtz et al. 2011)<sup><a href="#Note9"><strong>(9)</strong></a></sup>).</li>
</ul>

<p>Also, are there results that estimate <em>f</em>(<strong>E</strong>[<em>X</em>]) with a user-specified error bound even if <em>X</em> follows a certain kind of unbounded distribution (such as a geometric, exponential, or Poisson distribution, or another distribution with exponential tails)?</p>

<p><a id=Color_Topics_for_Programmers></a></p>

<h2>Color Topics for Programmers</h2>

<p><a href="https://peteroupc.github.io/colorgen.html"><strong>https://peteroupc.github.io/colorgen.html</strong></a></p>

<p>Should this document cover the following topics, and if so, how?</p>

<ul>
<li>The CAM02 color appearance model.</li>
<li>Color rendering metrics for light sources, including color rendering index (CRI) and the metrics given in TM-30-15 by the Illuminating Engineering Society.</li>
</ul>

<p>Does any of the following exist?</p>

<ul>
<li>A method for performing color calibration and color matching using a smartphone&#39;s camera and, possibly, a color calibration card and/or white balance card, provided that method is not covered by any active patents or pending patent applications.</li>
<li>Reference source code for a method to match a desired color on paper given spectral reflectance curves of the paper and of the inks being used in various concentrations, provided that method is not covered by any active patents or pending patent applications.</li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<ul>
<li><small><sup id=Note1>(1)</sup> Keane, M. S., and O&#39;Brien, G. L., &quot;A Bernoulli factory&quot;, ACM Transactions on Modeling and Computer Simulation 4(2), 1994.</small></li>
<li><small><sup id=Note2>(2)</sup> Thomas, A.C., Blanchet, J., &quot;<a href="https://arxiv.org/abs/1106.2508v3"><strong>A Practical Implementation of the Bernoulli Factory</strong></a>&quot;, arXiv:1106.2508v3  [stat.AP], 2012.</small></li>
<li><small><sup id=Note3>(3)</sup> Łatuszyński, K., Kosmidis, I.,  Papaspiliopoulos, O., Roberts, G.O., &quot;<a href="https://arxiv.org/abs/0907.4018v2"><strong>Simulating events of unknown probabilities via reverse time martingales</strong></a>&quot;, arXiv:0907.4018v2 [stat.CO], 2009/2011.</small></li>
<li><small><sup id=Note4>(4)</sup> Mossel, Elchanan, and Yuval Peres. New coins from old: computing with unknown bias. Combinatorica, 25(6), pp.707-724.</small></li>
<li><small><sup id=Note5>(5)</sup> Icard, Thomas F., &quot;Calibrating generative models: The probabilistic Chomsky–Schützenberger hierarchy.&quot; Journal of Mathematical Psychology 95 (2020): 102308.</small></li>
<li><small><sup id=Note6>(6)</sup> Huber, M., 2017. A Bernoulli mean estimate with known relative error distribution. Random Structures &amp; Algorithms, 50(2), pp.173-182. (preprint in arXiv:1309.5413v2  [math.ST], 2015).</small></li>
<li><small><sup id=Note7>(7)</sup> Kunsch, Robert J., Erich Novak, and Daniel Rudolf. &quot;Solvable integration problems and optimal sample size selection.&quot; Journal of Complexity 53 (2019): 40-67.  Also in <a href="https://arxiv.org/pdf/1805.08637.pdf"><strong>https://arxiv.org/pdf/1805.08637.pdf</strong></a> .</small></li>
<li><small><sup id=Note8>(8)</sup> Pierre E. Jacob.  Alexandre H. Thiery. &quot;On nonnegative unbiased estimators.&quot; Ann. Statist. 43 (2) 769 - 784, April 2015.</small></li>
<li><small><sup id=Note9>(9)</sup> Holtz, O., Nazarov, F., Peres, Y., &quot;New Coins from Old, Smoothly&quot;, Constructive Approximation 33 (2011).</small></li>
</ul>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
