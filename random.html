<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generator Recommendations for Applications</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generator Recommendations for Applications</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>Begun on Mar. 5, 2016; last updated on Nov. 3, 2018.</p>

<p>Most apps that use random numbers care about either unpredictability, speed/high quality, or repeatability.  This article explains the three kinds of RNGs and gives recommendations on each kind.</p>

<p><a id=Introduction_and_Summary></a></p>

<h2>Introduction and Summary</h2>

<p>Many applications rely on random number generators (RNGs); these RNGs include&mdash;</p>

<ul>
<li><em>statistical RNGs</em>, which seek to generate numbers that follow a uniform random distribution,</li>
<li><em>cryptographic RNGs</em>, which seek to generate numbers that are cost-prohibitive to predict, and</li>
<li><em>seeded PRNGs</em> (pseudorandom number generators), which generate numbers that &quot;seem&quot; random given an initial &quot;seed&quot;.</li>
</ul>

<p><strong>This document covers:</strong></p>

<ul>
<li>Statistical and cryptographic RNGs, as well as recommendations on their use and properties.</li>
<li>A discussion on when an application that needs numbers that &quot;seem&quot; random SHOULD specify their own &quot;seed&quot; (the initial state that the numbers are based on).</li>
<li>Nondeterministic RNGs, entropy, and seed generation.</li>
<li>An explanation of how to implement RNGs in programming code, including APIs that help in doing so.</li>
<li>Issues on shuffling with an RNG.</li>
</ul>

<p><strong>This document does not cover:</strong></p>

<ul>
<li>Testing an RNG implementation for correctness or adequate random number generation (e.g., DÃ¶rre and Klebanov 2016<sup><a href="#Note1"><strong>(1)</strong></a></sup>).</li>
<li>Generation of random numbers or keying material based at least in part on a password (e.g. <em>key derivation functions</em>).</li>
<li>Generation of random numbers that follow a nonuniform distribution; I discuss this topic in <a href="https://peteroupc.github.io/randomfunc.html"><strong>another document</strong></a>.</li>
<li>Low-discrepancy sequences (quasirandom sequences), such as Sobol sequences.  Their structure differs in an essential way from independent uniform random numbers.</li>
<li>Applications for which the selection of RNGs is constrained by regulatory requirements.</li>
</ul>

<p><strong>The following table summarizes the kinds of RNGs covered in this document:</strong></p>

<table><thead>
<tr>
<th>Kind of RNG</th>
<th>When to Use This RNG</th>
<th>Examples</th>
</tr>
</thead><tbody>
<tr>
<td><a href="#Cryptographic_RNGs"><strong>Cryptographic RNG</strong></a></td>
<td>In information security cases, or when speed is not a concern.</td>
<td><code>/dev/urandom</code>, <code>BCryptGenRandom</code></td>
</tr>
<tr>
<td><a href="#Statistical_RNGs"><strong>Statistical RNG</strong></a></td>
<td>When information security is not a concern, but speed is.</td>
<td><code>xoroshiro128+</code>, <code>xorshift128+</code></td>
</tr>
<tr>
<td><a href="#Seeded_PRNGs"><strong>Seeded PRNG</strong></a></td>
<td>When generating reproducible &quot;randomness&quot; in a way not practical otherwise.</td>
<td>High-quality PRNG with custom seed</td>
</tr>
</tbody></table>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/random.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/random.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document either on</strong> <a href="https://www.codeproject.com/Articles/1083372/Random-Number-Generator-Recommendations-for-Applic"><strong>CodeProject</strong></a> <strong>or on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction_and_Summary"><strong>Introduction and Summary</strong></a>

<ul>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
</ul></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Definitions"><strong>Definitions</strong></a></li>
<li><a href="#Cryptographic_RNGs"><strong>Cryptographic RNGs</strong></a>

<ul>
<li><a href="#Requirements"><strong>Requirements</strong></a></li>
<li><a href="#Examples"><strong>Examples</strong></a></li>
<li><a href="#Resource_Constrained_Devices"><strong>Resource-Constrained Devices</strong></a></li>
</ul></li>
<li><a href="#Statistical_RNGs"><strong>Statistical RNGs</strong></a>

<ul>
<li><a href="#Requirements_2"><strong>Requirements</strong></a></li>
<li><a href="#Examples_and_Non_Examples"><strong>Examples and Non-Examples</strong></a></li>
</ul></li>
<li><a href="#Seeded_PRNGs"><strong>Seeded PRNGs</strong></a>

<ul>
<li><a href="#When_to_Use_a_Seeded_PRNG"><strong>When to Use a Seeded PRNG</strong></a></li>
<li><a href="#Which_Seeded_PRNG_to_Use"><strong>Which Seeded PRNG to Use</strong></a></li>
<li><a href="#Seed_Generation_for_Seeded_PRNGs"><strong>Seed Generation for Seeded PRNGs</strong></a></li>
<li><a href="#Examples_2"><strong>Examples</strong></a>

<ul>
<li><a href="#Games"><strong>Games</strong></a></li>
<li><a href="#Unit_Tests"><strong>Unit Tests</strong></a></li>
<li><a href="#Noise"><strong>Noise</strong></a></li>
<li><a href="#Verifiable_Random_Numbers"><strong>Verifiable Random Numbers</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#Nondeterministic_Sources_and_Seed_Generation"><strong>Nondeterministic Sources and Seed Generation</strong></a>

<ul>
<li><a href="#Examples_of_Nondeterministic_Sources"><strong>Examples of Nondeterministic Sources</strong></a></li>
<li><a href="#Entropy"><strong>Entropy</strong></a></li>
<li><a href="#Seed_Generation"><strong>Seed Generation</strong></a></li>
</ul></li>
<li><a href="#Programming_Language_APIs"><strong>Programming Language APIs</strong></a>

<ul>
<li><a href="#Existing_RNG_APIs"><strong>Existing RNG APIs</strong></a></li>
<li><a href="#Implementing_New_RNG_APIs"><strong>Implementing New RNG APIs</strong></a></li>
</ul></li>
<li><a href="#RNG_Topics"><strong>RNG Topics</strong></a>

<ul>
<li><a href="#How_to_Initialize_RNGs"><strong>How to Initialize RNGs</strong></a></li>
<li><a href="#Shuffling"><strong>Shuffling</strong></a></li>
<li><a href="#GPU_Programming_Environments"><strong>GPU Programming Environments</strong></a></li>
</ul></li>
<li><a href="#Hash_Functions"><strong>Hash Functions</strong></a></li>
<li><a href="#Motivation"><strong>Motivation</strong></a></li>
<li><a href="#Conclusion"><strong>Conclusion</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Suggested_Entropy_Size"><strong>Suggested Entropy Size</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Definitions></a></p>

<h2>Definitions</h2>

<p>The following definitions are helpful in better understanding this document.</p>

<ul>
<li><strong>Random number generator (RNG).</strong> Software and/or hardware that seeks to generate independent numbers that seem to occur by chance and that are approximately uniformly distributed<sup><a href="#Note2"><strong>(2)</strong></a></sup>.</li>
<li><strong>Pseudorandom number generator (PRNG).</strong> A random number generator that outputs seemingly random numbers using a deterministic algorithm (that is, an algorithm that returns the same output for the same input and state every time), and in which its state can be initialized and possibly reinitialized with arbitrary data.</li>
<li><strong>Seed.</strong>  Arbitrary data for initializing the state of a PRNG.</li>
<li><strong>State length.</strong>  The maximum size of the seed a PRNG can take to initialize its state without shortening or compressing that seed.</li>
<li><strong>Period.</strong> The maximum number of values in a generated sequence for a PRNG before that sequence repeats.  The period will not be greater than 2<sup><em>L</em></sup> where <em>L</em> is the PRNG&#39;s <em>state length</em>.</li>
<li><strong>Stable.</strong> A programming interface is <em>stable</em> if it has no behavior that is unspecified, implementation-dependent, nondeterministic, or subject to future change.</li>
<li><strong>Information security.</strong> Defined in ISO/IEC 27000.</li>
<li><strong>Nondeterministic source.</strong> Data source that does not always return the same output for the same input.</li>
<li><strong>MUST, SHOULD, SHOULD NOT, MAY, RECOMMENDED, NOT RECOMMENDED.</strong>  As defined in RFC 2119 and RFC 8174.</li>
</ul>

<p><a id=Cryptographic_RNGs></a></p>

<h2>Cryptographic RNGs</h2>

<p>Cryptographic RNGs (also known as &quot;cryptographically strong&quot; or &quot;cryptographically secure&quot; RNGs) seek to generate random numbers that are cost-prohibitive to predict.  Cryptographic RNGs are RECOMMENDED for applications that use random numbers for information security, such as&mdash;</p>

<ul>
<li> generating keying material, such as encryption keys,</li>
<li> generating random passwords, nonces, or session identifiers,</li>
<li> generating &quot;salts&quot; to vary hash codes of the same password,</li>
<li> use in communications between two networked computers (including in data transfer, data transport, and messaging), and</li>
<li> cases (such as in multiplayer networked games) when predicting future random numbers would give a player or user a significant and unfair advantage,</li>
</ul>

<p>as well as for applications that generate random numbers so infrequently that the RNG&#39;s speed is not a concern.</p>

<p><a id=Requirements></a></p>

<h3>Requirements</h3>

<p>A cryptographic RNG generates uniformly distributed random bits such that it would be cost-prohibitive for an outside party to correctly guess, with more than a 50% chance per bit, prior or future unseen outputs of that RNG after knowing how the RNG works and/or extremely many outputs of the RNG, or prior unseen outputs of that RNG after knowing the RNG&#39;s internal state at the given point in time.</p>

<p>If a cryptographic RNG implementation uses a PRNG, the following requirements apply.</p>

<ol>
<li><p>The PRNG&#39;s <em>state length</em> MUST be at least 128 bits and SHOULD be at least 256 bits.  The <em>security strength</em> used by the RNG MUST be at least 112 bits, SHOULD be at least 128 bits, and is less than or equal to the PRNG&#39;s <em>state length</em>.</p></li>
<li><p>Before an instance of the RNG generates a random number, it MUST have been initialized (&quot;seeded&quot;) with a seed defined as follows. The seed&mdash;</p>

<ul>
<li>MUST have as many bits as the PRNG&#39;s <em>state length</em>,</li>
<li>MUST consist of data that ultimately derives from the output of one or more <a href="#Nondeterministic_Sources_and_Seed_Generation"><strong>nondeterministic sources</strong></a>, where the output is at least as hard to predict as ideal random data with as many bits as the <em>security strength</em>, and</li>
<li>MAY be mixed with arbitrary data other than the seed as long as the result is no easier to predict<sup><a href="#Note3"><strong>(3)</strong></a></sup>.</li>
</ul></li>
<li><p>The RNG SHOULD reseed itself from time to time, using a newly generated seed as described earlier. If the RNG reseeds, it SHOULD do so as often as feasible (whenever doing so would not slow down applications undesirably).  If the RNG reseeds if it would generate more than a threshold number of bits without reseeding, that threshold SHOULD be 2<sup>67</sup> or less.</p></li>
</ol>

<p><a id=Examples></a></p>

<h3>Examples</h3>

<p>Examples of cryptographic RNG implementations include the following:</p>

<ul>
<li>The <code>/dev/random</code> device on many Unix-based operating systems, which generally uses only nondeterministic sources; however, in some implementations of the device it can block for seconds at a time, especially if not enough randomness is available.</li>
<li>The <code>/dev/urandom</code> device on many Unix-based operating systems, which often relies on both a PRNG and the same nondeterministic sources used by <code>/dev/random</code>.</li>
<li>The <code>BCryptGenRandom</code> method in Windows 7 and later.</li>
<li>Two-source extractors, multi-source extractors, or cryptographic <a href="#Hash_Functions"><strong>hash functions</strong></a> that take very hard-to-predict signals from two or more nondeterministic sources as input.</li>
<li>A &quot;fast-key-erasure&quot; random number generator described by D.J. Bernstein in his blog (Bernstein 2017)<sup><a href="#Note4"><strong>(4)</strong></a></sup>.</li>
<li>An RNG implementation complying with NIST SP 800-90A.  The SP 800-90 series goes into further detail on how RNGs appropriate for information security can be constructed, and inspired much of the &quot;Cryptographic RNGs&quot; section.</li>
</ul>

<p><a id=Resource_Constrained_Devices></a></p>

<h3>Resource-Constrained Devices</h3>

<p>Compared to general-purpose computing devices such as desktops and smartphones, resource-constrained devices (&quot;embedded&quot; devices) are much less likely to have a cryptographic RNG available (Wetzels 2017)<sup><a href="#Note5"><strong>(5)</strong></a></sup>, although methods exist for implementing a cryptographic RNG on the Arduino (Peng 2017)<sup><a href="#Note6"><strong>(6)</strong></a></sup>.</p>

<p><a id=Statistical_RNGs></a></p>

<h2>Statistical RNGs</h2>

<p>Statistical RNGs are used, for example, in simulations, machine learning, numerical integration, and many games to bring an element of chance and variation to the application. However, statistical RNGs are generally suitable only if&mdash;</p>

<ul>
<li> information security is not involved, and</li>
<li> the application generates random numbers so frequently that it would slow down undesirably if a cryptographic RNG were used instead.</li>
</ul>

<p>A statistical RNG is usually implemented with a PRNG, but can also be implemented in a similar way as a cryptographic RNG provided it remains reasonably fast.</p>

<p><a id=Requirements_2></a></p>

<h3>Requirements</h3>

<p>A statistical RNG generates random bits, each of which is uniformly distributed independently of the other bits, at least for nearly all practical purposes.  If the implementation uses a PRNG, that PRNG algorithm MUST either satisfy the <em>collision resistance</em> property or be significantly more likely than not to pass all tests (other than MatrixRank and LinearComp) of <code>BigCrush</code>, part of L&#39;Ecuyer and Simard&#39;s &quot;TestU01&quot;. The RNG need not be perfectly equidistributed.</p>

<p>If a statistical RNG implementation uses a PRNG, the following requirements apply.</p>

<ol>
<li><p>The PRNG&#39;s <em>state length</em> MUST be at least 64 bits, SHOULD be at least 128 bits, and is encouraged to be as high as the implementation can go to remain reasonably fast for most applications.</p></li>
<li><p>Before an instance of the RNG generates a random number, it MUST have been initialized (&quot;seeded&quot;) with a seed described as follows. The seed&mdash;</p>

<ul>
<li>MUST have as many bits as the PRNG&#39;s <em>state length</em>,</li>
<li>MUST consist of data that ultimately derives from the output of one or more <a href="#Nondeterministic_Sources_and_Seed_Generation"><strong>nondeterministic sources</strong></a> and/or cryptographic RNGs, where the output is encouraged to cover a state space of at least as many bits as the PRNG&#39;s <em>state length</em>, and</li>
<li>MAY be mixed with arbitrary data other than the seed.</li>
</ul></li>
<li><p>The RNG MAY reseed itself from time to time, using a newly generated seed as described earlier.  If the RNG reseeds if it would generate more than a threshold number of values without reseeding, that threshold SHOULD be the PRNG&#39;s period&#39;s square root or less.</p></li>
</ol>

<p><a id=Examples_and_Non_Examples></a></p>

<h3>Examples and Non-Examples</h3>

<p>Examples of statistical RNGs include the following:</p>

<ul>
<li><a href="http://xoshiro.di.unimi.it/xoshiro256starstar.c"><strong>xoshiro256&#x2a;&#x2a;</strong></a> (state length 256 bits; nonzero seed).</li>
<li><a href="http://xoshiro.di.unimi.it/xoroshiro128starstar.c"><strong>xoroshiro128&#x2a;&#x2a;</strong></a> (state length 128 bits; nonzero seed).</li>
<li><code>Lehmer64</code> and <code>Lehmer128</code> (for each: state length 128 bits; odd seed, so effectively 127 bits state length).</li>
<li>XorShift* 128/64 (state length 128 bits; nonzero seed).</li>
<li>XorShift* 64/32 (state length 64 bits; nonzero seed).</li>
<li><code>JKISS</code>, <code>JKISS32</code>, <code>JLKISS</code>, <code>JLKISS64</code>, described in (Jones 2007/2010)<sup><a href="#Note7"><strong>(7)</strong></a></sup>.</li>
<li>C++&#39;s <a href="http://www.cplusplus.com/reference/random/ranlux48/"><strong><code>std::ranlux48</code> engine</strong></a> (state length 577 bits; nonzero seed).</li>
<li>PCG (<code>pcg32</code>, <code>pcg64</code>, and <code>pcg64_fast</code> classes), by Melissa O&#39;Neill. See also a <a href="http://pcg.di.unimi.it/pcg.php"><strong>critique by S. Vigna</strong></a>.</li>
<li>Other examples include B. Jenkins&#39;s &quot;A small noncryptographic PRNG&quot; (sometimes called <code>jsf</code>), C. Doty-Humphrey&#39;s <code>sfc</code>, <code>msws</code> (Widynski 2017)<sup><a href="#Note8"><strong>(8)</strong></a></sup>, and D. Blackman&#39;s <code>gjrand</code>.</li>
</ul>

<p>The following also count as statistical RNGs, but are not preferred:</p>

<ul>
<li>Mersenne Twister shows a <a href="http://xoroshiro.di.unimi.it/#quality"><strong>systematic failure</strong></a> in <code>BigCrush</code>&#39;s LinearComp test. (See also (Vigna 2016)<sup><a href="#Note9"><strong>(9)</strong></a></sup>.)</li>
<li><a href="http://xoshiro.di.unimi.it/xoroshiro128plus.c"><strong><code>xoroshiro128+</code></strong></a>, <code>xoshiro256+</code>, and <code>xorshift128+</code>.  As described by (Blackman and Vigna 2018)<sup><a href="#Note10"><strong>(10)</strong></a></sup>, these linear PRNGs use weak scramblers, so that each output&#39;s lowest bits have low linear complexity even though the output as a whole has excellent statistical randomness.  See also <a href="http://xoshiro.di.unimi.it/lowcomp.php"><strong>&quot;Testing lowest bits in isolation&quot;</strong></a>.</li>
</ul>

<p>Non-examples include the following:</p>

<ul>
<li>Any <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator"><strong>linear congruential generator</strong></a> with modulus 2<sup>63</sup> or less (such as <code>java.util.Random</code> and C++&#39;s <code>std::minstd_rand</code> and <code>std::minstd_rand0</code> engines) has a <em>state length</em> of less than 64 bits.</li>
<li><code>System.Random</code>, as implemented in the .NET Framework 4.7, can take a seed of at most 32 bits, so has a state length of at most 32 bits.</li>
</ul>

<p><a id=Seeded_PRNGs></a></p>

<h2>Seeded PRNGs</h2>

<p>In addition, some applications use pseudorandom number generators (PRNGs) to generate apparently &quot;random&quot; numbers starting from a known initial state, or &quot;seed&quot;. Such applications usually care about repeatable &quot;randomness&quot;. (Note that in the definitions for <a href="#Cryptographic_RNGs"><strong>cryptographic</strong></a> and <a href="#Statistical_RNGs"><strong>statistical</strong></a> RNGs given earlier, the PRNGs involved are automatically seeded before use.)</p>

<p><a id=When_to_Use_a_Seeded_PRNG></a></p>

<h3>When to Use a Seeded PRNG</h3>

<p>An application SHOULD NOT use a PRNG with a seed it specifies (rather than an automatically-initialized PRNG or another kind of RNG) unless&mdash;</p>

<ol>
<li>the application might need to generate the same &quot;random&quot; result multiple times,</li>
<li>the application either&mdash;

<ul>
<li>makes the seed (or a &quot;code&quot; or &quot;password&quot; based on the seed) accessible to the user, or</li>
<li>finds it impractical to store or distribute the &quot;random&quot; numbers or results (rather than the seed) for later use, such as&mdash;

<ul>
<li>by saving the result to a file,</li>
<li>by storing the &quot;random&quot; numbers for the feature generating the result to &quot;replay&quot; later, or</li>
<li>by distributing the &quot;random&quot; numbers or results to networked users as they are generated, and</li>
</ul></li>
</ul></li>
<li>any feature that uses such a PRNG to generate that &quot;random&quot; result will remain backward compatible with respect to the &quot;random&quot; results it generates, for as long as that feature is still in use by the application.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> Meeting statement 3 is aided by using <em>stable</em> PRNGs; see <a href="#Definitions"><strong>&quot;Definitions&quot;</strong></a> and the following examples:</p>

<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html"><strong><code>java.util.Random</code></strong></a> is stable.</li>
<li>The C <a href="http://en.cppreference.com/w/cpp/numeric/random/rand"><strong><code>rand</code> method</strong></a> is not stable (because the algorithm it uses is unspecified).</li>
<li>C++&#39;s random number distribution classes, such as <a href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"><strong><code>std::uniform_int_distribution</code></strong></a>, are not stable (because the algorithms they use are implementation-defined according to the specification).</li>
<li>.NET&#39;s <a href="https://docs.microsoft.com/dotnet/api/system.random"><strong><code>System.Random</code></strong></a> is not stable (because its generation behavior could change in the future).</li>
</ul>
</blockquote>

<p>Using seeded RNGs ties the application to a particular RNG or RNG implementation, which is why they are NOT RECOMMENDED except in the limited circumstances given above.</p>

<p><a id=Which_Seeded_PRNG_to_Use></a></p>

<h3>Which Seeded PRNG to Use</h3>

<p>If an application decides to use a seeded PRNG for repeatable &quot;randomness&quot;, that PRNG SHOULD meet or exceed the requirements of a <a href="#Statistical_RNGs"><strong>statistical RNG</strong></a> (except the seed is application-defined instead) and SHOULD be reasonably fast.</p>

<p><a id=Seed_Generation_for_Seeded_PRNGs></a></p>

<h3>Seed Generation for Seeded PRNGs</h3>

<p>As much as possible, an application SHOULD generate seeds for a seeded PRNG&mdash;</p>

<ul>
<li>using a cryptographic or statistical RNG (as defined earlier),</li>
<li>as described in <a href="#Nondeterministic_Sources_and_Seed_Generation"><strong>Nondeterministic Sources and Seed Generation</strong></a>, or</li>
<li>otherwise using hard-to-predict data.</li>
</ul>

<p><a id=Examples_2></a></p>

<h3>Examples</h3>

<p>Custom seeds can come into play in the following situations, among others.</p>

<p><a id=Games></a></p>

<h4>Games</h4>

<p>Many kinds of games generate game content based on apparent randomness, such as&mdash;</p>

<ul>
<li>procedurally generated maps for a role-playing game,</li>
<li><a href="#Shuffling"><strong>shuffling</strong></a> a digital deck of cards for a solitaire game, or</li>
<li>a game board or puzzle board that normally varies every session,</li>
</ul>

<p>where the game might need to generate the same content of that kind multiple times.</p>

<p>In general, such a game SHOULD NOT use a PRNG with a custom seed for such purposes unless&mdash;</p>

<ol>
<li>generating the random content uses relatively many random numbers (say, more than a few thousand), and the application finds it impractical to store or distribute the content or the numbers for later use, or</li>
<li>the game makes the seed (or a &quot;code&quot; or &quot;password&quot; based on the seed, such as a barcode or a string of letters and digits) accessible to the player, to allow the player to regenerate the content.</li>
</ol>

<p>Option 1 often applies to games that generate procedural terrain for game levels, since the terrain often exhibits random variations over an extended space.  Option 1 is less suitable for puzzle game boards or card shuffling, since much less data needs to be stored.</p>

<blockquote>
<p><strong>Example:</strong> Suppose a game generates a map with random terrain and shows the player a &quot;code&quot; to generate that map. In this case, the game&mdash;</p>

<ul>
<li>MAY change the algorithm it uses to generate random maps, but</li>
<li>SHOULD use, in connection with the new algorithm, &quot;codes&quot; that can&#39;t be confused with &quot;codes&quot; it used for previous algorithms, and</li>
<li>SHOULD continue to generate the same random map using an old &quot;code&quot; when the player enters it, even after the change to a new algorithm.</li>
</ul>
</blockquote>

<p><a id=Unit_Tests></a></p>

<h4>Unit Tests</h4>

<p>A custom seed is appropriate when unit testing a method that uses a seeded PRNG in place of another kind of RNG for the purpose of the test (provided the test ensures backward compatibility).</p>

<p><a id=Noise></a></p>

<h4>Noise</h4>

<p><em>Noise</em> is a randomized variation in images, sound, and other data.  (See also Red Blob Games, <a href="http://www.redblobgames.com/articles/noise/introduction.html"><strong>&quot;Noise Functions and Map Generation&quot;</strong></a>).  For the purposes of RNG recommendations, there are two kinds of noise:</p>

<ol>
<li><p><strong><em>Procedural noise</em></strong> is generated using a <em>noise function</em>, which is a function that outputs seemingly random numbers given an <em>n</em>-dimensional point and, optionally, additional data (such as gradients or hash values).<sup><a href="#Note11"><strong>(11)</strong></a></sup>  Procedural noise includes <a href="https://en.wikipedia.org/wiki/Cellular_noise"><strong>cellular noise</strong></a>, <a href="https://en.wikipedia.org/wiki/Value_noise"><strong>value noise</strong></a>, and <a href="https://en.wikipedia.org/wiki/Gradient_noise"><strong>gradient noise</strong></a> (such as <a href="https://en.wikipedia.org/wiki/Perlin_noise"><strong>Perlin noise</strong></a>).  As much as possible, procedural noise implementations SHOULD <strong>use an RNG to generate the additional data</strong> for the noise function in advance.  If using a <a href="#When_to_Use_a_Seeded_PRNG"><strong>custom-seeded PRNG</strong></a> is appropriate for the application, the additional data MAY be <strong>&quot;hard-coded&quot;</strong> instead.  If the noise function <strong>incorporates a</strong> <a href="#Hash_Functions"><strong><em>hash function</em></strong></a>, that hash function SHOULD be reasonably fast, be <em>stable</em> (see <a href="#Definitions"><strong>&quot;Definitions&quot;</strong></a>), and have the so-called <em>avalanche property</em>.</p></li>
<li><p><strong><em>Nonprocedural noise</em></strong> is generated using the help of an RNG.  Nonprocedural noise includes <a href="https://en.wikipedia.org/wiki/Colors_of_noise"><strong>colored noise</strong></a> (including white noise and pink noise), periodic noise, and noise following a Gaussian or other <a href="https://peteroupc.github.io/randomfunc.html#Specific_Non_Uniform_Distributions"><strong>probability distribution</strong></a>.  For nonprocedural noise, the same considerations apply to any RNGs the noise implementation uses as in cases not involving noise.</p></li>
</ol>

<p><a id=Verifiable_Random_Numbers></a></p>

<h4>Verifiable Random Numbers</h4>

<p><em>Verifiable random numbers</em> are random numbers (such as seeds for PRNGs) that are disclosed along with all the information necessary to verify their generation.  Usually, such information includes random numbers and/or uncertain data to be determined and publicly disclosed in the future.  Generating verifiable randomness has been described in <a href="https://www.rfc-editor.org/rfc/rfc3797.txt"><strong>RFC 3797</strong></a>, in (Lenstra et al., 2015)<sup><a href="#Note12"><strong>(12)</strong></a></sup>, in (Boneh et al., 2018)<sup><a href="#Note13"><strong>(13)</strong></a></sup> (which introduces the concept of <em>verifiable delay functions</em>, functions whose output deliberately takes time to compute but is easy to verify), and elsewhere.</p>

<p><a id=Nondeterministic_Sources_and_Seed_Generation></a></p>

<h2>Nondeterministic Sources and Seed Generation</h2>

<p>RNGs ultimately rely on nondeterministic sources to generate random numbers.  Such sources are used to help generate a <em>seed</em> for a PRNG, for example.  The best nondeterministic sources for this purpose are those whose output is very hard to predict.</p>

<p><a id=Examples_of_Nondeterministic_Sources></a></p>

<h3>Examples of Nondeterministic Sources</h3>

<p>Examples of nondeterministic sources are&mdash;</p>

<ul>
<li>disk access timings,</li>
<li>timings of keystrokes and/or other input device interactions,</li>
<li>thermal noise,</li>
<li>the output of assembly instructions specially dedicated to random number generation, such as RdSeed,</li>
<li>the output generated with A. Seznec&#39;s technique called hardware volatile entropy gathering and expansion (HAVEGE), provided a high-resolution counter is available, and</li>
<li>differences between two high-resolution counter values taken in quick succession (such as in &quot;Jitter RNG&quot;; see (M&uuml;ller)<sup><a href="#Note14"><strong>(14)</strong></a></sup>).</li>
</ul>

<p>RFC 4086, &quot;Randomness Requirements for Security&quot;, section 3, contains a survey of nondeterministic sources.</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>Online services that make random numbers available to applications, as well as outputs of audio and video devices (see RFC 4086 sec. 3.2.1), are additional nondeterministic sources.  However, online services require Internet or other network access, and some of them require access credentials.  Also, many mobile operating systems require applications to declare network, camera, and microphone access to users upon installation.  For these reasons, these kinds of sources are NOT RECOMMENDED if other approaches are adequate.</li>
<li>For noncryptographic RNGs, timestamps from the system clock are commonly used.  Timestamps with millisecond or coarser granularity are not encouraged, however, because multiple instances of a PRNG automatically seeded with a timestamp, when they are created at about the same time, run the risk of starting with the same seed and therefore generating the same sequence of random numbers.</li>
<li>For general-purpose use, nondeterministic sources that enable many high-quality seeds per second to be generated are highly advantageous, especially for a cryptographic RNG.</li>
</ol>
</blockquote>

<p><a id=Entropy></a></p>

<h3>Entropy</h3>

<p><em>Entropy</em> is a value that describes how hard it is to predict a nondeterministic source&#39;s output, compared to ideal random data; this is generally the size in bits of the ideal random data.  (For example, a 64-bit output with 32 bits of entropy is as hard to predict as an ideal random 32-bit data block.)  NIST SP 800-90B recommends <em>min-entropy</em> as the entropy measure.  Characterizing a nondeterministic source&#39;s entropy is nontrivial and beyond the scope of this document.  See also RFC 4086 section 2.</p>

<p><a id=Seed_Generation></a></p>

<h3>Seed Generation</h3>

<p>In general, especially for cryptographic RNGs, <strong>to generate an N-bit seed, enough data needs to be gathered from nondeterministic sources to reach N bits of entropy or more</strong>.</p>

<p>Once data with enough entropy is gathered, it might need to be condensed into a seed to initialize a PRNG with. Following (Cliff et al., 2009)<sup><a href="#Note15"><strong>(15)</strong></a></sup>, it is suggested to generate an N-bit seed by using an HMAC or &quot;cascade&quot; hash function (such as SHA-256 or SHA-512), with outputs at least N times 3 bits long, on data with at least N times 3 bits of entropy, then truncating the output to N bits.  See also NIST SP 800-90B sec. 3.1.5.1 and RFC 4086 sec. 4.2 and 5.2.</p>

<p><a id=Programming_Language_APIs></a></p>

<h2>Programming Language APIs</h2>

<p>&nbsp;</p>

<p><a id=Existing_RNG_APIs></a></p>

<h3>Existing RNG APIs</h3>

<p>As much as possible, <strong>applications SHOULD use existing libraries and techniques</strong> that already meet the requirements for cryptographic and statistical RNGs.</p>

<p>The following table lists application programming interfaces (APIs) for
cryptographic and statistical RNGs for popular programming languages.</p>

<ul>
<li>Methods and libraries mentioned in the &quot;Statistical&quot; column need to be initialized with a seed before use (for example, a seed generated using an implementation in the &quot;Cryptographic&quot; column).</li>
<li>The mention of a third-party library in this section does not imply sponsorship or endorsement of that library, or imply a preference of that library over others. The list is not comprehensive.</li>
<li>See also <a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"><strong>Paragon&#39;s blog post</strong></a> on existing cryptographic RNGs.</li>
</ul>

<table><thead>
<tr>
<th>Language</th>
<th>Cryptographic</th>
<th>Statistical</th>
</tr>
</thead><tbody>
<tr>
<td>.NET (incl. C# and VB.NET) (H)</td>
<td><code>RNGCryptoServiceProvider</code> in <code>System.Security.Cryptography</code> namespace</td>
<td><a href="https://github.com/airbreather/Airbreather.Common"><strong>airbreather/AirBreather.Common library</strong></a> (XorShift1024Star, XorShift128Plus, XoroShiro128Plus)</td>
</tr>
<tr>
<td>C/C++ (G)</td>
<td>(C)</td>
<td><a href="http://xoroshiro.di.unimi.it/xoroshiro128plus.c"><strong><code>xoroshiro128plus.c</code></strong></a> (128-bit nonzero seed); <a href="http://xoroshiro.di.unimi.it/xorshift128plus.c"><strong><code>xorshift128plus.c</code></strong></a> (128-bit nonzero seed); <a href="https://github.com/frostburn/jkiss"><strong>frostburn/jkiss</strong></a> library</td>
</tr>
<tr>
<td>Python (A)</td>
<td><code>secrets.SystemRandom</code> (since Python 3.6); <code>os.urandom()</code></td>
<td><code>pypcg</code> package; <a href="https://github.com/ihaque/xorshift"><strong>ihaque/xorshift</strong></a> library (128-bit nonzero seed; default seed uses <code>os.urandom()</code>)</td>
</tr>
<tr>
<td>Java (A) (D)</td>
<td>(C); <code>java.security.SecureRandom</code> (F)</td>
<td><a href="https://github.com/grunka/xorshift"><strong>grunka/xorshift</strong></a> (<code>XORShift1024Star</code> or <code>XORShift128Plus</code>); <a href="https://github.com/jenetics/prngine"><strong>jenetics/prngine</strong></a> (<code>KISS32Random</code>, <code>KISS64Random</code>)</td>
</tr>
<tr>
<td>JavaScript (B)</td>
<td><code>crypto.randomBytes(byteCount)</code> (node.js only); <code>random-number-csprng</code> package (node.js only); <code>crypto.getRandomValues()</code> (Web)</td>
<td><code>pcg-random</code> or <code>xoroshiro128starstar</code> package</td>
</tr>
<tr>
<td>Ruby (A) (E)</td>
<td>(C); <code>SecureRandom.rand()</code> (ranges from 0 to 1 exclusive) (E); <code>SecureRandom.rand(N)</code> (integer) (E) (for both, <code>require &#39;securerandom&#39;</code>); <code>sysrandom</code> gem</td>
<td></td>
</tr>
<tr>
<td>PHP (A)</td>
<td><code>random_int()</code>, <code>random_bytes()</code> (both since PHP 7)</td>
<td></td>
</tr>
<tr>
<td>Go</td>
<td><code>crypto/rand</code> package</td>
<td></td>
</tr>
</tbody></table>

<p><small>(A) The general RNGs of Python and Ruby implement <a href="https://en.wikipedia.org/wiki/Mersenne_Twister"><strong>Mersenne Twister</strong></a>, which is not preferred for a statistical RNG.  PHP&#39;s <code>mt_rand()</code> implements or implemented a flawed version of Mersenne Twister. <code>prngine</code>, a Java library, also has <code>MT19937_32Random</code>, <code>MT19937_64Random</code> classes that implement Mersenne Twister.</small></p>

<p><small>(B) JavaScript&#39;s <code>Math.random()</code> (which ranges from 0 to 1 exclusive) is implemented using <code>xorshift128+</code> (or a variant) in the V8 engine, Firefox, and certain other modern browsers as of late 2017; <code>Math.random()</code> uses an &quot;implementation-dependent algorithm or strategy&quot;, though (see ECMAScript sec. 20.2.2.27).</small></p>

<p><small>(C) A cryptographic RNG implementation can&mdash;</p>

<ul>
<li>read from the <code>/dev/urandom</code> device in most Unix-based systems (using the <code>open</code> and <code>read</code> system calls where available),</li>
<li>call the <code>getentropy</code> method on OpenBSD, or</li>
<li>call the <code>BCryptGenRandom</code> API in Windows 7 and later,</small></li>
</ul>

<p><small>and only use other techniques if the existing ones are inadequate for the application.</small></p>

<p><small>(D) Java&#39;s <code>java.util.Random</code> class uses a 48-bit seed, so doesn&#39;t meet the statistical RNG requirements.  However, a subclass of <code>java.util.Random</code> might be implemented to meet those requirements.</small></p>

<p><small>(E) Ruby&#39;s <code>Random#rand</code> and <code>SecureRandom.rand</code> methods present a beautiful and simple API for random number generation, in my opinion.  Namely, <code>rand()</code> returns a number from 0 to 1 exclusive, and <code>rand(N)</code> returns an integer from 0 to N exclusive.</small></p>

<p><small>(F) Calling the <code>setSeed</code> method of <code>SecureRandom</code> before use is RECOMMENDED. The data passed to the method SHOULD be data described in note (C). (Despite the name, <code>setSeed</code> <em>supplements</em> the existing seed, according to the documentation.)  See also (Klyubin 2013)<sup><a href="#Note16"><strong>(16)</strong></a></sup>.</small></p>

<p><small>(G) <a href="http://en.cppreference.com/w/cpp/numeric/random/random_device"><strong><code>std::random_device</code></strong></a>, introduced in C++11, is NOT RECOMMENDED because its specification leaves considerably much to be desired.  For example,  <code>std::random_device</code> can fall back to a pseudorandom number generator of unspecified quality without much warning.  At best, <code>std::random_device</code> SHOULD only be used to supplement other techniques for random number generation.</small></p>

<p><small>(H) The .NET Framework&#39;s <code>System.Random</code> class uses a seed of at most 32 bits, so doesn&#39;t meet the statistical RNG requirements.  However, a subclass of <code>System.Random</code> might be implemented to meet those requirements.</small></p>

<p><a id=Implementing_New_RNG_APIs></a></p>

<h3>Implementing New RNG APIs</h3>

<p>As mentioned before, applications SHOULD <a href="#Existing_RNG_APIs"><strong>use existing implementations</strong></a> of cryptographic and statistical RNGs whenever possible.  In the limited cases where existing implementations are inadequate, a <strong>programming language API</strong> could implement such RNGs using the following guidelines:</p>

<ol>
<li> The RNG API can include a method that fills one or more memory units (such as 8-bit bytes) completely with random bits (see example 1).</li>
<li> If the API implements an automatically-initialized RNG, it SHOULD NOT allow applications to initialize that same RNG with a seed for repeatable &quot;randomness&quot;<sup><a href="#Note17"><strong>(17)</strong></a></sup> (it MAY provide a separate PRNG to accept such a seed). See example 2.</li>
<li> If the API provides a PRNG that an application can seed for repeatable &quot;randomness&quot;, that PRNG SHOULD be <em>stable</em> and documented, and so SHOULD any methods the API provides that use that PRNG (such as shuffling and Gaussian number generation). See example 2.</li>
<li> My document on <a href="https://peteroupc.github.io/randomfunc.html"><strong>random number generation methods</strong></a> includes details on ten uniform random number methods. In my opinion, a new programming language&#39;s <strong>standard library</strong> ought to include those ten methods separately for cryptographic and for statistical RNGs.</li>
</ol>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>A C language RNG method for filling memory could look like the following: <code>int random(uint8_t[] bytes, size_t size);</code>, where <code>bytes</code> is a pointer to an array of 8-bit bytes, and <code>size</code> is the number of random 8-bit bytes to generate, and where 0 is returned if the method succeeds and nonzero otherwise.</li>
<li>A Java API that follows these guidelines can contain two classes: a <code>RandomGen</code> class that implements an unspecified but general-purpose RNG, and a <code>RandomStable</code> class that implements a PCG PRNG that is documented and will not change in the future. <code>RandomStable</code> includes a constructor that takes a seed for repeatable &quot;randomness&quot;, while <code>RandomGen</code> does not.  Both classes include methods to generate uniform random numbers, but <code>RandomStable</code> specifies the exact algorithms to those methods and <code>RandomGen</code> does not.  At any time in the future, <code>RandomGen</code> can change its implementation to use a different RNG while remaining backward compatible, while <code>RandomStable</code> has to use the same algorithms for all time to remain backward compatible, especially because it takes a seed for repeatable &quot;randomness&quot;.</li>
</ol>
</blockquote>

<p><a id=RNG_Topics></a></p>

<h2>RNG Topics</h2>

<p>&nbsp;</p>

<p><a id=How_to_Initialize_RNGs></a></p>

<h3>How to Initialize RNGs</h3>

<p>For cryptographic RNGs, an application SHOULD use only one thread-safe instance of the RNG for the entire application to use.</p>

<p>For statistical and seeded RNGs, to <strong>reduce the chance of correlated random numbers or identical random number sequences</strong>, an application is encouraged to create&mdash;</p>

<ul>
<li>one thread-safe instance of an RNG for the entire application to use, or</li>
<li>one instance of an RNG for each thread of the application, where each instance&mdash;

<ul>
<li>is accessible to only one thread (such as with thread-local storage),</li>
<li>is initialized with a seed that is unrelated to the other seeds (using sequential or linearly related seeds can cause <a href="https://blogs.unity3d.com/2015/01/07/a-primer-on-repeatable-random-numbers/"><strong>undesirable correlations</strong></a> in some PRNGs), and</li>
<li>MAY use a different conforming RNG scheme from the others.</li>
</ul></li>
</ul>

<p>(Many questions on <em>Stack Overflow</em> highlight the pitfalls of creating a new RNG instance each time a random number is needed, rather than only once in the application.  This is notably the case with the .NET generator <code>System.Random</code>.)</p>

<p><a id=Shuffling></a></p>

<h3>Shuffling</h3>

<p>In a list with <code>N</code> different items, there are <code>N</code> factorial (that is, <code>1 * 2 * ... * N</code>, or <code>N!</code>) ways to arrange the items in that list.  These ways are called <em>permutations</em><sup><a href="#Note18"><strong>(18)</strong></a></sup>.</p>

<p>An application can <strong>shuffle a list</strong>&mdash;</p>

<ul>
<li>by generating a random integer at least 0 and less than the number of permutations, and converting that integer to a permutation, or</li>
<li>by doing a <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle"><strong>Fisher&ndash;Yates shuffle</strong></a> (which is unfortunately easy to mess up &mdash; see (Atwood)<sup><a href="#Note19"><strong>(19)</strong></a></sup> &mdash; and is implemented correctly in <a href="https://peteroupc.github.io/randomfunc.html"><strong>another document of mine</strong></a>).</li>
</ul>

<p>Either way, however, if a PRNG&#39;s period is less than the number of permutations, then there are <strong>some permutations that that PRNG can&#39;t choose</strong> when it shuffles that list. (This is not the same as <em>generating</em> all permutations of a list, which, for a list big enough, can&#39;t be done by any computer in a reasonable time.)</p>

<p>If an application uses PRNGs for shuffling purposes, it is encouraged to&mdash;</p>

<ol>
<li>choose a PRNG with a state length <code>B</code> or greater, then</li>
<li>gather data with at least <strong><code>B</code> bits of</strong> <a href="#Nondeterministic_Sources_and_Seed_Generation"><strong><em>entropy</em></strong></a> (randomness), then</li>
<li><a href="#Seed_Generation"><strong>generate a full-length seed</strong></a> with the data gathered this way, then</li>
<li>pass the seed to the chosen PRNG, then</li>
<li>use the PRNG to do a Fisher&ndash;Yates shuffle.</li>
</ol>

<p>Here, <code>B</code> can usually be calculated for different lists using the Python code in the <a href="#Suggested_Entropy_Size"><strong>appendix</strong></a>; see also (van Staveren 2000, &quot;Lack of randomness&quot;)<sup><a href="#Note20"><strong>(20)</strong></a></sup>.  For example, <code>B</code> is 226 bits for a 52-item list.  (However, if information security is not involved, an application can instead choose any number 256 or more for <code>B</code> and follow the steps above accordingly &mdash; for a list big enough, it&#39;s generally more important to have shuffles act random than to choose from among all permutations.)</p>

<p>The PRNG chosen this way SHOULD meet or exceed the requirements of a statistical RNG (except it uses a seed generated as given above) and SHOULD have the highest feasible period for its state length.</p>

<p><a id=GPU_Programming_Environments></a></p>

<h3>GPU Programming Environments</h3>

<p>In general, GL Shading Language (GLSL) and other programming environments designed for execution on a graphics processing unit (GPU) are stateless (they take data in and give data out without storing any state themselves), so random number generators for such environments are often designed as <a href="#Hash_Functions"><strong>hash functions</strong></a>, because their output is determined solely by the input rather than both the input and state (as with PRNGs).</p>

<p>However, some of the hash functions which have been written in GLSL give undesirable results in computers whose GPUs support only 16-bit binary floating point numbers and no other kinds of numbers, which makes such GPUs an important consideration when choosing a hash function.</p>

<p><a id=Hash_Functions></a></p>

<h2>Hash Functions</h2>

<p>A seemingly random number can be generated from arbitrary data using a <em>hash function</em>.</p>

<p>A <em>hash function</em> is a function that takes an arbitrary input of any size (such as an array of 8-bit bytes or a sequence of characters) and returns an output with a fixed number of bits. That output is also known as a <em>hash code</em>. (By definition, hash functions are deterministic<sup><a href="#Note21"><strong>(21)</strong></a></sup>.)</p>

<p>A hash code can be used as follows:</p>

<ul>
<li>The hash code can serve as a seed for a PRNG, and the desired random numbers can be generated from that PRNG.  (See my document on <a href="https://peteroupc.github.io/randomfunc.html"><strong>random number generation methods</strong></a> for techniques.)</li>
<li>If a number of random bits is needed, and the hash code has at least that many bits, then that many bits can instead be taken directly from the hash code.</li>
</ul>

<p>Useful properties of some hash functions include&mdash;</p>

<ul>
<li>the <em>avalanche property</em> (every bit of the input affects every bit of the output without a clear preference for 0 or 1),</li>
<li><em>collision resistance</em> (finding two different inputs that lead to a given output is cost-prohibitive), and</li>
<li>the <em>one-way property</em> (finding an unknown input that leads to a given output is cost-prohibitive) (see NIST SP 800-108).</li>
</ul>

<p>Hash functions not used for information security SHOULD have the avalanche property (e.g, MurmurHash3, xxHash, CityHash).  Hash functions used for information security SHOULD have the collision resistance, avalanche, and one-way properties (e.g., SHA2-256, BLAKE2).</p>

<p><a id=Motivation></a></p>

<h2>Motivation</h2>

<p>What has motivated me to write a more rigorous definition of random number generators is the fact that many applications still use weak RNGs.  In my opinion, this is largely because most popular programming languages today&mdash;</p>

<ul>
<li>specify few and weak requirements on RNGs (such as <a href="http://en.cppreference.com/w/cpp/numeric/random/rand"><strong>C&#39;s <code>rand</code></strong></a>),</li>
<li>specify a relatively weak general-purpose RNG (such as Java&#39;s <code>java.math.Random</code>, although it also includes a much stronger <code>SecureRandom</code> class),</li>
<li>implement RNGs by default that leave something to be desired (particularly the Mersenne Twister algorithm found in PHP&#39;s <code>mt_rand</code> as well as in Python and Ruby),</li>
<li>seed RNGs with a timestamp by default (such as the <a href="https://docs.microsoft.com/dotnet/api/system.random"><strong>.NET Framework implementation of <code>System.Random</code></strong></a>), and/or</li>
<li>leave the default seeding fixed (as is the case in <a href="https://www.mathworks.com/help/matlab/examples/controlling-random-number-generation.html"><strong>MATLAB</strong></a>; see also the question titled &quot;Matlab rand and c++ rand()&quot; on <em>Stack Overflow</em>).</li>
</ul>

<p>Many programming languages offer a general-purpose RNG (such as C&#39;s <code>rand</code> or Java&#39;s <code>java.util.Random</code>) and sometimes an RNG intended for information security purposes (such as <code>java.security.SecureRandom</code>).  Thus, a distinction between <em>statistical</em> and <em>cryptographic</em> RNGs seems natural.</p>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>Random numbers that merely &quot;look random&quot; are not enough for most applications.  That is why this document defines <a href="#Cryptographic_RNGs"><strong>cryptographic RNGs</strong></a> and <a href="#Statistical_RNGs"><strong>statistical RNGs</strong></a>; I believe RNGs that meet either category will fulfill the expectations of many applications as regards random numbers.  In general:</p>

<ul>
<li>For <em>statistical RNGs</em>, the random numbers not only &quot;look random&quot;, but are shown to behave like random numbers through statistical tests.</li>
<li>For <em>cryptographic RNGs</em>, the random numbers not only &quot;look random&quot;, but are virtually unpredictable.</li>
</ul>

<p>In addition, this document recommends using cryptographic RNGs in many cases, especially in information security contexts, and recommends easier programming interfaces for both cryptographic and statistical RNGs in new programming languages.</p>

<p>I acknowledge&mdash;</p>

<ul>
<li>the commenters to the CodeProject version of this page (as well as a similar article of mine on CodeProject), including &quot;Cryptonite&quot; and member 3027120, and</li>
<li>Lee Daniel Crocker, who reviewed this document and gave comments.</li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> F. DÃ¶rre and V. Klebanov, &quot;Practical Detection of Entropy Loss in Pseudo-Random Number Generators&quot;, 2016.</small></p>

<p><small><sup id=Note2>(2)</sup> If the software and/or hardware uses a nonuniform distribution, but otherwise meets this definition, it can be converted to use a uniform distribution, at least in theory, using <em>unbiasing</em>, <em>deskewing</em>, or <em>randomness extraction</em> (see RFC 4086 sec. 4 or Cliff et al. 2009 for further discussion).</small></p>

<p><small><sup id=Note3>(3)</sup> Such arbitrary data can include process identifiers, time stamps, environment variables, random numbers, virtual machine guest identifiers, and/or other data specific to the session or to the instance of the RNG.  See also NIST SP800-90A and the references below.<br/>Everspaugh, A., Zhai, Y., et al.  &quot;Not-So-Random Numbers in Virtualized Linux and the Whirlwind RNG&quot;, 2014.<br>Ristenpart, T., Yilek, S. &quot;When Good Randomness Goes Bad: Virtual Machine Reset Vulnerabilities and Hedging Deployed Cryptography&quot;, 2010.</small></p>

<p><small><sup id=Note4>(4)</sup> Bernstein, D.J.  &quot;Fast-key-erasure random number generators&quot;, Jun. 23, 2017.</small></p>

<p><small><sup id=Note5>(5)</sup> Wetzels, J., &quot;33C3: Analyzing Embedded Operating System Random Number Generators&quot;, samvartaka.github.io, Jan. 3, 2017.</small></p>

<p><small><sup id=Note6>(6)</sup> B. Peng, &quot;Two Fast Methods of Generating True Random Numbers on the Arduino&quot;, GitHub Gist, December 2017.</small></p>

<p><small><sup id=Note7>(7)</sup> Jones, D., &quot;Good Practice in (Pseudo) Random Number Generation for Bioinformatics Applications&quot;, 2007/2010.</small></p>

<p><small><sup id=Note8>(8)</sup> Widynski, B., &quot;Middle Square Weyl Sequence RNG&quot;, arXiv:1704.00358v1 [cs.CR], 2017.</small></p>

<p><small><sup id=Note9>(9)</sup> S. Vigna, &quot;<a href="http://vigna.di.unimi.it/ftp/papers/xorshift.pdf"><strong>An experimental exploration of Marsaglia&#39;s <code>xorshift</code> generators, scrambled</strong></a>&quot;, 2016.</small></p>

<p><small><sup id=Note10>(10)</sup> Blackman, D., Vigna, S. &quot;Scrambled Linear Pseudorandom Number Generators&quot;, 2018.</small></p>

<p><small><sup id=Note11>(11)</sup> Noise functions include functions that combine several outputs of a noise function, including by <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion"><strong>fractional Brownian motion</strong></a>.  By definition, noise functions are deterministic.</small></p>

<p><small><sup id=Note12>(12)</sup> Lenstra, A.K., Wesolowski, B. &quot;A random zoo: sloth, unicorn, and trx&quot;, 2015.</small></p>

<p><small><sup id=Note13>(13)</sup> Boneh, D., Bonneau, J., et al. &quot;Verifiable Delay Functions&quot;, 2018.</small></p>

<p><small><sup id=Note14>(14)</sup> M&uuml;ller, S. &quot;CPU Time Jitter Based Non-Physical True Random Number Generator&quot;.</small></p>

<p><small><sup id=Note15>(15)</sup> Cliff, Y., Boyd, C., Gonzalez Nieto, J.  &quot;How to Extract and Expand Randomness: A Summary and Explanation of Existing Results&quot;, 2009.</small></p>

<p><small><sup id=Note16>(16)</sup> A. Klyubin, &quot;Some SecureRandom Thoughts&quot;, Android Developers Blog, Aug. 14, 2013.</small></p>

<p><small><sup id=Note17>(17)</sup> Allowing applications to do so would hamper forward compatibility &mdash; the API would then be less free to change how the RNG is implemented in the future (e.g., to use a cryptographic or otherwise &quot;better&quot; RNG), or to make improvements or bug fixes in methods that use that RNG (such as shuffling and Gaussian number generation).  (As a notable example, the V8 JavaScript engine recently changed its <code>Math.random()</code> implementation to use a variant of <code>xorshift128+</code>, which is backward compatible because nothing in JavaScript allows  <code>Math.random()</code> to be seeded.)  Nevertheless, APIs can still allow applications to provide additional input (&quot;entropy&quot;) to the RNG in order to increase its randomness rather than to ensure repeatability.</small></p>

<p><small><sup id=Note18>(18)</sup> More generally, a list has <code>N! / (W_1! * W_2! * ... * W_K!)</code> permutations (a <a href="http://mathworld.wolfram.com/MultinomialCoefficient.html"><strong>multinomial coefficient</strong></a>), where <code>N</code> is the list&#39;s size, <code>K</code> is the number of different items in the list, and <code>W_i</code> is the number of times the item identified by <code>i</code> appears in the list.  However, this number is never more than <code>N!</code> and suggests using less randomness, so an application need not use this more complicated formula and MAY assume that a list has <code>N!</code> permutations even if some of its items occur more than once.</small></p>

<p><small><sup id=Note19>(19)</sup> Atwood, Jeff. &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/"><strong>The danger of na&iuml;vet&eacute;</strong></a>&quot;.</small></p>

<p><small><sup id=Note20>(20)</sup> van Staveren, Hans. <a href="https://sater.home.xs4all.nl/doc.html"><strong>&quot;Big Deal: A new program for dealing bridge hands&quot;</strong></a>, Sep. 8, 2000</small></p>

<p><small><sup id=Note21>(21)</sup> Note that although PRNGs can also act like hash functions (if they&#39;re seeded with the input and the PRNG is &quot;large enough&quot; for the input), some PRNGs (such as <code>xorshift128+</code>) are not well suited to serve as hash functions, because they don&#39;t mix their state before generating a random number from that state.</small></p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Suggested_Entropy_Size></a></p>

<h3>Suggested Entropy Size</h3>

<p>The following Python code suggests how many bits of entropy are needed for shuffling.  For example:</p>

<ul>
<li>To shuffle an <code>n</code>-item list, the suggested bits of entropy is at least as high as the base-2 logarithm, rounded up, of <code>n!</code> (<code>stateLengthN(n)</code>).</li>
<li>To shuffle a 52-item list, at least 226 bits of entropy is suggested (<code>stateLengthN(52)</code>).</li>
<li>To shuffle two 52-item lists of identical contents together, at least 500 bits of entropy is suggested (<code>stateLengthDecks(2, 52)</code>).</li>
</ul>

<p>&nbsp;</p>

<pre>from math import factorial as fac

def ceillog2(x):
    &quot;&quot;&quot; Calculates base-2 logarithm, rounded up, of x. &quot;&quot;&quot;
    ret=0
    needCeil=True
    while x&gt;1:
       one=needCeil and ((x&amp;1)!=0)
       x=x&gt;&gt;1
       if one:
         ret+=1; needCeil=False
       ret+=1
    return ret

def stateLengthN(n):
  &quot;&quot;&quot; Suggested state length (or bits of entropy)
     for PRNGs that shuffle
    a list of n items. &quot;&quot;&quot;
  return ceillog2(fac(n))

def stateLengthNChooseK(n, k):
  &quot;&quot;&quot; Suggested state length/entropy for PRNGs that choose k
   different items randomly from a list of n items
   (see RFC 3797, sec. 3.3) &quot;&quot;&quot;
  return ceillog2(fac(n)/(fac(k)*fac(n-k)))

def stateLengthDecks(numDecks, numCards):
  &quot;&quot;&quot; Suggested state length/entropy for PRNGs that shuffle
    multiple decks of cards in one. &quot;&quot;&quot;
  return ceillog2(fac(numDecks*numCards)/ \
      (fac(numDecks)**numCards))
</pre>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = xExtra(document).getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
}
document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
