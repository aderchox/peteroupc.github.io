<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generator Recommendations for Applications</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generator Recommendations for Applications</h1>

<p><a href="mailto:poccil14@gmail.com">Peter Occil</a></p>

<p>Begun on Mar. 5, 2016; last updated on June 2, 2017.</p>

<p>Most apps that use random numbers care about either unpredictability or speed/high quality.</p>

<h2>Introduction</h2>

<p>As I see it, there are two kinds of random number generators (RNGs) needed by most applications, namely <em>unpredictable random generators</em> and <em>statistically random generators</em>. This page will discuss these two kinds of RNG in the nature of a sketch of a C programming interface.</p>

<p>In addition, other applications require numbers that &quot;seem&quot; random but are based on an initial state, or &quot;seed&quot;.  This page will discuss when seeds should be used by applications.</p>

<p>Finally, this page will discuss issues on the practical use of RNGs in applications, namely, shuffling and the two &quot;building blocks&quot; for higher-level randomness methods.</p>

<h2>Definitions</h2>

<p>The following definitions are helpful in better understanding this document.</p>

<ul>
<li><strong>Pseudorandom number generator (PRNG).</strong> A number generator that outputs seemingly random numbers using an algorithm that returns the same output for the same state every time. (In this document, RNGs include PRNGs.)</li>
<li><strong>Seed.</strong>  Arbitrary data for initializing the state of a PRNG.</li>
<li><strong>Seed length.</strong>  The maximum size of the seed a PRNG can take to initialize its state without truncating or compressing that seed.</li>
<li><strong>Period.</strong> The number of random numbers a PRNG can generate in one sequence before the sequence repeats.  The period will not be greater than 2<sup><code>L</code></sup> where <code>L</code> is the PRNG&#39;s <em>seed length</em>.</li>
</ul>

<h2>Unpredictable RNGs</h2>

<p>Unpredictable random implementations (also known as &quot;cryptographically strong&quot; or &quot;cryptographically secure&quot; RNGs) are indispensable in computer security and information security contexts, such as--</p>

<ul>
<li> generating keying material, such as encryption keys,</li>
<li> generating random passwords,</li>
<li> generating &quot;salts&quot; to vary cryptographic hashes of the same password, and</li>
<li> use in secure communication protocols.</li>
</ul>

<p>They are also useful in other contexts, such as--</p>

<ul>
<li> shuffling a digital deck of cards, for reasons described later, and</li>
<li> cases where the application generates random numbers so infrequently that the RNG&#39;s speed is not a concern.</li>
</ul>

<p>The goal of this kind of generator is to keep the random numbers from being guessed easily.</p>

<pre><code>int random(uint8_t[] bytes, size_t size);
</code></pre>

<p>Generates random bits using an unpredictable-random implementation.</p>

<ul>
<li> <strong>Quality:</strong> An unpredictable-random implementation generates random bits that are unpredictable. &quot;Unpredictable&quot; means that an outside party can guess neither prior nor future unseen bits of the random sequence correctly with more than a 50% chance per bit, even with knowledge of the random algorithm, the implementation&#39;s internal state at the given point in time, or extremely many outputs of the RNG. (If the sequence was generated directly by a PRNG, ensuring future bits are unguessable this way should be done wherever the implementation finds it feasible; see &quot;Seeding and Reseeding&quot;.)</li>
<li><p><strong>Seeding and Reseeding:</strong> The following applies only to implementations that use PRNGs.</p>

<p>The implementation must be initialized (&quot;seeded&quot;) with a &quot;seed&quot; described as follows. The seed--</p>

<ul>
<li>must consist of unpredictable data (as defined above), no part of which may be the PRNG&#39;s own output (the unpredictable data may be mixed with other arbitrary data as long as the result is no less unpredictable), and</li>
<li>must be at least the same size as the PRNG&#39;s <em>seed length</em>.</li>
</ul>

<p>The PRNG&#39;s <em>seed length</em> must be at least 128 bits and should be at least 256 bits.</p>

<p>The implementation should be reseeded from time to time (using a newly generated seed as described above) to help ensure the unpredictability of the output. If the implementation reseeds, it must do so before it generates more than 2<sup>67</sup> bits without reseeding and should do so  before it generates more than 2<sup>32</sup> bits without reseeding.</p></li>
<li> <strong>Speed:</strong> The implementation should select algorithms that are reasonably fast for most applications.</li>
<li> <strong>Time Complexity:</strong> The implementation must run in amortized linear time on the size of the output array.</li>
<li> <strong>Thread Safety:</strong> The implementation should be safe for concurrent use by multiple threads.</li>
<li> <strong>Examples:</strong> The &quot;<code>/dev/urandom</code>&quot; device on many Unix-based operating systems; <code>CryptGenRandom</code> function on Windows; cryptographic hash functions that take unpredictable signals as input (such as disk access and keystroke timings).</li>
</ul>

<p>&quot;bytes&quot; is a pointer to a byte array, &quot;size&quot; is the number of random bytes to generate. Each bit in each byte will be randomly set to 0 or 1. Returns 0 if the function succeeds, and nonzero otherwise.</p>

<h2>Statistical RNGs</h2>

<p>Statistically random generators are used by simulations and many games to bring an element of chance and variation to the application. This kind of generator is generally suitable only if--</p>

<ul>
<li> computer security and information security are not involved,</li>
<li> 20 or fewer items are being shuffled (in cases where the RNG is used for shuffling), and</li>
<li> the application generates random numbers so frequently that it would slow down undesirably if an unpredictable RNG were used instead.</li>
</ul>

<p>The goal of this kind of generator is for each possible outcome to be equally likely.</p>

<pre><code>int random_fast(uint8_t[] bytes, size_t size);
</code></pre>

<p>Generates random bits using a statistical-random implementation.</p>

<ul>
<li> <strong>Quality:</strong> A statistical-random implementation generates random bits, each of which is uniformly randomly distributed independently of the other bits, at least for nearly all practical purposes. The implementation must be almost certain to pass simple statistical randomness tests and many complex ones. (For example, any RNG algorithm that shows no <a href="http://xoroshiro.di.unimi.it/#quality">systematic failures</a> in <code>TestU01</code>&#39;s <code>BigCrush</code> test battery [L&#39;Ecuyer and Simard 2007] meets these requirements.)</li>
<li><p><strong>Seeding and Reseeding:</strong> The following applies only to implementations that use PRNGs.</p>

<p>The implementation must be initialized (&quot;seeded&quot;) with a seed described as follows. The seed--</p>

<ul>
<li>must consist of data not known <em>a priori</em> by the implementation, such as random bits from an unpredictable-random implementation,</li>
<li>must not be a fixed value or a user-entered value,</li>
<li>should not be trivially predictable, as far as practical, and</li>
<li>must be at least the same size as the PRNG&#39;s <em>seed length</em>.</li>
</ul>

<p>The PRNG&#39;s <em>seed length</em> must be at least 64 bits and should be at least 128 bits.</p>

<p>The implementation may reseed itself from time to time (using a newly generated seed as described above). It should do so if the PRNG&#39;s <em>seed length</em> is less than 238 bits. If the implementation reseeds, it should do so before it generates more values than the square root of the PRNG&#39;s period without reseeding.</p></li>
<li> <strong>Speed:</strong> The implementation should select algorithms that are reasonably fast for most applications. The implementation may instead use an unpredictable-random implementation as long as the function remains at least as fast, in the average case, as the statistical-random implementation it would otherwise use.</li>
<li> <strong>Time Complexity:</strong> The implementation must run in amortized linear time on the size of the output array.</li>
<li> <strong>Thread Safety:</strong> The implementation should be safe for concurrent use by multiple threads.</li>
<li> <strong>Examples:</strong> The &quot;<code>xorshift128+</code>&quot; and <code>Lehmer128</code> random number generators.</li>
<li> <strong>Non-Examples:</strong>  Mersenne Twister <a href="http://xoroshiro.di.unimi.it/#quality">systematically fails</a> one of the <code>BigCrush</code> tests.  Any linear congruential generator with modulus 2<sup>63</sup> or less (such as <code>java.util.Random</code>) has a <em>seed length</em> of less than 64 bits.</li>
</ul>

<p>&quot;bytes&quot; is a pointer to a byte array, &quot;size&quot; is the number of random bytes to generate. Each bit in each byte will be randomly set to 0 or 1. Returns 0 if the function succeeds, and nonzero otherwise.</p>

<h2>Seedable Random Generators</h2>

<p>In addition, some applications use pseudorandom number generators (PRNGs) to generate results based on apparently-random principles, starting from a known initial state, or &quot;seed&quot;. One notable example is a &quot;code&quot;, or password, for generating a particular game level in some role-playing games.</p>

<p>Applications that require seeding usually care about reproducible results. Such applications often need to keep not only the PRNG algorithm stable, but also any algorithm that uses that algorithm (such as a game level generator), especially if it publishes seeds (for example, game level passwords). Moreover, which PRNG to use for such purpose depends on the application. But here are some recommendations:</p>

<ul>
<li> Any PRNG algorithm selected for producing reproducible results should meet or exceed the quality requirements of a statistical-random implementation, and should be reasonably fast.</li>
<li> The PRNG&#39;s <em>seed length</em> should be 64 bits or greater.</li>
<li> Any seed passed to the PRNG should be at least the same size as the PRNG&#39;s <em>seed length</em>.</li>
</ul>

<p>An application should only use seeding if--</p>

<ol>
<li>the initial state (the seed) which the &quot;random&quot; result will be generated from--

<ul>
<li>is hard-coded,</li>
<li>was entered by the user,</li>
<li>was generated using a statistical or unpredictable RNG (as defined above), or</li>
<li>is based on a timestamp (but only if the reproducible result is not intended to vary during the time specified on the timestamp and within the timestamp&#39;s granularity; for example, a year/month/day timestamp for a result that varies only daily),</li>
</ul></li>
<li>the application needs to generate the same &quot;random&quot; result multiple times,</li>
<li> it would be impractical to store or distribute that &quot;random&quot; result without relying on seeding, such as--

<ul>
<li>  by saving the result to a file, or</li>
<li>  by distributing the results or the random numbers to networked users as they are generated, and</li>
</ul></li>
<li>the PRNG algorithm and any procedure using that algorithm to generate that &quot;random&quot; result will remain stable as long as the relevant feature is still in use by the application. (Not using seeding allows either to be changed or improved without affecting the application&#39;s functionality.)</li>
</ol>

<p>On the other hand, an application need not use seeding if the randomness is only used for slight and inconspicuous visual variations, provided the visual variations have no impact on application functionality and do not implicate
computer or information security. For such purposes, the random number generator need only be as strong as required to achieve the desired visual variations.</p>

<h2>Using Random Number Generators</h2>

<p>The following topics deal with the practical use of RNGs in applications.  Unless stated otherwise,
they apply regardless of the kind of RNG used (such as unpredictable, statistical, or seedable).</p>

<h3>RNG Building Blocks</h3>

<p>Two methods given below form the building blocks for writing code that makes practical use
of randomness. Both methods assume the RNG produces uniformly random numbers, like the RNGs
described in this page.</p>

<ol>
<li>The first building-block is to generate a random integer from 0 inclusive to N exclusive (here
called <code>RNDINT(N)</code>), where N is an integer greater than 0. To do so, use the RNG to generate as many
random bits as used to represent N-minus-1, then convert those bits to a nonnegative integer.
If that nonnegative integer is N or greater, repeat this process.</li>
<li>The second building-block is to generate a random number from 0 inclusive to 1 exclusive. This can be
implemented by calling <code>RNDINT(X)</code> and dividing by X.  For 64-bit IEEE 854 floating-point numbers
(Java <code>double</code>), X will be 2<sup>53</sup>.  For 32-bit IEEE 854 floating-point numbers
(Java <code>float</code>), X will be 2<sup>24</sup>. (See &quot;Generating uniform doubles in the unit interval&quot; in the <a href="http://xoroshiro.di.unimi.it/#remarks"><code>xoroshiro+</code> remarks page</a>
for further discussion.)</li>
</ol>

<p>A detailed discussion of other methods to generate random numbers or integers that
follow a given distribution, such as a normal, geometric, binomial, or discrete weighted
distribution, or that fall within a given range, is outside the scope of this page.  In general, such methods can be
written in terms of the two basic building blocks for generating uniform random numbers.</p>

<p>In my opinion, new programming languages should include methods for the two building blocks
given above in their standard libraries -- one set for unpredictable-random generators, and another
set for statistical RNGs.</p>

<h3>Shuffling</h3>

<p>There are special considerations in play when applications use RNGs to shuffle a list of items.</p>

<ol>
<li><strong>Shuffling method.</strong> The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle">Fisher-Yates shuffle method</a> shuffles a list such that all permutations of that list are equally likely to occur, assuming the RNG it uses produces uniformly random numbers and can generate all permutations of that list.  However, that method is also easy to get wrong.</li>
<li><strong>Generating all permutations.</strong> A pseudorandom number generator (PRNG) can&#39;t generate all permutations of a list if the <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a> of the list&#39;s size is greater than the generator&#39;s <em>period</em>. This means that the items in a shuffled list of that size will never appear in certain orders when that generator is used to shuffle it. For example, a PRNG with period 2<sup>64</sup> (or one with a 64-bit seed length) can&#39;t generate all permutations of a list with more than 20 items; with period 2<sup>128</sup>, more than 34 items; with period 2<sup>226</sup>, more than 52 items; and with period 2<sup>256</sup>, more than 57 items. When shuffling more than 20 items, a concerned application would be well advised to use an unpredictable-random implementation.</li>
</ol>

<h2>Conclusion</h2>

<p>In conclusion, most applications that require random numbers usually want either unpredictability (cryptographic security), or speed and high quality. I believe that RNGs that meet the descriptions specified in the &quot;Unpredictable RNGs&quot; and &quot;Statistical RNGs&quot; sections will meet the needs of those applications.</p>

<p>What has motivated me to write a more rigorous definition of random number generators is the fact that many applications still use weak RNGs.  In my opinion, this is largely because most popular programming languages today--</p>

<ul>
<li>don&#39;t specify virtually any requirements on RNGs (such as C&#39;s <code>rand</code> function),</li>
<li>specify a relatively weak RNG (such as Java&#39;s <code>java.math.Random</code>, although it also includes a much stronger <code>SecureRandom</code> class),</li>
<li>implement RNGs by default that leave a bit to be desired (particularly the Mersenne Twister algorithm found in PHP&#39;s <code>mt_rand</code> as well as in Python and Ruby),</li>
<li>seed RNGs with a timestamp by default (such as the <a href="https://msdn.microsoft.com/en-us/library/h343ddh9.aspx">.NET Framework implementation of <code>System.Random</code></a>), and/or</li>
<li>leave the default seeding unspecified (such as C&#39;s <code>rand</code> function).</li>
</ul>

<p>In addition, this document recommends using unpredictable RNGs in many cases, especially in computer and information security contexts, and recommends easier programming interfaces for both unpredictable and statistical RNGs in new programming languages.</p>

<p>Feel free to send comments. They may help improve this page.</p>

<h2>License</h2>

<p>This page is licensed under <a href="http://creativecommons.org/licenses/publicdomain/">A Public Domain dedication</a>.</p>
</div><nav id="navigation"><p><a href="/">Back to start site.</a></p>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
