<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generator Recommendations for Applications</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generator Recommendations for Applications</h1>

<p><a href="mailto:poccil14@gmail.com">Peter Occil</a></p>

<p>Begun on Mar. 5, 2016; last updated on July 10, 2017.</p>

<p>Most apps that use random numbers care about either unpredictability or speed/high quality.</p>

<p><a id=Introduction_and_Summary></a></p>

<h2>Introduction and Summary</h2>

<p>As I see it, there are two kinds of random number generators (RNGs) needed by most applications, namely&mdash;</p>

<ul>
<li><em>statistical-random generators</em>, which seek to generate numbers that follow a uniform random distribution, and</li>
<li><em>unpredictable-random generators</em>, which seek to generate numbers that are cost-prohibitive to predict.</li>
</ul>

<p>This page will discuss these two kinds of RNG, and make recommendations on their use and properties.</p>

<p>In addition, other applications require numbers that &quot;seem&quot; random but are based on an initial state, or &quot;seed&quot;.  This page will discuss when applications should specify their own seeds.</p>

<p>Then, this page will explain what programming language APIs implement statistical-random and unpredictable-random generators and give advice on implementing them in programming languages.</p>

<p>Finally, this page will discuss issues on shuffling with an RNG.</p>

<p><a id=Summary></a></p>

<h3>Summary</h3>

<p>The following table summarizes the kinds of RNGs covered in this document.</p>

<table><thead>
<tr>
<th>Kind of RNG</th>
<th>When to Use This RNG</th>
<th>Examples</th>
</tr>
</thead><tbody>
<tr>
<td><a href="#Unpredictable_Random_Generators">Unpredictable-Random</a></td>
<td>In computer/information security cases, or when speed is not a concern.</td>
<td><code>/dev/urandom</code>, <code>CryptGenRandom</code></td>
</tr>
<tr>
<td><a href="#Statistical_Random_Generators">Statistical-Random</a></td>
<td>When computer/information security is not a concern, but speed is.  See also <a href="#Shuffling">&quot;Shuffling&quot;</a>.</td>
<td><code>xoroshiro128+</code>, <code>xorshift128+</code></td>
</tr>
<tr>
<td><a href="#Seeded_Random_Generators">Seeded PRNG</a></td>
<td>When generating reproducible results in a way not practical otherwise.</td>
<td>Statistical-random quality PRNG with custom seed</td>
</tr>
</tbody></table>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction_and_Summary">Introduction and Summary</a>

<ul>
<li><a href="#Summary">Summary</a></li>
</ul></li>
<li><a href="#Contents">Contents</a></li>
<li><a href="#Definitions">Definitions</a></li>
<li><a href="#Unpredictable_Random_Generators">Unpredictable-Random Generators</a>

<ul>
<li><a href="#Quality">Quality</a></li>
<li><a href="#Seeding_and_Reseeding">Seeding and Reseeding</a></li>
<li><a href="#Examples">Examples</a></li>
</ul></li>
<li><a href="#Statistical_Random_Generators">Statistical-Random Generators</a>

<ul>
<li><a href="#Quality_2">Quality</a></li>
<li><a href="#Seeding_and_Reseeding_2">Seeding and Reseeding</a></li>
<li><a href="#Examples_and_Non_Examples">Examples and Non-Examples</a></li>
</ul></li>
<li><a href="#Seeded_Random_Generators">Seeded Random Generators</a>

<ul>
<li><a href="#Seeding_Recommendations">Seeding Recommendations</a></li>
<li><a href="#Seedable_PRNG_Recommendations">Seedable PRNG Recommendations</a></li>
<li><a href="#Examples_2">Examples</a>

<ul>
<li><a href="#Games">Games</a></li>
<li><a href="#Unit_Testing">Unit Testing</a></li>
<li><a href="#Verifiable_Random_Numbers">Verifiable Random Numbers</a></li>
<li><a href="#Noise">Noise</a></li>
</ul></li>
</ul></li>
<li><a href="#Programming_Language_APIs">Programming Language APIs</a></li>
<li><a href="#Advice_for_New_Programming_Language_APIs">Advice for New Programming Language APIs</a></li>
<li><a href="#Shuffling">Shuffling</a>

<ul>
<li><a href="#Shuffling_Method">Shuffling Method</a></li>
<li><a href="#Generating_Every_Permutation">Generating Every Permutation</a></li>
</ul></li>
<li><a href="#Motivation">Motivation</a></li>
<li><a href="#Conclusion">Conclusion</a>

<ul>
<li><a href="#Request_for_Comments">Request for Comments</a></li>
</ul></li>
<li><a href="#Notes">Notes</a></li>
<li><a href="#License">License</a></li>
</ul>

<p><a id=Definitions></a></p>

<h2>Definitions</h2>

<p>The following definitions are helpful in better understanding this document.</p>

<ul>
<li><strong>Pseudorandom number generator (PRNG).</strong> A number generator that outputs seemingly random numbers using a deterministic algorithm, that is, an algorithm that returns the same output for the same state every time. (In this document, RNGs include PRNGs.)</li>
<li><strong>Seed.</strong>  Arbitrary data for initializing the state of a PRNG.</li>
<li><strong>State length.</strong>  The maximum size of the seed a PRNG can take to initialize its state without truncating or compressing that seed.</li>
<li><strong>Period.</strong> The maximum number of random numbers a PRNG can generate in one sequence before the sequence repeats.  The period will not be greater than 2<sup><code>L</code></sup> where <code>L</code> is the PRNG&#39;s <em>state length</em>.</li>
</ul>

<p><a id=Unpredictable_Random_Generators></a></p>

<h2>Unpredictable-Random Generators</h2>

<p>Unpredictable-random implementations (also known as &quot;cryptographically strong&quot; or &quot;cryptographically secure&quot; RNGs) seek to generate random numbers that are cost-prohibitive to predict.  Such implementations are indispensable in computer security and information security contexts, such as&mdash;</p>

<ul>
<li> generating keying material, such as encryption keys,</li>
<li> generating random passwords or session identifiers,</li>
<li> generating &quot;salts&quot; to vary cryptographic hashes of the same password,</li>
<li> use in communications between two networked computers,</li>
<li> use in transfer, transport, messaging, and other communication protocols, and</li>
<li> cases (such as in multiplayer networked games) when predicting future random numbers would give a player or user a significant and unfair advantage.</li>
</ul>

<p>They are also useful in cases where the application generates random numbers so infrequently that the RNG&#39;s speed is not a concern.</p>

<p>An unpredictable-random implementation ultimately relies on one or more <em>nondeterministic sources</em> (sources that don&#39;t always return the same output for the same input) for random number generation.  Sources that are reasonably fast for most applications (for instance, by producing very many random bits per second), especially sources implemented in hardware, are highly advantageous here, since an implementation for which such sources are available can rely less on PRNGs, which are deterministic and benefit from reseeding as explained later.</p>

<p><a id=Quality></a></p>

<h3>Quality</h3>

<p>An unpredictable-random implementation generates uniformly random bits such that an outside party can guess neither prior nor future unseen bits of the random sequence correctly with more than a 50% chance per bit, even with knowledge of the randomness-generating procedure, the implementation&#39;s internal state at the given point in time, and/or extremely many outputs of the RNG. (If the sequence was generated directly by a PRNG, ensuring future bits are unguessable this way should be done wherever the implementation finds it feasible; see &quot;Seeding and Reseeding&quot;.)</p>

<p><a id=Seeding_and_Reseeding></a></p>

<h3>Seeding and Reseeding</h3>

<p>If an unpredictable-random implementation uses a PRNG, the following requirements apply.</p>

<p>The PRNG&#39;s <em>state length</em> must be at least 128 bits and should be at least 256 bits.</p>

<p>Before an instance of the RNG generates a random number, it must have been initialized (&quot;seeded&quot;) with an <em>unpredictable seed</em>, defined as follows. The seed&mdash;</p>

<ul>
<li>must consist of data which meets the quality requirement described earlier, which does not contain, in whole or in part, the PRNG&#39;s own output, and which ultimately derives from one or more nondeterministic sources (such data may be mixed with other arbitrary data as long as the result is no less cost-prohibitive to predict), and</li>
<li>must be at least the same size as the PRNG&#39;s <em>state length</em>.</li>
</ul>

<p>The RNG should be reseeded from time to time (using a newly generated <em>unpredictable seed</em>) to help ensure the unguessability of the output. If the implementation reseeds, it must do so before it generates more than 2<sup>67</sup> bits without reseeding and should do so before it generates more than 2<sup>32</sup> bits without reseeding.</p>

<p><a id=Examples></a></p>

<h3>Examples</h3>

<p>Examples of unpredictable-random implementations include the following:</p>

<ul>
<li>The <code>/dev/random</code> device on many Unix-based operating systems, which generally uses only nondeterministic sources; however, in some implementations of the device it can block for seconds at a time, especially if not enough randomness (&quot;entropy&quot;) is available.</li>
<li>The <code>/dev/urandom</code> device on many Unix-based operating systems, which often relies on both a PRNG and the same nondeterministic sources used by <code>/dev/random</code>.</li>
<li>The <code>CryptGenRandom</code> method on Windows.</li>
<li>Cryptographic hash functions that take very hard-to-predict signals as input (such as disk access timings, keystroke timings, thermal noise, and/or A. Seznec&#39;s technique called hardware volatile entropy gathering and expansion).</li>
</ul>

<p><a id=Statistical_Random_Generators></a></p>

<h2>Statistical-Random Generators</h2>

<p>Statistical-random generators are used, for example, in simulations, numerical integration, and many games to bring an element of chance and variation to the application, with the goal that each possible outcome is equally likely. However, statistical-random generators are generally suitable only if&mdash;</p>

<ul>
<li> computer security and information security are not involved, and</li>
<li> the application generates random numbers so frequently that it would slow down undesirably if an unpredictable-random implementation were used instead.</li>
</ul>

<p>If more than 20 items are being shuffled, a concerned application would be well advised to use alternatives to this kind of implementation (see <a href="#Shuffling">&quot;Shuffling&quot;</a>).</p>

<p>A statistical-random implementation is usually implemented with a PRNG, but can also be implemented in a similar way as an unpredictable-random implementation provided it remains reasonably fast.</p>

<p><a id=Quality_2></a></p>

<h3>Quality</h3>

<p>A statistical-random implementation generates random bits, each of which is uniformly randomly distributed independently of the other bits, at least for nearly all practical purposes. The implementation must be highly likely to pass all the tests used in <code>TestU01</code>&#39;s <code>Crush</code>, <code>SmallCrush</code>, and <code>BigCrush</code> test batteries [L&#39;Ecuyer and Simard 2007], and should be highly likely to pass other known statistical randomness tests. The RNG need not be equidistributed. (Mentioning specific test batteries here is in the interest of precision and makes it clearer whether a particular RNG meets these quality requirements.)</p>

<p><a id=Seeding_and_Reseeding_2></a></p>

<h3>Seeding and Reseeding</h3>

<p>If statistical-random implementation uses a PRNG, the following requirements apply.</p>

<p>The PRNG&#39;s <em>state length</em> must be at least 64 bits, should be at least 128 bits, and is encouraged to be as high as the implementation can go to remain reasonably fast for most applications.</p>

<p>Before an instance of the RNG generates a random number, it must have been initialized (&quot;seeded&quot;) with a seed described as follows. The seed&mdash;</p>

<ul>
<li>must consist of data not known <em>a priori</em> by the implementation, such as random bits from an unpredictable-random implementation,</li>
<li>must not be a fixed value or a user-entered value,</li>
<li>should not be trivially predictable in any of its bits, as far as practical,</li>
<li>is encouraged not to consist of a timestamp (especially not a timestamp with millisecond or coarser granularity)<sup>(1)</sup>, and</li>
<li>must be at least the same size as the PRNG&#39;s <em>state length</em>.</li>
</ul>

<p>The implementation is encouraged to reseed itself from time to time (using a newly generated seed as described earlier), especially if the PRNG has a <em>state length</em> less than 238 bits. If the implementation reseeds, it should do so before it generates more values than the square root of the PRNG&#39;s period without reseeding.</p>

<p><a id=Examples_and_Non_Examples></a></p>

<h3>Examples and Non-Examples</h3>

<p>Examples of statistically-random generators include the following:</p>

<ul>
<li><code>xoroshiro128+</code> (state length 128 bits; nonzero seed &mdash; but see warning in the <a href="http://xoroshiro.di.unimi.it/xoroshiro128plus.c">source code</a> about the lowest bit of the PRNG&#39;s outputs).</li>
<li><code>xorshift128+</code> (state length 128 bits; nonzero seed).</li>
<li><code>Lehmer128</code> (state length 128 bits).</li>
<li><code>JKISS</code> on top of page 3 of Jones 2010 (state length 128 bits; seed with four 32-bit nonzero pieces).</li>
<li>C++&#39;s <a href="http://www.cplusplus.com/reference/random/ranlux48/"><code>ranlux48</code> engine</a> (state length 577 bits; nonzero seed).</li>
</ul>

<p>Non-examples include the following:</p>

<ul>
<li>Mersenne Twister shows a <a href="http://xoroshiro.di.unimi.it/#quality">systematic failure</a> in one of the <code>BigCrush</code> tests. (See also S. Vigna, &quot;<a href="http://vigna.di.unimi.it/ftp/papers/xorshift.pdf">An experimental exploration of Marsaglia&#39;s <code>xorshift</code> generators, scrambled</a>&quot;, as published in the <code>xoroshiro128+</code> website.)</li>
<li>Any <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">linear congruential generator</a> with modulus 2<sup>63</sup> or less (such as <code>java.util.Random</code> and C++&#39;s <code>minstd_rand</code> and <code>minstd_rand0</code> engines) has a <em>state length</em> of less than 64 bits.</li>
</ul>

<p><a id=Seeded_Random_Generators></a></p>

<h2>Seeded Random Generators</h2>

<p>In addition, some applications use pseudorandom number generators (PRNGs) to generate results based on apparently-random principles, starting from a known initial state, or &quot;seed&quot;. Such applications usually care about reproducible results. (Note that in the definitions for <a href="#Unpredictable_Random_Generators">unpredictable-random</a> and <a href="#Statistical_Random_Generators">statistical-random</a> generators given earlier, the PRNGs involved are automatically seeded before use.)</p>

<p><a id=Seeding_Recommendations></a></p>

<h3>Seeding Recommendations</h3>

<p>An application should use a PRNG with a seed it specifies (rather than an automatically-initialized PRNG or another kind of RNG) only if&mdash;</p>

<ol>
<li>the initial state (the seed) which the &quot;random&quot; result will be generated from&mdash;

<ul>
<li>is hard-coded,</li>
<li>was entered by the user,</li>
<li>is known to the application and was generated using a statistical or unpredictable-random implementation (as defined earlier), or</li>
<li>is based on a timestamp (but only if the reproducible result is not intended to vary during the time specified on the timestamp and within the timestamp&#39;s granularity; for example, a year/month/day timestamp for a result that varies only daily),</li>
</ul></li>
<li>the application might need to generate the same &quot;random&quot; result multiple times,</li>
<li>the application either&mdash;

<ul>
<li>makes the seed (or a &quot;code&quot; or &quot;password&quot; based on the seed) accessible to the user, or</li>
<li>finds it impractical to store or distribute the &quot;random&quot; results or the random numbers (rather than the seed) for later use, such as&mdash;

<ul>
<li>by saving the result to a file,</li>
<li>by storing the random numbers for the feature generating the result to &quot;replay&quot; later, or</li>
<li>by distributing the results or the random numbers to networked users as they are generated,</li>
</ul></li>
</ul></li>
<li>the random number generation method will remain <em>stable</em> for as long as the relevant feature is still in use by the application, and</li>
<li>any feature using that random number generation method to generate that &quot;random&quot; result will remain backward compatible with respect to the &quot;random&quot; results it generates, for as long as that feature is still in use by the application.</li>
</ol>

<p>As used here, a random number generation method is <em>stable</em> if it uses a PRNG, outputs the same random sequence given the same seed, and has no random-number generation behavior that is unspecified, that is implementation-dependent, or that may change in the future.  For example&mdash;</p>

<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html"><code>java.util.Random</code></a> is stable,</li>
<li>the C <a href="http://en.cppreference.com/w/cpp/numeric/random/rand"><code>rand</code> method</a> is not stable (because the algorithm it uses is unspecified), and</li>
<li>.NET&#39;s <a href="https://msdn.microsoft.com/en-us/library/h343ddh9.aspx"><code>System.Random</code></a> is not stable (because itis generation behavior may change in the future).</li>
</ul>

<p><a id=Seedable_PRNG_Recommendations></a></p>

<h3>Seedable PRNG Recommendations</h3>

<p>Which PRNG to use for generating reproducible results depends on the application. But here are some recommendations:</p>

<ul>
<li> Any PRNG algorithm selected for producing reproducible results should meet or exceed the quality requirements of a statistical-random implementation, and should be reasonably fast.</li>
<li> The PRNG&#39;s <em>state length</em> should be 64 bits or greater.</li>
<li> Any seed passed to the PRNG should be at least the same size as the PRNG&#39;s <em>state length</em>.</li>
</ul>

<p><a id=Examples_2></a></p>

<h3>Examples</h3>

<p>Custom seeds can come into play in the following situations, among others.</p>

<p><a id=Games></a></p>

<h4>Games</h4>

<p>Many kinds of games generate game content using apparently-random principles, such as&mdash;</p>

<ul>
<li>procedurally generated maps for a role-playing game,</li>
<li><a href="#Shuffling">shuffling</a> a digital deck of cards for a solitaire game, or</li>
<li>a game board or puzzle board that normally varies every session,</li>
</ul>

<p>where the game might need to generate the same content of that kind multiple times.</p>

<p>In general, such a game should use a PRNG with a custom seed for such purposes only if&mdash;</p>

<ol>
<li>generating the random content uses relatively many random numbers (say, more than a few thousand), and the application finds it impractical to store or distribute the content or the numbers for later use (see recommendations 2 and 3), or</li>
<li>the game makes the seed (or a &quot;code&quot; or &quot;password&quot; based on the seed, such as a barcode or a string of letters and digits) accessible to the player, to allow the player to generate the level or state repeatedly (see recommendations 2 and 3).</li>
</ol>

<p>Option 1 often applies to games that generate procedural terrain for game levels, since the terrain often exhibits random variations over an extended space.  Option 1 is less suitable for puzzle game boards or card shuffling, since much less data needs to be stored.</p>

<p><a id=Unit_Testing></a></p>

<h4>Unit Testing</h4>

<p>A custom seed is appropriate when unit testing a method that uses a seeded PRNG in place of another kind of RNG for the purpose of the test (provided the method meets recommendation 5).</p>

<p><a id=Verifiable_Random_Numbers></a></p>

<h4>Verifiable Random Numbers</h4>

<p><em>Verifiable random numbers</em> are random numbers (such as seeds for PRNGs) that are disclosed along with all the information required to verify their generation.  Usually, of the information used to derive such numbers, at least some of it is not known by anyone until some time after the announcement is made that those numbers will be generated, but all of it will eventually be publicly available.  In some cases, some of the information required to verify the numbers&#39; generation is disclosed in the announcement that those numbers will be generated.</p>

<p>One process to generate verifiable random numbers is described in <a href="https://www.rfc-editor.org/rfc/rfc3797.txt">RFC 3797</a> (to the extent its advice is not specific to the Internet Engineering Task Force or its Nominations Committee).  Although the source code given in that RFC uses the MD5 algorithm, the process does not preclude the use of hash algorithms stronger than MD5 (see the last paragraph of section 3.3 of that RFC).</p>

<p><a id=Noise></a></p>

<h4>Noise</h4>

<p>Randomly generated numbers can serve as <em>noise</em>, that is, a randomized variation in images and sound.  There are two kinds of noise generation methods:</p>

<ol>
<li><a href="https://en.wikipedia.org/wiki/Colors_of_noise">Colored noise</a>, such as white noise and pink noise. Here, the same RNG recommendations apply to these functions as they do to most other cases.<sup>(2)</sup></li>
<li><em>Noise functions</em>, including <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> and <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion">fractional Brownian motion</a>, output one or more random numbers given an <em>n</em>-dimensional point as input. Although noise functions don&#39;t take seeds themselves, the core of a noise function can be an RNG that converts an <em>n</em>-dimensional point to a seed for a PRNG, then uses the PRNG to generate a random number.  The noise function&#39;s PRNG should follow the <a href="#Seedable_PRNG_Recommendations">seedable PRNG recommendations</a> if the <a href="#Seeding_Recommendations">seeding recommendations</a> apply to the noise generation or if the PRNG is not used solely to generate noise; otherwise, that PRNG need only be as strong as required to achieve the desired effect.  However, noise functions (rather than other RNGs) ought to be used only if it&#39;s not feasible to achieve the randomized variation without them.</li>
</ol>

<p><a id=Programming_Language_APIs></a></p>

<h2>Programming Language APIs</h2>

<p>The following table lists techniques, methods, and functions that implement
unpredictable-random and statistical-random RNGs for popular programming languages. Note the following:</p>

<ul>
<li>For both kinds of generators it&#39;s encouraged to create a single instance of the RNG on application startup and use that instance throughout the application (if the application is multithreaded, the instance ought to be thread-safe).</li>
<li>Methods and libraries mentioned in the &quot;Statistical-random&quot; column need to be initialized with a full-length seed before use (for example, a seed generated using an implementation in the &quot;Unpredictable-random&quot; column).</li>
<li>The mention of a third-party library in this section does not imply sponsorship or endorsement
of that library, or imply a preference of that library over others. The list is not comprehensive.</li>
</ul>

<table><thead>
<tr>
<th>Language</th>
<th>Unpredictable-random</th>
<th>Statistical-random</th>
<th>Other</th>
</tr>
</thead><tbody>
<tr>
<td>C/C++</td>
<td>(C)</td>
<td><a href="http://xoroshiro.di.unimi.it/xoroshiro128plus.c"><code>xoroshiro128plus.c</code></a> (128-bit nonzero seed); <a href="http://xoroshiro.di.unimi.it/xorshift128plus.c"><code>xorshift128plus.c</code></a> (128-bit nonzero seed)</td>
<td></td>
</tr>
<tr>
<td>Python</td>
<td><code>secrets.SystemRandom</code> (since Python 3.6); <code>os.urandom()</code></td>
<td><a href="https://github.com/ihaque/xorshift">ihaque/xorshift</a> library (128-bit nonzero seed; default seed uses <code>os.urandom()</code>)</td>
<td><code>random.getrandbits()</code> (A); <code>random.seed()</code> (19,936-bit seed) (A)</td>
</tr>
<tr>
<td>Java (D)</td>
<td>(C); <code>java.security.SecureRandom</code> (F)</td>
<td><a href="https://github.com/grunka/xorshift">grunka/xorshift</a> (<code>XORShift1024Star</code> or <code>XORShift128Plus</code>)</td>
<td></td>
</tr>
<tr>
<td>JavaScript</td>
<td><code>crypto.randomBytes(byteCount)</code> (node.js only)</td>
<td><a href="https://github.com/AndreasMadsen/xorshift"><code>xorshift</code></a> library</td>
<td><code>Math.random()</code> (floating-point) (B)</td>
</tr>
<tr>
<td>Ruby</td>
<td>(C); <code>SecureRandom</code> class (<code>require &#39;securerandom&#39;</code>)</td>
<td></td>
<td><code>Random#rand()</code> (floating-point) (A) (E); <code>Random#rand(N)</code> (integer) (A) (E); <code>Random.new(seed)</code> (default seed uses entropy)</td>
</tr>
</tbody></table>

<p>(A) Default general RNG implements the <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a>, which doesn&#39;t
meet the statistical-random requirements, strictly speaking, but may be adequate for many applications due to its extremely long period.</p>

<p>(B) JavaScript&#39;s <code>Math.random</code> is implemented using <code>xorshift128+</code> in the latest V8 engine, Firefox, and certain other modern browsers at the time of writing; the exact algorithm to be used by JavaScript&#39;s <code>Math.random</code> is &quot;implementation-dependent&quot;, though, according to the ECMAScript specification.</p>

<p>(C) Read from the <code>/dev/urandom</code> and/or <code>/dev/random</code> devices in Unix-based systems (both devices can generally be read from in the same way as disk files), or call the <code>CryptGenRandom</code> API in Windows-based systems (see <a href="#Advice_for_New_Programming_Language_APIs">&quot;Advice for New Programming Language APIs&quot;</a>).</p>

<p>(D) Java&#39;s <code>java.util.Random</code> class uses a 48-bit seed, so doesn&#39;t meet the statistical-random requirements.  However, a subclass of <code>java.util.Random</code> might be implemented to meet those requirements.</p>

<p>(E) In my opinion, Ruby&#39;s <code>Random#rand</code> method presents a beautiful and simple API for random number generation.</p>

<p>(F) At least in Unix-based systems, calling the <code>SecureRandom</code> constructor that takes a byte array is recommended. The byte array should be data described in note (C).</p>

<p><a id=Advice_for_New_Programming_Language_APIs></a></p>

<h2>Advice for New Programming Language APIs</h2>

<p>Wherever possible, existing libraries or techniques that already meet the requirements for unpredictable-random and statistical-random RNGs should be used.  For example:</p>

<ul>
<li>An unpredictable-random implementation can read from the <code>/dev/urandom</code> and/or <code>/dev/random</code> devices in Unix-based systems, or call the <code>CryptGenRandom</code> API in Windows-based systems, and only use other techniques if the existing solutions are inadequate in certain respects or in certain circumstances.</li>
<li>A statistical-random implementation can use a PRNG algorithm mentioned as an example in the <a href="#Statistical_Random_Generators">statistical-random generator</a> section.</li>
</ul>

<p>If existing solutions are inadequate, a programming language API could implement unpredictable-random and statistical-random RNGs by filling an output byte buffer with random bytes, where each bit in each byte will be randomly set to 0 or 1.  For instance, a C language API for unpredictable-random generators could look like the following: <code>int random(uint8_t[] bytes, size_t size);</code>, where &quot;bytes&quot; is a pointer to a byte array, and &quot;size&quot; is the number of random bytes to generate, and where 0 is returned if the method succeeds and nonzero otherwise. Any programming language API that implements such RNGs by filling a byte buffer must run in amortized linear time on the number of random bytes the API will generate.</p>

<p>Unpredictable-random and statistical-random implementations&mdash;</p>

<ul>
<li>should be reasonably fast for most applications, and</li>
<li>should be safe for concurrent use by multiple threads, whenever convenient.</li>
</ul>

<p>In my opinion, a new programming language&#39;s standard library should include&mdash;</p>

<ul>
<li>a method that returns a random integer 0 or greater and less than a positive integer, and</li>
<li>a method that returns a floating-point number 0 or greater and less than 1,</li>
</ul>

<p>and should include those two methods separately for unpredictable-random generators and for statistical RNGs. However, a detailed discussion of how to implement those two methods or other methods to generate random numbers or integers that follow a given distribution (such as a normal, geometric, binomial, or discrete weighted
distribution) or fall within a given range is outside the scope of this page;  I have written about this in <a href="https://peteroupc.github.io/randomfunc.html">another document</a>.</p>

<p><a id=Shuffling></a></p>

<h2>Shuffling</h2>

<p>There are special considerations in play when applications use RNGs to shuffle a list of items.</p>

<p><a id=Shuffling_Method></a></p>

<h3>Shuffling Method</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle">Fisher-Yates shuffle method</a> shuffles a list such that all permutations of that list are equally likely to occur, assuming the RNG it uses produces uniformly random numbers and can generate all permutations of that list.  However, that method is also easy to mess up (see also Jeff Atwood, &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/">The danger of na&iuml;vet&eacute;</a>&quot;); I give a correct implementation in <a href="https://peteroupc.github.io/randomfunc.html">another document</a>.</p>

<p><a id=Generating_Every_Permutation></a></p>

<h3>Choosing from Among All Permutations</h3>

<p>If a pseudorandom number generator&#39;s period is less than the number of distinct permutations (arrangements) of a list, then there are some permutations that PRNG can&#39;t choose when it shuffles that list. (This is not the same as <em>generating</em> all permutations of a list, which, for a sufficiently large list size, can&#39;t be done by any computer in a reasonable time.)</p>

<p>The number of distinct permutations is the <a href="http://mathworld.wolfram.com/MultinomialCoefficient.html">multinomial coefficient</a> <em>m</em>! / (<em>w</em><sub>1</sub>! &times; <em>w</em><sub>2</sub>! &times; ... &times; <em>w</em><sub><em>n</em></sub>!), where <em>m</em> is the list&#39;s size, <em>n</em> is the number of different items in the list, <em>x</em>! means &quot;<em>x</em> <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a>&quot;, and <em>w</em><sub><em>i</em></sub> is the number of times the item identified by <em>i</em> appears in the list. Special cases of this are&mdash;</p>

<ul>
<li><em>n</em>!, if the list consists of <em>n</em> different items, and</li>
<li>(<em>nm</em>)! / <em>m</em>!<sup><em>n</em></sup>, if the list is formed from <em>m</em> identical lists each with <em>n</em> different items.</li>
</ul>

<p>In general, a PRNG with state length <em>k</em> bits, as shown in the table below, can&#39;t choose from among all the distinct permutations of a list with more items than the given maximum list size (<em>k</em> is the base-2 logarithm of <em>n</em>!, rounded up to an integer). (Note that a PRNG with state length <em>k</em> bits can&#39;t have a period greater than 2<sup><em>k</em></sup>, so can&#39;t choose from among more than 2<sup><em>k</em></sup> permutations.)</p>

<table><thead>
<tr>
<th>State length (<em>k</em>)</th>
<th>Maximum list size (<em>n</em>)</th>
</tr>
</thead><tbody>
<tr>
<td>64</td>
<td>20</td>
</tr>
<tr>
<td>128</td>
<td>34</td>
</tr>
<tr>
<td>226</td>
<td>52</td>
</tr>
<tr>
<td>256</td>
<td>72</td>
</tr>
</tbody></table>

<p>A PRNG with state length less than the number of bits given below (<em>k</em>) can&#39;t choose from among all the distinct permutations of a list formed from <em>m</em> identical lists each with <em>n</em> different items, as shown in this table  (<em>k</em> is the base-2 logarithm of ((<em>nm</em>)! / <em>m</em>!<sup><em>n</em></sup>), rounded up to an integer).</p>

<table><thead>
<tr>
<th>Number of lists (<em>m</em>)</th>
<th>Items per list (<em>n</em>)</th>
<th>Minimum state length (<em>k</em>)</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>20</td>
<td>62</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>140</td>
</tr>
<tr>
<td>4</td>
<td>20</td>
<td>304</td>
</tr>
<tr>
<td>1</td>
<td>52</td>
<td>226</td>
</tr>
<tr>
<td>2</td>
<td>52</td>
<td>500</td>
</tr>
<tr>
<td>4</td>
<td>52</td>
<td>1069</td>
</tr>
<tr>
<td>1</td>
<td>60</td>
<td>273</td>
</tr>
<tr>
<td>2</td>
<td>60</td>
<td>601</td>
</tr>
<tr>
<td>4</td>
<td>60</td>
<td>1282</td>
</tr>
</tbody></table>

<p>An application concerned about being able to choose from among all the distinct permutations of a shuffled list (and not just from among some of them) would be well advised&mdash;</p>

<ul>
<li>to use an unpredictable-random implementation, or</li>
<li>if speed is a concern and computer and information security is not, to use a PRNG&mdash;

<ul>
<li>that meets or exceeds the quality requirements of a statistical-random implementation,</li>
<li>that has a period at least as high as the number of permutations of the list to be shuffled, and</li>
<li>that was initialized automatically with an <em>unpredictable seed</em> before use.</li>
</ul></li>
</ul>

<p>(See &quot;Lack of randomness&quot; in the <a href="https://sater.home.xs4all.nl/doc.html">BigDeal document by van Staveren</a> for further discussion.)</p>

<p><a id=Motivation></a></p>

<h2>Motivation</h2>

<p>In this document, I made the distinction between <em>statistical-random</em> and <em>unpredictable-random</em> generators because that is how programming languages often present random number generators &mdash; they usually offer a general-purpose RNG (such as C&#39;s <code>rand</code> or Java&#39;s <code>java.util.Random</code>) and sometimes an RNG intended for security purposes (such as <code>java.security.SecureRandom</code>).</p>

<p>What has motivated me to write a more rigorous definition of random number generators is the fact that many applications still use weak RNGs.  In my opinion, this is largely because most popular programming languages today&mdash;</p>

<ul>
<li>specify few and weak requirements on RNGs (such as C&#39;s <code>rand</code>),</li>
<li>specify a relatively weak general-purpose RNG (such as Java&#39;s <code>java.math.Random</code>, although it also includes a much stronger <code>SecureRandom</code> class),</li>
<li>implement RNGs by default that leave a bit to be desired (particularly the Mersenne Twister algorithm found in PHP&#39;s <code>mt_rand</code> as well as in Python and Ruby),</li>
<li>seed RNGs with a timestamp by default (such as the <a href="https://msdn.microsoft.com/en-us/library/h343ddh9.aspx">.NET Framework implementation of <code>System.Random</code></a>), and/or</li>
<li>leave the default seeding fixed (such as <a href="http://en.cppreference.com/w/cpp/numeric/random/rand">C&#39;s <code>rand</code></a>).</li>
</ul>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>In conclusion, most applications that require random numbers usually want either unpredictability (cryptographic security), or speed and high quality. I believe that RNGs that meet the descriptions specified in the <a href="#Unpredictable_Random_Generators">Unpredictable-Random Generators</a> and <a href="#Statistical_Random_Generators">Statistical-Random Generators</a> sections will meet the needs of those applications.</p>

<p>In addition, this document recommends using unpredictable-random implementations in many cases, especially in computer and information security contexts, and recommends easier programming interfaces for both unpredictable-random and statistical-random implementations in new programming languages.</p>

<p>I acknowledge&mdash;</p>

<ul>
<li>the commenters to the CodeProject version of this page, including Cryptonite, and</li>
<li>Lee Daniel Crocker, who reviewed this document and gave comments.</li>
</ul>

<p><a id=Request_for_Comments></a></p>

<h3>Request for Comments</h3>

<p>Feel free to send comments. They may help improve this page.</p>

<p>Comments on any aspect of the document are welcome, but answers to the following would be particularly appreciated.</p>

<ul>
<li> Have I characterized the randomness needs of applications properly?</li>
<li> Did I cover the vast majority of applications that require randomness?</li>
<li> Are there existing programming language APIs or software libraries, not mentioned in this document, that already meet the requirements for unpredictable-random or statistical-random RNGs?</li>
<li> Are there certain kinds of applications that require a different kind of RNG (unpredictable-random, statistical-random, seeded, etc.) than I recommended?</li>
<li>In a typical computer a consumer would have today:

<ul>
<li>How many random numbers per second would an unpredictable-random implementation generate? A statistical-random implementation?</li>
<li>How many random numbers per second does a typical application using RNGs generate? Are there applications that usually generate considerably more random numbers than that per second?</li>
</ul></li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><sup>(1)</sup> This statement appears because multiple instances of a PRNG automatically seeded with a timestamp, when they are created at about the same time, run the risk of starting with the same seed and therefore generating the same sequence of random numbers.</p>

<p><sup>(2)</sup> This is because usual implementations of colored noise don&#39;t sample each point of the sample space more than once; rather, all the samples are generated, then, for some kinds of colored noise, a filter is applied to the samples.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="http://creativecommons.org/licenses/publicdomain/">A Public Domain dedication</a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
