<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generator Recommendations for Applications</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generator Recommendations for Applications</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>Begun on Mar. 5, 2016; last updated on Jul. 2, 2018.</p>

<p>Most apps that use random numbers care about either unpredictability or speed/high quality.</p>

<p><a id=Introduction_and_Summary></a></p>

<h2>Introduction and Summary</h2>

<p>Many applications rely on random number generators (RNGs); these RNGs include&mdash;</p>

<ul>
<li><em>statistical RNGs</em>, which seek to generate numbers that follow a uniform random distribution,</li>
<li><em>cryptographic RNGs</em>, which seek to generate numbers that are cost-prohibitive to predict, and</li>
<li><em>seeded PRNGs</em> (pseudorandom number generators), which generate numbers that &quot;seem&quot; random given an initial &quot;seed&quot;.</li>
</ul>

<p><strong>This document covers:</strong></p>

<ul>
<li>Statistical and cryptographic RNGs, as well as recommendations on their use and properties.</li>
<li>A discussion on when an application that needs numbers that &quot;seem&quot; random should specify their own &quot;seed&quot; (the initial state that the numbers are based on).</li>
<li>An explanation of what programming language interfaces implement statistical and cryptographic RNGs, as well as advice on implementing them in programming languages.</li>
<li>Issues on shuffling with an RNG.</li>
</ul>

<p><strong>This document does not cover:</strong></p>

<ul>
<li>Testing an RNG implementation for correctness or adequate random number generation.</li>
<li>Generation of random numbers or keying material based at least in part on a password.</li>
<li>Applications for which the selection of RNGs is constrained by statutory or regulatory requirements.</li>
</ul>

<p><strong>The following table summarizes the kinds of RNGs covered in this document:</strong></p>

<table><thead>
<tr>
<th>Kind of RNG</th>
<th>When to Use This RNG</th>
<th>Examples</th>
</tr>
</thead><tbody>
<tr>
<td><a href="#Cryptographic_RNGs"><strong>Cryptographic RNG</strong></a></td>
<td>In information security cases, or when speed is not a concern.</td>
<td><code>/dev/urandom</code>, <code>BCryptGenRandom</code></td>
</tr>
<tr>
<td><a href="#Statistical_RNGs"><strong>Statistical RNG</strong></a></td>
<td>When information security is not a concern, but speed is.  See also <a href="#Shuffling"><strong>&quot;Shuffling&quot;</strong></a>.</td>
<td><code>xoroshiro128+</code>, <code>xorshift128+</code></td>
</tr>
<tr>
<td><a href="#Seeded_PRNGs"><strong>Seeded PRNG</strong></a></td>
<td>When generating reproducible results in a way not practical otherwise.</td>
<td>High-quality PRNG with custom seed</td>
</tr>
</tbody></table>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction_and_Summary"><strong>Introduction and Summary</strong></a></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Definitions"><strong>Definitions</strong></a></li>
<li><a href="#Cryptographic_RNGs"><strong>Cryptographic RNGs</strong></a>

<ul>
<li><a href="#Quality"><strong>Quality</strong></a></li>
<li><a href="#Seeding_and_Reseeding"><strong>Seeding and Reseeding</strong></a></li>
<li><a href="#Nondeterministic_Sources"><strong>Nondeterministic Sources</strong></a></li>
<li><a href="#Examples"><strong>Examples</strong></a></li>
</ul></li>
<li><a href="#Statistical_RNGs"><strong>Statistical RNGs</strong></a>

<ul>
<li><a href="#Quality_2"><strong>Quality</strong></a></li>
<li><a href="#Seeding_and_Reseeding_2"><strong>Seeding and Reseeding</strong></a></li>
<li><a href="#Examples_and_Non_Examples"><strong>Examples and Non-Examples</strong></a></li>
</ul></li>
<li><a href="#Seeded_PRNGs"><strong>Seeded PRNGs</strong></a>

<ul>
<li><a href="#Seeding_Recommendations"><strong>Seeding Recommendations</strong></a></li>
<li><a href="#Recommendations_for_Seeded_PRNGs"><strong>Recommendations for Seeded PRNGs</strong></a></li>
<li><a href="#Examples_2"><strong>Examples</strong></a>

<ul>
<li><a href="#Games"><strong>Games</strong></a></li>
<li><a href="#Unit_Testing"><strong>Unit Testing</strong></a></li>
<li><a href="#Verifiable_Random_Numbers"><strong>Verifiable Random Numbers</strong></a></li>
<li><a href="#Noise"><strong>Noise</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#Programming_Language_APIs"><strong>Programming Language APIs</strong></a></li>
<li><a href="#Advice_for_New_Programming_Language_APIs"><strong>Advice for New Programming Language APIs</strong></a></li>
<li><a href="#Shuffling"><strong>Shuffling</strong></a>

<ul>
<li><a href="#Shuffling_Method"><strong>Shuffling Method</strong></a></li>
<li><a href="#Choosing_from_Among_All_Permutations"><strong>Choosing from Among All Permutations</strong></a></li>
</ul></li>
<li><a href="#Hash_Functions"><strong>Hash Functions</strong></a></li>
<li><a href="#GPU_Programming_Environments"><strong>GPU Programming Environments</strong></a></li>
<li><a href="#Motivation"><strong>Motivation</strong></a></li>
<li><a href="#Conclusion"><strong>Conclusion</strong></a>

<ul>
<li><a href="#Request_for_Comments"><strong>Request for Comments</strong></a></li>
</ul></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Definitions></a></p>

<h2>Definitions</h2>

<p>The following definitions are helpful in better understanding this document.</p>

<ul>
<li><strong>Random number generator (RNG).</strong> Software and/or hardware that seeks to generate independent numbers that seem to occur by chance and that are approximately uniformly distributed<sup><a href="#Note1"><strong>(1)</strong></a></sup>.</li>
<li><strong>Pseudorandom number generator (PRNG).</strong> A random number generator that outputs seemingly random numbers using a deterministic algorithm (that is, an algorithm that returns the same output for the same input and state every time), and in which its state can be initialized and possibly reinitialized with arbitrary data.</li>
<li><strong>Seed.</strong>  Arbitrary data for initializing the state of a PRNG.</li>
<li><strong>State length.</strong>  The maximum size of the seed a PRNG can take to initialize its state without shortening or compressing that seed.</li>
<li><strong>Period.</strong> The maximum number of values in a generated sequence for a PRNG before that sequence repeats.  The period will not be greater than 2<sup><em>L</em></sup> where <em>L</em> is the PRNG&#39;s <em>state length</em>.</li>
<li><strong>Stable.</strong> A programming interface is <em>stable</em> if it has no behavior that is unspecified, implementation-dependent, nondeterministic, or subject to future change.</li>
<li><strong>Information security.</strong> Defined in ISO/IEC 27000.</li>
<li><strong>Nondeterministic source.</strong> Data source that does not always return the same output for the same input.</li>
</ul>

<p><a id=Cryptographic_RNGs></a></p>

<h2>Cryptographic RNGs</h2>

<p>Cryptographic RNGs (also known as &quot;cryptographically strong&quot; or &quot;cryptographically secure&quot; RNGs) seek to generate random numbers that are cost-prohibitive to predict.  Such RNGs are indispensable in information security contexts, such as&mdash;</p>

<ul>
<li> generating keying material, such as encryption keys,</li>
<li> generating random passwords, nonces, or session identifiers,</li>
<li> generating &quot;salts&quot; to vary hash codes of the same password,</li>
<li> use in communications between two networked computers (including in data transfer, data transport, and messaging), and</li>
<li> cases (such as in multiplayer networked games) when predicting future random numbers would give a player or user a significant and unfair advantage.</li>
</ul>

<p>They are also useful when the application generates random numbers so infrequently that the RNG&#39;s speed is not a concern.</p>

<p><a id=Quality></a></p>

<h3>Quality</h3>

<p>A cryptographic RNG implementation generates uniformly distributed random bits such that it would be at least cost-prohibitive for an outside party to guess either prior or future unseen bits of the random sequence correctly with more than a 50% chance per bit, even with knowledge of the randomness-generating procedure, the implementation&#39;s internal state at the given point in time, and/or extremely many outputs of the RNG. (If the sequence was generated directly by a PRNG, ensuring future bits are unguessable this way should be done wherever the implementation finds it feasible; for example, see &quot;Seeding and Reseeding&quot;.)</p>

<p><a id=Seeding_and_Reseeding></a></p>

<h3>Seeding and Reseeding</h3>

<p>If a cryptographic RNG implementation uses a PRNG, the following requirements apply.</p>

<p>The PRNG&#39;s <em>state length</em> must be at least 128 bits and should be at least 256 bits.  The <em>security strength</em> used by the RNG must be at least 112 bits, should be at least 128 bits, and may equal the PRNG&#39;s <em>state length</em>.</p>

<p>Before an instance of the RNG generates a random number, it must have been initialized (&quot;seeded&quot;) with a seed defined as follows. The seed&mdash;</p>

<ul>
<li>must have as many bits as the PRNG&#39;s <em>state length</em>,</li>
<li>must consist of data that ultimately derives from the output of one or more nondeterministic sources, where the output is at least as hard to predict as ideal random data with as many bits as the <em>security strength</em>, and</li>
<li>may be mixed with arbitrary data other than the seed as long as the result is no easier to predict.</li>
</ul>

<p>The RNG should be reseeded, using a newly generated seed as described earlier, to help ensure the unguessability of its output. If the implementation reseeds, it should do so as often as feasible (whenever doing so would not slow down applications undesirably).  If the RNG reseeds if it would generate more than a threshold number of bits without reseeding, that threshold should be 2<sup>67</sup> or less.</p>

<p><a id=Nondeterministic_Sources></a></p>

<h3>Nondeterministic Sources</h3>

<p>A cryptographic RNG ultimately relies on one or more <em>nondeterministic sources</em> for random number generation.<sup><a href="#Note2"><strong>(2)</strong></a></sup>  Examples of nondeterministic sources are&mdash;</p>

<ul>
<li>disk access timings,</li>
<li>keystroke timings,</li>
<li>thermal noise, and</li>
<li>the output generated with A. Seznec&#39;s technique called hardware volatile entropy gathering and expansion (HAVEGE), provided a high-resolution counter is available.</li>
</ul>

<p>A value called <em>entropy</em> measures how hard it is to predict a nondeterministic source&#39;s output, compared to ideal random data; this is generally the size in bits of the ideal random data.  (For example, a 64-bit output with 32 bits of entropy is as hard to predict as an ideal random 32-bit data block.)  NIST SP 800-90B recommends <em>min-entropy</em> as the entropy measure and also details how nondeterministic sources can be used for information security.</p>

<p>If a cryptographic RNG implementation uses a PRNG, the output of the strongest nondeterministic source used to derive a seed ought to have as many bits of entropy as the <em>security strength</em>.  If the implementation does not use a PRNG, the output of the strongest nondeterministic source used to derive an RNG output ought to have as many bits of entropy as the RNG output&#39;s size in bits.</p>

<p><a id=Examples></a></p>

<h3>Examples</h3>

<p>Examples of cryptographic RNG implementations include the following:</p>

<ul>
<li>The <code>/dev/random</code> device on many Unix-based operating systems, which generally uses only nondeterministic sources; however, in some implementations of the device it can block for seconds at a time, especially if not enough randomness is available.</li>
<li>The <code>/dev/urandom</code> device on many Unix-based operating systems, which often relies on both a PRNG and the same nondeterministic sources used by <code>/dev/random</code>.</li>
<li>The <code>BCryptGenRandom</code> method in recent versions of Windows. (An independent analysis, published in 2007, showed flaws in an earlier version of <code>CryptGenRandom</code>.)</li>
<li>Two-source extractors, multi-source extractors, or cryptographic <a href="#Hash_Functions"><strong>hash functions</strong></a> that take very hard-to-predict signals from two or more nondeterministic sources as input.</li>
<li>An RNG implementation complying with NIST SP 800-90A.  The SP 800-90 series goes into further detail on how RNGs appropriate for information security can be constructed, and inspired much of the &quot;Cryptographic RNGs&quot; section.</li>
</ul>

<p><a id=Statistical_RNGs></a></p>

<h2>Statistical RNGs</h2>

<p>Statistical RNGs are used, for example, in simulations, numerical integration, and many games to bring an element of chance and variation to the application, with the goal that each possible outcome is equally likely. However, statistical RNGs are generally suitable only if&mdash;</p>

<ul>
<li> information security is not involved, and</li>
<li> the application generates random numbers so frequently that it would slow down undesirably if a cryptographic RNG were used instead.</li>
</ul>

<p>If more than 20 items are being shuffled, a concerned application would be well advised to use alternatives to this kind of implementation (see <a href="#Shuffling"><strong>&quot;Shuffling&quot;</strong></a>).</p>

<p>A statistical RNG is usually implemented with a PRNG, but can also be implemented in a similar way as a cryptographic RNG provided it remains reasonably fast.</p>

<p><a id=Quality_2></a></p>

<h3>Quality</h3>

<p>A statistical RNG generates random bits, each of which is uniformly distributed independently of the other bits, at least for nearly all practical purposes.  If the implementation uses a PRNG, that PRNG algorithm must either satisfy the <em>one-way property</em> or be significantly more likely than not to pass all tests (other than MatrixRank and LinearComp) of <code>BigCrush</code>, part of L&#39;Ecuyer and Simard&#39;s &quot;TestU01&quot;. The RNG need not be perfectly equidistributed.</p>

<p><a id=Seeding_and_Reseeding_2></a></p>

<h3>Seeding and Reseeding</h3>

<p>If a statistical RNG implementation uses a PRNG, the following requirements apply.</p>

<p>The PRNG&#39;s <em>state length</em> must be at least 64 bits, should be at least 128 bits, and is encouraged to be as high as the implementation can go to remain reasonably fast for most applications.</p>

<p>Before an instance of the RNG generates a random number, it must have been initialized (&quot;seeded&quot;) with a seed described as follows. The seed&mdash;</p>

<ul>
<li>must have as many bits as the PRNG&#39;s <em>state length</em>,</li>
<li>must consist of data that ultimately derives from the output of one or more nondeterministic sources (for example, the system clock) and/or cryptographic RNGs, where the output is encouraged to cover a state space of at least as many bits as the PRNG&#39;s <em>state length</em><sup><a href="#Note3"><strong>(3)</strong></a></sup>, and</li>
<li>may be mixed with arbitrary data other than the seed.</li>
</ul>

<p>The implementation is encouraged to reseed itself from time to time (using a newly generated seed as described earlier), especially if the PRNG has a <em>state length</em> less than 238 bits.  If the RNG reseeds if it would generate more than a threshold number of values without reseeding, that threshold should be the PRNG&#39;s period&#39;s square root or less.</p>

<p><a id=Examples_and_Non_Examples></a></p>

<h3>Examples and Non-Examples</h3>

<p>Examples of statistical RNGs include the following:</p>

<ul>
<li><a href="http://xoshiro.di.unimi.it/xoshiro256starstar.c"><strong>xoshiro256 star star</strong></a> (state length 256 bits; nonzero seed).</li>
<li><code>xoroshiro128+</code> (state length 128 bits; nonzero seed &mdash; but see note in the <a href="http://xoshiro.di.unimi.it/xoroshiro128plus.c"><strong>source code</strong></a> about the lowest bit of the PRNG&#39;s outputs).</li>
<li><code>Lehmer128</code> (state length 128 bits).</li>
<li>XorShift* 128/64 (state length 128 bits; nonzero seed).</li>
<li>XorShift* 64/32 (state length 64 bits; nonzero seed).</li>
<li><code>JKISS</code> on top of page 3 of Jones 2010 (state length 128 bits; seed with four 32-bit nonzero pieces).</li>
<li>C++&#39;s <a href="http://www.cplusplus.com/reference/random/ranlux48/"><strong><code>std::ranlux48</code> engine</strong></a> (state length 577 bits; nonzero seed).</li>
</ul>

<p>The following also count as statistical RNGs, but are not preferred:</p>

<ul>
<li>Mersenne Twister shows a <a href="http://xoroshiro.di.unimi.it/#quality"><strong>systematic failure</strong></a> in <code>BigCrush</code>&#39;s LinearComp test. (See also S. Vigna, &quot;<a href="http://vigna.di.unimi.it/ftp/papers/xorshift.pdf"><strong>An experimental exploration of Marsaglia&#39;s <code>xorshift</code> generators, scrambled</strong></a>&quot;, as published in the <code>xoroshiro128+</code> website.)</li>
<li>PCG (<code>pcg32</code>, <code>pcg64</code>, and <code>pcg64_fast</code> classes), by Melissa O&#39;Neill. <a href="http://pcg.di.unimi.it/pcg.php"><strong>S. Vigna believes</strong></a> &quot;there is no reason to use PCG generators&quot; when better alternatives exist.</li>
</ul>

<p>Non-examples include the following:</p>

<ul>
<li>Any <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator"><strong>linear congruential generator</strong></a> with modulus 2<sup>63</sup> or less (such as <code>java.util.Random</code> and C++&#39;s <code>std::minstd_rand</code> and <code>std::minstd_rand0</code> engines) has a <em>state length</em> of less than 64 bits.</li>
</ul>

<p><a id=Seeded_PRNGs></a></p>

<h2>Seeded PRNGs</h2>

<p>In addition, some applications use pseudorandom number generators (PRNGs) to generate results based on apparent randomness, starting from a known initial state, or &quot;seed&quot;. Such applications usually care about reproducible results. (Note that in the definitions for <a href="#Cryptographic_RNGs"><strong>cryptographic</strong></a> and <a href="#Statistical_RNGs"><strong>statistical</strong></a> RNGs given earlier, the PRNGs involved are automatically seeded before use.)</p>

<p><a id=Seeding_Recommendations></a></p>

<h3>Seeding Recommendations</h3>

<p>An application should use a PRNG with a seed it specifies (rather than an automatically-initialized PRNG or another kind of RNG) only if&mdash;</p>

<ol>
<li>the initial state (the seed) which the &quot;random&quot; result will be generated from&mdash;

<ul>
<li>is hard-coded,</li>
<li>is derived from user-entered data,</li>
<li>is known to the application and was generated using a <a href="#Cryptographic_RNGs"><strong>cryptographic</strong></a> or <a href="#Statistical_RNGs"><strong>statistical</strong></a> RNG (as defined earlier),</li>
<li>is a <a href="#Verifiable_Random_Numbers"><strong>verifiable random number</strong></a> (as defined later), or</li>
<li>is based on a timestamp (but only if the reproducible result is not intended to vary during the time specified on the timestamp and within the timestamp&#39;s granularity; for example, a year/month/day timestamp for a result that varies only daily),</li>
</ul></li>
<li>the application might need to generate the same &quot;random&quot; result multiple times,</li>
<li>the application either&mdash;

<ul>
<li>makes the seed (or a &quot;code&quot; or &quot;password&quot; based on the seed) accessible to the user, or</li>
<li>finds it impractical to store or distribute the &quot;random&quot; numbers or results (rather than the seed) for later use, such as&mdash;

<ul>
<li>by saving the result to a file,</li>
<li>by storing the random numbers for the feature generating the result to &quot;replay&quot; later, or</li>
<li>by distributing the results or the random numbers to networked users as they are generated, and</li>
</ul></li>
</ul></li>
<li>any feature using that random number generation method to generate that &quot;random&quot; result will remain backward compatible with respect to the &quot;random&quot; results it generates, for as long as that feature is still in use by the application.</li>
</ol>

<p>Meeting recommendation 4 is aided by using <em>stable</em> PRNGs; see <a href="#Definitions"><strong>&quot;Definitions&quot;</strong></a> and the following examples:</p>

<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html"><strong><code>java.util.Random</code></strong></a> is stable.</li>
<li>The C <a href="http://en.cppreference.com/w/cpp/numeric/random/rand"><strong><code>rand</code> method</strong></a> is not stable (because the algorithm it uses is unspecified).</li>
<li>C++&#39;s random number distribution classes, such as <a href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"><strong><code>std::uniform_int_distribution</code></strong></a>, are not stable (because the algorithms they use are implementation-defined according to the specification).</li>
<li>.NET&#39;s <a href="https://docs.microsoft.com/dotnet/api/system.random"><strong><code>System.Random</code></strong></a> is not stable (because its generation behavior could change in the future).</li>
</ul>

<p><a id=Recommendations_for_Seeded_PRNGs></a></p>

<h3>Recommendations for Seeded PRNGs</h3>

<p>Which PRNG to use for generating reproducible results depends on the application. But as recommendations, any PRNG algorithm selected for producing reproducible results&mdash;</p>

<ul>
<li>should meet or exceed the quality requirements of a statistical RNG,</li>
<li>should be reasonably fast, and</li>
<li>should have a <em>state length</em> of 64 bits or greater.</li>
</ul>

<p><a id=Examples_2></a></p>

<h3>Examples</h3>

<p>Custom seeds can come into play in the following situations, among others.</p>

<p><a id=Games></a></p>

<h4>Games</h4>

<p>Many kinds of games generate game content based on apparent randomness, such as&mdash;</p>

<ul>
<li>procedurally generated maps for a role-playing game,</li>
<li><a href="#Shuffling"><strong>shuffling</strong></a> a digital deck of cards for a solitaire game, or</li>
<li>a game board or puzzle board that normally varies every session,</li>
</ul>

<p>where the game might need to generate the same content of that kind multiple times.</p>

<p>In general, such a game should use a PRNG with a custom seed for such purposes only if&mdash;</p>

<ol>
<li>generating the random content uses relatively many random numbers (say, more than a few thousand), and the application finds it impractical to store or distribute the content or the numbers for later use (see recommendations 2 and 3), or</li>
<li>the game makes the seed (or a &quot;code&quot; or &quot;password&quot; based on the seed, such as a barcode or a string of letters and digits) accessible to the player, to allow the player to regenerate the content (see recommendations 2 and 3).</li>
</ol>

<p>Option 1 often applies to games that generate procedural terrain for game levels, since the terrain often exhibits random variations over an extended space.  Option 1 is less suitable for puzzle game boards or card shuffling, since much less data needs to be stored.</p>

<blockquote>
<p><strong>Example:</strong> Suppose a game generates a map with random terrain and shows the player a &quot;code&quot; to generate that map. Under recommendation 4, the game&mdash;</p>

<ul>
<li>may change the algorithm it uses to generate random maps, but</li>
<li>should use, in connection with the new algorithm, &quot;codes&quot; that can&#39;t be confused with &quot;codes&quot; it used for previous algorithms, and</li>
<li>should continue to generate the same random map using an old &quot;code&quot; when the player enters it, even after the change to a new algorithm.</li>
</ul>
</blockquote>

<p><a id=Unit_Testing></a></p>

<h4>Unit Testing</h4>

<p>A custom seed is appropriate when unit testing a method that uses a seeded PRNG in place of another kind of RNG for the purpose of the test (provided the method meets recommendation 4).</p>

<p><a id=Verifiable_Random_Numbers></a></p>

<h4>Verifiable Random Numbers</h4>

<p><em>Verifiable random numbers</em> are random numbers (such as seeds for PRNGs) that are disclosed along with all the information necessary to verify their generation.  Usually, of the information used to derive such numbers&mdash;</p>

<ul>
<li>at least some of it is not known by anyone until some time after the announcement is made that those numbers will be generated, but all of it will eventually be publicly available, and</li>
<li>some of it can be disclosed in the announcement that those numbers will be generated.</li>
</ul>

<p>One process to generate verifiable random numbers is described in <a href="https://www.rfc-editor.org/rfc/rfc3797.txt"><strong>RFC 3797</strong></a> (to the extent its advice is not specific to the Internet Engineering Task Force or its Nominations Committee).  Although the source code given in that RFC uses the MD5 algorithm, the process does not preclude the use of <a href="#Hash_Functions"><strong>hash functions</strong></a> stronger than MD5 (see the last paragraph of section 3.3 of that RFC).</p>

<p><a id=Noise></a></p>

<h4>Noise</h4>

<p>Randomly generated numbers can serve as <em>noise</em>, that is, a randomized variation in images, sound, and other data.  (See also Red Blob Games, <a href="http://www.redblobgames.com/articles/noise/introduction.html"><strong>&quot;Noise Functions and Map Generation&quot;</strong></a>).  For the purposes of RNG recommendations, there are two kinds of noise:</p>

<ol>
<li><p><strong><em>Procedural noise</em></strong> is generated using a <em>noise function</em>, which is a function that outputs seemingly random numbers given an <em>n</em>-dimensional point and, optionally, additional data (such as gradients or hash values).<sup><a href="#Note4"><strong>(4)</strong></a></sup>  Procedural noise includes <a href="https://en.wikipedia.org/wiki/Cellular_noise"><strong>cellular noise</strong></a>, <a href="https://en.wikipedia.org/wiki/Value_noise"><strong>value noise</strong></a>, and <a href="https://en.wikipedia.org/wiki/Gradient_noise"><strong>gradient noise</strong></a> (such as <a href="https://en.wikipedia.org/wiki/Perlin_noise"><strong>Perlin noise</strong></a>).  Wherever feasible, procedural noise implementations should <strong>use an RNG to generate the additional data</strong> for the noise function in advance.  The additional data may be <strong>&quot;hard-coded&quot;</strong> instead if the <a href="#Seeding_Recommendations"><strong>seeding recommendations</strong></a> apply to the noise generation (treating the hard-coded data as the seed).  If the noise function <strong>incorporates a</strong> <a href="#Hash_Functions"><strong><em>hash function</em></strong></a>, that hash function should be reasonably fast, be <em>stable</em> (see <a href="#Definitions"><strong>&quot;Definitions&quot;</strong></a>), and have the so-called <em>avalanche property</em>.</p></li>
<li><p><strong><em>Nonprocedural noise</em></strong> is generated using the help of an RNG.  Nonprocedural noise includes <a href="https://en.wikipedia.org/wiki/Colors_of_noise"><strong>colored noise</strong></a> (including white noise and pink noise), periodic noise, and noise following a Gaussian or other <a href="https://peteroupc.github.io/randomfunc.html#Specific_Non_Uniform_Distributions"><strong>probability distribution</strong></a>.  For nonprocedural noise, the same considerations apply to any RNGs the noise implementation uses as in cases not involving noise.</p></li>
</ol>

<p><a id=Programming_Language_APIs></a></p>

<h2>Programming Language APIs</h2>

<p>The following table lists application programming interfaces (APIs) for
cryptographic and statistical RNGs for popular programming languages. Note the following:</p>

<ul>
<li>In single-threaded applications, for each kind of RNG, it&#39;s encouraged to create a single instance of the RNG on application startup and use that instance throughout the application.</li>
<li>In multithreaded applications, for each kind of RNG, it&#39;s encouraged to either&mdash;

<ul>
<li>create a single thread-safe instance of the RNG on application startup and use that instance throughout the application, or</li>
<li>store separate and independently-initialized instances of the RNG in thread-local storage, so that each thread accesses a different instance<sup><a href="#Note5"><strong>(5)</strong></a></sup> (this might not always be ideal for cryptographic RNG implementations)</li>
</ul></li>
<li>Methods and libraries mentioned in the &quot;Statistical&quot; column need to be initialized with a seed before use (for example, a seed generated using an implementation in the &quot;Cryptographic&quot; column).</li>
<li>The mention of a third-party library in this section does not imply sponsorship or endorsement
of that library, or imply a preference of that library over others. The list is not comprehensive.</li>
</ul>

<table><thead>
<tr>
<th>Language</th>
<th>Cryptographic</th>
<th>Statistical</th>
<th>Other</th>
</tr>
</thead><tbody>
<tr>
<td>C/C++ (G)</td>
<td>(C)</td>
<td><a href="http://xoroshiro.di.unimi.it/xoroshiro128plus.c"><strong><code>xoroshiro128plus.c</code></strong></a> (128-bit nonzero seed); <a href="http://xoroshiro.di.unimi.it/xorshift128plus.c"><strong><code>xorshift128plus.c</code></strong></a> (128-bit nonzero seed)</td>
<td></td>
</tr>
<tr>
<td>Python</td>
<td><code>secrets.SystemRandom</code> (since Python 3.6); <code>os.urandom()</code></td>
<td><a href="https://github.com/ihaque/xorshift"><strong>ihaque/xorshift</strong></a> library (128-bit nonzero seed; default seed uses <code>os.urandom()</code>)</td>
<td><code>random.getrandbits()</code> (A); <code>random.seed()</code> (19,936-bit seed) (A)</td>
</tr>
<tr>
<td>Java (D)</td>
<td>(C); <code>java.security.SecureRandom</code> (F)</td>
<td><a href="https://github.com/grunka/xorshift"><strong>grunka/xorshift</strong></a> (<code>XORShift1024Star</code> or <code>XORShift128Plus</code>)</td>
<td></td>
</tr>
<tr>
<td>JavaScript</td>
<td><code>crypto.randomBytes(byteCount)</code> (node.js only)</td>
<td><a href="https://github.com/AndreasMadsen/xorshift"><strong><code>xorshift</code></strong></a> library</td>
<td><code>Math.random()</code> (ranges from 0 through 1) (B)</td>
</tr>
<tr>
<td>Ruby</td>
<td>(C); <code>SecureRandom</code> class (<code>require &#39;securerandom&#39;</code>)</td>
<td></td>
<td><code>Random#rand()</code> (ranges from 0 through 1) (A) (E); <code>Random#rand(N)</code> (integer) (A) (E); <code>Random.new(seed)</code> (default seed uses nondeterministic data)</td>
</tr>
<tr>
<td>PHP</td>
<td><code>random_int()</code> (since PHP 7)</td>
<td></td>
<td><code>mt_rand()</code> (A)</td>
</tr>
</tbody></table>

<p><small></p>

<p>(A) General RNG implements <a href="https://en.wikipedia.org/wiki/Mersenne_Twister"><strong>Mersenne Twister</strong></a>, which is not preferred for a statistical RNG.  PHP&#39;s <code>mt_rand()</code> implements or implemented a flawed version of Mersenne Twister.</p>

<p>(B) JavaScript&#39;s <code>Math.random</code> is implemented using <code>xorshift128+</code> in the latest V8 engine, Firefox, and certain other modern browsers as of late 2017; the exact algorithm to be used by JavaScript&#39;s <code>Math.random</code> is &quot;implementation-dependent&quot;, though, according to the ECMAScript specification.</p>

<p>(C) See <a href="#Advice_for_New_Programming_Language_APIs"><strong>&quot;Advice for New Programming Language APIs&quot;</strong></a> for implementation notes for cryptographic RNG implementations.</p>

<p>(D) Java&#39;s <code>java.util.Random</code> class uses a 48-bit seed, so doesn&#39;t meet the statistical RNG requirements.  However, a subclass of <code>java.util.Random</code> might be implemented to meet those requirements.</p>

<p>(E) In my opinion, Ruby&#39;s <code>Random#rand</code> method presents a beautiful and simple API for random number generation.</p>

<p>(F) At least in Unix-based systems, calling the <code>SecureRandom</code> constructor that takes a byte array is recommended. The byte array should be data described in note (C).</p>

<p>(G) <a href="http://en.cppreference.com/w/cpp/numeric/random/random_device"><strong><code>std::random_device</code></strong></a>, introduced in C++11, is not recommended because its specification leaves considerably much to be desired.  For example,  <code>std::random_device</code> can fall back to a pseudorandom number generator of unspecified quality without much warning.</p>

<p></small></p>

<p><a id=Advice_for_New_Programming_Language_APIs></a></p>

<h2>Advice for New Programming Language APIs</h2>

<p>Wherever possible, applications should use existing libraries and techniques that already meet the requirements for cryptographic and statistical RNGs.  For example&mdash;</p>

<ul>
<li><p>a cryptographic RNG implementation can&mdash;</p>

<ul>
<li>read from the <code>/dev/urandom</code> and/or <code>/dev/random</code> devices in most Unix-based systems (using the <code>open</code> and <code>read</code> system calls where available),</li>
<li>call the <code>getentropy</code> method on OpenBSD, or</li>
<li>call the <code>BCryptGenRandom</code> API in recent Windows-based systems,</li>
</ul>

<p>and only use other techniques if the existing solutions are inadequate in certain respects or in certain circumstances, and</p></li>
<li>a statistical RNG implementation can use a PRNG algorithm mentioned as an example in the <a href="#Statistical_RNGs"><strong>statistical RNGs</strong></a> section.</li>
</ul>

<p>If existing solutions are inadequate, a programming language API could implement cryptographic and statistical RNGs by filling an output byte buffer with random bytes, where each bit in each byte will be randomly set to 0 or 1.  For instance, a C language API for such RNGs could look like the following: <code>int random(uint8_t[] bytes, size_t size);</code>, where &quot;bytes&quot; is a pointer to a byte array, and &quot;size&quot; is the number of random bytes to generate, and where 0 is returned if the method succeeds and nonzero otherwise. Any programming language API that implements such RNGs by filling a byte buffer ought to run in amortized linear time on the number of random bytes the API will generate.</p>

<p>Cryptographic and statistical RNG implementations&mdash;</p>

<ul>
<li>should be reasonably fast for most applications, and</li>
<li>should be safe for concurrent use by multiple threads, whenever convenient.</li>
</ul>

<p>My document on <a href="https://peteroupc.github.io/randomfunc.html"><strong>random number generation methods</strong></a> includes details on
ten uniform random number methods; in my opinion, a new programming language&#39;s standard library ought to include
those ten methods separately for cryptographic and for statistical RNGs. That document also
discusses how to implement other methods to generate random numbers or integers that follow a given distribution (such
as a normal, geometric, binomial, or discrete weighted distribution) or fall within a given range.</p>

<p><a id=Shuffling></a></p>

<h2>Shuffling</h2>

<p>There are special considerations in play when applications use RNGs to shuffle a list of items.</p>

<p><a id=Shuffling_Method></a></p>

<h3>Shuffling Method</h3>

<p>The first consideration touches on the shuffling method.  The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle"><strong>Fisher&ndash;Yates shuffle method</strong></a> does a substantially unbiased shuffle of a list, assuming the RNG it uses can choose from among all permutations of that list.  However, that method is also easy to mess up (see also Jeff Atwood, &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/"><strong>The danger of na&iuml;vet&eacute;</strong></a>&quot;); I give a correct implementation in <a href="https://peteroupc.github.io/randomfunc.html"><strong>another document</strong></a>.</p>

<p><a id=Choosing_from_Among_All_Permutations></a></p>

<h3>Choosing from Among All Permutations</h3>

<p>The second consideration is present if the application uses PRNGs for shuffling. If the PRNG&#39;s period is less than the number of distinct permutations (arrangements) of a list, then there are some permutations that PRNG can&#39;t choose when it shuffles that list. (This is not the same as <em>generating</em> all permutations of a list, which, for a sufficiently large list size, can&#39;t be done by any computer in a reasonable time.)</p>

<p>The number of distinct permutations is the <a href="http://mathworld.wolfram.com/MultinomialCoefficient.html"><strong>multinomial coefficient</strong></a> <em>m</em>! / (<em>w</em><sub>1</sub>! &times; <em>w</em><sub>2</sub>! &times; ... &times; <em>w</em><sub><em>n</em></sub>!), where <em>m</em> is the list&#39;s size, <em>n</em> is the number of different items in the list, <em>x</em>! means &quot;<em>x</em> <a href="https://en.wikipedia.org/wiki/Factorial"><strong>factorial</strong></a>&quot;, and <em>w</em><sub><em>i</em></sub> is the number of times the item identified by <em>i</em> appears in the list. (This reduces to <em>n</em>!, if the list consists of <em>n</em> different items.)</p>

<p>Formulas suggesting state lengths for PRNGs are implemented below in Python.  For example, to shuffle a 52-item list, a PRNG with state length 226 or more is suggested, and to shuffle two 52-item lists of identical contents together, a PRNG with state length 500 or more is suggested.</p>

<pre>def fac(x):
    &quot;&quot;&quot; Calculates factorial of x. &quot;&quot;&quot;
    if x&lt;=1: return 1
    ret=1
    for i in range(x): ret=ret*(i+1)
    return ret

def ceillog2(x):
    &quot;&quot;&quot; Calculates base-2 logarithm of x, rounded up. &quot;&quot;&quot;
    ret=0
    needCeil=True
    while x&gt;1:
       one=needCeil and ((x&amp;1)!=0)
       x=x&gt;&gt;1
       if one:
         ret+=1; needCeil=False
       ret+=1
    return ret

def stateLengthN(n):
  &quot;&quot;&quot; Suggested state length for PRNGs that shuffle
    a list of n items. &quot;&quot;&quot;
  return ceillog2(fac(n))

def stateLengthNChooseK(n, k):
  &quot;&quot;&quot; Suggested state length for PRNGs that choose k
   different items randomly from a list of n items
   (see RFC 3797, sec. 3.3) &quot;&quot;&quot;
  return ceillog2(fac(n)/(fac(k)*fac(n-k)))

def stateLengthDecks(numDecks, numCards):
  &quot;&quot;&quot; Suggested state length for PRNGs that shuffle
    multiple decks of cards in one. &quot;&quot;&quot;
  return ceillog2(fac(numDecks*numCards)/ \
      (fac(numDecks)**numCards))
</pre>

<p>Whenever a <a href="#Statistical_RNGs"><strong>statistical RNG implementation</strong></a> or <a href="#Seeded_PRNGs"><strong>seeded PRNG</strong></a> is otherwise called for, an application is encouraged to choose a PRNG with a state length suggested by the formulas above (and with the highest feasible period for that state length), where the choice of PRNG is based on&mdash;</p>

<ul>
<li>the maximum size of lists the application is expected to shuffle, if that number is less than 100; otherwise,</li>
<li>the average size of such lists; or, if the application chooses,</li>
<li>the application shuffling 100-item lists (which usually means a state length of 525 or greater).</li>
</ul>

<p>(Practically speaking, for sufficiently large list sizes, any given PRNG will not be able to randomly choose some permutations of the list.  See also &quot;Lack of randomness&quot; in the <a href="https://sater.home.xs4all.nl/doc.html"><strong>BigDeal document by van Staveren</strong></a>.)</p>

<p>The PRNG chosen this way should meet or exceed the quality requirements of a statistical RNG implementation.</p>

<p><a id=Hash_Functions></a></p>

<h2>Hash Functions</h2>

<p>A seemingly random number can be generated from arbitrary data using a <em>hash function</em>.</p>

<p>A <em>hash function</em> is a function that takes an arbitrary input of any size (such as a sequence of bytes or a sequence of characters) and returns an output with a fixed size. That output is also known as a <em>hash code</em>. (By definition, hash functions are deterministic.  The definition includes a PRNG that takes the input as a seed and outputs a random number of fixed size<sup><a href="#Note6"><strong>(6)</strong></a></sup>.)</p>

<p>A hash code can be used as follows:</p>

<ul>
<li>The hash code can serve as a seed for a PRNG, and the desired random numbers can be generated from that PRNG.  (See my document on <a href="https://peteroupc.github.io/randomfunc.html"><strong>random number generation methods</strong></a> for techniques.)</li>
<li>If a number of random bits is needed, and the hash code has at least that many bits, then that many bits can instead be taken directly from the hash code.</li>
</ul>

<p>For such purposes, applications should choose hash functions designed such that every bit of the input affects every bit of the output without a clear preference for 0 or 1 (the so-called <em>avalanche property</em>).  Hash functions used in information security contexts should be designed such that finding an unknown second input that leads to the same output as that of a given input is cost-prohibitive (the <em>one-way property</em>) and so is finding an unknown input that leads to a given output (<em>collision resistance</em>), and should have other information security properties depending on the application.</p>

<p><a id=GPU_Programming_Environments></a></p>

<h2>GPU Programming Environments</h2>

<p>Because, in general, GL Shading Language (GLSL) and other programming environments designed for execution on a graphics processing unit (GPU)&mdash;</p>

<ul>
<li>have limited access to some system resources compared with other programming environments,</li>
<li>are designed for parallel execution, and</li>
<li>do not store state,</li>
</ul>

<p>random number generators for such environments are often designed as <a href="#Hash_Functions"><strong>hash functions</strong></a>, because their output is determined solely by the input rather than both the input and state (as with PRNGs).  Moreover, some of the hash functions which have been written in GLSL give undesirable results in computers whose GPUs support only 16-bit binary floating point numbers and no other kinds of numbers, which makes such GPUs an important consideration when choosing a hash function.</p>

<p><a id=Motivation></a></p>

<h2>Motivation</h2>

<p>In this document, I made the distinction between <em>statistical</em> and <em>cryptographic</em> RNGs because that is how programming languages often present random number generators &mdash; they usually offer a general-purpose RNG (such as C&#39;s <code>rand</code> or Java&#39;s <code>java.util.Random</code>) and sometimes an RNG intended for information security purposes (such as <code>java.security.SecureRandom</code>).</p>

<p>What has motivated me to write a more rigorous definition of random number generators is the fact that many applications still use weak RNGs.  In my opinion, this is largely because most popular programming languages today&mdash;</p>

<ul>
<li>specify few and weak requirements on RNGs (such as <a href="http://en.cppreference.com/w/cpp/numeric/random/rand"><strong>C&#39;s <code>rand</code></strong></a>),</li>
<li>specify a relatively weak general-purpose RNG (such as Java&#39;s <code>java.math.Random</code>, although it also includes a much stronger <code>SecureRandom</code> class),</li>
<li>implement RNGs by default that leave something to be desired (particularly the Mersenne Twister algorithm found in PHP&#39;s <code>mt_rand</code> as well as in Python and Ruby),</li>
<li>seed RNGs with a timestamp by default (such as the <a href="https://docs.microsoft.com/dotnet/api/system.random"><strong>.NET Framework implementation of <code>System.Random</code></strong></a>), and/or</li>
<li>leave the default seeding fixed (as is the case in <a href="https://www.mathworks.com/help/matlab/examples/controlling-random-number-generation.html"><strong>MATLAB</strong></a>).</li>
</ul>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>Random numbers that merely &quot;look random&quot; are not enough for most applications.  That is why this document defines <a href="#Cryptographic_RNGs"><strong>cryptographic RNGs</strong></a> and <a href="#Statistical_RNGs"><strong>statistical RNGs</strong></a>; I believe RNGs that meet either category will fulfill the expectations of many applications as regards random numbers.  In general:</p>

<ul>
<li>For <em>statistical RNGs</em>, the random numbers not only &quot;look random&quot;, but are shown to behave like random numbers through statistical tests.</li>
<li>For <em>cryptographic RNGs</em>, the random numbers not only &quot;look random&quot;, but are virtually unpredictable.</li>
</ul>

<p>In addition, this document recommends using cryptographic RNGs in many cases, especially in information security contexts, and recommends easier programming interfaces for both cryptographic and statistical RNGs in new programming languages.</p>

<p>I acknowledge&mdash;</p>

<ul>
<li>the commenters to the CodeProject version of this page (as well as a similar article of mine on CodeProject), including &quot;Cryptonite&quot; and member 3027120, and</li>
<li>Lee Daniel Crocker, who reviewed this document and gave comments.</li>
</ul>

<p><a id=Request_for_Comments></a></p>

<h3>Request for Comments</h3>

<p>Feel free to send comments. They could help improve this page.</p>

<p>Comments on any aspect of the document are welcome, but answers to the following would be particularly appreciated.</p>

<ul>
<li> Have I characterized the randomness needs of applications properly?</li>
<li> Did I cover the vast majority of applications that require randomness?</li>
<li> Are there existing programming language APIs or software libraries, not mentioned in this document, that already meet the requirements for cryptographic or statistical RNGs?</li>
<li> Are there certain kinds of applications that require a different kind of RNG (cryptographic, statistical, seeded, etc.) than I recommended?</li>
<li>In a typical computer a consumer would have today, how many random numbers per second does a typical application using RNGs generate? Are there applications that usually generate considerably more random numbers than that per second?</li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> If the software and/or hardware uses a nonuniform distribution, but otherwise meets this definition, it can be converted to use a uniform distribution, at least in theory, using <em>unbiasing</em> or <em>randomness extraction</em> methods that it is outside the scope of this document to describe.</small></p>

<p><small><sup id=Note2>(2)</sup> Nondeterministic sources that are reasonably fast for most applications (for instance, by enabling very many seeds to be generated per second), especially sources implemented in hardware, are highly advantageous in a cryptographic RNG.</small></p>

<p><small><sup id=Note3>(3)</sup> Timestamps with millisecond or coarser granularity are not encouraged, however, because multiple instances of a PRNG automatically seeded with a timestamp, when they are created at about the same time, run the risk of starting with the same seed and therefore generating the same sequence of random numbers.</small></p>

<p><small><sup id=Note4>(4)</sup> Noise functions include functions that combine several outputs of a noise function, including by <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion"><strong>fractional Brownian motion</strong></a>.  By definition, noise functions are deterministic.</small></p>

<p><small><sup id=Note5>(5)</sup> An application that generates random numbers in parallel can also&mdash;</p>

<ul>
<li>use a different conforming RNG method for each instance, in addition to using independently-initialized instances, or</li>
<li>use a conforming RNG method specially designed for parallel random number generation,</li>
</ul>

<p>or both, to reduce the chance of correlations between the generated random numbers.</small></p>

<p><small><sup id=Note6>(6)</sup> Note that some PRNGs (such as <code>xorshift128+</code>) are not well suited to serve as hash functions, because they don&#39;t mix their state before generating a random number from that state.</small></p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = xExtra(document).getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
}
document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
