<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generator Recommendations for Applications</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generator Recommendations for Applications</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>Most apps that use random numbers care about either unpredictability, high quality, or repeatability.  This article explains the three kinds of RNGs and gives recommendations on each kind.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>Many applications rely on random number generators (RNGs);
however, it&#39;s not enough for random numbers to merely &quot;look random&quot;.  But unfortunately, most popular programming languages today&mdash;</p>

<ul>
<li>specify few and weak requirements on their built-in RNGs (such as <a href="http://en.cppreference.com/w/cpp/numeric/random/rand"><strong>C&#39;s <code>rand</code></strong></a>),</li>
<li>specify a relatively weak general-purpose RNG (such as Java&#39;s <code>java.math.Random</code>),</li>
<li>implement RNGs by default that leave something to be desired (such as Mersenne Twister),</li>
<li>initialize RNGs with a timestamp by default (such as the <a href="https://docs.microsoft.com/dotnet/api/system.random"><strong>.NET Framework implementation of <code>System.Random</code></strong></a>), and/or</li>
<li>use RNGs that are initialized with a fixed value by default (as is the case in <a href="https://www.mathworks.com/help/matlab/examples/controlling-random-number-generation.html"><strong>MATLAB</strong></a> and C<sup><a href="#Note1"><strong>(1)</strong></a></sup>),</li>
</ul>

<p>so that as a result, many applications use RNGs, especially built-in RNGs, that have little assurance of high quality or security.   That is why this document discusses high-quality RNGs and suggests <a href="#Existing_RNG_APIs_in_Programming_Languages"><strong>existing implementations</strong></a> of them.</p>

<p><strong>This document covers:</strong></p>

<ul>
<li>Cryptographic RNGs<sup><a href="#Note2"><strong>(2)</strong></a></sup>, noncryptographic RNGs, and manually-seeded RNGs, as well as recommendations on their use and properties.</li>
<li>Nondeterministic sources, entropy, and seed generation.</li>
<li>Existing implementations of RNGs.</li>
<li>Guidance for implementations of RNGs designed for reuse by applications.</li>
<li>Issues on shuffling with an RNG.</li>
</ul>

<p><strong>This document does not cover:</strong></p>

<ul>
<li>Testing an RNG implementation for correctness or adequate random number generation (e.g., DÃ¶rre and Klebanov 2016<sup><a href="#Note3"><strong>(3)</strong></a></sup>).</li>
<li>Generation of random numbers with unequal probabilities (<em>nonuniform</em> random numbers); I discuss this topic in <a href="https://peteroupc.github.io/randomfunc.html"><strong>another document</strong></a>.</li>
<li>Generators of low-discrepancy sequences (quasirandom sequences), such as Sobol sequences.  They are not RNGs since the numbers they produce depend on prior results.</li>
<li>Applications for which the selection of RNGs is limited by regulatory requirements.</li>
</ul>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/random.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/random.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document either on</strong> <a href="https://www.codeproject.com/Articles/1083372/Random-Number-Generator-Recommendations-for-Applic"><strong>CodeProject</strong></a> <strong>or on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction"><strong>Introduction</strong></a>

<ul>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
</ul></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Definitions"><strong>Definitions</strong></a></li>
<li><a href="#Summary"><strong>Summary</strong></a></li>
<li><a href="#Cryptographic_RNGs"><strong>Cryptographic RNGs</strong></a></li>
<li><a href="#Noncryptographic_PRNGs"><strong>Noncryptographic PRNGs</strong></a></li>
<li><a href="#Manually_Seeded_PRNGs"><strong>Manually-Seeded PRNGs</strong></a>

<ul>
<li><a href="#When_to_Use_a_Manually_Seeded_PRNG"><strong>When to Use a Manually-Seeded PRNG</strong></a></li>
<li><a href="#Manually_Seeded_PRNG_Recommendations"><strong>Manually-Seeded PRNG Recommendations</strong></a></li>
<li><a href="#Manually_Seeded_PRNG_Use_Cases"><strong>Manually-Seeded PRNG Use Cases</strong></a></li>
<li><a href="#Manually_Seeded_PRNGs_in_Games"><strong>Manually-Seeded PRNGs in Games</strong></a></li>
<li><a href="#Single_Random_Value"><strong>Single Random Value</strong></a></li>
</ul></li>
<li><a href="#Nondeterministic_Sources_and_Seed_Generation"><strong>Nondeterministic Sources and Seed Generation</strong></a>

<ul>
<li><a href="#What_Is_a_Nondeterministic_Source"><strong>What Is a Nondeterministic Source?</strong></a></li>
<li><a href="#What_Is_Entropy"><strong>What Is Entropy?</strong></a></li>
<li><a href="#Seed_Generation"><strong>Seed Generation</strong></a></li>
<li><a href="#Seed_Generation_for_Noncryptographic_PRNGs"><strong>Seed Generation for Noncryptographic PRNGs</strong></a>

<ul>
<li><a href="#Seeding_Multiple_Processes"><strong>Seeding Multiple Processes</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#Existing_RNG_APIs_in_Programming_Languages"><strong>Existing RNG APIs in Programming Languages</strong></a></li>
<li><a href="#RNG_Topics"><strong>RNG Topics</strong></a>

<ul>
<li><a href="#Shuffling"><strong>Shuffling</strong></a></li>
<li><a href="#Unique_Random_Identifiers"><strong>Unique Random Identifiers</strong></a></li>
<li><a href="#Determinism_and_Consistency"><strong>Determinism and Consistency</strong></a></li>
</ul></li>
<li><a href="#Hash_Functions"><strong>Hash Functions</strong></a>

<ul>
<li><a href="#Procedural_Noise_Functions"><strong>Procedural Noise Functions</strong></a></li>
<li><a href="#Pseudorandom_Functions"><strong>Pseudorandom Functions</strong></a></li>
</ul></li>
<li><a href="#Verifiable_Random_Numbers"><strong>Verifiable Random Numbers</strong></a></li>
<li><a href="#Guidelines_for_New_RNG_APIs"><strong>Guidelines for New RNG APIs</strong></a>

<ul>
<li><a href="#Cryptographic_RNGs_Requirements"><strong>Cryptographic RNGs: Requirements</strong></a></li>
<li><a href="#High_Quality_RNGs_Requirements"><strong>High-Quality RNGs: Requirements</strong></a>

<ul>
<li><a href="#High_Quality_PRNG_Examples"><strong>High-Quality PRNG Examples</strong></a></li>
</ul></li>
<li><a href="#Designs_for_PRNGs"><strong>Designs for PRNGs</strong></a></li>
<li><a href="#Implementing_New_RNG_APIs"><strong>Implementing New RNG APIs</strong></a></li>
</ul></li>
<li><a href="#Acknowledgments"><strong>Acknowledgments</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Suggested_Entropy_Size"><strong>Suggested Entropy Size</strong></a></li>
<li><a href="#Bays_ndash_Durham_Shuffle"><strong>Bays&ndash;Durham Shuffle</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
<li><a href="#License_2"><strong>License</strong></a></li>
</ul>

<p><a id=Definitions></a></p>

<h2>Definitions</h2>

<p>The following definitions are helpful in better understanding this document.</p>

<ul>
<li><strong>Random number generator (RNG).</strong> Software and/or hardware that seeks to generate numbers with the property that each possible outcome is as likely as any other without influence by anything else<sup><a href="#Note4"><strong>(4)</strong></a></sup>.</li>
<li><strong>Pseudorandom number generator (PRNG).</strong> A random number generator in which the numbers it generates are completely determined by its input.</li>
<li><strong>Seed.</strong>  Arbitrary data serving as a PRNG&#39;s input.</li>
<li><strong>Information security.</strong> Keeping information safe from attacks that could access, use, delay, or manipulate that information.<sup><a href="#Note5"><strong>(5)</strong></a></sup></li>
<li><strong>SHOULD, SHOULD NOT, MAY, RECOMMENDED, NOT RECOMMENDED.</strong>  These terms have the meanings given in RFC 2119 and RFC 8174.</li>
</ul>

<p><a id=Summary></a></p>

<h2>Summary</h2>

<ul>
<li>Does the application use random numbers for <strong>information security</strong> purposes (e.g., as passwords or other secrets)?

<ul>
<li>Yes: Use a <a href="#Cryptographic_RNGs"><strong>cryptographic RNG</strong></a>.</li>
</ul></li>
<li>No: Does the application require <a href="#When_to_Use_a_Manually_Seeded_PRNG"><strong>reproducible &quot;random&quot; numbers</strong></a>?

<ul>
<li>Yes: Use a manually-seeded high-quality PRNG.  If a seed is known, use it.  Otherwise, generate a fresh seed using a cryptographic RNG.

<ul>
<li>Does the application run <strong>multiple independent processes</strong> that use random numbers?

<ul>
<li>No: Seed one PRNG with the seed determined above.</li>
<li>Yes: Pass the seed determined above to each process as described in &quot;<a href="#Seed_Generation_for_Noncryptographic_PRNGs"><strong>Seed Generation for Noncryptographic PRNGs</strong></a>&quot;.</li>
</ul></li>
</ul></li>
</ul></li>
<li>No: Is a cryptographic RNG <strong>too slow</strong> for the application?

<ul>
<li>Yes: Use a <a href="#High_Quality_PRNG_Examples"><strong>high-quality PRNG</strong></a> with a seed generated using a cryptographic RNG.</li>
<li>No: Use a cryptographic RNG.</li>
</ul></li>
</ul>

<p><a id=Cryptographic_RNGs></a></p>

<h2>Cryptographic RNGs</h2>

<p>Cryptographic RNGs (also known as &quot;cryptographically strong&quot; or &quot;cryptographically secure&quot; RNGs) seek to generate random numbers that not only &quot;look random&quot;, but are cost-prohibitive to guess.  An application SHOULD use a cryptographic RNG whenever the application&mdash;</p>

<ul>
<li>generates random numbers for information security purposes, or</li>
<li>generates random numbers so infrequently that the RNG&#39;s speed is not a concern.</li>
</ul>

<p>See &quot;<a href="#Cryptographic_RNGs_Requirements"><strong>Cryptographic RNGs: Requirements</strong></a>&quot; for requirements.<br/>
See &quot;<a href="#Existing_RNG_APIs_in_Programming_Languages"><strong>Existing RNG APIs in Programming Languages</strong></a>&quot; for existing APIs.<br/>
For cryptographic RNGs, an application SHOULD use only one thread-safe instance of the RNG for the entire application to use.</p>

<blockquote>
<p><strong>Examples:</strong> A cryptographic RNG is RECOMMENDED&mdash;</p>

<ul>
<li> when generating security parameters (including encryption keys, random passwords, nonces, session identifiers, &quot;salts&quot;, and secret values),</li>
<li> for the purposes of sending or receiving messages or other data securely between computers, or</li>
<li> whenever predicting future random numbers would give a player or user a significant and unfair advantage (such as in multiplayer networked games).</li>
</ul>
</blockquote>

<p><a id=Noncryptographic_PRNGs></a></p>

<h2>Noncryptographic PRNGs</h2>

<p>Noncryptographic PRNGs vary widely in the quality of randomness of the numbers they generate.  For this reason, a noncryptographic PRNG SHOULD NOT be used&mdash;</p>

<ul>
<li>for information security purposes (e.g., to generate random passwords, encryption keys, or other secrets),</li>
<li>if cryptographic RNGs are fast enough for the application, or</li>
<li>if the PRNG is not <em>high quality</em> (see &quot;<a href="#High_Quality_RNGs_Requirements"><strong>High-Quality RNGs: Requirements</strong></a>&quot;).</li>
</ul>

<p>Noncryptographic PRNGs can be <em>automatically seeded</em> (a new seed is generated upon PRNG creation) or <em>manually seeded</em> (the PRNG uses a predetermined seed).</p>

<ul>
<li>See &quot;<a href="#When_to_Use_a_Manually_Seeded_PRNG"><strong>When to Use a Manually-Seeded PRNG</strong></a>&quot; to learn which kind of seeding to use.</li>
<li>See &quot;<a href="#Seed_Generation_for_Noncryptographic_PRNGs"><strong>Seed Generation for Noncryptographic PRNGs</strong></a>&quot; for advice on how to seed.</li>
<li>See &quot;<a href="#Existing_RNG_APIs_in_Programming_Languages"><strong>Existing RNG APIs in Programming Languages</strong></a>&quot; for existing APIs.</li>
<li>For automatically-seeded PRNGs, an application SHOULD use only one thread-safe instance of the RNG for the entire application to use.</li>
</ul>

<p><a id=Manually_Seeded_PRNGs></a></p>

<h2>Manually-Seeded PRNGs</h2>

<p>A given pseudorandom number generator (PRNG) generates the same sequence of &quot;random&quot; numbers for the same &quot;seed&quot;.  Some applications care about reproducible &quot;randomness&quot; and thus could set a PRNG&#39;s seed manually for reproducible &quot;random&quot; numbers.</p>

<p><a id=When_to_Use_a_Manually_Seeded_PRNG></a></p>

<h3>When to Use a Manually-Seeded PRNG</h3>

<p>By seeding a PRNG manually for reproducible &quot;randomness&quot;, an application will be tied to that PRNG or its implementation. For this reason, an application SHOULD NOT use a manually-seeded PRNG (rather than a cryptographic or automatically-seeded RNG) unless&mdash;</p>

<ol>
<li>the application might need to generate the same &quot;random&quot; result multiple times,</li>
<li>the application either&mdash;

<ul>
<li>makes the seed (or a &quot;code&quot; or &quot;password&quot; based on the seed) accessible to the user, or</li>
<li>finds it impractical to store or distribute the &quot;random&quot; numbers or &quot;random&quot; content, rather than the seed, for later use (e.g., to store those numbers to &quot;replay&quot; later, to store that content in a &quot;save file&quot;, or to distribute that content rather than a seed to networked users), and</li>
</ul></li>
<li>any feature that uses such a PRNG to generate that &quot;random&quot; result will be consistent (see &quot;Determinism and Consistency&quot;) for as long as that feature is still in use by that application.</li>
</ol>

<p><a id=Manually_Seeded_PRNG_Recommendations></a></p>

<h3>Manually-Seeded PRNG Recommendations</h3>

<p>If an application chooses to use a manually-seeded PRNG for reproducible &quot;randomness&quot;, the application&mdash;</p>

<ul>
<li>SHOULD choose a <a href="#High_Quality_PRNG_Examples"><strong>high-quality PRNG</strong></a>,</li>
<li>SHOULD choose a PRNG implementation with consistent behavior that will not change in the future,</li>
<li>ought to document the chosen PRNG being used as well as all the parameters for that PRNG, and</li>
<li>SHOULD NOT seed the PRNG with floating-point numbers or generate floating-point numbers with that PRNG.</li>
</ul>

<p>For advice on generating seeds for the PRNG, see &quot;<a href="#Seed_Generation_for_Noncryptographic_PRNGs"><strong>Seed Generation for Noncryptographic PRNGs</strong></a>&quot;).</p>

<blockquote>
<p><strong>Example:</strong> An application could implement a manually-seeded PRNG using a third-party library that specifically says it implements a <a href="#High_Quality_PRNG_Examples"><strong>high-quality PRNG algorithm</strong></a>, and could initialize that PRNG using a bit sequence from a cryptographic RNG.  The developers could also mention the use of the specific PRNG chosen on any code that uses it, to alert other developers that the PRNG needs to remain unchanged.</p>
</blockquote>

<p><a id=Manually_Seeded_PRNG_Use_Cases></a></p>

<h3>Manually-Seeded PRNG Use Cases</h3>

<p>Use cases for manually-seeded PRNGs include the following:</p>

<ul>
<li>Simulations and machine learning.  This includes physics simulations and artificial intelligence (AI) in games, as well as simulations to reproduce published research data.</li>
<li>Monte Carlo estimations.</li>
<li>Procedural noise generation.</li>
<li>Games that generate &quot;random&quot; content that is impractical to store.</li>
<li>Unit tests in which &quot;randomness&quot; ought not to influence whether they pass or fail.  Here, a manually-seeded PRNG with a fixed seed is used in place of another kind of RNG for the purpose of the test, to help ensure consistent results across the computers under test.</li>
</ul>

<p><a id=Manually_Seeded_PRNGs_in_Games></a></p>

<h3>Manually-Seeded PRNGs in Games</h3>

<p>Many kinds of game software generate seemingly &quot;random&quot; game content that might need to be repeatedly regenerated, such as&mdash;</p>

<ul>
<li>procedurally generated maps for a role-playing game,</li>
<li><a href="#Shuffling"><strong>shuffling</strong></a> a virtual deck of cards for a solitaire game, or</li>
<li>a game board or puzzle board that normally varies every session.</li>
</ul>

<p>In general, the bigger that &quot;random&quot; content is, the greater the justification to use a manually-seeded PRNG and a custom seed to generate that content.  The following are special cases:</p>

<ol>
<li>If the game needs reproducible &quot;random&quot; content only at the start of the game session (e.g., a &quot;random&quot; game board or a &quot;random&quot; order of virtual cards) and that content is small (say, no more than a hundred numbers):

<ul>
<li>The game SHOULD NOT use a manually-seeded PRNG unless the seed is based on a &quot;code&quot; or &quot;password&quot; entered by the user.  This is a good sign that the game ought to store the &quot;random&quot; content instead of a seed.</li>
</ul></li>
<li>In a networked game where multiple computers (e.g., multiple players, or a client and server) have a shared view of the game state and random numbers are used to update that game state:

<ul>
<li>The game SHOULD NOT use a manually-seeded PRNG where predicting a random outcome could give a player a significant and unfair advantage (e.g., the random number is the result of a die roll, or the top card of the draw pile, for a board or card game).  The game MAY use such a PRNG in other cases to ensure the game state is consistent among computers, including in physics simulations and AI.</li>
</ul></li>
</ol>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li><p>Suppose a game generates a map with random terrain (which uses lots of random numbers) and shows the player a &quot;code&quot; to generate that map (such as a barcode or a string of letters and digits). In this case, the game&mdash;</p>

<ul>
<li>MAY change the algorithm it uses to generate random maps, but</li>
<li>SHOULD use, in connection with the new algorithm, &quot;codes&quot; that can&#39;t be confused with &quot;codes&quot; it used for previous algorithms, and</li>
<li>SHOULD continue to generate the same random map using an old &quot;code&quot; when the player enters it, even after the change to a new algorithm.</li>
</ul></li>
<li><p>Suppose a game implements a chapter that involves navigating a randomly generated dungeon with randomly scattered monsters and items.  If the layout of the dungeon, monsters, and items has to be the same for a given week and for all players, the game can seed a PRNG with a hash code generated from the current week, the current month, the current year, and, optionally, a constant sequence of bits.</p></li>
</ol>
</blockquote>

<p><a id=Single_Random_Value></a></p>

<h3>Single Random Value</h3>

<p>If an application requires only one random value, with a fixed number of bits, then the application can pass the seed to a hash function rather than a PRNG.  Examples of this include the following:</p>

<ul>
<li>Generating a random color by passing the seed to the MD5 hash function, which outputs a 128-bit hash code, and taking the first 24 bits of the hash code as the random color.</li>
<li>Generating a random number in a GLSL (OpenGL Shading Language) fragment shader by passing the fragment coordinates (which vary for each fragment, or &quot;pixel&quot;) as well as a seed (which is the same for all fragments) to the Wang hash, which outputs a 32-bit integer.<sup><a href="#Note6"><strong>(6)</strong></a></sup></li>
</ul>

<p><a id=Nondeterministic_Sources_and_Seed_Generation></a></p>

<h2>Nondeterministic Sources and Seed Generation</h2>

<p>RNGs ultimately rely on so-called <em>nondeterministic sources</em>; without such sources, no computer can produce random numbers.</p>

<p><a id=What_Is_a_Nondeterministic_Source></a></p>

<h3>What Is a Nondeterministic Source?</h3>

<p>A <em>nondeterministic source</em> is a source that doesn&#39;t give the same output for the same input each time (for example, a clock that doesn&#39;t always give the same time).  There are many kinds of them, but sources useful for random number generation have hard-to-guess output (that is, they have high <em>entropy</em>; see the next section).  They include&mdash;</p>

<ul>
<li>timings of interrupts and disk accesses,</li>
<li>timings of keystrokes and/or other input device interactions,</li>
<li>thermal noise,</li>
<li>the output of assembly instructions specially dedicated to random number generation, such as RdSeed,</li>
<li>the output generated with A. Seznec&#39;s technique called hardware volatile entropy gathering and expansion (HAVEGE), provided a high-resolution counter is available, and</li>
<li>differences between two high-resolution counter values taken in quick succession (such as in &quot;Jitter RNG&quot;; see (M&uuml;ller)<sup><a href="#Note7"><strong>(7)</strong></a></sup>).</li>
</ul>

<p>RFC 4086, &quot;Randomness Requirements for Security&quot;, section 3, contains a survey of nondeterministic sources.</p>

<blockquote>
<p><strong>Note:</strong> Online services that make random numbers available to applications, as well as the noise registered by microphone and camera recordings (see RFC 4086 sec. 3.2.1, (Liebow-Feeser 2017a)<sup><a href="#Note8"><strong>(8)</strong></a></sup>, and  (Liebow-Feeser 2017b)<sup><a href="#Note9"><strong>(9)</strong></a></sup>), are additional nondeterministic sources.  However, online services require Internet or other network access, and some of them require access credentials.  Also, many mobile operating systems require applications to declare network, camera, and microphone access to users upon installation.  For these reasons, these kinds of sources are NOT RECOMMENDED if other approaches are adequate.</p>
</blockquote>

<p><a id=What_Is_Entropy></a></p>

<h3>What Is Entropy?</h3>

<p><em>Entropy</em> is a value that describes how hard it is to guess a nondeterministic source&#39;s output, compared to ideal random data; this is generally the size in bits of the ideal random data.  (For example, a 64-bit output with 32 bits of entropy is as hard to guess as an ideal random 32-bit data block.)  NIST SP 800-90B recommends <em>min-entropy</em> as the entropy measure.  Characterizing a nondeterministic source&#39;s entropy is nontrivial and beyond the scope of this document.  See also RFC 4086 section 2.</p>

<p><a id=Seed_Generation></a></p>

<h3>Seed Generation</h3>

<p>In general, there are two steps to generate an <code>N</code>-bit seed for a PRNG<sup><a href="#Note10"><strong>(10)</strong></a></sup>:</p>

<ol>
<li>Gather enough data from <em>nondeterministic sources</em> to reach <code>N</code> bits of <em>entropy</em> or more.</li>
<li>Then, condense the data into an <code>N</code>-bit number, a process called <em>randomness extraction</em>.<sup><a href="#Note11"><strong>(11)</strong></a></sup></li>
</ol>

<p>Randomness extraction is discussed in NIST SP 800-90B sec. 3.1.5.1, RFC 4086 sec. 4.2 and 5.2, and (Cliff et al., 2009)<sup><a href="#Note12"><strong>(12)</strong></a></sup>.</p>

<blockquote>
<p><strong>Example:</strong> The Cliff reference reviewed the use of HMAC (hash-based message authentication code) algorithms, and implies that one way to generate a seed is as follows:</p>

<ol>
<li>Gather data with at least 512 bits of entropy.</li>
<li>Run HMAC-SHA-512 with that data to generate a 512-bit HMAC.</li>
<li>Take the first 170 (or fewer) bits as the seed (512 divided by 3, rounded down).</li>
</ol>
</blockquote>

<p><a id=Seed_Generation_for_Noncryptographic_PRNGs></a></p>

<h3>Seed Generation for Noncryptographic PRNGs</h3>

<p>In general, to generate a seed allowed by a noncryptographic PRNG, an application ought to use a cryptographic RNG or a method described in the <a href="#Seed_Generation"><strong>previous section</strong></a>.</p>

<p>It is NOT RECOMMENDED to seed PRNGs with timestamps, since they can carry the risk of generating the same &quot;random&quot; number sequence accidentally.<sup><a href="#Note13"><strong>(13)</strong></a></sup></p>

<p><a id=Seeding_Multiple_Processes></a></p>

<h4>Seeding Multiple Processes</h4>

<p>Some applications require multiple processes (including threads, tasks, or subtasks) to use <a href="#Manually_Seeded_PRNGs"><strong>reproducible &quot;random&quot; numbers</strong></a> for the same purpose.  An example is multiple instances of a simulation with random starting conditions.  However, noncryptographic PRNGs tend to produce number sequences that are correlated to each other, which is undesirable for simulations in particular.</p>

<p>To reduce this correlation risk, the application can choose a <a href="#High_Quality_RNGs_Requirements"><strong>high-quality PRNG</strong></a> that supports &quot;streams&quot; of uncorrelated sequences (sequences that behave like independent random number sequences and don&#39;t overlap) and has an efficient way to assign a different stream to each process.  Examples of such PRNGs include so-called &quot;counter-based&quot; PRNGs (Salmon et al. 2011)<sup><a href="#Note14"><strong>(14)</strong></a></sup>.</p>

<p>Depending on the PRNG, there are different ways to seed multiple processes for random number generation, described as follows.<sup><a href="#Note15"><strong>(15)</strong></a></sup></p>

<ol>
<li><p>For counter-based PRNGs: Generate a seed (or use a predetermined seed), then:</p>

<ol>
<li>Create a PRNG instance for each process.</li>
<li>Hash the seed and a fixed identifier to generate a new seed allowed by the PRNG.  The counter either is 0 or is generated similarly to the new seed.</li>
<li>For each process, initialize its PRNG instance with the new seed and the counter, then add 1 to the new seed (in case of overflow, the new seed is 0 instead).</li>
</ol></li>
<li><p>For PRNGs that implement &quot;streams&quot; by providing an efficient way to discard a fixed but huge number of PRNG outputs (that is, to &quot;jump the PRNG ahead&quot;): Generate a seed (or use a predetermined seed), then:</p>

<ol>
<li>Create one PRNG instance.</li>
<li>Hash the seed and a fixed identifier to generate a new seed allowed by the PRNG, and initialize the PRNG with that seed.</li>
<li>For each process, jump the original PRNG ahead (unless it&#39;s the first process), then give that process a copy of the PRNG&#39;s current internal state.</li>
</ol></li>
<li><p>For other PRNGs, or if each process uses a different PRNG design, the following is a way to seed multiple processes for random number generation, but it carries the risk of generating seeds that lead to overlapping, correlated, or even identical number sequences, especially if the processes use the same PRNG.<sup><a href="#Note16"><strong>(16)</strong></a></sup> Generate a seed (or use a predetermined seed), then:</p>

<ol>
<li>Create a PRNG instance for each process.  The instances need not all use the same PRNG design or the same parameters; for example, some can be Philox and others <code>xoroshiro128**</code>.</li>
<li>For each process, hash the seed, a unique number for that process, and a fixed identifier to generate a new seed allowed by the process&#39;s PRNG, and initialize that PRNG with the new seed.</li>
</ol></li>
</ol>

<p>The steps above include hashing several things to generate a new seed.  This has to be done with either a <a href="#Hash_Functions"><strong>hash function</strong></a> of N or more bits (where N is the PRNG&#39;s maximum seed size), or a so-called &quot;seed sequence generator&quot; like C++&#39;s <code>std::seed_seq</code>.<sup><a href="#Note17"><strong>(17)</strong></a></sup></p>

<blockquote>
<p><strong>Example:</strong> SFC64 is a counter-based PRNG. To seed two processes based on the seed &quot;seed&quot; and this PRNG, an application can&mdash;</p>

<ul>
<li>take the first 192 bits of the SHA2-256 hash of &quot;seed-mysimulation&quot; as a new seed,</li>
<li>initialize the first process&#39;s PRNG with the new seed and a counter of 0, and</li>
<li>initialize the second process&#39;s PRNG with 1 plus the new seed and a counter of 0.</li>
</ul>
</blockquote>

<p><a id=Existing_RNG_APIs_in_Programming_Languages></a></p>

<h2>Existing RNG APIs in Programming Languages</h2>

<p>As much as possible, <strong>applications SHOULD use existing libraries and techniques</strong> for cryptographic and high-quality RNGs. The following table lists application programming interfaces (APIs) for such RNGs for popular programming languages.</p>

<ul>
<li>PRNGs mentioned in the &quot;High-Quality&quot; column need to be initialized with a seed (see &quot;<a href="#Seed_Generation_for_Noncryptographic_PRNGs"><strong>Seed Generation for Noncryptographic PRNGs</strong></a>&quot;).</li>
<li>The mention of a third-party library in this section does not imply that the library is the best one available for any particular purpose. The list is not comprehensive.</li>
<li>See also <a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"><strong>Paragon&#39;s blog post</strong></a> on existing cryptographic RNGs.</li>
</ul>

<table><thead>
<tr>
<th>Language</th>
<th>Cryptographic</th>
<th>High-Quality</th>
</tr>
</thead><tbody>
<tr>
<td>.NET (incl. C# and VB.NET) (H)</td>
<td><code>RandomNumberGenerator.Create()</code> in <code>System.Security.Cryptography</code> namespace; <a href="https://github.com/airbreather/Airbreather.Common"><strong>airbreather/AirBreather.Common library</strong></a> (CryptographicRandomGenerator)</td>
<td><code>XoshiroPRNG.Net</code> package (XoRoShiRo128starstar, XoShiRo256plus, XoShiRo256starstar); <code>Data.HashFunction.MurmurHash</code> or <code>Data.HashFunction.CityHash</code> package (hash the string <code>seed + &quot;_&quot; + counter</code>)</td>
</tr>
<tr>
<td>C/C++ (G)</td>
<td>(C)</td>
<td><a href="http://xoroshiro.di.unimi.it/xoroshiro128plusplus.c"><strong><code>xoroshiro128plusplus.c</code></strong></a>; <a href="http://xoroshiro.di.unimi.it/xoshiro256starstar.c"><strong><code>xoshiro256starstar.c</code></strong></a></td>
</tr>
<tr>
<td>Python (A)</td>
<td><code>secrets.SystemRandom</code> (since Python 3.6); <code>os.urandom()</code></td>
<td><a href="https://github.com/ihaque/xorshift"><strong>ihaque/xorshift</strong></a> library (default seed uses <code>os.urandom()</code>); <a href="https://docs.scipy.org/doc/numpy/reference/random/index.html"><strong><code>numpy.random.Generator</code></strong></a> with <code>Philox</code> or <code>SFC64</code> (since ver. 1.7); <code>hashlib.md5(b&quot;%d_%d&quot; % (seed, counter)).digest()</code>, <code>hashlib.sha1(b&quot;%d_%d&quot; % (seed, counter)).digest()</code></td>
</tr>
<tr>
<td>Java (A) (D)</td>
<td>(C); <code>java.security.SecureRandom</code> (F)</td>
<td><a href="http://dsiutils.di.unimi.it/docs/it/unimi/dsi/util/package-summary.html"><strong><code>it.unimi.dsi/dsiutils</code> artifact</strong></a> (XoRoShiRo128PlusPlusRandom, XoShiRo128PlusPlusRandom, XoShiRo256PlusRandom, XorShift1024StarPhiRandom); <a href="https://commons.apache.org/proper/commons-rng/commons-rng-simple/apidocs/"><strong><code>org.apache.commons/commons-rng-simple</code></strong></a> artifact (<code>RandomSource</code> of <code>SFC_64</code>, <code>XO_RO_SHI_RO_128_PP</code>, <code>XO_RO_SHI_RO_128_SS</code>, <code>XO_SHI_RO_256_PP</code>, or <code>XO_SHI_RO_256_SS</code>)</td>
</tr>
<tr>
<td>JavaScript (B)</td>
<td><code>crypto.randomBytes(byteCount)</code> (node.js only); <code>random-number-csprng</code> package (node.js only); <code>crypto.getRandomValues()</code> (Web)</td>
<td><code>xoroshiro128starstar</code> package; <code>md5</code> package (<code>md5(seed+&quot;_&quot;+counter, {asBytes: true})</code>); <code>murmurhash3js</code> package (<code>murmurhash3js.x86.hash32(seed+&quot;_&quot;+counter)</code>); <code>crypto.createHash(&quot;sha1&quot;)</code> (node.js only)</td>
</tr>
<tr>
<td>Ruby (A) (E)</td>
<td>(C); <code>SecureRandom.rand()</code> (0 or greater and less than 1) (E); <code>SecureRandom.rand(N)</code> (integer) (E) (for both, <code>require &#39;securerandom&#39;</code>); <code>sysrandom</code> gem</td>
<td><code>Digest::MD5.digest(&quot;#{seed}_#{counter}&quot;)</code>, <code>Digest::SHA1.digest(&quot;#{seed}_#{counter}&quot;)</code> (for both, <code>require &#39;digest&#39;</code>)</td>
</tr>
<tr>
<td>PHP (A)</td>
<td><code>random_int()</code>, <code>random_bytes()</code> (both since PHP 7)</td>
<td><code>md5($seed.&#39;_&#39;.$counter, true)</code>; <code>sha1($seed.&#39;_&#39;.$counter, true)</code></td>
</tr>
<tr>
<td>Go</td>
<td><code>crypto/rand</code> package</td>
<td><code>md5.Sum</code> in <code>crypto/md5</code> package or <code>sha1.Sum</code> in <code>crypto/sha1</code> package (for both, hash the byte array <code>seed + &quot;_&quot; + counter</code>)</td>
</tr>
<tr>
<td>Rust</td>
<td>(C)</td>
<td><code>rand_xoshiro</code> crate (Xoroshiro128PlusPlus, Xoshiro256PlusPlus, Xoshiro256StarStar, Xoshiro512StarStar)</td>
</tr>
<tr>
<td>Perl</td>
<td><code>Crypt::URandom</code> module</td>
<td><code>Crypt::Digest::MD5</code> module (<code>md5($seed.&#39;_&#39;.$counter)</code>); <code>Digest::SHA</code> module (<code>sha1($seed.&#39;_&#39;.$counter)</code>); <code>Digest::MurmurHash3</code> module (<code>murmurhash3($seed.&#39;_&#39;.$counter)</code>)</td>
</tr>
<tr>
<td>Other Languages</td>
<td>(C)</td>
<td>Hash the string <code>seed + &quot;_&quot; + counter</code> with MurmurHash3, xxHash64, CityHash, MD5, or SHA-1</td>
</tr>
</tbody></table>

<p><small>(A) The general RNGs of recent versions of Python and Ruby implement <a href="https://en.wikipedia.org/wiki/Mersenne_Twister"><strong>Mersenne Twister</strong></a>, which is not preferred for a high-quality RNG.  PHP&#39;s <code>mt_rand()</code> implements or implemented a flawed version of Mersenne Twister.</small></p>

<p><small>(B) JavaScript&#39;s <code>Math.random()</code> (which ranges 0 or greater and less than 1) is implemented using <code>xorshift128+</code> (or a variant) in the V8 engine, Firefox, and certain other modern browsers as of late 2017; <code>Math.random()</code> uses an &quot;implementation-dependent algorithm or strategy&quot;, though (see ECMAScript sec. 20.2.2.27).</small></p>

<p><small>(C) A cryptographic RNG implementation can&mdash;</p>

<ul>
<li>read from the <code>/dev/urandom</code> device in Linux-based systems (using the <code>open</code> and <code>read</code> system calls where available)<sup><a href="#Note18"><strong>(18)</strong></a></sup>,</li>
<li>call the <code>arc4random</code> or <code>arc4random_buf</code> method on FreeBSD or macOS,</li>
<li>call the <code>getentropy</code> method on OpenBSD, or</li>
<li>call the <code>BCryptGenRandom</code> API in Windows 7 and later,</small></li>
</ul>

<p><small>and only use other techniques if the existing ones are inadequate for the application.  But unfortunately, resource-constrained devices (&quot;embedded&quot; devices) are much less likely to have a cryptographic RNG available compared to general-purpose computing devices such as desktop computers and smartphones (Wetzels 2017)<sup><a href="#Note19"><strong>(19)</strong></a></sup>, although methods exist for implementing a cryptographic RNG on the Arduino (Peng 2017)<sup><a href="#Note20"><strong>(20)</strong></a></sup>.
</small></p>

<p><small>(D) Java&#39;s <code>java.util.Random</code> class uses a 48-bit seed, so is not considered a high-quality RNG.  However, a subclass of <code>java.util.Random</code> might be implemented as a high-quality RNG.</small></p>

<p><small>(E) Ruby&#39;s <code>SecureRandom.rand</code> method presents a beautiful and simple API for random number generation, in my opinion.  Namely, <code>rand()</code> returns a number 0 or greater and less than 1, and <code>rand(N)</code> returns an integer 0 or greater and less than N.</small></p>

<p><small>(F) In Java 8 and later, use <code>SecureRandom.getInstanceStrong()</code>.  In Java earlier than 8, call <code>SecureRandom.getInstance(&quot;NativePRNGNonBlocking&quot;)</code> or, if that fails, <code>SecureRandom.getInstance(&quot;NativePRNG&quot;)</code>.  For Android, especially versions 4.3 and earlier, see (Klyubin 2013)<sup><a href="#Note21"><strong>(21)</strong></a></sup>.  Using the <code>SecureRandom</code> implementation <code>&quot;SHA1PRNG&quot;</code> is NOT RECOMMENDED, because of weaknesses in seeding and RNG quality in implementations as of 2013 (Michaelis et al., 2013)<sup><a href="#Note22"><strong>(22)</strong></a></sup>.</small></p>

<p><small>(G) <a href="http://en.cppreference.com/w/cpp/numeric/random/random_device"><strong><code>std::random_device</code></strong></a> was introduced in C++11, but its specification leaves considerably much to be desired.  For example,  <code>std::random_device</code> can fall back to a PRNG of unspecified quality without much warning.  At best, <code>std::random_device</code> SHOULD NOT be used except to supplement other techniques for random number generation.</small></p>

<p><small>(H) The .NET Framework&#39;s <code>System.Random</code> class uses a seed of at most 32 bits, so is not considered a high-quality RNG.  However, a subclass of <code>System.Random</code> might be implemented as a high-quality RNG.</small></p>

<p><a id=RNG_Topics></a></p>

<h2>RNG Topics</h2>

<p>This section discusses several important points on the use and selection of RNGs, including things to consider when shuffling or generating &quot;unique&quot; random numbers.</p>

<p><a id=Shuffling></a></p>

<h3>Shuffling</h3>

<p>In a list with <code>N</code> different items, there are <code>N</code> factorial (that is, <code>1 * 2 * ... * N</code>, or <code>N!</code>) ways to arrange the items in that list.  These ways are called <em>permutations</em><sup><a href="#Note23"><strong>(23)</strong></a></sup>.</p>

<p>In practice, an application can <strong>shuffle a list</strong> by doing a <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle"><strong>Fisher&ndash;Yates shuffle</strong></a>, which is unfortunately easy to mess up &mdash; see (Atwood 2007)<sup><a href="#Note24"><strong>(24)</strong></a></sup> &mdash; and is implemented correctly in <a href="https://peteroupc.github.io/randomfunc.html"><strong>another document of mine</strong></a>.</p>

<p>However, if a PRNG admits fewer seeds than the number of permutations, then there are <strong>some permutations that that PRNG can&#39;t choose</strong> when it shuffles that list. (This is not the same as <em>generating</em> all permutations of a list, which, for a list big enough, can&#39;t be done by any computer in a reasonable time.)</p>

<p>On the other hand, for a list big enough, it&#39;s generally <strong>more important to have shuffles act random</strong> than to choose from among all permutations.</p>

<p>An application that shuffles a list can do the shuffling&mdash;</p>

<ol>
<li>using a cryptographic RNG, preferably one with a security strength of <code>B</code> bits or greater, or</li>
<li>if a noncryptographic RNG is otherwise appropriate, using a <em>high-quality PRNG</em> that&mdash;

<ul>
<li>admits <code>B</code>-bit seeds without shortening or compressing those seeds, and</li>
<li>is initialized with a seed derived from data with at least <strong><code>B</code> bits of</strong> <a href="#Nondeterministic_Sources_and_Seed_Generation"><strong><em>entropy</em></strong></a>, or &quot;randomness&quot;.</li>
</ul></li>
</ol>

<p>For shuffling purposes, <code>B</code> can usually be calculated for different lists using the Python code in the <a href="#Suggested_Entropy_Size"><strong>appendix</strong></a>; see also (van Staveren 2000, &quot;Lack of randomness&quot;)<sup><a href="#Note25"><strong>(25)</strong></a></sup>.  For example, <code>B</code> is 226 (bits) for a 52-item list.  For shuffling purposes, an application MAY limit <code>B</code> to 256 or greater, in cases when variety of permutations is not important.</p>

<p><a id=Unique_Random_Identifiers></a></p>

<h3>Unique Random Identifiers</h3>

<p>Some applications require generating unique identifiers, especially to identify database records or other shared resources.  Such identifiers include auto-incremented numbers, sequentially assigned numbers, random numbers, and combinations of these.  The following are some questions to consider when generating unique identifiers, especially random ones:</p>

<ol>
<li>Can the application easily check identifiers for uniqueness within the desired scope and range (e.g., check whether a file or database record with that identifier already exists)<sup><a href="#Note26"><strong>(26)</strong></a></sup>?</li>
<li>Can the application tolerate the risk of generating the same identifier for different resources<sup><a href="#Note27"><strong>(27)</strong></a></sup>?</li>
<li>Do identifiers have to be hard to guess, be simply &quot;random-looking&quot;, or be neither?</li>
<li>Do identifiers have to be typed in or otherwise relayed by end users<sup><a href="#Note28"><strong>(28)</strong></a></sup>?</li>
<li>Is the resource an identifier identifies available to anyone who knows that identifier (even without being logged in or authorized in some way)?</li>
<li>Do identifiers have to be memorable?</li>
</ol>

<p>Examples of unique integers include sequentially-assigned integers as well as the primary key of a database table.  If the application requires a unique integer to &quot;look random&quot;, it can apply any of the following operations to that integer:</p>

<ol>
<li>A reversible mixing function, also known as a permutation (see &quot;<a href="https://papa.bretmulvey.com/post/124027987928"><strong>Hash functions</strong></a>&quot; by B. Mulvey).</li>
<li>A &quot;full-period&quot; linear PRNG that cycles through all N-bit integers exactly once<sup><a href="#Note29"><strong>(29)</strong></a></sup>.</li>
<li>If unique integers 0 or greater, but less than K, are desired, choose an N-bit function described in (1) or (2), where N is the number of bits needed to store the number K-minus-1, and discard all outputs that are K or greater.</li>
</ol>

<p>An application that generates unique identifiers SHOULD do so as follows:</p>

<ul>
<li>If the application can answer yes to 1 or 2 above:

<ul>
<li>And yes to 5: Generate a 128-bit-long or longer random integer using a cryptographic RNG.</li>
<li>And no to 5: Generate a 32-bit-long or longer random integer using a cryptographic RNG.</li>
</ul></li>
<li>Otherwise:

<ul>
<li>If identifiers have to be hard to guess: Use a unique integer which is followed by a random integer generated using a cryptographic RNG (the random integer&#39;s length depends on the answer to 5, as above).</li>
<li>Otherwise: Use a unique integer. (Note that generally, random numbers alone can&#39;t ensure uniqueness.)</li>
</ul></li>
</ul>

<p><a id=Determinism_and_Consistency></a></p>

<h3>Determinism and Consistency</h3>

<p>For an RNG algorithm to generate &quot;random&quot; numbers that are reproducible across computers, it needs to be a <em>consistent</em> algorithm.  (This factor is important only for manually-seeded PRNGs, not necessarily for other RNGs.)</p>

<p>A <em>consistent algorithm</em> is an algorithm that delivers the same output each time if given the same input twice (is <em>deterministic</em>) and that does so&mdash;</p>

<ul>
<li>across time,</li>
<li>across different executions of the algorithm,</li>
<li>across versions of the application that uses the algorithm,</li>
<li>across supported hardware, and</li>
<li>across supported operating systems.</li>
</ul>

<p>An application can generally achieve consistency by not changing the algorithm between application versions.  Also, algorithms that use floating-point or other non-integer numbers are harder to make consistent than other algorithms.  Finally, C and C++ have a concept of <em>undefined behavior</em> that any consistent algorithm has to avoid relying on, as well as data types with compiler-dependent properties (such as <code>int</code> and <code>long</code>).<sup><a href="#Note30"><strong>(30)</strong></a></sup></p>

<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html"><strong><code>java.util.Random</code></strong></a> is one example of a PRNG with consistent behavior, but none of the following is such a PRNG:</p>

<ul>
<li>The C <a href="http://en.cppreference.com/w/cpp/numeric/random/rand"><strong><code>rand</code> method</strong></a>, as well as C++&#39;s random number distribution classes, such as <a href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"><strong><code>std::uniform_int_distribution</code></strong></a>, use implementation-defined algorithms for random number generation.</li>
<li>.NET&#39;s <a href="https://docs.microsoft.com/dotnet/api/system.random"><strong><code>System.Random</code></strong></a> has random number generation behavior that could change in the future.</li>
</ul>

<p><a id=Hash_Functions></a></p>

<h2>Hash Functions</h2>

<p>A <em>hash function</em> is a function that takes an arbitrary input of any size (such as an array of 8-bit bytes or a sequence of characters) and returns an output with a fixed number of bits. That output is also known as a <em>hash code</em>.</p>

<p>For random number generation purposes:</p>

<ul>
<li>The individual bits of a hash code can serve as random numbers, or the hash code can serve as the seed for a PRNG that, in turn, <a href="https://peteroupc.github.io/randomfunc.html"><strong>generates random numbers</strong></a> in the desired way.</li>
<li>Good hash functions include cryptographic hash functions (e.g., SHA2-256, BLAKE2) and other hash functions that tend to produce wildly dispersed hash codes for nearby inputs.</li>
<li>Poor hash functions include linear PRNGs such as LCGs and the Xorshift family.</li>
</ul>

<p>The use of hash functions for other purposes (such as data lookup and data integrity) is beyond the scope of this document.<sup><a href="#Note31"><strong>(31)</strong></a></sup></p>

<p><a id=Procedural_Noise_Functions></a></p>

<h3>Procedural Noise Functions</h3>

<p><em>Noise</em> is a randomized variation in images, sound, and other data.<sup><a href="#Note32"><strong>(32)</strong></a></sup></p>

<p>A <em>noise function</em> is similar to a hash function; it takes an <em>n</em>-dimensional point and, optionally, additional data, and outputs a seemingly random number.<sup><a href="#Note33"><strong>(33)</strong></a></sup>  Noise functions generate <strong><em>procedural noise</em></strong> such as <a href="https://en.wikipedia.org/wiki/Cellular_noise"><strong>cellular noise</strong></a>, <a href="https://en.wikipedia.org/wiki/Value_noise"><strong>value noise</strong></a>, and <a href="https://en.wikipedia.org/wiki/Gradient_noise"><strong>gradient noise</strong></a> (including <a href="https://en.wikipedia.org/wiki/Perlin_noise"><strong>Perlin noise</strong></a>).  If the noise function takes additional data, that data&mdash;</p>

<ul>
<li>SHOULD include random numbers (from any RNG), and</li>
<li>SHOULD NOT vary from one run to the next while the noise function is used for a given purpose (e.g., to generate terrain for a given map).</li>
</ul>

<p><a id=Pseudorandom_Functions></a></p>

<h3>Pseudorandom Functions</h3>

<p>A <em>pseudorandom function</em> is a kind of hash function that takes&mdash;</p>

<ul>
<li>a <em>secret</em> (such as a password or a long-term key), and</li>
<li>additional data such as a <em>salt</em> (which is designed to mitigate precomputation attacks) or a <em>nonce</em>,</li>
</ul>

<p>and outputs a seemingly random number.  (If the output is encryption keys, the function is also called a <em>key derivation function</em>; see NIST SP 800-108.)  Some pseudorandom functions deliberately take time to compute their output; these are designed above all for cases in which the secret is a password or is otherwise easy to guess &mdash; examples of such functions include PBKDF2 (RFC 2898), <code>scrypt</code> (RFC 7914), and Ethash.  Pseudorandom functions are also used in proofs of work such as the one described in RFC 8019 sec. 4.4.</p>

<p><a id=Verifiable_Random_Numbers></a></p>

<h2>Verifiable Random Numbers</h2>

<p><em>Verifiable random numbers</em> are random numbers (such as seeds for PRNGs) that are disclosed along with all the information necessary to verify their generation.  Usually, such information includes random numbers and/or uncertain data to be determined and publicly disclosed in the future.  Techniques to generate verifiable random numbers (as opposed to cryptographic RNGs alone) are used whenever one party alone can&#39;t be trusted to produce a number at random.  Verifiable random numbers that are disclosed <em>publicly</em> SHOULD NOT be used as encryption keys or other secret parameters.</p>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>Generating verifiable randomness has been described in <a href="https://www.rfc-editor.org/rfc/rfc3797.txt"><strong>RFC 3797</strong></a>, which describes the selection process for the Nominations Committee (NomCom) of the Internet Engineering Task Force.</li>
<li><em>Verifiable delay functions</em> calculate an output as well as a proof that the output was correctly calculated; these functions deliberately take much more time to calculate the output (e.g., to generate a seemingly random number from public data) than to verify its correctness.<sup><a href="#Note34"><strong>(34)</strong></a></sup> In many cases, such a function deliberately takes much more time than the time allowed to contribute randomness to that function.<sup><a href="#Note35"><strong>(35)</strong></a></sup></li>
<li>In a so-called <a href="https://en.wikipedia.org/wiki/Commitment_scheme"><strong><em>commitment scheme</em></strong></a>, one computer generates data to be committed (e.g. a random number or a chess move), then reveals its hash code or digital signature (<em>commitment</em>), and only later reveals to all participants the committed data (along with other information needed, if any, to verify that the data wasn&#39;t changed in between).  Examples of commitment schemes are <em>hash-based commitments</em>.<sup><a href="#Note35"><strong>(35)</strong></a></sup></li>
<li>So-called <em>mental card game</em> (<em>mental poker</em>) schemes can be used in networked games where a deck of cards has to be shuffled and dealt to players, so that the identity of some cards is known to some but not all players.<sup><a href="#Note35"><strong>(35)</strong></a></sup></li>
</ol>
</blockquote>

<p><a id=Guidelines_for_New_RNG_APIs></a></p>

<h2>Guidelines for New RNG APIs</h2>

<p>This section contains guidelines for those seeking to implement RNGs designed for wide reuse (such as in a programming language&#39;s standard library).  <em>As mentioned earlier, an application SHOULD use existing RNG implementations whenever possible.</em></p>

<p>This section contains suggested requirements on cryptographic and high-quality RNGs that a new programming language can choose to adopt.</p>

<p><a id=Cryptographic_RNGs_Requirements></a></p>

<h3>Cryptographic RNGs: Requirements</h3>

<p>A cryptographic RNG generates random bits that behave like independent uniform random bits, such that it would be cost-prohibitive for an outside party to correctly guess, with more than a 50% chance per bit, prior or future unseen outputs of that RNG after knowing how the RNG works and/or extremely many outputs of the RNG, or prior unseen outputs of that RNG after knowing the RNG&#39;s internal state at the given point in time.<sup><a href="#Note36"><strong>(36)</strong></a></sup></p>

<p>If a cryptographic RNG implementation uses a PRNG, the following requirements apply.</p>

<ol>
<li><p>The maximum size of seeds the PRNG admits is 128 bits or more and SHOULD be 256 bits or more.</p></li>
<li><p>The <em>security strength</em> used by the RNG is at least 128 bits and is not more than the maximum size, in bits, of seeds the PRNG admits.</p></li>
<li><p>While or after the PRNG is created, and before it generates a random number, it is initialized (&quot;seeded&quot;) with a seed that&mdash;</p>

<ul>
<li>consists of data that ultimately derives from the output of one or more <a href="#Nondeterministic_Sources_and_Seed_Generation"><strong>nondeterministic sources</strong></a>, where the output is at least as hard to guess as ideal random data with as many bits as the <em>security strength</em>, and</li>
<li>MAY be mixed with arbitrary data other than the seed as long as the result is no easier to guess<sup><a href="#Note37"><strong>(37)</strong></a></sup>.</li>
</ul></li>
</ol>

<p>A cryptographic RNG is not required to reseed itself.</p>

<blockquote>
<p><strong>Examples:</strong> The following are examples of cryptographic RNGs:</p>

<ul>
<li>Randomness extractors or cryptographic <a href="#Hash_Functions"><strong>hash functions</strong></a> that take very hard-to-predict signals from two or more <a href="#Nondeterministic_Sources_and_Seed_Generation"><strong>nondeterministic sources</strong></a> as input.</li>
<li>A &quot;fast-key-erasure&quot; random number generator described by D.J. Bernstein in his blog (Bernstein 2017)<sup><a href="#Note38"><strong>(38)</strong></a></sup>.</li>
<li>An RNG implementation complying with NIST SP 800-90A.  The SP 800-90 series goes into further detail on how RNGs appropriate for information security can be constructed, and inspired much of this section.</li>
<li>An RNG made up of two or more independently initialized cryptographic RNGs of different designs.<sup><a href="#Note39"><strong>(39)</strong></a></sup></li>
</ul>
</blockquote>

<p><a id=High_Quality_RNGs_Requirements></a></p>

<h3>High-Quality RNGs: Requirements</h3>

<p>A PRNG is a high-quality RNG if&mdash;</p>

<ul>
<li>it generates bits that behave like independent uniform random bits (at least for nearly all practical purposes outside of information security),</li>
<li>the number of different seeds the PRNG admits without shortening or compressing those seeds is 2<sup>63</sup> or more, and</li>
<li>it either&mdash;

<ul>
<li>provides multiple sequences that are different for each seed, have at least 2<sup>64</sup> numbers each, do not overlap, and behave like independent random number sequences (at least for nearly all practical purposes outside of information security), or</li>
<li>has a period (maximum size of a &quot;random&quot; number cycle) equal or close to the number of different seeds the PRNG admits.</li>
</ul></li>
</ul>

<p>The high-quality PRNG SHOULD admit any of 2<sup>127</sup> or more seeds.</p>

<p>Every cryptographic RNG is also a high-quality RNG.</p>

<p>A Bays&ndash;Durham shuffle (see the appendix) of a high-quality RNG is also a high-quality RNG.</p>

<p><a id=High_Quality_PRNG_Examples></a></p>

<h4>High-Quality PRNG Examples</h4>

<p>Besides cryptographic RNGs, the following are examples of high-quality PRNGs:</p>

<table><thead>
<tr>
<th>PRNG</th>
<th>Seeds Allowed</th>
<th>Period</th>
<th>Stream Support</th>
<th>Notes</th>
</tr>
</thead><tbody>
<tr>
<td>xoshiro256**</td>
<td>2^256 - 1</td>
<td>2^256 - 1</td>
<td>Jump-ahead<sup><a href="#Note40"><strong>(40)</strong></a></sup></td>
<td></td>
</tr>
<tr>
<td>xoshiro256+</td>
<td>2^256 - 1</td>
<td>2^256 - 1</td>
<td>Jump-ahead</td>
<td>Lowest bits have low linear complexity (see (Blackman and Vigna 2019)<sup><a href="#Note41"><strong>(41)</strong></a></sup> and see also &quot;<a href="http://xoshiro.di.unimi.it/lowcomp.php"><strong>Testing low bits in isolation</strong></a>&quot;); if the application or library cares, it can discard those bits before using this PRNG&#39;s output.</td>
</tr>
<tr>
<td>xoshiro256++</td>
<td>2^256 - 1</td>
<td>2^256 - 1</td>
<td>Jump-ahead</td>
<td></td>
</tr>
<tr>
<td>xoshiro512**</td>
<td>2^512 - 1</td>
<td>2^512 - 1</td>
<td>Jump-ahead</td>
<td></td>
</tr>
<tr>
<td>xoshiro512+</td>
<td>2^512 - 1</td>
<td>2^512 - 1</td>
<td>Jump-ahead</td>
<td>Lowest bits have low linear complexity</td>
</tr>
<tr>
<td>xoshiro512++</td>
<td>2^512 - 1</td>
<td>2^512 - 1</td>
<td>Jump-ahead</td>
<td></td>
</tr>
<tr>
<td>xoroshiro128++</td>
<td>2^128 - 1</td>
<td>2^128 - 1</td>
<td>Jump-ahead</td>
<td></td>
</tr>
<tr>
<td>xoroshiro128**</td>
<td>2^128 - 1</td>
<td>2^128 - 1</td>
<td>Jump-ahead</td>
<td></td>
</tr>
<tr>
<td>SFC64 (C. Doty-Humphrey)</td>
<td>2^192</td>
<td>At least 2^64 per seed</td>
<td>64-bit counter</td>
<td>256-bit state</td>
</tr>
<tr>
<td>Philox</td>
<td>2^128</td>
<td>At least 2^256 per seed</td>
<td>256-bit counter</td>
<td>384-bit state</td>
</tr>
<tr>
<td>Velox3b</td>
<td>2^64</td>
<td>At least 2^128 per seed</td>
<td>Separate stream per seed</td>
<td>256-bit state</td>
</tr>
<tr>
<td>A high-quality PRNG that uses a C-bit block cipher with an S-bit key to output C-bit encrypted counters (Salmon et al. 2011)<sup><a href="#Note14"><strong>(14)</strong></a></sup></td>
<td>2^S</td>
<td>At least 2^C per seed</td>
<td>C-bit counter</td>
<td>(C + S) bit state; C and S are each 64 or greater</td>
</tr>
<tr>
<td>A high-quality PRNG that outputs hash codes of a C-bit counter and an S-bit seed (Salmon et al. 2011)<sup><a href="#Note14"><strong>(14)</strong></a></sup></td>
<td>2^S</td>
<td>At least 2^C per seed</td>
<td>C-bit counter</td>
<td>(C + S) bit state; C and S are each 64 or greater</td>
</tr>
<tr>
<td><code>gjrand</code> named after Geronimo Jones</td>
<td>2^128</td>
<td>At least 2^64 per seed</td>
<td>Separate stream per seed</td>
<td>256-bit state</td>
</tr>
<tr>
<td>TinyMT64 (Tiny Mersenne Twister)</td>
<td>2^127 - 1</td>
<td>2^127 - 1</td>
<td><a href="http://www.math.sci.hiroshima-u.ac.jp/%7Em-mat/MT/TINYMT/JUMP/index.html"><strong>Jump-ahead</strong></a></td>
<td>Millions of possible parameter sets</td>
</tr>
<tr>
<td>A multiplicative <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator"><strong>linear congruential generator</strong></a> (LCG) with prime modulus greater than 2<sup>63</sup> described in Table 2 of (L&#39;Ecuyer 1999)<sup><a href="#Note42"><strong>(42)</strong></a></sup></td>
<td>Modulus - 1</td>
<td>Modulus - 1</td>
<td>Jump-ahead</td>
<td>Memory used depends on modulus size</td>
</tr>
<tr>
<td>XorShift* 128/64</td>
<td>2^128 - 1</td>
<td>2^128 - 1</td>
<td>No known implementation</td>
<td>128-bit state.  Described by M. O&#39;Neill in &quot;You don&#39;t have to use PCG!&quot;, 2017.<sup><a href="#Note43"><strong>(43)</strong></a></sup></td>
</tr>
<tr>
<td>XorShift* 64/32</td>
<td>2^64 - 1</td>
<td>2^64 - 1</td>
<td>No known implementation</td>
<td>64-bit state. Described by M. O&#39;Neill in &quot;You don&#39;t have to use PCG!&quot;, 2017.</td>
</tr>
<tr>
<td>C++&#39;s <a href="http://www.cplusplus.com/reference/random/ranlux48/"><strong><code>std::ranlux48</code> engine</strong></a></td>
<td>2^577 - 2</td>
<td>Not discussed (see notes)</td>
<td>No known implementation</td>
<td>Usually takes about 192 8-bit bytes of memory. Seed&#39;s bits cannot be all zeros or all ones (L&uuml;scher 1994)<sup><a href="#Note44"><strong>(44)</strong></a></sup>.  The period for <code>ranlux48</code>&#39;s underlying generator is very close to 2^576.  This PRNG is not preferred.</td>
</tr>
<tr>
<td>A high-quality PRNG that is an LCG with non-prime modulus (or a PRNG based on one, such as PCG)</td>
<td>Depends on parameters</td>
<td>Depends on parameters</td>
<td>Jump-ahead. What PCG calls &quot;streams&quot; does not produce independent sequences.</td>
<td>These PRNGs are not preferred; in particular, if the modulus is a power of 2, they produce highly correlated &quot;random&quot; number sequences from seeds that differ only in their high bits (see S. Vigna, &quot;<a href="http://pcg.di.unimi.it/pcg.php"><strong>The wrap-up on PCG generators</strong></a>&quot;) and lowest bits have short periods.</td>
</tr>
</tbody></table>

<p>The following are not considered high-quality PRNGs:</p>

<ul>
<li>Any LCG with modulus less than 2<sup>63</sup> (such as <code>java.util.Random</code> and C++&#39;s <code>std::minstd_rand</code> and <code>std::minstd_rand0</code> engines) admits fewer than 2<sup>63</sup> seeds.</li>
<li><code>System.Random</code>, as implemented in the .NET Framework 4.7, can take a seed of at most 32 bits, so it admits fewer than 2<sup>63</sup> seeds.</li>
<li>Mersenne Twister (MT19937) shows a <a href="http://xoroshiro.di.unimi.it/#quality"><strong>systematic failure</strong></a> in BigCrush&#39;s LinearComp test (part of L&#39;Ecuyer and Simard&#39;s &quot;TestU01&quot;). (See also (Vigna 2019)<sup><a href="#Note45"><strong>(45)</strong></a></sup>.) Moreover, it usually takes about 2500 8-bit bytes of memory.</li>
<li>Tyche and Tyche-i, as given in (Neves and Araujo 2011)<sup><a href="#Note46"><strong>(46)</strong></a></sup>, allow 2<sup>64</sup> valid seeds, but have no guaranteed cycle length of at least 2<sup>64</sup> per seed.</li>
<li>In general, any so-called &quot;chaotic&quot; PRNG whose period is not close to the number of admissible seeds.  This includes middle square, Rule-30 and other cellular-automaton PRNGs, multiply-with-carry (MWC), and PRNGs that use MWC, such as JKISS, JLKISS, and JLKISS64 (Jones 2007/2010)<sup><a href="#Note47"><strong>(47)</strong></a></sup>.</li>
<li>B. Jenkins&#39;s &quot;A small noncryptographic PRNG&quot; (sometimes known as JSF or JSF64) has no guaranteed cycle length of at least 2<sup>64</sup> per seed.  Moreover, the 32-bit version (JSF32) allows only 2<sup>32</sup> valid seeds (however, Jenkins found JSF32 to produce nonoverlapping streams of at least 2^20 values per seed).</li>
<li><code>msws</code> (Widynski 2017)<sup><a href="#Note48"><strong>(48)</strong></a></sup> allows only about 2<sup>54.1</sup> valid seeds.</li>
<li>Sequential counters.</li>
</ul>

<p><a id=Designs_for_PRNGs></a></p>

<h3>Designs for PRNGs</h3>

<p>There are several possible ways to implement a PRNG:</p>

<ol>
<li>As an object that uses an internal state and the following methods:

<ul>
<li>An initializer method that takes a seed and converts it to an internal state.  This method is called while the PRNG object is being created.</li>
<li>A method that takes no parameters.  It uses only the internal state to output one or more &quot;random&quot; numbers and update the internal state.  This method is available after the initializer is called.</li>
</ul></li>
<li>As a function that takes a seed and outputs one or more &quot;random&quot; numbers.  An example is a <a href="#Hash_Functions"><strong>hash function</strong></a>.</li>
<li>As a function that takes an internal state and outputs a new internal state and one or more &quot;random&quot; numbers.  This is how PRNGs can be implemented as so-called &quot;pure functions&quot; in functional programming languages (as in the package <code>AC-Random</code> for the Haskell language).</li>
<li>As a so-called &quot;splittable&quot; PRNG (Claessen et al., 2013)<sup><a href="#Note49"><strong>(49)</strong></a></sup> with two functions:

<ul>
<li>Split: A function that takes an internal state and outputs two or more new internal states.</li>
<li>Generate: A function that takes an internal state and outputs one or more &quot;random&quot; numbers.</li>
</ul></li>
</ol>

<p>Of the designs just given, the first is <em>stateful</em> and the last three are <em>stateless</em>.</p>

<p><a id=Implementing_New_RNG_APIs></a></p>

<h3>Implementing New RNG APIs</h3>

<p>A <strong>programming language API</strong> designed for reuse by applications could implement RNGs using the following guidelines:</p>

<ol>
<li> The RNG API can include a method that fills one or more memory units (such as 8-bit bytes) completely with random bits.  See example 1.</li>
<li> If the API implements an automatically-seeded RNG, it SHOULD NOT allow applications to initialize that same RNG with a seed for reproducible &quot;randomness&quot;<sup><a href="#Note50"><strong>(50)</strong></a></sup> (it MAY provide a separate PRNG to accept such a seed). See example 2.</li>
<li> If the API provides a PRNG that an application can seed for reproducible &quot;randomness&quot;, it SHOULD document that PRNG and any methods the API provides that use that PRNG (such as shuffling and Gaussian number generation), and SHOULD NOT change that PRNG or those methods in a way that would change the &quot;random&quot; numbers they deliver for a given seed. See example 2.</li>
<li> A new programming language&#39;s <strong>standard library</strong> ought to include the following methods for generating numbers that behave like independent uniform random numbers (see my document on <a href="https://peteroupc.github.io/randomfunc.html"><strong>random number generation methods</strong></a> for details).

<ul>
<li>Four methods for random integers: 0 to <code>n</code> including <code>n</code>, 0 to <code>n</code> excluding <code>n</code>, <code>a</code> to <code>b</code> including <code>b</code>, and <code>a</code> to <code>b</code> excluding <code>b</code>.</li>
<li>Four methods for random numbers bounded by 0 and 1, with and without the endpoints.</li>
<li>Four methods for random numbers bounded by <code>a</code> and <code>b</code>, with and without the endpoints.</li>
</ul></li>
</ol>

<p>&nbsp;</p>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>A C language RNG method for filling memory could look like the following: <code>int random(uint8_t[] bytes, size_t size);</code>, where <code>bytes</code> is a pointer to an array of 8-bit bytes, and <code>size</code> is the number of random 8-bit bytes to generate, and where 0 is returned if the method succeeds and nonzero otherwise.</li>
<li>A Java API that follows these guidelines can contain two classes: a <code>RandomGen</code> class that implements an unspecified but general-purpose RNG, and a <code>RandomStable</code> class that implements an SFC64 PRNG that is documented and will not change in the future. <code>RandomStable</code> includes a constructor that takes a seed for reproducible &quot;randomness&quot;, while <code>RandomGen</code> does not.  Both classes include methods described in point 4, but <code>RandomStable</code> specifies the exact algorithms to those methods and <code>RandomGen</code> does not.  At any time in the future, <code>RandomGen</code> can change its implementation to use a different RNG while remaining backward compatible, while <code>RandomStable</code> has to use the same algorithms for all time to remain backward compatible, especially because it takes a seed for reproducible &quot;randomness&quot;.</li>
</ol>
</blockquote>

<p><a id=Acknowledgments></a></p>

<h2>Acknowledgments</h2>

<p>I acknowledge&mdash;</p>

<ul>
<li>the commenters to the CodeProject version of this page (as well as a similar article of mine on CodeProject), including &quot;Cryptonite&quot; and member 3027120,</li>
<li>Sebastiano Vigna,</li>
<li>Severin Pappadeux, and</li>
<li>Lee Daniel Crocker, who reviewed this document and gave comments.</li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> See also the question titled &quot;Matlab rand and c++ rand()&quot; on <em>Stack Overflow</em>.</small></p>

<p><small><sup id=Note2>(2)</sup> A distinction between <em>cryptographic</em> and <em>noncryptographic</em> RNGs seems natural, because many programming languages offer a general-purpose RNG (such as C&#39;s <code>rand</code> or Java&#39;s <code>java.util.Random</code>) and sometimes an RNG intended for information security purposes (such as Ruby&#39;s <code>SecureRandom</code>).</small></p>

<p><small><sup id=Note3>(3)</sup> F. DÃ¶rre and V. Klebanov, &quot;Practical Detection of Entropy Loss in Pseudo-Random Number Generators&quot;, 2016.</small></p>

<p><small><sup id=Note4>(4)</sup> If the generator produces numbers with unequal probabilities, but is otherwise an RNG as defined here, then  <em>randomness extraction</em> can make it produce numbers with closer to equal probabilities (see &quot;<a href="#Seed_Generation"><strong>Seed Generation</strong></a>&quot;).</small></p>

<p><small><sup id=Note5>(5)</sup> See also the FIPS 200 definition (&quot;The protection of information and information systems from unauthorized access, use, disclosure, disruption, modification, or destruction in order to provide confidentiality, integrity, and availability&quot;) and ISO/IEC 27000.</small></p>

<p><small><sup id=Note6>(6)</sup> However, some versions of GLSL (notably GLSL ES 1.0, as used by WebGL 1.0) might support integers with a restricted range (as low as -1024 to 1024) rather than 32-bit or bigger integers as are otherwise common, making it difficult to write hash functions for random number generation.  An application ought to choose hash functions that deliver acceptable &quot;random&quot; numbers regardless of the kinds of numbers supported.</p>

<p>An alternative for GLSL and other fragment or pixel shaders to support randomness is to have the shader sample a &quot;noise texture&quot; with random data in each pixel; for example, C. Peters, &quot;<a href="http://momentsingraphics.de/?p=127"><strong>Free blue noise textures</strong></a>&quot;, <em>Moments in Graphics</em>, Dec. 22, 2016, discusses how so-called &quot;blue noise&quot; can be sampled this way.</p>

<p>See also N. Reed, &quot;Quick And Easy GPU Random Numbers In D3D11&quot;, Nathan Reed&#39;s coding blog, Jan. 12, 2013.</small></p>

<p><small><sup id=Note7>(7)</sup> M&uuml;ller, S. &quot;CPU Time Jitter Based Non-Physical True Random Number Generator&quot;.</small></p>

<p><small><sup id=Note8>(8)</sup> Liebow-Feeser, J., &quot;Randomness 101: LavaRand in Production&quot;, blog.cloudflare.com, Nov. 6, 2017.</small></p>

<p><small><sup id=Note9>(9)</sup> Liebow-Feeser, J., &quot;LavaRand in Production: The Nitty-Gritty Technical Details&quot;, blog.cloudflare.com, Nov. 6, 2017.</small></p>

<p><small><sup id=Note10>(10)</sup> These steps could also generate random numbers, rather than a seed, but this is generally slower than using PRNGs to do so.</small></p>

<p><small><sup id=Note11>(11)</sup> Also known as <em>entropy extraction</em>, <em>deskewing</em>, <em>whitening</em>, or <em>unbiasing</em>.</small></p>

<p><small><sup id=Note12>(12)</sup> Cliff, Y., Boyd, C., Gonzalez Nieto, J.  &quot;How to Extract and Expand Randomness: A Summary and Explanation of Existing Results&quot;, 2009.</small></p>

<p><small><sup id=Note13>(13)</sup> For example, many questions on <em>Stack Overflow</em> highlight the pitfalls of creating a new instance of the .NET Framework&#39;s <code>System.Random</code> each time a random number is needed, rather than only once in the application.  See also Johansen, R. S., &quot;<a href="https://blogs.unity3d.com/2015/01/07/a-primer-on-repeatable-random-numbers/"><strong>A Primer on Repeatable Random Numbers</strong></a>&quot;, Unity Blog, Jan. 7, 2015.</small></p>

<p><small><sup id=Note14>(14)</sup> Salmon, J.K.; Moraes, M.A.; et al., &quot;Parallel Random Numbers: As Easy as 1, 2, 3&quot;, 2011.</small></p>

<p><small><sup id=Note15>(15)</sup> P. L&#39;Ecuyer, D. Munger, et al. &quot;Random Numbers for Parallel Computers: Requirements and Methods, With Emphasis on GPUs&quot;, April 17, 2015, section 4, goes in greater detail on ways to initialize PRNGs for generating random numbers in parallel, including how to ensure reproducible &quot;randomness&quot; this way if that is desired.</small></p>

<p><small><sup id=Note16>(16)</sup> Using two or more PRNG designs can reduce correlation risks due to a particular PRNG&#39;s design.  For further discussion and an example of a PRNG combining two different PRNG designs, see Agner Fog, &quot;<a href="http://digitalcommons.wayne.edu/jmasm/vol14/iss1/23"><strong>Pseudo-Random Number Generators for Vector Processors and Multicore Processors</strong></a>&quot;, <em>Journal of Modern Applied Statistical Methods</em> 14(1), article 23 (2015).</small></p>

<p><small><sup id=Note17>(17)</sup> Besides the seed, other things are hashed that together serve as a <em>domain separation tag</em> (see, e.g., the work-in-progress document &quot;draft-irtf-cfrg-hash-to-curve&quot;).  Note the following:</p>

<ul>
<li>In general, hash functions carry the risk that two processes will end up with the same PRNG seed (a <em>collision risk</em>) or that a seed not allowed by the PRNG is produced (a &quot;rejection risk&quot;), but this risk decreases the more seeds the PRNG admits (see &quot;<a href="https://en.wikipedia.org/wiki/Birthday_problem"><strong>Birthday problem</strong></a>&quot;).</li>
<li>M. O&#39;Neill (in &quot;Developing a seed_seq Alternative&quot;, Apr. 30, 2015) developed hash functions (<code>seed_seq_fe</code>) that are designed to avoid collisions if possible, and otherwise to reduce collision bias.   For example, <code>seed_seq_fe128</code> hashes 128-bit seeds to 128-bit or longer unique values.</li>
<li>An application can handle a rejected seed by hashing with a different value or by using a backup seed instead, depending on how tolerant the application is to bias.</li>
<li>See also Matsumoto, M., et al., &quot;Common defects in initialization of pseudorandom number generators&quot;, <em>Transactions on Modeling and Computer Simulation</em> 17(4), Sep. 2007.</small></li>
</ul>

<p><small><sup id=Note18>(18)</sup> Using the similar <code>/dev/random</code> is NOT RECOMMENDED, since in some implementations it can block for seconds at a time, especially if not enough randomness is available.  See also <a href="https://www.2uo.de/myths-about-urandom"><strong>&quot;Myths about /dev/urandom&quot;</strong></a>.</small></p>

<p><small><sup id=Note19>(19)</sup> Wetzels, J., &quot;33C3: Analyzing Embedded Operating System Random Number Generators&quot;, samvartaka.github.io, Jan. 3, 2017.</small></p>

<p><small><sup id=Note20>(20)</sup> B. Peng, &quot;Two Fast Methods of Generating True Random Numbers on the Arduino&quot;, GitHub Gist, December 2017.</small></p>

<p><small><sup id=Note21>(21)</sup> A. Klyubin, &quot;Some SecureRandom Thoughts&quot;, Android Developers Blog, Aug. 14, 2013.</small></p>

<p><small><sup id=Note22>(22)</sup> Michaelis, K., Meyer, C., and Schwenk, J. &quot;Randomly Failed! The State of Randomness in Current Java Implementations&quot;, 2013.</small></p>

<p><small><sup id=Note23>(23)</sup> More generally, a list has <code>N! / (W_1! * W_2! * ... * W_K!)</code> permutations (a <a href="http://mathworld.wolfram.com/MultinomialCoefficient.html"><strong>multinomial coefficient</strong></a>), where <code>N</code> is the list&#39;s size, <code>K</code> is the number of different items in the list, and <code>W_i</code> is the number of times the item identified by <code>i</code> appears in the list.  However, this number is never more than <code>N!</code> and suggests using less randomness, so an application need not use this more complicated formula and MAY assume that a list has <code>N!</code> permutations even if some of its items occur more than once.</small></p>

<p><small><sup id=Note24>(24)</sup> Atwood, Jeff. &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/"><strong>The danger of na&iuml;vet&eacute;</strong></a>&quot;, Dec. 7, 2007.</small></p>

<p><small><sup id=Note25>(25)</sup> van Staveren, Hans. <a href="https://sater.home.xs4all.nl/doc.html"><strong>&quot;Big Deal: A new program for dealing bridge hands&quot;</strong></a>, Sep. 8, 2000</small></p>

<p><small><sup id=Note26>(26)</sup> For applications distributed across multiple computers, this check is made easier if each computer is assigned a unique value from a central database, because then the computer can use that unique value as part of unique identifiers it generates and ensure that the identifiers are unique across the application without further contacting other computers or the central database.  An example is Twitter&#39;s <a href="https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake.html"><strong>Snowflake service</strong></a>.</small></p>

<p><small><sup id=Note27>(27)</sup> In theory, generating two or more random integers of the same size runs the risk of producing a duplicate number this way.  However, this risk decreases as that size increases (see &quot;<a href="https://en.wikipedia.org/wiki/Birthday_problem"><strong>Birthday problem</strong></a>&quot;).  For example, in theory, an application has a 50% chance for duplicate numbers after generating&mdash;</p>

<ul>
<li>about 2.7 billion billion random 122-bit integers (including those found in version-4 UUIDs, or universally unique identifiers),</li>
<li>about 1.4 million billion billion random 160-bit integers, or</li>
<li>about 93 billion billion billion random 192-bit integers.</small></li>
</ul>

<p><small><sup id=Note28>(28)</sup> If an application expects end users to type in a unique identifier, it could find that very long unique identifiers are unsuitable for it (e.g. 128-bit numbers take up 32 base-16 characters).  There are ways to deal with these and other long identifiers, including (1) separating memorable chunks of the identifier with a hyphen, space, or another character (e.g., &quot;ABCDEF&quot; becomes &quot;ABC-DEF&quot;); (2) generating the identifier from a sequence of memorable words (as in Electrum or in Bitcoin&#39;s BIP39); or (3) adding a so-called &quot;checksum digit&quot; at the end of the identifier to guard against typing mistakes.  The application ought to consider trying (1) or (2) before deciding to use shorter identifiers than what this document recommends.</small></p>

<p><small><sup id=Note29>(29)</sup> For suggested full-period <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator"><strong>LCGs</strong></a>, see tables 3, 5, 7, and 8 of Steele and Vigna, &quot;Computationally easy, spectrally good multipliers for congruential pseudorandom number generators&quot;, arXiv:2001.05304 [cs.DS].</small></p>

<p><small><sup id=Note30>(30)</sup> The following are some reasons an algorithm might produce different results from run to run or from machine to machine (making it an <em>inconsistent</em> algorithm):</p>

<ul>
<li>The algorithm relies on floating-point number operations.  Different implementations of the same floating-point operation might have subtle differences, including in terms of accuracy, rounding, and operation order, even if they&#39;re given the same input (e.g., Java&#39;s <code>Math</code> vs. <code>StrictMath</code>; the x87 <code>FSIN</code> instruction vs. a software implementation of sine; or a dot product method that decides which implementation to use at runtime). For more information, see &quot;<a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/"><strong>Floating-Point Determinism</strong></a>&quot; by Bruce Dawson, and the white paper &quot;<a href="https://docs.nvidia.com/cuda/floating-point/"><strong>Floating Point and IEEE 754 Compliance for NVIDIA GPUs</strong></a>&quot;.</li>
<li>The algorithm uses features that are not deterministic (output can vary even if input and state are the same), such as accessing the file system or the system clock.</li>
<li>The algorithm relies on undocumented, undefined, or implementation-dependent behavior or features (such as  <em>undefined behavior</em> in C and C++, a particular hash table traversal order, or a particular size for C/C++&#39;s <code>int</code> or <code>long</code>).</small></li>
</ul>

<p><small><sup id=Note31>(31)</sup> For more information on these uses, see B. Mulvey, &quot;<a href="https://papa.bretmulvey.com/post/124027987928"><strong>Hash functions</strong></a>&quot;, <em>The Pluto Scarab</em> July 13, 2015, and Richter, Alvarez, Dittrich, &quot;A Seven-Dimensional Analysis of Hashing Methods and its Implications on Query Processing&quot;, <em>Proceedings of the VLDB Endowment</em> 9(3), 2015.</small></p>

<p><small><sup id=Note32>(32)</sup> There are many kinds of noise, such as procedural noise (including Perlin noise, cellular noise, and value noise), <a href="https://en.wikipedia.org/wiki/Colors_of_noise"><strong>colored noise</strong></a> (including white noise and pink noise), periodic noise, and noise following a Gaussian or other <a href="https://peteroupc.github.io/randomfunc.html#Specific_Non_Uniform_Distributions"><strong>probability distribution</strong></a>.  See also two articles by Red Blob Games: <a href="http://www.redblobgames.com/articles/noise/introduction.html"><strong>&quot;Noise Functions and Map Generation&quot;</strong></a> and <a href="https://www.redblobgames.com/maps/terrain-from-noise/"><strong>&quot;Making maps from noise functions&quot;</strong></a>.</small></p>

<p><small><sup id=Note33>(33)</sup> Noise functions include functions that combine several outputs of a noise function, including by <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion"><strong>fractional Brownian motion</strong></a>.  By definition, noise functions deliver the same output for the same input.</small></p>

<p><small><sup id=Note34>(34)</sup> Verifiable delay functions are different from proofs of work, in which there can be multiple correct answers. These functions were first formally defined in Boneh, D., Bonneau, J., et al., &quot;Verifiable Delay Functions&quot;, 2018, but such functions appeared earlier in Lenstra, A.K., Wesolowski, B., &quot;A random zoo: sloth, unicorn, and trx&quot;, 2015.</small></p>

<p><small><sup id=Note35>(35)</sup> It is outside the scope of this page to explain how to build a protocol using verifiable delay functions, commitment schemes, or mental card game schemes, especially because such protocols are not yet standardized for general use and few implementations of them are used in production.</small></p>

<p><small><sup id=Note36>(36)</sup> Implementing a cryptographic RNG involves many security considerations, including these:</p>

<ol>
<li>If an application runs code from untrusted sources in the same operating system process in which a cryptographic RNG&#39;s state is stored, it&#39;s possible for malicious code to read out that state via side-channel attacks. A cryptographic RNG SHOULD NOT be implemented in such a process. See (A) and see also (B).</li>
<li>A cryptographic RNG&#39;s state could be reused due to process forking or virtual machine snapshot resets.  See (C) and (D), for example.</li>
<li>If a cryptographic RNG is not &quot;constant-time&quot; (the RNG is data-dependent), its timing differences could be exploited in a security attack.</li>
</ol>

<p>(A) &quot;Post-Spectre Threat Model Re-Think&quot; in the Chromium source code repository (May 29, 2018).<br/>(B) Bernstein, D.J. &quot;Entropy Attacks!&quot;, Feb. 5, 2014.<br/>(C) Everspaugh, A., Zhai, Y., et al. &quot;Not-So-Random Numbers in Virtualized Linux and the Whirlwind RNG&quot;, 2014.<br/>(D) Ristenpart, T., Yilek, S. &quot;When Good Randomness Goes Bad: Virtual Machine Reset Vulnerabilities and Hedging Deployed Cryptography&quot;, 2010.</small></p>

<p><small><sup id=Note37>(37)</sup> Such arbitrary data can include process identifiers, time stamps, environment variables, random numbers, virtual machine guest identifiers, and/or other data specific to the session or to the instance of the RNG.  See also NIST SP800-90A and the previous note.</small></p>

<p><small><sup id=Note38>(38)</sup> Bernstein, D.J.  &quot;Fast-key-erasure random number generators&quot;, Jun. 23, 2017.</small></p>

<p><small><sup id=Note39>(39)</sup> For example, a new RNG can be constructed from two independent RNGs using the so-called &quot;shrinking generator&quot; technique: generate one bit from the first RNG and one bit from the second, and take the second bit if the first bit is 1, or repeat this process otherwise.  See J. D. Cook, &quot;Using one RNG to sample another&quot;, June 4, 2019, for more on this technique, including its advantages and drawbacks.</small></p>

<p><small><sup id=Note40>(40)</sup> Although any linear PRNG, such as LCGs and the Xorshift, xoroshiro, and xoshiro families, can support jump-ahead by any number of steps, one interesting choice of jump size is a size equal to the period divided by the golden ratio (see, e.g., the <a href="https://docs.scipy.org/doc/numpy/reference/random/parallel.html#jumping-the-bitgenerator-state"><strong>NumPy implementation</strong></a>).</small></p>

<p><small><sup id=Note41>(41)</sup> Blackman, D., Vigna, S. &quot;Scrambled Linear Pseudorandom Number Generators&quot;, 2019 (xoroshiro and xoshiro families); S. Vigna, &quot;<a href="http://vigna.di.unimi.it/ftp/papers/xorshift.pdf"><strong>An experimental exploration of Marsaglia&#39;s <code>xorshift</code> generators, scrambled</strong></a>&quot;, 2016 (scrambled xorshift family).</small></p>

<p><small><sup id=Note42>(42)</sup> P. L&#39;Ecuyer, &quot;Tables of Linear Congruential Generators of Different Sizes and Good Lattice Structure&quot;, <em>Mathematics of Computation</em> 68(225), January 1999.</small></p>

<p><small><sup id=Note43>(43)</sup> This XorShift* generator is not to be confused with S. Vigna&#39;s *-scrambled PRNGs, which multiply the PRNG state differently than this one does.</small></p>

<p><small><sup id=Note44>(44)</sup> L&uuml;scher, M., &quot;A Portable High-Quality Random Number Generator for Lattice Field Theory Simulations&quot;, arXiv:hep-lat/9309020 (1994).</small></p>

<p><small><sup id=Note45>(45)</sup> S. Vigna, &quot;It Is High Time We Let Go of the Mersenne Twister&quot;, arXiv:1910.06437 [cs.DS], 2019.</small></p>

<p><small><sup id=Note46>(46)</sup> Neves, S., and Araujo, F., &quot;Fast and Small Nonlinear Pseudorandom Number Generators for Computer Simulation&quot;, 2011.</small></p>

<p><small><sup id=Note47>(47)</sup> Jones, D., &quot;Good Practice in (Pseudo) Random Number Generation for Bioinformatics Applications&quot;, 2007/2010.</small></p>

<p><small><sup id=Note48>(48)</sup> Widynski, B., &quot;Middle Square Weyl Sequence RNG&quot;, arXiv:1704.00358 [cs.CR], 2017.</small></p>

<p><small><sup id=Note49>(49)</sup> Claessen, K., Palma, M. &quot;Splittable Pseudorandom Number Generators using Cryptographic Hashing&quot;, <em>Proceedings of Haskell Symposium 2013</em>, pp. 47-58.</small></p>

<p><small><sup id=Note50>(50)</sup> Allowing applications to do so would hamper forward compatibility &mdash; the API would then be less free to change how the RNG is implemented in the future (e.g., to use a cryptographic or otherwise &quot;better&quot; RNG), or to make improvements or bug fixes in methods that use that RNG (such as shuffling and Gaussian number generation).  (As a notable example, the V8 JavaScript engine recently changed its <code>Math.random()</code> implementation to use a variant of <code>xorshift128+</code>, which is backward compatible because nothing in JavaScript allows  <code>Math.random()</code> to be seeded.)  Nevertheless, APIs can still allow applications to provide additional input (&quot;entropy&quot;) to the RNG in order to increase its randomness rather than to ensure repeatability.</small></p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Suggested_Entropy_Size></a></p>

<h3>Suggested Entropy Size</h3>

<p>The following Python code suggests how many bits of entropy are needed for shuffling.  For example:</p>

<ul>
<li>To shuffle an <code>n</code>-item list, the suggested bits of entropy is at least as high as the base-2 logarithm, rounded up, of <code>n!</code> (<code>stateLengthN(n)</code>).</li>
<li>To shuffle a 52-item list, at least 226 bits of entropy is suggested (<code>stateLengthN(52)</code>).</li>
<li>To shuffle two 52-item lists of identical contents together, at least 500 bits of entropy is suggested (<code>stateLengthDecks(2, 52)</code>).</li>
</ul>

<p>&nbsp;</p>

<pre>from math import factorial as fac

def ceillog2(x):
    &quot;&quot;&quot; Calculates base-2 logarithm, rounded up, of x. &quot;&quot;&quot;
    ret=0
    needCeil=True
    while x&gt;1:
       one=needCeil and ((x&amp;1)!=0)
       x=x&gt;&gt;1
       if one:
         ret+=1; needCeil=False
       ret+=1
    return ret

def stateLengthN(n):
  &quot;&quot;&quot; Suggested bits of entropy for PRNGs that shuffle
    a list of n items. &quot;&quot;&quot;
  return ceillog2(fac(n))

def stateLengthNChooseK(n, k):
  &quot;&quot;&quot; Suggested bits of entropy for PRNGs that choose k
   different items randomly from a list of n items
   (see RFC 3797, sec. 3.3) &quot;&quot;&quot;
  return ceillog2(fac(n)/(fac(k)*fac(n-k)))

def stateLengthDecks(numDecks, numCards):
  &quot;&quot;&quot; Suggested bits of entropy for PRNGs that shuffle
    multiple decks of cards in one. &quot;&quot;&quot;
  return ceillog2(fac(numDecks*numCards)/ \
      (fac(numDecks)**numCards))
</pre>

<p><a id=Bays_ndash_Durham_Shuffle></a></p>

<h3>Bays&ndash;Durham Shuffle</h3>

<p>The Bays&ndash;Durham shuffle extends a PRNG&#39;s period (maximum size of a &quot;random&quot; number cycle) by giving it a bigger state. Generally, for a size of <code>tablesize</code>, the period is extended to about the number of ways to arrange a list of size <code>tablesize</code>.  The following describes the Bays&ndash;Durham shuffle with a size of <code>tablesize</code>. (C++&#39;s <code>shuffle_order_engine</code> implements something similar to the shuffle described below.) For PRNGs that output 32- or 64-bit integers 0 or greater, a <code>tablesize</code> of 256, 512, or 1024 is suggested.</p>

<ul>
<li>To initialize, fill a list with as many numbers from the PRNG as <code>tablesize</code>, then set <code>k</code> to another number from the PRNG.</li>
<li>For each &quot;random&quot; number, take the entry at position (<code>k</code> % <code>tablesize</code>) in the list, where &#39;%&#39; is the remainder operator and positions start at 0, then set <code>k</code> to that entry, then replace the entry at that position with a new number from the PRNG, then output <code>k</code>.</li>
</ul>

<p>The Bays&ndash;Durham shuffle is NOT RECOMMENDED for information security purposes.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.
to the shuffle described below.) For PRNGs that output 32- or 64-bit integers 0 or greater, a <code>tablesize</code> of 256, 512, or 1024 is suggested.</p>

<ul>
<li>To initialize, fill a list with as many numbers from the PRNG as <code>tablesize</code>, then set <code>k</code> to another number from the PRNG.</li>
<li>For each &quot;random&quot; number, take the entry at position (<code>k</code> % <code>tablesize</code>) in the list, where &#39;%&#39; is the remainder operator and positions start at 0, then set <code>k</code> to that entry, then replace the entry at that position with a new number from the PRNG, then output <code>k</code>.</li>
</ul>

<p>The Bays&ndash;Durham shuffle is NOT RECOMMENDED for information security purposes.</p>

<p><a id=License_2></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
