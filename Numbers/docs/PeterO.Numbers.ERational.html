<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Numbers.ERational</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>PeterO.Numbers.ERational</h1>

<h2>PeterO.Numbers.ERational</h2>

<pre>public sealed class ERational :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an arbitrary-precision rational number. This class can&#39;t be nherited. (The &quot;E&quot; stands for &quot;extended&quot;, meaning that instances of this lass can be values other than numbers proper, such as infinity and ot-a-number.)<b>Thread safety:</b>Instances of this class are immutable, so they are inherently safe for se by multiple threads. Multiple instances of this object with the same roperties are interchangeable, so they should not be compared using the ==&quot; operator (which might only check if each side of the operator is he same instance).</p>

<h3>ERational Constructor</h3>

<pre>public ERational(
    PeterO.Numbers.EInteger numerator,
    PeterO.Numbers.EInteger denominator);
</pre>

<p><b>Deprecated.</b> Use the ERational.Create method instead. This constructor will be private or unavailable in version 1.0.</p>

<p>Initializes a new instance of the<a href="PeterO.Numbers.ERational.html">PeterO.Numbers.ERational</a>class.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>numerator</i>: The numerator.</p></li>
<li><p><i>denominator</i>: The denominator.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>numerator</i>
or <i>denominator</i>
is null.</p></li>
<li><p>System.ArgumentException:
The denominator is zero.</p></li>
</ul>

<h3>NaN</h3>

<pre>public static readonly PeterO.Numbers.ERational NaN;
</pre>

<p>A not-a-number value.</p>

<h3>NegativeInfinity</h3>

<pre>public static readonly PeterO.Numbers.ERational NegativeInfinity;
</pre>

<p>Negative infinity, less than any other number.</p>

<h3>NegativeZero</h3>

<pre>public static readonly PeterO.Numbers.ERational NegativeZero;
</pre>

<p>A rational number for negative zero.</p>

<h3>One</h3>

<pre>public static readonly PeterO.Numbers.ERational One;
</pre>

<p>The rational number one.</p>

<h3>PositiveInfinity</h3>

<pre>public static readonly PeterO.Numbers.ERational PositiveInfinity;
</pre>

<p>Positive infinity, greater than any other number.</p>

<h3>SignalingNaN</h3>

<pre>public static readonly PeterO.Numbers.ERational SignalingNaN;
</pre>

<p>A signaling not-a-number value.</p>

<h3>Ten</h3>

<pre>public static readonly PeterO.Numbers.ERational Ten;
</pre>

<p>The rational number ten.</p>

<h3>Zero</h3>

<pre>public static readonly PeterO.Numbers.ERational Zero;
</pre>

<p>A rational number for zero.</p>

<h3>Denominator</h3>

<pre>public PeterO.Numbers.EInteger Denominator { get; }
</pre>

<p>Gets this object&#39;s denominator.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s denominator.</p>

<h3>IsFinite</h3>

<pre>public bool IsFinite { get; }
</pre>

<p>Gets a value indicating whether this object is finite (not infinity or aN).</p>

<p><b>Returns:</b></p>

<p><code>
        true
</code> if this object is finite (not infinity or not-a-number (NaN)); otherwise, <code>
        false
</code> .</p>

<h3>IsNegative</h3>

<pre>public bool IsNegative { get; }
</pre>

<p>Gets a value indicating whether this object&#39;s value is negative including negative zero).</p>

<p><b>Returns:</b></p>

<p><code>
        true
</code> if this object&#39;s value is negative; otherwise, <code>
        false
</code> .</p>

<h3>IsZero</h3>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this object&#39;s value equals 0.</p>

<p><b>Returns:</b></p>

<p><code>
        true
</code> if this object&#39;s value equals 0; otherwise, . <code>
        false
</code> .</p>

<h3>Numerator</h3>

<pre>public PeterO.Numbers.EInteger Numerator { get; }
</pre>

<p>Gets this object&#39;s numerator.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s numerator. If this object is a not-a-number value, returns he diagnostic information (which will be negative if this object is egative).</p>

<h3>Sign</h3>

<pre>public int Sign { get; }
</pre>

<p>Gets the sign of this rational number.</p>

<p><b>Returns:</b></p>

<p>Zero if this value is zero or negative zero; -1 if this value is less han 0; and 1 if this value is greater than 0.</p>

<h3>UnsignedNumerator</h3>

<pre>public PeterO.Numbers.EInteger UnsignedNumerator { get; }
</pre>

<p>Gets this object&#39;s numerator with the sign removed.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s numerator. If this object is a not-a-number value, returns he diagnostic information.</p>

<h3>Abs</h3>

<pre>public PeterO.Numbers.ERational Abs();
</pre>

<p>Returns the absolute value of this rational number, that is, a number ith the same value as this one but as a nonnegative number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<h3>Add</h3>

<pre>public PeterO.Numbers.ERational Add(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Adds two rational numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: Another arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two numbers. Returns not-a-number (NaN) if either operand s NaN.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>otherValue</i>
is null.</li>
</ul>

<h3>CompareTo</h3>

<pre>public sealed int CompareTo(
    PeterO.Numbers.ERational other);
</pre>

<p>Compares an arbitrary-precision rational number with this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, r a positive number if this instance is greater.</p>

<h3>CompareToBinary</h3>

<pre>public int CompareToBinary(
    PeterO.Numbers.EFloat other);
</pre>

<p>Compares an arbitrary-precision binary float with this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision binary float.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, r a positive number if this instance is greater.</p>

<h3>CompareToDecimal</h3>

<pre>public int CompareToDecimal(
    PeterO.Numbers.EDecimal other);
</pre>

<p>Compares an arbitrary-precision decimal number with this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, r a positive number if this instance is greater.</p>

<h3>CompareToTotal</h3>

<pre>public int CompareToTotal(
    PeterO.Numbers.ERational other);
</pre>

<p>Compares the values of this object and another object, imposing a total rdering on all possible values. In this method:</p>

<ul>
<li><p>For objects with the same value, the one with the higher denominator as a greater &quot;absolute value&quot;.</p></li>
<li><p>Negative zero is less than positive zero.</p></li>
<li><p>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If both bjects are quiet NaN or both are signaling NaN, the one with the igher diagnostic information has a greater &quot;absolute value&quot;.</p></li>
<li><p>NaN has a higher &quot;absolute value&quot; than infinity.</p></li>
<li><p>Infinity has a higher &quot;absolute value&quot; than any finite number.</p></li>
<li><p>Negative numbers are less than positive numbers.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number to compare with this one.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 0 if both objects have the same value, or -1 if this object is ess than the other value, or 1 if this object is greater.</p>

<h3>CompareToTotalMagnitude</h3>

<pre>public int CompareToTotalMagnitude(
    PeterO.Numbers.ERational other);
</pre>

<p>Compares the absolute values of this object and another object, imposing total ordering on all possible values (ignoring their signs). In this ethod:</p>

<ul>
<li><p>For objects with the same value, the one with the higher denominator as a greater &quot;absolute value&quot;.</p></li>
<li><p>Negative zero and positive zero are considered equal.</p></li>
<li><p>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If both bjects are quiet NaN or both are signaling NaN, the one with the igher diagnostic information has a greater &quot;absolute value&quot;.</p></li>
<li><p>NaN has a higher &quot;absolute value&quot; than infinity.</p></li>
<li><p>Infinity has a higher &quot;absolute value&quot; than any finite number.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number to compare with this one.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 0 if both objects have the same value, or -1 if this object is ess than the other value, or 1 if this object is greater.</p>

<h3>CopySign</h3>

<pre>public PeterO.Numbers.ERational CopySign(
    PeterO.Numbers.ERational other);
</pre>

<p>Returns a number with the same value as this one, but copying the sign positive or negative) of another number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: A number whose sign will be copied.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>other</i>
is null.</li>
</ul>

<h3>Create</h3>

<pre>public static PeterO.Numbers.ERational Create(
    int numeratorSmall,
    int denominatorSmall);
</pre>

<p>Creates a rational number with the given numerator and denominator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>numeratorSmall</i>: The numerator.</p></li>
<li><p><i>denominatorSmall</i>: The denominator.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The denominator is zero.</li>
</ul>

<h3>Create</h3>

<pre>public static PeterO.Numbers.ERational Create(
    PeterO.Numbers.EInteger numerator,
    PeterO.Numbers.EInteger denominator);
</pre>

<p>Creates a rational number with the given numerator and denominator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>numerator</i>: The numerator.</p></li>
<li><p><i>denominator</i>: The denominator.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The denominator is zero.</li>
</ul>

<h3>CreateNaN</h3>

<pre>public static PeterO.Numbers.ERational CreateNaN(
    PeterO.Numbers.EInteger diag);
</pre>

<p>Creates a not-a-number arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>diag</i>: A number to use as diagnostic information associated with this object. If one is needed, should be zero.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>diag</i>
is null.</p></li>
<li><p>System.ArgumentException:
The parameter <i>diag</i>
is less than 0.</p></li>
</ul>

<h3>CreateNaN</h3>

<pre>public static PeterO.Numbers.ERational CreateNaN(
    PeterO.Numbers.EInteger diag,
    bool signaling,
    bool negative);
</pre>

<p>Creates a not-a-number arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>diag</i>: A number to use as diagnostic information associated with this object. If one is needed, should be zero.</p></li>
<li><p><i>signaling</i>: Whether the return value will be signaling (true) or quiet (false).</p></li>
<li><p><i>negative</i>: Whether the return value is negative.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>diag</i>
is null.</p></li>
<li><p>System.ArgumentException:
The parameter <i>diag</i>
is less than 0.</p></li>
</ul>

<h3>Divide</h3>

<pre>public PeterO.Numbers.ERational Divide(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Divides this instance by the value of an arbitrary-precision rational umber object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>otherValue</i>
is null.</li>
</ul>

<h3>Equals</h3>

<pre>public override bool Equals(
    object obj);
</pre>

<p>Determines whether this object&#39;s numerator, denominator, and properties re equal to those of another object and that other object is an rbitrary-precision rational number. Not-a-number values are considered qual if the rest of their properties are equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The parameter <i>obj</i>
is an arbitrary object.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if the objects are equal; otherwise, <code>
        false
</code> .</p>

<h3>Equals</h3>

<pre>public sealed bool Equals(
    PeterO.Numbers.ERational other);
</pre>

<p>Determines whether this object&#39;s numerator, denominator, and properties re equal to those of another object. Not-a-number values are considered qual if the rest of their properties are equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number to compare to.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Either <code>
        true
</code> or <code>
        false
</code> .</p>

<h3>FromByte</h3>

<pre>public static PeterO.Numbers.ERational FromByte(
    byte inputByte);
</pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputByte</i>: The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>FromDecimal</h3>

<pre>public static PeterO.Numbers.ERational FromDecimal(
    System.Decimal eint);
</pre>

<p>Converts a <code>
        decimal
</code> under the Common Language Infrastructure (usually a .NET Framework ecimal) to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: The number to convert as a <code>
    decimal
</code> under the Common Language Infrastructure (usually a .NET Framework ecimal).</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<h3>FromDouble</h3>

<pre>public static PeterO.Numbers.ERational FromDouble(
    double flt);
</pre>

<p>Converts a 64-bit floating-point number to a rational number. This method omputes the exact value of the floating point number, not an pproximation, as is often the case by converting the number to a string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>flt</i>: The parameter <i>flt</i>
is a 64-bit floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A rational number with the same value as <i>flt</i>
.</p>

<h3>FromEDecimal</h3>

<pre>public static PeterO.Numbers.ERational FromEDecimal(
    PeterO.Numbers.EDecimal ef);
</pre>

<p>Converts an arbitrary-precision decimal number to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>ef</i>
is null.</li>
</ul>

<h3>FromEFloat</h3>

<pre>public static PeterO.Numbers.ERational FromEFloat(
    PeterO.Numbers.EFloat ef);
</pre>

<p>Converts an arbitrary-precision binary float to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision binary float.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>ef</i>
is null.</li>
</ul>

<h3>FromEInteger</h3>

<pre>public static PeterO.Numbers.ERational FromEInteger(
    PeterO.Numbers.EInteger bigint);
</pre>

<p>Converts an arbitrary-precision integer to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigint</i>: The number to convert as an arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the integer as a rational number.</p>

<h3>FromExtendedDecimal</h3>

<pre>public static PeterO.Numbers.ERational FromExtendedDecimal(
    PeterO.Numbers.EDecimal ef);
</pre>

<p><b>Deprecated.</b> Renamed to FromEDecimal.</p>

<p>Converts an arbitrary-precision decimal number to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>ef</i>
is null.</li>
</ul>

<h3>FromExtendedFloat</h3>

<pre>public static PeterO.Numbers.ERational FromExtendedFloat(
    PeterO.Numbers.EFloat ef);
</pre>

<p><b>Deprecated.</b> Renamed to FromEFloat.</p>

<p>Converts an arbitrary-precision binary float to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision binary float.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>ef</i>
is null.</li>
</ul>

<h3>FromInt16</h3>

<pre>public static PeterO.Numbers.ERational FromInt16(
    short inputInt16);
</pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt16</i>: The number to convert as a 16-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>FromInt32</h3>

<pre>public static PeterO.Numbers.ERational FromInt32(
    int inputInt32);
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>FromInt64</h3>

<pre>public static PeterO.Numbers.ERational FromInt64(
    long inputInt64);
</pre>

<p>Converts a 64-bit signed integer to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt64</i>: The number to convert as a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>FromSByte</h3>

<pre>public static PeterO.Numbers.ERational FromSByte(
    sbyte inputSByte);
</pre>

<p>Converts an 8-bit signed integer to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputSByte</i>: The number to convert as an 8-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>FromSingle</h3>

<pre>public static PeterO.Numbers.ERational FromSingle(
    float flt);
</pre>

<p>Converts a 32-bit binary floating-point number to a rational number. This ethod computes the exact value of the floating point number, not an pproximation, as is often the case by converting the number to a string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>flt</i>: The parameter <i>flt</i>
is a 32-bit binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A rational number with the same value as <i>flt</i>
.</p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    string str);
</pre>

<p>Creates a rational number from a text string that represents a number. ee <code>
        FromString(String, int, int)
</code> for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>str</i>: A string that represents a number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number with the same value as the given tring.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>str</i>
is null.</p></li>
<li><p>System.FormatException:
The parameter <i>str</i>
is not a correctly formatted number string.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    string str,
    int offset,
    int length);
</pre>

<p>Creates a rational number from a text string that represents a number.</p>

<p>The format of the string generally consists of:</p>

<ul>
<li><p>An optional plus sign (&quot;+&quot; , U+002B) or minus sign (&quot;-&quot;, U+002D) (if -&#39; , the value is negative.)</p></li>
<li><p>The numerator in the form of one or more digits.</p></li>
<li><p>Optionally, &quot;/&quot; followed by the denominator in the form of one or ore digits. If a denominator is not given, it&#39;s equal to 1.</p></li>
</ul>

<p>The string can also be &quot;-INF&quot;, &quot;-Infinity&quot;, &quot;Infinity&quot;, &quot;INF&quot;, quiet aN (&quot;NaN&quot; /&quot;-NaN&quot;) followed by any number of digits, or signaling NaN &quot;sNaN&quot; /&quot;-sNaN&quot;) followed by any number of digits, all in any ombination of upper and lower case.</p>

<p>All characters mentioned above are the corresponding characters in the asic Latin range. In particular, the digits must be the basic digits 0 o 9 (U+0030 to U+0039). The string is not allowed to contain white pace characters, including spaces.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A text string, a portion of which represents a number.</p></li>
<li><p><i>offset</i>: A zero-based index that identifies the start of the number.</p></li>
<li><p><i>length</i>: The length of the number within the string.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>str</i>
is null.</p></li>
<li><p>System.FormatException:
The parameter <i>str</i>
is not a correctly formatted number string.</p></li>
</ul>

<h3>FromUInt16</h3>

<pre>public static PeterO.Numbers.ERational FromUInt16(
    ushort inputUInt16);
</pre>

<p>Converts a 16-bit unsigned integer to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt16</i>: The number to convert as a 16-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>FromUInt32</h3>

<pre>public static PeterO.Numbers.ERational FromUInt32(
    uint inputUInt32);
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>FromUInt64</h3>

<pre>public static PeterO.Numbers.ERational FromUInt64(
    ulong inputUInt64);
</pre>

<p>Converts a 64-bit unsigned integer to an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt64</i>: The number to convert as a 64-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<h3>GetHashCode</h3>

<pre>public override int GetHashCode();
</pre>

<p>Returns the hash code for this instance. No application or process IDs re used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit hash code.</p>

<h3>IsInfinity</h3>

<pre>public bool IsInfinity();
</pre>

<p>Gets a value indicating whether this object&#39;s value is infinity.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object&#39;s value is infinity; otherwise, <code>
        false
</code> .</p>

<h3>IsNaN</h3>

<pre>public bool IsNaN();
</pre>

<p>Returns whether this object is a not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is a not-a-number value; otherwise, <code>
        false
</code> .</p>

<h3>IsNegativeInfinity</h3>

<pre>public bool IsNegativeInfinity();
</pre>

<p>Returns whether this object is negative infinity.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is negative infinity; otherwise, <code>
        false
</code> .</p>

<h3>IsPositiveInfinity</h3>

<pre>public bool IsPositiveInfinity();
</pre>

<p>Returns whether this object is positive infinity.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is positive infinity; otherwise, <code>
        false
</code> .</p>

<h3>IsQuietNaN</h3>

<pre>public bool IsQuietNaN();
</pre>

<p>Returns whether this object is a quiet not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is a quiet not-a-number value; otherwise, <code>
        false
</code> .</p>

<h3>IsSignalingNaN</h3>

<pre>public bool IsSignalingNaN();
</pre>

<p>Returns whether this object is a signaling not-a-number value (which auses an error if the value is passed to any arithmetic operation in this lass).</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is a signaling not-a-number value (which causes an error f the value is passed to any arithmetic operation in this class); therwise, <code>
        false
</code> .</p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.ERational Multiply(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Multiplies this instance by the value of an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>otherValue</i>
is null.</li>
</ul>

<h3>Negate</h3>

<pre>public PeterO.Numbers.ERational Negate();
</pre>

<p>Returns a rational number with the same value as this one but with the ign reversed.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<h3>Operator <code>+</code></h3>

<pre>public static PeterO.Numbers.ERational operator +(
    PeterO.Numbers.ERational bthis,
    PeterO.Numbers.ERational augend);
</pre>

<p>Adds two rational numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The first operand.</p></li>
<li><p><i>augend</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two numbers. Returns not-a-number (NaN) if either operand s NaN.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<h3>Operator <code>/</code></h3>

<pre>public static PeterO.Numbers.ERational operator /(
    PeterO.Numbers.ERational dividend,
    PeterO.Numbers.ERational divisor);
</pre>

<p>Divides an arbitrary-precision rational number by the value of another rbitrary-precision rational number object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: An arbitrary-precision rational number serving as the dividend.</p></li>
<li><p><i>divisor</i>: An arbitrary-precision rational number serving as the divisor.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<h3>Operator <code>%</code></h3>

<pre>public static PeterO.Numbers.ERational operator %(
    PeterO.Numbers.ERational dividend,
    PeterO.Numbers.ERational divisor);
</pre>

<p>Finds the remainder that results when this instance is divided by the alue of an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: The dividend.</p></li>
<li><p><i>divisor</i>: The divisor.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<h3>Operator <code>*</code></h3>

<pre>public static PeterO.Numbers.ERational operator *(
    PeterO.Numbers.ERational operand1,
    PeterO.Numbers.ERational operand2);
</pre>

<p>Multiplies this instance by the value of an arbitrary-precision rational umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>operand1</i>: The first operand.</p></li>
<li><p><i>operand2</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.ERational operator -(
    PeterO.Numbers.ERational bthis,
    PeterO.Numbers.ERational subtrahend);
</pre>

<p>Subtracts an arbitrary-precision rational number from this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The first operand.</p></li>
<li><p><i>subtrahend</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.ERational operator -(
    PeterO.Numbers.ERational bigValue);
</pre>

<p>Returns an arbitrary-precision rational number with the same value as the iven one but with its sign reversed.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: An arbitrary-precision rational number to negate.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigValue</i>
is null.</li>
</ul>

<h3>Remainder</h3>

<pre>public PeterO.Numbers.ERational Remainder(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Finds the remainder that results when this instance is divided by the alue of an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>otherValue</i>
is null.</li>
</ul>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.ERational Subtract(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Subtracts an arbitrary-precision rational number from this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>otherValue</i>
is null.</li>
</ul>

<h3>ToByteChecked</h3>

<pre>public byte ToByteChecked();
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a yte (from 0 to 255) after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 255.</li>
</ul>

<h3>ToByteIfExact</h3>

<pre>public byte ToByteIfExact();
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a yte (from 0 to 255) without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 255.</li>
</ul>

<h3>ToByteUnchecked</h3>

<pre>public byte ToByteUnchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a byte (from 0 to 55).</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a byte (from 0 to 255). Returns 0 if this value s infinity or not-a-number.</p>

<h3>ToDecimal</h3>

<pre>public System.Decimal ToDecimal();
</pre>

<p>Converts this value to a <code>
        decimal
</code> under the Common Language Infrastructure (usually a .NET Framework ecimal). Currently, converts this value to the precision and range of a NET Framework decimal.</p>

<p><b>Return Value:</b></p>

<p>A <code>
        decimal
</code> under the Common Language Infrastructure (usually a .NET Framework ecimal).</p>

<h3>ToDouble</h3>

<pre>public double ToDouble();
</pre>

<p>Converts this value to a 64-bit floating-point number. The half-even ounding mode is used.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit floating-point number to this value. The return value an be positive infinity or negative infinity if this value exceeds the ange of a 64-bit floating point number.</p>

<h3>ToEDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToEDecimal(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to a decimal number and rounds the result o the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. If HasFlags of the context is true, will lso store the flags resulting from the operation (the flags are in ddition to the pre-existing flags). Can be null, in which case the recision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns ot-a-number (NaN) if the context is null and the result can&#39;t be exact ecause it has a nonterminating decimal expansion.</p>

<h3>ToEDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToEDecimal();
</pre>

<p>Converts this rational number to a decimal number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the esult can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<h3>ToEDecimalExactIfPossible</h3>

<pre>public PeterO.Numbers.EDecimal ToEDecimalExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to a decimal number, but if the result ould have a nonterminating decimal expansion, rounds that result to the iven precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used only if the exact esult would have a nonterminating decimal expansion. If HasFlags of the ontext is true, will also store the flags resulting from the operation the flags are in addition to the pre-existing flags). Can be null, in hich case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise,the rounded ersion of the result if a context is given. Returns not-a-number (NaN) if he context is null and the result can&#39;t be exact because it has a onterminating decimal expansion.</p>

<h3>ToEFloat</h3>

<pre>public PeterO.Numbers.EFloat ToEFloat(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to a binary float and rounds that result to he given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. If HasFlags of the context is true, will lso store the flags resulting from the operation (the flags are in ddition to the pre-existing flags). Can be null, in which case the recision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns ot-a-number (NaN) if the context is null and the result can&#39;t be exact ecause it has a nonterminating binary expansion.</p>

<h3>ToEFloat</h3>

<pre>public PeterO.Numbers.EFloat ToEFloat();
</pre>

<p>Converts this rational number to a binary float.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the esult can&#39;t be exact because it has a nonterminating binary expansion.</p>

<h3>ToEFloatExactIfPossible</h3>

<pre>public PeterO.Numbers.EFloat ToEFloatExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to a binary float, but if the result would ave a nonterminating binary expansion, rounds that result to the given recision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used only if the exact esult would have a nonterminating binary expansion. If HasFlags of the ontext is true, will also store the flags resulting from the operation the flags are in addition to the pre-existing flags). Can be null, in hich case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise,the rounded ersion of the result if a context is given. Returns not-a-number (NaN) if he context is null and the result can&#39;t be exact because it has a onterminating binary expansion.</p>

<h3>ToEInteger</h3>

<pre>public PeterO.Numbers.EInteger ToEInteger();
</pre>

<p>Converts this value to an arbitrary-precision integer. Any fractional art in this value will be discarded when converting to an rbitrary-precision integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</li>
</ul>

<h3>ToEIntegerExact</h3>

<pre>public PeterO.Numbers.EInteger ToEIntegerExact();
</pre>

<p><b>Deprecated.</b> Renamed to ToEIntegerIfExact.</p>

<p>Converts this value to an arbitrary-precision integer, checking whether he value is an exact integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</p></li>
<li><p>System.ArithmeticException:
This object&#39;s value is not an exact integer.</p></li>
</ul>

<h3>ToEIntegerIfExact</h3>

<pre>public PeterO.Numbers.EInteger ToEIntegerIfExact();
</pre>

<p>Converts this value to an arbitrary-precision integer, checking whether he value is an exact integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</p></li>
<li><p>System.ArithmeticException:
This object&#39;s value is not an exact integer.</p></li>
</ul>

<h3>ToExtendedDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimal(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimal.</p>

<p>Converts this rational number to a decimal number and rounds the result o the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. If HasFlags of the context is true, will lso store the flags resulting from the operation (the flags are in ddition to the pre-existing flags). Can be null, in which case the recision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns ot-a-number (NaN) if the context is null and the result can&#39;t be exact ecause it has a nonterminating decimal expansion.</p>

<h3>ToExtendedDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimal();
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimal.</p>

<p>Converts this rational number to a decimal number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the esult can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<h3>ToExtendedDecimalExactIfPossible</h3>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimalExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimalExactIfPossible.</p>

<p>Converts this rational number to a decimal number, but if the result ould have a nonterminating decimal expansion, rounds that result to the iven precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used only if the exact esult would have a nonterminating decimal expansion. If HasFlags of the ontext is true, will also store the flags resulting from the operation the flags are in addition to the pre-existing flags). Can be null, in hich case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise,the rounded ersion of the result if a context is given. Returns not-a-number (NaN) if he context is null and the result can&#39;t be exact because it has a onterminating decimal expansion.</p>

<h3>ToExtendedFloat</h3>

<pre>public PeterO.Numbers.EFloat ToExtendedFloat(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloat.</p>

<p>Converts this rational number to a binary float and rounds that result to he given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. If HasFlags of the context is true, will lso store the flags resulting from the operation (the flags are in ddition to the pre-existing flags). Can be null, in which case the recision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns ot-a-number (NaN) if the context is null and the result can&#39;t be exact ecause it has a nonterminating binary expansion.</p>

<h3>ToExtendedFloat</h3>

<pre>public PeterO.Numbers.EFloat ToExtendedFloat();
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloat.</p>

<p>Converts this rational number to a binary float.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the esult can&#39;t be exact because it has a nonterminating binary expansion.</p>

<h3>ToExtendedFloatExactIfPossible</h3>

<pre>public PeterO.Numbers.EFloat ToExtendedFloatExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloatExactIfPossible.</p>

<p>Converts this rational number to a binary float, but if the result would ave a nonterminating binary expansion, rounds that result to the given recision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used only if the exact esult would have a nonterminating binary expansion. If HasFlags of the ontext is true, will also store the flags resulting from the operation the flags are in addition to the pre-existing flags). Can be null, in hich case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise,the rounded ersion of the result if a context is given. Returns not-a-number (NaN) if he context is null and the result can&#39;t be exact because it has a onterminating binary expansion.</p>

<h3>ToInt16Checked</h3>

<pre>public short ToInt16Checked();
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in 16-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -32768 or greater than 32767.</li>
</ul>

<h3>ToInt16IfExact</h3>

<pre>public short ToInt16IfExact();
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in 16-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -32768 or greater than 32767.</li>
</ul>

<h3>ToInt16Unchecked</h3>

<pre>public short ToInt16Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 16-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToInt32Checked</h3>

<pre>public int ToInt32Checked();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -2147483648 or greater than 2147483647.</li>
</ul>

<h3>ToInt32IfExact</h3>

<pre>public int ToInt32IfExact();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -2147483648 or greater than 2147483647.</li>
</ul>

<h3>ToInt32Unchecked</h3>

<pre>public int ToInt32Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 32-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToInt64Checked</h3>

<pre>public long ToInt64Checked();
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in 64-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<h3>ToInt64IfExact</h3>

<pre>public long ToInt64IfExact();
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in 64-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<h3>ToInt64Unchecked</h3>

<pre>public long ToInt64Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 64-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToSByteChecked</h3>

<pre>public sbyte ToSByteChecked();
</pre>

<p>Converts this number&#39;s value to an 8-bit signed integer if it can fit in n 8-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -128 or greater than 127.</li>
</ul>

<h3>ToSByteIfExact</h3>

<pre>public sbyte ToSByteIfExact();
</pre>

<p>Converts this number&#39;s value to an 8-bit signed integer if it can fit in n 8-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -128 or greater than 127.</li>
</ul>

<h3>ToSByteUnchecked</h3>

<pre>public sbyte ToSByteUnchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as an 8-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an 8-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToSingle</h3>

<pre>public float ToSingle();
</pre>

<p>Converts this value to a 32-bit binary floating-point number. The alf-even rounding mode is used.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value. The return alue can be positive infinity or negative infinity if this value exceeds he range of a 32-bit floating point number.</p>

<h3>ToString</h3>

<pre>public override string ToString();
</pre>

<p>Converts this object to a text string.</p>

<p><b>Return Value:</b></p>

<p>A string representation of this object. If this object&#39;s value is nfinity or not-a-number, the result is the analogous return value of the <code>
        EDecimal.ToString
</code> method. Otherwise, the return value has the following form: <code>
        [-]numerator/denominator
</code> .</p>

<h3>ToUInt16Checked</h3>

<pre>public ushort ToUInt16Checked();
</pre>

<p>Converts this number&#39;s value to a 16-bit unsigned integer if it can fit n a 16-bit unsigned integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 65535.</li>
</ul>

<h3>ToUInt16IfExact</h3>

<pre>public ushort ToUInt16IfExact();
</pre>

<p>Converts this number&#39;s value to a 16-bit unsigned integer if it can fit n a 16-bit unsigned integer without rounding to a different numerical alue.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 65535.</li>
</ul>

<h3>ToUInt16Unchecked</h3>

<pre>public ushort ToUInt16Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 16-bit unsigned nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit unsigned integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToUInt32Checked</h3>

<pre>public uint ToUInt32Checked();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 4294967295.</li>
</ul>

<h3>ToUInt32IfExact</h3>

<pre>public uint ToUInt32IfExact();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 4294967295.</li>
</ul>

<h3>ToUInt32Unchecked</h3>

<pre>public uint ToUInt32Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 32-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToUInt64Checked</h3>

<pre>public ulong ToUInt64Checked();
</pre>

<p>Converts this number&#39;s value to a 64-bit unsigned integer if it can fit n a 64-bit unsigned integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 18446744073709551615.</li>
</ul>

<h3>ToUInt64IfExact</h3>

<pre>public ulong ToUInt64IfExact();
</pre>

<p>Converts this number&#39;s value to a 64-bit unsigned integer if it can fit n a 64-bit unsigned integer without rounding to a different numerical alue.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 18446744073709551615.</li>
</ul>

<h3>ToUInt64Unchecked</h3>

<pre>public ulong ToUInt64Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 64-bit unsigned nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit unsigned integer. Returns 0 if this alue is infinity or not-a-number.</p>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = xExtra(document).getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
}
document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
