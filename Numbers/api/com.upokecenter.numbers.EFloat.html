<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>com.upokecenter.numbers.EFloat</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>com.upokecenter.numbers.EFloat</h1>

<h1>com.upokecenter.numbers.EFloat</h1>

<pre>public final class EFloat extends java.lang.Object implements java.lang.Comparable&lt;EFloat&gt;
</pre>

<p>Represents an arbitrary-precision binary floating-point number. (The &quot;E&quot;
  stands for &quot;extended&quot;, meaning that instances of this class can be
 values other than numbers proper, such as infinity and
 not-a-number.) Each number consists of an integer mantissa
 (significand) and an integer exponent, both arbitrary-precision. The
 value of the number equals mantissa (significand) * 2^exponent. This
 class also supports values for negative zero, not-a-number (NaN)
 values, and infinity. <p>Passing a signaling NaN to any arithmetic
 operation shown here will signal the flag FlagInvalid and return a
 quiet NaN, even if another operand to that operation is a quiet NaN,
 unless noted otherwise.</p> <p>Passing a quiet NaN to any arithmetic
 operation shown here will return a quiet NaN, unless noted
 otherwise.</p> <p>Unless noted otherwise, passing a null
 arbitrary-precision binary float argument to any method here will
 throw an exception.</p> <p>When an arithmetic operation signals the
 flag FlagInvalid, FlagOverflow, or FlagDivideByZero, it will not
 throw an exception too, unless the operation&#39;s trap is enabled in
 the arithmetic context (see EContext&#39;s Traps property).</p> <p>An
 arbitrary-precision binary float value can be serialized in one of
 the following ways:</p> <ul> <li>By calling the toString() method.
 However, not all strings can be converted back to an
 arbitrary-precision binary float without loss, especially if the
 string has a fractional part.</li> <li>By calling the
 UnsignedMantissa, Exponent, and IsNegative properties, and calling
 the IsInfinity, IsQuietNaN, and IsSignalingNaN methods. The return
 values combined will uniquely identify a particular
 arbitrary-precision binary float value.</li></ul> <p>If an operation
 requires creating an intermediate value that might be too big to fit
 in memory (or might require more than 2 gigabytes of memory to store
 -- due to the current use of a 32-bit integer internally as a
 length), the operation may signal an invalid-operation flag and
 return not-a-number (NaN). In certain rare cases, the compareTo
 method may throw OutOfMemoryError (called OutOfMemoryError in Java)
 in the same circumstances.</p> <p><b>Thread safety</b></p>
 <p>Instances of this class are immutable, so they are inherently
 safe for use by multiple threads. Multiple instances of this object
 with the same properties are interchangeable, so they should not be
  compared using the &quot;==&quot; operator (which might only check if each
 side of the operator is the same instance).</p> <p><b>Comparison
 considerations</b></p> <p>This class&#39;s natural ordering (under the
 compareTo method) is not consistent with the Equals method. This
 means that two values that compare as equal under the compareTo
 method might not be equal under the Equals method. The compareTo
 method compares the mathematical values of the two instances passed
 to it (and considers two different NaN values as equal), while two
 instances with the same mathematical value, but different exponents,
 will be considered unequal under the Equals method.</p>
 <p><b>Security note</b></p> <p>It is not recommended to implement
 security-sensitive algorithms using the methods in this class, for
 several reasons:</p> <ul> <li><code>EFloat</code> objects are immutable,
 so they can&#39;t be modified, and the memory they occupy is not
 guaranteed to be cleared in a timely fashion due to garbage
 collection. This is relevant for applications that use many-bit-long
 numbers as secret parameters.</li> <li>The methods in this class
 (especially those that involve arithmetic) are not guaranteed to be
  &quot;constant-time&quot; (non-data-dependent) for all relevant inputs.
 Certain attacks that involve encrypted communications have exploited
 the timing and other aspects of such communications to derive keying
 material or cleartext indirectly.</li></ul> <p>Applications should
 instead use dedicated security libraries to handle big numbers in
 security-sensitive algorithms.</p></p>

<h2>Fields</h2>

<ul>
<li><code>static EFloat NaN</code><br>
A not-a-number value.</li>
<li><code>static EFloat NegativeInfinity</code><br>
Negative infinity, less than any other number.</li>
<li><code>static EFloat NegativeZero</code><br>
Represents the number negative zero.</li>
<li><code>static EFloat One</code><br>
Represents the number 1.</li>
<li><code>static EFloat PositiveInfinity</code><br>
Positive infinity, greater than any other number.</li>
<li><code>static EFloat SignalingNaN</code><br>
A not-a-number value that signals an invalid operation flag when it&#39;s passed
as an argument to any arithmetic operation in arbitrary-precision
binary float.</li>
<li><code>static EFloat Ten</code><br>
Represents the number 10.</li>
<li><code>static EFloat Zero</code><br>
Represents the number 0.</li>
</ul>

<h2>Methods</h2>

<ul>
<li><code>EFloat Abs()</code><br>
Finds the absolute value of this object (if it&#39;s negative, it becomes
positive).</li>
<li><code>EFloat Abs​(EContext context)</code><br>
Finds the absolute value of this object (if it&#39;s negative, it becomes
positive).</li>
<li><code>EFloat Add​(int intValue)</code><br>
Not documented yet.</li>
<li><code>EFloat Add​(EFloat otherValue)</code><br>
Adds this object and another binary float and returns the result.</li>
<li><code>EFloat Add​(EFloat otherValue,
EContext ctx)</code><br>
Finds the sum of this object and another object.</li>
<li><code>int compareTo​(EFloat other)</code><br>
Compares the mathematical values of this object and another object,
accepting NaN values.</li>
<li><code>EFloat CompareToSignal​(EFloat other,
           EContext ctx)</code><br>
Compares the mathematical values of this object and another object, treating
quiet NaN as signaling.</li>
<li><code>int CompareToTotal​(EFloat other)</code><br>
Compares the values of this object and another object, imposing a total
ordering on all possible values.</li>
<li><code>int CompareToTotal​(EFloat other,
          EContext ctx)</code><br>
Compares the values of this object and another object, imposing a total
ordering on all possible values.</li>
<li><code>int CompareToTotalMagnitude​(EFloat other)</code><br>
Compares the absolute values of this object and another object, imposing a
total ordering on all possible values (ignoring their signs).</li>
<li><code>int CompareToTotalMagnitude​(EFloat other,
                   EContext ctx)</code><br>
Compares the values of this object and another object, imposing a total
ordering on all possible values (ignoring their signs).</li>
<li><code>EFloat CompareToWithContext​(EFloat other,
                EContext ctx)</code><br>
Compares the mathematical values of this object and another object.</li>
<li><code>EFloat Copy()</code><br>
Creates a copy of this arbitrary-precision binary number.</li>
<li><code>EFloat CopySign​(EFloat other)</code><br>
Returns a number with the same value as this one, but copying the sign
(positive or negative) of another number.</li>
<li><code>static EFloat Create​(int mantissaSmall,
  int exponentSmall)</code><br>
Creates a number with the value exponent*2^mantissa (significand).</li>
<li><code>static EFloat Create​(EInteger mantissa,
  EInteger exponent)</code><br>
Creates a number with the value exponent*2^mantissa (significand).</li>
<li><code>static EFloat CreateNaN​(EInteger diag)</code><br>
Creates a not-a-number arbitrary-precision binary floating-point number.</li>
<li><code>static EFloat CreateNaN​(EInteger diag,
     boolean signaling,
     boolean negative,
     EContext ctx)</code><br>
Creates a not-a-number arbitrary-precision binary floating-point number.</li>
<li><code>EFloat Divide​(int intValue)</code><br>
Divides this instance by the value of an arbitrary-precision integer.</li>
<li><code>EFloat Divide​(EFloat divisor)</code><br>
Divides this object by another binary float and returns the result.</li>
<li><code>EFloat Divide​(EFloat divisor,
  EContext ctx)</code><br>
Divides this arbitrary-precision binary float by another arbitrary-precision
binary floating-point number.</li>
<li><code>EFloat[] DivideAndRemainderNaturalScale​(EFloat divisor)</code><br>
Deprecated.
Renamed to DivRemNaturalScale.
Renamed to DivRemNaturalScale.</li>
<li><code>EFloat[] DivideAndRemainderNaturalScale​(EFloat divisor,
                          EContext ctx)</code><br>
Deprecated.
Renamed to DivRemNaturalScale.
Renamed to DivRemNaturalScale.</li>
<li><code>EFloat DivideToExponent​(EFloat divisor,
            long desiredExponentSmall,
            EContext ctx)</code><br>
Divides two arbitrary-precision binary floating-point numbers, and gives a
particular exponent to the result.</li>
<li><code>EFloat DivideToExponent​(EFloat divisor,
            long desiredExponentSmall,
            ERounding rounding)</code><br>
Divides two arbitrary-precision binary floating-point numbers, and gives a
particular exponent to the result.</li>
<li><code>EFloat DivideToExponent​(EFloat divisor,
            EInteger exponent,
            EContext ctx)</code><br>
Divides two arbitrary-precision binary floating-point numbers, and gives a
particular exponent to the result.</li>
<li><code>EFloat DivideToExponent​(EFloat divisor,
            EInteger desiredExponent,
            ERounding rounding)</code><br>
Divides two arbitrary-precision binary floating-point numbers, and gives a
particular exponent to the result.</li>
<li><code>EFloat DivideToIntegerNaturalScale​(EFloat divisor)</code><br>
Divides two arbitrary-precision binary floating-point numbers, and returns
the integer part of the result, rounded down, with the preferred
exponent set to this value&#39;s exponent minus the divisor&#39;s exponent.</li>
<li><code>EFloat DivideToIntegerNaturalScale​(EFloat divisor,
                       EContext ctx)</code><br>
Divides this object by another object, and returns the integer part of the
result (which is initially rounded down), with the preferred
exponent set to this value&#39;s exponent minus the divisor&#39;s exponent.</li>
<li><code>EFloat DivideToIntegerZeroScale​(EFloat divisor,
                    EContext ctx)</code><br>
Divides this object by another object, and returns the integer part of the
result, with the exponent set to 0.</li>
<li><code>EFloat DivideToSameExponent​(EFloat divisor,
                ERounding rounding)</code><br>
Divides this object by another binary float and returns a result with the
same exponent as this object (the dividend).</li>
<li><code>EFloat[] DivRemNaturalScale​(EFloat divisor)</code><br>
Calculates the quotient and remainder using the DivideToIntegerNaturalScale
and the formula in RemainderNaturalScale.</li>
<li><code>EFloat[] DivRemNaturalScale​(EFloat divisor,
              EContext ctx)</code><br>
Calculates the quotient and remainder using the DivideToIntegerNaturalScale
and the formula in RemainderNaturalScale.</li>
<li><code>boolean equals​(EFloat other)</code><br>
Determines whether this object&#39;s mantissa (significand), exponent, and
properties are equal to those of another object.</li>
<li><code>boolean equals​(java.lang.Object obj)</code><br>
Determines whether this object&#39;s mantissa (significand), exponent, and
properties are equal to those of another object and that other
object is an arbitrary-precision binary floating-point number.</li>
<li><code>boolean EqualsInternal​(EFloat otherValue)</code><br>
Determines whether this object&#39;s mantissa (significand) and exponent are
equal to those of another object.</li>
<li><code>EFloat Exp​(EContext ctx)</code><br>
Finds e (the base of natural logarithms) raised to the power of this
object&#39;s value.</li>
<li><code>static EFloat FromBoolean​(boolean boolValue)</code><br>
Converts a boolean value (either true or false) to an arbitrary-precision
binary float.</li>
<li><code>static EFloat FromByte​(byte inputByte)</code><br>
Converts a byte (from 0 to 255) to an arbitrary-precision binary
floating-point number.</li>
<li><code>static EFloat FromDouble​(double dbl)</code><br>
Creates a binary float from a 64-bit floating-point number.</li>
<li><code>static EFloat FromEInteger​(EInteger bigint)</code><br>
Converts an arbitrary-precision integer to the same value as a binary float.</li>
<li><code>static EFloat FromInt16​(short inputInt16)</code><br>
Converts a 16-bit signed integer to an arbitrary-precision binary
floating-point number.</li>
<li><code>static EFloat FromInt32​(int inputInt32)</code><br>
Converts a 32-bit signed integer to an arbitrary-precision binary
floating-point number.</li>
<li><code>static EFloat FromInt64​(long inputInt64)</code><br>
Converts a 64-bit signed integer to an arbitrary-precision binary
floating-point number.</li>
<li><code>static EFloat FromSingle​(float flt)</code><br>
Creates a binary float from a 32-bit floating-point number.</li>
<li><code>static EFloat FromString​(java.lang.String str)</code><br>
Creates a binary float from a text string that represents a number, using an
unlimited precision context.</li>
<li><code>static EFloat FromString​(java.lang.String str,
      int offset,
      int length)</code><br>
Creates a binary float from a text string that represents a number.</li>
<li><code>static EFloat FromString​(java.lang.String str,
      int offset,
      int length,
      EContext ctx)</code><br>
Creates a binary float from a text string that represents a number.</li>
<li><code>static EFloat FromString​(java.lang.String str,
      EContext ctx)</code><br>
Creates a binary float from a text string that represents a number.</li>
<li><code>EInteger getExponent()</code><br>
Gets this object&#39;s exponent.</li>
<li><code>EInteger getMantissa()</code><br>
Gets this object&#39;s unscaled value, or mantissa, and makes it negative if
this object is negative.</li>
<li><code>EInteger getUnsignedMantissa()</code><br>
Gets the absolute value of this object&#39;s unscaled value, or mantissa.</li>
<li><code>int hashCode()</code><br>
Calculates this object&#39;s hash code.</li>
<li><code>boolean isFinite()</code><br>
Gets a value indicating whether this object is finite (not infinity or NaN).</li>
<li><code>boolean IsInfinity()</code><br>
Gets a value indicating whether this object is positive or negative
infinity.</li>
<li><code>boolean IsNaN()</code><br>
Gets a value indicating whether this object is not a number (NaN).</li>
<li><code>boolean isNegative()</code><br>
Gets a value indicating whether this object is negative, including negative
zero.</li>
<li><code>boolean IsNegativeInfinity()</code><br>
Returns whether this object is negative infinity.</li>
<li><code>boolean IsPositiveInfinity()</code><br>
Returns whether this object is positive infinity.</li>
<li><code>boolean IsQuietNaN()</code><br>
Gets a value indicating whether this object is a quiet not-a-number value.</li>
<li><code>boolean IsSignalingNaN()</code><br>
Gets a value indicating whether this object is a signaling not-a-number
value.</li>
<li><code>boolean isZero()</code><br>
Gets a value indicating whether this object&#39;s value equals 0.</li>
<li><code>EFloat Log​(EContext ctx)</code><br>
Finds the natural logarithm of this object, that is, the power (exponent)
that e (the base of natural logarithms) must be raised to in order
to equal this object&#39;s value.</li>
<li><code>EFloat Log10​(EContext ctx)</code><br>
Finds the base-10 logarithm of this object, that is, the power (exponent)
that the number 10 must be raised to in order to equal this object&#39;s
value.</li>
<li><code>static EFloat Max​(EFloat first,
EFloat second)</code><br>
Gets the greater value between two binary floating-point numbers.</li>
<li><code>static EFloat Max​(EFloat first,
EFloat second,
EContext ctx)</code><br>
Gets the greater value between two binary floating-point numbers.</li>
<li><code>static EFloat MaxMagnitude​(EFloat first,
        EFloat second)</code><br>
Gets the greater value between two values, ignoring their signs.</li>
<li><code>static EFloat MaxMagnitude​(EFloat first,
        EFloat second,
        EContext ctx)</code><br>
Gets the greater value between two values, ignoring their signs.</li>
<li><code>static EFloat Min​(EFloat first,
EFloat second)</code><br>
Gets the lesser value between two binary floating-point numbers.</li>
<li><code>static EFloat Min​(EFloat first,
EFloat second,
EContext ctx)</code><br>
Gets the lesser value between two binary floating-point numbers.</li>
<li><code>static EFloat MinMagnitude​(EFloat first,
        EFloat second)</code><br>
Gets the lesser value between two values, ignoring their signs.</li>
<li><code>static EFloat MinMagnitude​(EFloat first,
        EFloat second,
        EContext ctx)</code><br>
Gets the lesser value between two values, ignoring their signs.</li>
<li><code>EFloat MovePointLeft​(int places)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointLeft​(int places,
         EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointLeft​(EInteger bigPlaces)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointLeft​(EInteger bigPlaces,
         EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointRight​(int places)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat MovePointRight​(int places,
          EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat MovePointRight​(EInteger bigPlaces)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat MovePointRight​(EInteger bigPlaces,
          EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat Multiply​(int intValue)</code><br>
Multiplies this instance by the value of an arbitrary-precision integer
object.</li>
<li><code>EFloat Multiply​(EFloat otherValue)</code><br>
Multiplies two binary floating-point numbers.</li>
<li><code>EFloat Multiply​(EFloat op,
    EContext ctx)</code><br>
Multiplies two binary floating-point numbers.</li>
<li><code>EFloat MultiplyAndAdd​(EFloat multiplicand,
          EFloat augend)</code><br>
Multiplies by one binary float, and then adds another binary float.</li>
<li><code>EFloat MultiplyAndAdd​(EFloat op,
          EFloat augend,
          EContext ctx)</code><br>
Multiplies by one value, and then adds another value.</li>
<li><code>EFloat MultiplyAndSubtract​(EFloat op,
               EFloat subtrahend,
               EContext ctx)</code><br>
Multiplies by one value, and then subtracts another value.</li>
<li><code>EFloat Negate()</code><br>
Gets an object with the same value as this one, but with the sign reversed.</li>
<li><code>EFloat Negate​(EContext context)</code><br>
Returns a binary float with the same value as this object but with the sign
reversed.</li>
<li><code>EFloat NextMinus​(EContext ctx)</code><br>
Finds the largest value that&#39;s smaller than the given value.</li>
<li><code>EFloat NextPlus​(EContext ctx)</code><br>
Finds the smallest value that&#39;s greater than the given value.</li>
<li><code>EFloat NextToward​(EFloat otherValue,
      EContext ctx)</code><br>
Finds the next value that is closer to the other object&#39;s value than this
object&#39;s value.</li>
<li><code>static EFloat PI​(EContext ctx)</code><br>
Finds the constant π, the circumference of a circle divided by its diameter.</li>
<li><code>EFloat Plus​(EContext ctx)</code><br>
Rounds this object&#39;s value to a given precision, using the given rounding
mode and range of exponent, and also converts negative zero to
positive zero.</li>
<li><code>EFloat Pow​(int exponentSmall)</code><br>
Raises this object&#39;s value to the given exponent.</li>
<li><code>EFloat Pow​(int exponentSmall,
EContext ctx)</code><br>
Raises this object&#39;s value to the given exponent.</li>
<li><code>EFloat Pow​(EFloat exponent,
EContext ctx)</code><br>
Raises this object&#39;s value to the given exponent.</li>
<li><code>EInteger Precision()</code><br>
Finds the number of digits in this number&#39;s mantissa (significand).</li>
<li><code>EFloat Quantize​(int desiredExponentInt,
    EContext ctx)</code><br>
Returns a binary float with the same value but a new exponent.</li>
<li><code>EFloat Quantize​(EFloat otherValue,
    EContext ctx)</code><br>
Returns a binary float with the same value as this object but with the same
exponent as another binary float.</li>
<li><code>EFloat Quantize​(EInteger desiredExponent,
    EContext ctx)</code><br>
Returns a binary float with the same value but a new exponent.</li>
<li><code>EFloat Reduce​(EContext ctx)</code><br>
Returns an object with the same numerical value as this one but with
trailing zeros removed from its mantissa (significand).</li>
<li><code>EFloat Remainder​(EFloat divisor,
     EContext ctx)</code><br>
Finds the remainder that results when dividing two arbitrary-precision
binary floating-point numbers.</li>
<li><code>EFloat RemainderNaturalScale​(EFloat divisor) &quot;this&quot; - ((&quot;this&quot; /
&quot;divisor&quot;) * &quot;divisor&quot;)</code><br>
Calculates the remainder of a number by the formula &quot;this&quot; - ((&quot;this&quot; /
&quot;divisor&quot;) * &quot;divisor&quot;).</li>
<li><code>EFloat RemainderNaturalScale​(EFloat divisor,
                 EContext ctx)</code><br>
Calculates the remainder of a number by the formula &quot;this&quot; - ((&quot;this&quot; /
&quot;divisor&quot;) * &quot;divisor&quot;).</li>
<li><code>EFloat RemainderNear​(EFloat divisor,
         EContext ctx)</code><br>
Finds the distance to the closest multiple of the given divisor, based on
the result of dividing this object&#39;s value by another object&#39;s
value.</li>
<li><code>EFloat RemainderNoRoundAfterDivide​(EFloat divisor,
                       EContext ctx)</code><br>
Finds the remainder that results when dividing two arbitrary-precision
binary floating-point numbers.</li>
<li><code>EFloat RoundToExponent​(int exponentSmall,
           EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to a
new exponent if necessary.</li>
<li><code>EFloat RoundToExponent​(EInteger exponent,
           EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to a
new exponent if necessary.</li>
<li><code>EFloat RoundToExponentExact​(int exponentSmall,
                EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to the
given exponent represented as a 32-bit signed integer, and signals
an inexact flag if the result would be inexact.</li>
<li><code>EFloat RoundToExponentExact​(EInteger exponent,
                EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to the
given exponent, and signals an inexact flag if the result would be
inexact.</li>
<li><code>EFloat RoundToExponentExact​(EInteger exponent,
                ERounding rounding)</code><br>
Returns a binary number with the same value as this object but rounded to
the given exponent.</li>
<li><code>EFloat RoundToIntegerExact​(EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to an
integer, and signals an inexact flag if the result would be inexact.</li>
<li><code>EFloat RoundToIntegerNoRoundedFlag​(EContext ctx) FlagInexact FlagRounded</code><br>
Returns a binary float with the same value as this object but rounded to an
integer, without adding the FlagInexact or FlagRounded
flags.</li>
<li><code>EFloat RoundToIntegralExact​(EContext ctx)</code><br>
Deprecated.
Renamed to RoundToIntegerExact.
Renamed to RoundToIntegerExact.</li>
<li><code>EFloat RoundToIntegralNoRoundedFlag​(EContext ctx)</code><br>
Deprecated.
Renamed to RoundToIntegerNoRoundedFlag.
Renamed to RoundToIntegerNoRoundedFlag.</li>
<li><code>EFloat RoundToPrecision​(EContext ctx)</code><br>
Rounds this object&#39;s value to a given precision, using the given rounding
mode and range of exponent.</li>
<li><code>EFloat ScaleByPowerOfTwo​(int places)</code><br>
Returns a number similar to this number but with the scale adjusted.</li>
<li><code>EFloat ScaleByPowerOfTwo​(int places,
             EContext ctx)</code><br>
Returns a number similar to this number but with the scale adjusted.</li>
<li><code>EFloat ScaleByPowerOfTwo​(EInteger bigPlaces)</code><br>
Returns a number similar to this number but with the scale adjusted.</li>
<li><code>EFloat ScaleByPowerOfTwo​(EInteger bigPlaces,
             EContext ctx)</code><br>
Returns a number similar to this number but with its scale adjusted.</li>
<li><code>int signum()</code><br>
Gets this value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</li>
<li><code>EFloat Sqrt​(EContext ctx)</code><br>
Finds the square root of this object&#39;s value.</li>
<li><code>EFloat SquareRoot​(EContext ctx)</code><br>
Deprecated.
Renamed to Sqrt.
Renamed to Sqrt.</li>
<li><code>EFloat Subtract​(int intValue)</code><br>
Subtracts an arbitrary-precision integer from this arbitrary-precision
integer.</li>
<li><code>EFloat Subtract​(EFloat otherValue)</code><br>
Subtracts an arbitrary-precision binary float from this instance and returns
the result.</li>
<li><code>EFloat Subtract​(EFloat otherValue,
    EContext ctx)</code><br>
Subtracts an arbitrary-precision binary float from this instance.</li>
<li><code>byte ToByteChecked()</code><br>
Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
byte (from 0 to 255) after truncating to an integer.</li>
<li><code>byte ToByteIfExact()</code><br>
Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
byte (from 0 to 255) without rounding to a different numerical
value.</li>
<li><code>byte ToByteUnchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a byte (from
0 to 255).</li>
<li><code>double ToDouble()</code><br>
Converts this value to a 64-bit floating-point number.</li>
<li><code>EDecimal ToEDecimal()</code><br>
Converts this value to an arbitrary-precision decimal number.</li>
<li><code>EInteger ToEInteger()</code><br>
Converts this value to an arbitrary-precision integer.</li>
<li><code>EInteger ToEIntegerExact()</code><br>
Deprecated.
Renamed to ToEIntegerIfExact.
Renamed to ToEIntegerIfExact.</li>
<li><code>EInteger ToEIntegerIfExact()</code><br>
Converts this value to an arbitrary-precision integer, checking whether the
value contains a fractional part.</li>
<li><code>java.lang.String ToEngineeringString()</code><br>
Converts this value to an arbitrary-precision decimal number, then returns
the value of that decimal&#39;s ToEngineeringString method.</li>
<li><code>EDecimal ToExtendedDecimal()</code><br>
Deprecated.
Renamed to ToEDecimal.
Renamed to ToEDecimal.</li>
<li><code>short ToInt16Checked()</code><br>
Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
16-bit signed integer after truncating to an integer.</li>
<li><code>short ToInt16IfExact()</code><br>
Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
16-bit signed integer without rounding to a different numerical
value.</li>
<li><code>short ToInt16Unchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a 16-bit
signed integer.</li>
<li><code>int ToInt32Checked()</code><br>
Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
32-bit signed integer after truncating to an integer.</li>
<li><code>int ToInt32IfExact()</code><br>
Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
32-bit signed integer without rounding to a different numerical
value.</li>
<li><code>int ToInt32Unchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a 32-bit
signed integer.</li>
<li><code>long ToInt64Checked()</code><br>
Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
64-bit signed integer after truncating to an integer.</li>
<li><code>long ToInt64IfExact()</code><br>
Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
64-bit signed integer without rounding to a different numerical
value.</li>
<li><code>long ToInt64Unchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a 64-bit
signed integer.</li>
<li><code>java.lang.String ToPlainString()</code><br>
Converts this value to a string, but without exponential notation.</li>
<li><code>java.lang.String ToShortestString​(EContext ctx)</code><br>
Returns a string representation of this number&#39;s value after rounding to the
given precision (using the given arithmetic context).</li>
<li><code>float ToSingle()</code><br>
Converts this value to its closest equivalent as 32-bit floating-point
number.</li>
<li><code>java.lang.String toString()</code><br>
Converts this number&#39;s value to a text string.</li>
<li><code>EFloat Ulp()</code><br>
Returns the unit in the last place.</li>
</ul>

<h2>Field Details</h2>

<h3>NaN</h3>

<pre>public static final EFloat NaN
</pre>

<p>A not-a-number value.</p>

<h3>NegativeInfinity</h3>

<pre>public static final EFloat NegativeInfinity
</pre>

<p>Negative infinity, less than any other number.</p>

<h3>NegativeZero</h3>

<pre>public static final EFloat NegativeZero
</pre>

<p>Represents the number negative zero.</p>

<h3>One</h3>

<pre>public static final EFloat One
</pre>

<p>Represents the number 1.</p>

<h3>PositiveInfinity</h3>

<pre>public static final EFloat PositiveInfinity
</pre>

<p>Positive infinity, greater than any other number.</p>

<h3>SignalingNaN</h3>

<pre>public static final EFloat SignalingNaN
</pre>

<p>A not-a-number value that signals an invalid operation flag when it&#39;s passed
 as an argument to any arithmetic operation in arbitrary-precision
 binary float.</p>

<h3>Ten</h3>

<pre>public static final EFloat Ten
</pre>

<p>Represents the number 10.</p>

<h3>Zero</h3>

<pre>public static final EFloat Zero
</pre>

<p>Represents the number 0.</p>

<h2>Method Details</h2>

<h3>getExponent</h3>

<pre>public final EInteger getExponent()
</pre>

<p>Gets this object&#39;s exponent. This object&#39;s value will be an integer if the
 exponent is positive or zero.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39;s exponent. This object&#39; s value will be an integer if
the exponent is positive or zero.</li>
</ul>

<h3>isFinite</h3>

<pre>public final boolean isFinite()
</pre>

<p>Gets a value indicating whether this object is finite (not infinity or NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is finite (not infinity or NaN);
otherwise, <code>false</code>.</li>
</ul>

<h3>isNegative</h3>

<pre>public final boolean isNegative()
</pre>

<p>Gets a value indicating whether this object is negative, including negative
 zero.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is negative, including negative zero;
otherwise, <code>false</code>.</li>
</ul>

<h3>isZero</h3>

<pre>public final boolean isZero()
</pre>

<p>Gets a value indicating whether this object&#39;s value equals 0.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value equals 0; otherwise, <code>
false</code>. <code>true</code> if this object&#39; s value equals 0; otherwise,
<code>false</code>.</li>
</ul>

<h3>getMantissa</h3>

<pre>public final EInteger getMantissa()
</pre>

<p>Gets this object&#39;s unscaled value, or mantissa, and makes it negative if
 this object is negative. If this value is not-a-number (NaN), that
  value&#39;s absolute value is the NaN&#39;s &quot;payload&quot; (diagnostic
 information).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39; s unscaled value. Will be negative if this object&#39;s
value is negative (including a negative NaN).</li>
</ul>

<h3>signum</h3>

<pre>public final int signum()
</pre>

<p>Gets this value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</li>
</ul>

<h3>getUnsignedMantissa</h3>

<pre>public final EInteger getUnsignedMantissa()
</pre>

<p>Gets the absolute value of this object&#39;s unscaled value, or mantissa. If
  this value is not-a-number (NaN), that value is the NaN&#39;s &quot;payload&quot;
 (diagnostic information).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The absolute value of this object&#39;s unscaled value.</li>
</ul>

<h3>Copy</h3>

<pre>public EFloat Copy()
</pre>

<p>Creates a copy of this arbitrary-precision binary number.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>Create</h3>

<pre>public static EFloat Create​(int mantissaSmall, int exponentSmall)
</pre>

<p>Creates a number with the value exponent*2^mantissa (significand).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>mantissaSmall</code> - Desired value for the mantissa.</p></li>
<li><p><code>exponentSmall</code> - Desired value for the exponent.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>Create</h3>

<pre>public static EFloat Create​(EInteger mantissa, EInteger exponent)
</pre>

<p>Creates a number with the value exponent*2^mantissa (significand).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>mantissa</code> - Desired value for the mantissa.</p></li>
<li><p><code>exponent</code> - Desired value for the exponent.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter &quot;mantissa (significand)&quot; or
<code>exponent</code> is null.</li>
</ul>

<h3>CreateNaN</h3>

<pre>public static EFloat CreateNaN​(EInteger diag)
</pre>

<p>Creates a not-a-number arbitrary-precision binary floating-point number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>diag</code> - An integer, 0 or greater, to use as diagnostic information
associated with this object. If none is needed, should be zero. To
get the diagnostic information from another arbitrary-precision
binary floating-point number, use that object&#39;s <code>
UnsignedMantissa</code> property.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A quiet not-a-number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>diag</code> is less than 0.</li>
</ul>

<h3>CreateNaN</h3>

<pre>public static EFloat CreateNaN​(EInteger diag, boolean signaling, boolean negative, EContext ctx)
</pre>

<p>Creates a not-a-number arbitrary-precision binary floating-point number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>diag</code> - An integer, 0 or greater, to use as diagnostic information
associated with this object. If none is needed, should be zero. To
get the diagnostic information from another arbitrary-precision
binary floating-point number, use that object&#39;s <code>
UnsignedMantissa</code> property.</p></li>
<li><p><code>signaling</code> - Whether the return value will be signaling (true) or quiet
(false).</p></li>
<li><p><code>negative</code> - Whether the return value is negative.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision (in bits) of the
diagnostic information. The rounding and exponent range of this
context will be ignored. Can be null. The only flag that can be
signaled in this context is FlagInvalid, which happens if diagnostic
information needs to be truncated and too much memory is required to
do so.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>diag</code> is null.</li>
</ul>

<h3>FromDouble</h3>

<pre>public static EFloat FromDouble​(double dbl)
</pre>

<p>Creates a binary float from a 64-bit floating-point number. This method
 computes the exact value of the floating point number, not an
 approximation, as is often the case by converting the floating point
 number to a string first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>dbl</code> - The parameter <code>dbl</code> is a 64-bit floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as <code>dbl</code>.</li>
</ul>

<h3>FromEInteger</h3>

<pre>public static EFloat FromEInteger​(EInteger bigint)
</pre>

<p>Converts an arbitrary-precision integer to the same value as a binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigint</code> - An arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>FromSingle</h3>

<pre>public static EFloat FromSingle​(float flt)
</pre>

<p>Creates a binary float from a 32-bit floating-point number. This method
 computes the exact value of the floating point number, not an
 approximation, as is often the case by converting the floating point
 number to a string first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>flt</code> - The parameter <code>flt</code> is a 32-bit binary floating-point
number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as <code>flt</code>.</li>
</ul>

<h3>FromString</h3>

<pre>public static EFloat FromString​(java.lang.String str, int offset, int length, EContext ctx)
</pre>

<p>Creates a binary float from a text string that represents a number. Note
 that if the string contains a negative exponent, the resulting value
 might not be exact, in which case the resulting binary float will be
 an approximation of this decimal number&#39;s value. <p>The format of
 the string generally consists of:</p> <ul> <li>An optional plus sign
  (&quot;+&quot; , U+002B) or minus sign (&quot;-&quot;, U+002D) (if &#39;-&#39; , the value is
 negative.)</li> <li>One or more digits, with a single optional
 decimal point after the first digit and before the last digit.</li>
  <li>Optionally, &quot;E+&quot;/&quot;e+&quot; (positive exponent) or &quot;E-&quot;/&quot;e-&quot; (negative
 exponent) plus one or more digits specifying the exponent.</li></ul>
  <p>The string can also be &quot;-INF&quot;, &quot;-Infinity&quot;, &quot;Infinity&quot;, &quot;INF&quot;,
  quiet NaN (&quot;NaN&quot;) followed by any number of digits, or signaling NaN
  (&quot;sNaN&quot;) followed by any number of digits, all in any combination of
 upper and lower case.</p> <p>All characters mentioned above are the
 corresponding characters in the Basic Latin range. In particular,
 the digits must be the basic digits 0 to 9 (U+0030 to U+0039). The
 string is not allowed to contain white space characters, including
 spaces.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - The parameter <code>str</code> is a text string.</p></li>
<li><p><code>offset</code> - An index starting at 0 showing where the desired portion of
<code>str</code> begins.</p></li>
<li><p><code>length</code> - The length, in code units, of the desired portion of <code>
str</code> (but not more than <code>str</code> &#39;s length).</p></li>
<li><p><code>ctx</code> - The parameter <code>ctx</code> is an EContext object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The parsed number, converted to arbitrary-precision binary
floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Either <code>offset</code> or <code>length</code> is less
than 0 or greater than <code>str</code> &#39;s length, or <code>str</code> &#39; s
length minus <code>offset</code> is less than <code>length</code>.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static EFloat FromString​(java.lang.String str)
</pre>

<p>Creates a binary float from a text string that represents a number, using an
 unlimited precision context. For more information, see the
 <code>FromString(string, int, int, EContext)</code> method.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>str</code> - A text string to convert to a binary float.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The parsed number, converted to arbitrary-precision binary
floating-point number.</li>
</ul>

<h3>FromString</h3>

<pre>public static EFloat FromString​(java.lang.String str, EContext ctx)
</pre>

<p>Creates a binary float from a text string that represents a number. For more
 information, see the <code>FromString(string, int, int, EContext)</code>
 method.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string to convert to a binary float.</p></li>
<li><p><code>ctx</code> - An arithmetic context specifying the precision, rounding, and
exponent range to apply to the parsed number. Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The parsed number, converted to arbitrary-precision binary
floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</li>
</ul>

<h3>FromString</h3>

<pre>public static EFloat FromString​(java.lang.String str, int offset, int length)
</pre>

<p>Creates a binary float from a text string that represents a number. For more
 information, see the <code>FromString(string, int, int, EContext)</code>
 method.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - The parameter <code>str</code> is a text string.</p></li>
<li><p><code>offset</code> - An index starting at 0 showing where the desired portion of
<code>str</code> begins.</p></li>
<li><p><code>length</code> - The length, in code units, of the desired portion of <code>
str</code> (but not more than <code>str</code> &#39;s length).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Either <code>offset</code> or <code>length</code> is less
than 0 or greater than <code>str</code> &#39;s length, or <code>str</code> &#39;s
length minus <code>offset</code> is less than <code>length</code>.</p></li>
</ul>

<h3>Max</h3>

<pre>public static EFloat Max​(EFloat first, EFloat second, EContext ctx)
</pre>

<p>Gets the greater value between two binary floating-point numbers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The larger value of the two numbers.</li>
</ul>

<h3>Max</h3>

<pre>public static EFloat Max​(EFloat first, EFloat second)
</pre>

<p>Gets the greater value between two binary floating-point numbers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - An arbitrary-precision binary floating-point number.</p></li>
<li><p><code>second</code> - Another arbitrary-precision binary floating-point number.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The greater of the two arbitrary-precision numbers.</li>
</ul>

<h3>MaxMagnitude</h3>

<pre>public static EFloat MaxMagnitude​(EFloat first, EFloat second, EContext ctx)
</pre>

<p>Gets the greater value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Max.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>MaxMagnitude</h3>

<pre>public static EFloat MaxMagnitude​(EFloat first, EFloat second)
</pre>

<p>Gets the greater value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Max.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>Min</h3>

<pre>public static EFloat Min​(EFloat first, EFloat second, EContext ctx)
</pre>

<p>Gets the lesser value between two binary floating-point numbers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The smaller value of the two numbers.</li>
</ul>

<h3>Min</h3>

<pre>public static EFloat Min​(EFloat first, EFloat second)
</pre>

<p>Gets the lesser value between two binary floating-point numbers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>MinMagnitude</h3>

<pre>public static EFloat MinMagnitude​(EFloat first, EFloat second, EContext ctx)
</pre>

<p>Gets the lesser value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Min.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>MinMagnitude</h3>

<pre>public static EFloat MinMagnitude​(EFloat first, EFloat second)
</pre>

<p>Gets the lesser value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Min.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>PI</h3>

<pre>public static EFloat PI​(EContext ctx)
</pre>

<p>Finds the constant π, the circumference of a circle divided by its diameter.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as π can never be represented exactly.</i>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The constant π rounded to the given precision. Signals FlagInvalid
and returns not-a-number (NaN) if the parameter <code>ctx</code> is null
or the precision is unlimited (the context&#39;s Precision property is
0).</li>
</ul>

<h3>Abs</h3>

<pre>public EFloat Abs()
</pre>

<p>Finds the absolute value of this object (if it&#39;s negative, it becomes
 positive).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number. Returns
signaling NaN if this value is signaling NaN. (In this sense, this
method is similar to the &quot;copy-abs&quot; operation in the General Decimal
Arithmetic Specification, except this method does not necessarily
return a copy of this object.).</li>
</ul>

<h3>Abs</h3>

<pre>public EFloat Abs​(EContext context)
</pre>

<p>Finds the absolute value of this object (if it&#39;s negative, it becomes
 positive).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>context</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The absolute value of this object. Signals FlagInvalid and returns
quiet NaN if this value is signaling NaN.</li>
</ul>

<h3>Add</h3>

<pre>public EFloat Add​(int intValue)
</pre>

<p>Not documented yet.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>Subtract</h3>

<pre>public EFloat Subtract​(int intValue)
</pre>

<p>Subtracts an arbitrary-precision integer from this arbitrary-precision
 integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference of the two objects.</li>
</ul>

<h3>Multiply</h3>

<pre>public EFloat Multiply​(int intValue)
</pre>

<p>Multiplies this instance by the value of an arbitrary-precision integer
 object.<p> </p><pre>EInteger result =
  EInteger.FromString(&quot;5&quot;).Multiply(200);</pre> .</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two numbers.</li>
</ul>

<h3>Divide</h3>

<pre>public EFloat Divide​(int intValue)
</pre>

<p>Divides this instance by the value of an arbitrary-precision integer. The
 result is rounded down (the fractional part is discarded). Except if
 the result is 0, it will be negative if this object is positive and
 the other is negative, or vice versa, and will be positive if both
 are positive or both are negative.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The divisor.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - Attempted to divide by zero.</li>
</ul>

<h3>Add</h3>

<pre>public EFloat Add​(EFloat otherValue)
</pre>

<p>Adds this object and another binary float and returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The sum of the two objects.</li>
</ul>

<h3>Add</h3>

<pre>public EFloat Add​(EFloat otherValue, EContext ctx)
</pre>

<p>Finds the sum of this object and another object. The result&#39;s exponent is
 set to the lower of the exponents of the two operands.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - The number to add to.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>compareTo</h3>

<pre>public int compareTo​(EFloat other)
</pre>

<p>Compares the mathematical values of this object and another object,
 accepting NaN values. <p>This method is not consistent with the
 Equals method because two different numbers with the same
 mathematical value, but different exponents, will compare as
 equal.</p> <p>In this method, negative zero and positive zero are
 considered equal.</p> <p>If this object or the other object is a
 quiet NaN or signaling NaN, this method will not trigger an error.
 Instead, NaN will compare greater than any other number, including
 infinity. Two different NaN values will be considered equal.</p></p>

<p><strong>Specified by:</strong></p>

<ul>
<li><code>compareTo</code> in interface <code>java.lang.Comparable&lt;EFloat&gt;</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Less than 0 if this object&#39;s value is less than the other value, or
greater than 0 if this object&#39;s value is greater than the other
value or if <code>other</code> is null, or 0 if both values are equal.</li>
</ul>

<h3>CompareToSignal</h3>

<pre>public EFloat CompareToSignal​(EFloat other, EContext ctx)
</pre>

<p>Compares the mathematical values of this object and another object, treating
 quiet NaN as signaling. <p>In this method, negative zero and
 positive zero are considered equal.</p> <p>If this object or the
 other object is a quiet NaN or signaling NaN, this method will
 return a quiet NaN and will signal a FlagInvalid flag.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>other</code> - An arbitrary-precision binary floating-point number.</p></li>
<li><p><code>ctx</code> - An arithmetic context. The precision, rounding, and exponent
range are ignored. If <code>HasFlags</code> of the context is true, will
store the flags resulting from the operation (the flags are in
addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Quiet NaN if this object or the other object is NaN, or 0 if both
objects have the same value, or -1 if this object is less than the
other value, or 1 if this object is greater. This implementation
returns a positive number if.</li>
</ul>

<h3>CompareToTotal</h3>

<pre>public int CompareToTotal​(EFloat other, EContext ctx)
</pre>

<p>Compares the values of this object and another object, imposing a total
 ordering on all possible values. In this method: <ul> <li>For
 objects with the same value, the one with the higher exponent has a
  greater &quot;absolute value&quot;.</li> <li>Negative zero is less than
  positive zero.</li> <li>Quiet NaN has a higher &quot;absolute value&quot; than
 signaling NaN. If both objects are quiet NaN or both are signaling
 NaN, the one with the higher diagnostic information has a greater
  &quot;absolute value&quot;.</li> <li>NaN has a higher &quot;absolute value&quot; than
  infinity.</li> <li>Infinity has a higher &quot;absolute value&quot; than any
 finite number.</li> <li>Negative numbers are less than positive
 numbers.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>other</code> - An arbitrary-precision binary float to compare with this one.</p></li>
<li><p><code>ctx</code> - An arithmetic context. Flags will be set in this context only if
<code>HasFlags</code> and <code>IsSimplified</code> of the context are true
and only if an operand needed to be rounded before carrying out the
operation. Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 0 if both objects have the same value, or -1 if this
object is less than the other value, or 1 if this object is greater.
Does not signal flags if either value is signaling NaN. This
implementation returns a positive number if.</li>
</ul>

<h3>CompareToTotalMagnitude</h3>

<pre>public int CompareToTotalMagnitude​(EFloat other, EContext ctx)
</pre>

<p>Compares the values of this object and another object, imposing a total
 ordering on all possible values (ignoring their signs). In this
 method: <ul> <li>For objects with the same value, the one with the
  higher exponent has a greater &quot;absolute value&quot;.</li> <li>Negative
 zero is less than positive zero.</li> <li>Quiet NaN has a higher
  &quot;absolute value&quot; than signaling NaN. If both objects are quiet NaN
 or both are signaling NaN, the one with the higher diagnostic
  information has a greater &quot;absolute value&quot;.</li> <li>NaN has a
  higher &quot;absolute value&quot; than infinity.</li> <li>Infinity has a
  higher &quot;absolute value&quot; than any finite number.</li> <li>Negative
 numbers are less than positive numbers.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>other</code> - An arbitrary-precision binary float to compare with this one.</p></li>
<li><p><code>ctx</code> - An arithmetic context. Flags will be set in this context only if
<code>HasFlags</code> and <code>IsSimplified</code> of the context are true
and only if an operand needed to be rounded before carrying out the
operation. Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 0 if both objects have the same value (ignoring their
signs), or -1 if this object is less than the other value (ignoring
their signs), or 1 if this object is greater (ignoring their signs).
Does not signal flags if either value is signaling NaN. This
implementation returns a positive number if.</li>
</ul>

<h3>CompareToTotal</h3>

<pre>public int CompareToTotal​(EFloat other)
</pre>

<p>Compares the values of this object and another object, imposing a total
 ordering on all possible values. In this method: <ul> <li>For
 objects with the same value, the one with the higher exponent has a
  greater &quot;absolute value&quot;.</li> <li>Negative zero is less than
  positive zero.</li> <li>Quiet NaN has a higher &quot;absolute value&quot; than
 signaling NaN. If both objects are quiet NaN or both are signaling
 NaN, the one with the higher diagnostic information has a greater
  &quot;absolute value&quot;.</li> <li>NaN has a higher &quot;absolute value&quot; than
  infinity.</li> <li>Infinity has a higher &quot;absolute value&quot; than any
 finite number.</li> <li>Negative numbers are less than positive
 numbers.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary float to compare with this one.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 0 if both objects have the same value, or -1 if this
object is less than the other value, or 1 if this object is greater.
This implementation returns a positive number if.</li>
</ul>

<h3>CompareToTotalMagnitude</h3>

<pre>public int CompareToTotalMagnitude​(EFloat other)
</pre>

<p>Compares the absolute values of this object and another object, imposing a
 total ordering on all possible values (ignoring their signs). In
 this method: <ul> <li>For objects with the same value, the one with
  the higher exponent has a greater &quot;absolute value&quot;.</li>
 <li>Negative zero and positive zero are considered equal.</li>
  <li>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If
 both objects are quiet NaN or both are signaling NaN, the one with
  the higher diagnostic information has a greater &quot;absolute
  value&quot;.</li> <li>NaN has a higher &quot;absolute value&quot; than
  infinity.</li> <li>Infinity has a higher &quot;absolute value&quot; than any
 finite number.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary float to compare with this one.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 0 if both objects have the same value, or -1 if this
object is less than the other value, or 1 if this object is greater.
This implementation returns a positive number if.</li>
</ul>

<h3>CompareToWithContext</h3>

<pre>public EFloat CompareToWithContext​(EFloat other, EContext ctx)
</pre>

<p>Compares the mathematical values of this object and another object. <p>In
 this method, negative zero and positive zero are considered
 equal.</p> <p>If this object or the other object is a quiet NaN or
 signaling NaN, this method returns a quiet NaN, and will signal a
 FlagInvalid flag if either is a signaling NaN.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>other</code> - An arbitrary-precision binary floating-point number.</p></li>
<li><p><code>ctx</code> - An arithmetic context. The precision, rounding, and exponent
range are ignored. If <code>HasFlags</code> of the context is true, will
store the flags resulting from the operation (the flags are in
addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Quiet NaN if this object or the other object is NaN, or 0 if both
objects have the same value, or -1 if this object is less than the
other value, or 1 if this object is greater. This implementation
returns a positive number if.</li>
</ul>

<h3>CopySign</h3>

<pre>public EFloat CopySign​(EFloat other)
</pre>

<p>Returns a number with the same value as this one, but copying the sign
 (positive or negative) of another number. (This method is similar to
  the &quot;copy-sign&quot; operation in the General Decimal Arithmetic
 Specification, except this method does not necessarily return a copy
 of this object.).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - A number whose sign will be copied.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>other</code> is null.</li>
</ul>

<h3>Divide</h3>

<pre>public EFloat Divide​(EFloat divisor)
</pre>

<p>Divides this object by another binary float and returns the result. When
 possible, the result will be exact.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two numbers. Returns infinity if the divisor is
0 and the dividend is nonzero. Returns not-a-number (NaN) if the
divisor and the dividend are 0. Returns NaN if the result can&#39;t be
exact because it would have a nonterminating binary expansion.</li>
</ul>

<h3>Divide</h3>

<pre>public EFloat Divide​(EFloat divisor, EContext ctx)
</pre>

<p>Divides this arbitrary-precision binary float by another arbitrary-precision
 binary floating-point number. The preferred exponent for the result
 is this object&#39;s exponent minus the divisor&#39;s exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor
and the dividend are 0; or, either <code>ctx</code> is null or <code>
ctx</code> &#39;s precision is 0, and the result would have a nonterminating
binary expansion; or, the rounding mode is ERounding.None and the
result is not exact.</li>
</ul>

<h3>DivideAndRemainderNaturalScale</h3>

<pre>@Deprecated public EFloat[] DivideAndRemainderNaturalScale​(EFloat divisor)
</pre>

<p>Deprecated.
Renamed to DivRemNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>DivideAndRemainderNaturalScale</h3>

<pre>@Deprecated public EFloat[] DivideAndRemainderNaturalScale​(EFloat divisor, EContext ctx)
</pre>

<p>Deprecated.
Renamed to DivRemNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the result. This context will be used only in
the division portion of the remainder calculation; as a result, it&#39;s
possible for the remainder to have a higher precision than given in
this context. Flags will be set on the given context only if the
context&#39;s <code>HasFlags</code> is true and the integer part of the
division result doesn&#39;t fit the precision and exponent range without
rounding. Can be null, in which the precision is unlimited and no
additional rounding, other than the rounding down to an integer
after division, is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>DivideToExponent</h3>

<pre>public EFloat DivideToExponent​(EFloat divisor, long desiredExponentSmall, EContext ctx)
</pre>

<p>Divides two arbitrary-precision binary floating-point numbers, and gives a
 particular exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>desiredExponentSmall</code> - The desired exponent. A negative number places
the cutoff point to the right of the usual radix point (so a
negative number means the number of binary digit places to round
to). A positive number places the cutoff point to the left of the
usual radix point.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the rounding mode to use
if the result must be scaled down to have the same exponent as this
value. If the precision given in the context is other than 0, calls
the Quantize method with both arguments equal to the result of the
operation (and can signal FlagInvalid and return NaN if the result
doesn&#39;t fit the given precision). If <code>HasFlags</code> of the context
is true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor
and the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the context defines an exponent range and the desired
exponent is outside that range. Signals FlagInvalid and returns
not-a-number (NaN) if the rounding mode is ERounding.None and the
result is not exact.</li>
</ul>

<h3>DivideToExponent</h3>

<pre>public EFloat DivideToExponent​(EFloat divisor, long desiredExponentSmall, ERounding rounding)
</pre>

<p>Divides two arbitrary-precision binary floating-point numbers, and gives a
 particular exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>desiredExponentSmall</code> - The desired exponent. A negative number places
the cutoff point to the right of the usual radix point (so a
negative number means the number of binary digit places to round
to). A positive number places the cutoff point to the left of the
usual radix point.</p></li>
<li><p><code>rounding</code> - The rounding mode to use if the result must be scaled down
to have the same exponent as this value.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor
and the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the rounding mode is ERounding.None and the result is not
exact.</li>
</ul>

<h3>DivideToExponent</h3>

<pre>public EFloat DivideToExponent​(EFloat divisor, EInteger exponent, EContext ctx)
</pre>

<p>Divides two arbitrary-precision binary floating-point numbers, and gives a
 particular exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>exponent</code> - The desired exponent. A negative number places the cutoff
point to the right of the usual radix point (so a negative number
means the number of binary digit places to round to). A positive
number places the cutoff point to the left of the usual radix point.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the rounding mode to use
if the result must be scaled down to have the same exponent as this
value. If the precision given in the context is other than 0, calls
the Quantize method with both arguments equal to the result of the
operation (and can signal FlagInvalid and return NaN if the result
doesn&#39;t fit the given precision). If <code>HasFlags</code> of the context
is true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor
and the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the context defines an exponent range and the desired
exponent is outside that range. Signals FlagInvalid and returns
not-a-number (NaN) if the rounding mode is ERounding.None and the
result is not exact.</li>
</ul>

<h3>DivideToExponent</h3>

<pre>public EFloat DivideToExponent​(EFloat divisor, EInteger desiredExponent, ERounding rounding)
</pre>

<p>Divides two arbitrary-precision binary floating-point numbers, and gives a
 particular exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>desiredExponent</code> - The desired exponent. A negative number places the
cutoff point to the right of the usual radix point (so a negative
number means the number of binary digit places to round to). A
positive number places the cutoff point to the left of the usual
radix point.</p></li>
<li><p><code>rounding</code> - The rounding mode to use if the result must be scaled down
to have the same exponent as this value.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Returns not-a-number (NaN) if the divisor and the dividend are 0.
Returns NaN if the rounding mode is ERounding.None and the result is
not exact.</li>
</ul>

<h3>DivideToIntegerNaturalScale</h3>

<pre>public EFloat DivideToIntegerNaturalScale​(EFloat divisor)
</pre>

<p>Divides two arbitrary-precision binary floating-point numbers, and returns
 the integer part of the result, rounded down, with the preferred
 exponent set to this value&#39;s exponent minus the divisor&#39;s exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer part of the quotient of the two objects. Signals
FlagDivideByZero and returns infinity if the divisor is 0 and the
dividend is nonzero. Signals FlagInvalid and returns not-a-number
(NaN) if the divisor and the dividend are 0.</li>
</ul>

<h3>DivideToIntegerNaturalScale</h3>

<pre>public EFloat DivideToIntegerNaturalScale​(EFloat divisor, EContext ctx)
</pre>

<p>Divides this object by another object, and returns the integer part of the
 result (which is initially rounded down), with the preferred
 exponent set to this value&#39;s exponent minus the divisor&#39;s exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary floating-point number.</p></li>
<li><p><code>ctx</code> - The parameter <code>ctx</code> is an EContext object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer part of the quotient of the two objects. Signals
FlagInvalid and returns not-a-number (NaN) if the return value would
overflow the exponent range. Signals FlagDivideByZero and returns
infinity if the divisor is 0 and the dividend is nonzero. Signals
FlagInvalid and returns not-a-number (NaN) if the divisor and the
dividend are 0. Signals FlagInvalid and returns not-a-number (NaN)
if the rounding mode is ERounding.None and the result is not exact.</li>
</ul>

<h3>DivideToIntegerZeroScale</h3>

<pre>public EFloat DivideToIntegerZeroScale​(EFloat divisor, EContext ctx)
</pre>

<p>Divides this object by another object, and returns the integer part of the
 result, with the exponent set to 0.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision. The
rounding and exponent range settings of this context are ignored. If
<code>HasFlags</code> of the context is true, will also store the flags
resulting from the operation (the flags are in addition to the
pre-existing flags). Can be null, in which case the precision is
unlimited.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer part of the quotient of the two objects. The exponent
will be set to 0. Signals FlagDivideByZero and returns infinity if
the divisor is 0 and the dividend is nonzero. Signals FlagInvalid
and returns not-a-number (NaN) if the divisor and the dividend are
0, or if the result doesn&#39;t fit the given precision.</li>
</ul>

<h3>DivideToSameExponent</h3>

<pre>public EFloat DivideToSameExponent​(EFloat divisor, ERounding rounding)
</pre>

<p>Divides this object by another binary float and returns a result with the
 same exponent as this object (the dividend).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>rounding</code> - The rounding mode to use if the result must be scaled down
to have the same exponent as this value.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two numbers. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor
and the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the rounding mode is ERounding.None and the result is not
exact.</li>
</ul>

<h3>DivRemNaturalScale</h3>

<pre>public EFloat[] DivRemNaturalScale​(EFloat divisor)
</pre>

<p>Calculates the quotient and remainder using the DivideToIntegerNaturalScale
 and the formula in RemainderNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>DivRemNaturalScale</h3>

<pre>public EFloat[] DivRemNaturalScale​(EFloat divisor, EContext ctx)
</pre>

<p>Calculates the quotient and remainder using the DivideToIntegerNaturalScale
 and the formula in RemainderNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the result. This context will be used only in
the division portion of the remainder calculation; as a result, it&#39;s
possible for the remainder to have a higher precision than given in
this context. Flags will be set on the given context only if the
context&#39;s <code>HasFlags</code> is true and the integer part of the
division result doesn&#39;t fit the precision and exponent range without
rounding. Can be null, in which the precision is unlimited and no
additional rounding, other than the rounding down to an integer
after division, is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>equals</h3>

<pre>public boolean equals​(EFloat other)
</pre>

<p>Determines whether this object&#39;s mantissa (significand), exponent, and
 properties are equal to those of another object. Not-a-number values
 are considered equal if the rest of their properties are equal.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s mantissa (significand) and exponent
are equal to those of another object; otherwise, <code>false</code>.</li>
</ul>

<h3>equals</h3>

<pre>public boolean equals​(java.lang.Object obj)
</pre>

<p>Determines whether this object&#39;s mantissa (significand), exponent, and
 properties are equal to those of another object and that other
 object is an arbitrary-precision binary floating-point number.
 Not-a-number values are considered equal if the rest of their
 properties are equal.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>equals</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>obj</code> - The parameter <code>obj</code> is an arbitrary object.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the objects are equal; otherwise, <code>false</code>.</li>
</ul>

<h3>EqualsInternal</h3>

<pre>public boolean EqualsInternal​(EFloat otherValue)
</pre>

<p>Determines whether this object&#39;s mantissa (significand) and exponent are
 equal to those of another object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s mantissa (significand) and exponent
are equal to those of another object; otherwise, <code>false</code>.</li>
</ul>

<h3>Exp</h3>

<pre>public EFloat Exp​(EContext ctx)
</pre>

<p>Finds e (the base of natural logarithms) raised to the power of this
 object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the exponential function&#39;s results are generally
not exact.</i> (Unlike in the General Binary Arithmetic
Specification, any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Exponential of this object. If this object&#39;s value is 1, returns an
approximation to &quot; e&quot; within the given precision. Signals
FlagInvalid and returns not-a-number (NaN) if the parameter <code>
ctx</code> is null or the precision is unlimited (the context&#39;s Precision
property is 0).</li>
</ul>

<h3>hashCode</h3>

<pre>public int hashCode()
</pre>

<p>Calculates this object&#39;s hash code. No application or process IDs are used
 in the hash code calculation.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>hashCode</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 32-bit signed integer.</li>
</ul>

<h3>IsInfinity</h3>

<pre>public boolean IsInfinity()
</pre>

<p>Gets a value indicating whether this object is positive or negative
 infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is positive or negative infinity;
otherwise, <code>false</code>.</li>
</ul>

<h3>IsNaN</h3>

<pre>public boolean IsNaN()
</pre>

<p>Gets a value indicating whether this object is not a number (NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is not a number (NaN); otherwise, <code>
false</code>.</li>
</ul>

<h3>IsNegativeInfinity</h3>

<pre>public boolean IsNegativeInfinity()
</pre>

<p>Returns whether this object is negative infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is negative infinity; otherwise, <code>
false</code>.</li>
</ul>

<h3>IsPositiveInfinity</h3>

<pre>public boolean IsPositiveInfinity()
</pre>

<p>Returns whether this object is positive infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is positive infinity; otherwise, <code>
false</code>.</li>
</ul>

<h3>IsQuietNaN</h3>

<pre>public boolean IsQuietNaN()
</pre>

<p>Gets a value indicating whether this object is a quiet not-a-number value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is a quiet not-a-number value;
otherwise, <code>false</code>.</li>
</ul>

<h3>IsSignalingNaN</h3>

<pre>public boolean IsSignalingNaN()
</pre>

<p>Gets a value indicating whether this object is a signaling not-a-number
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is a signaling not-a-number value;
otherwise, <code>false</code>.</li>
</ul>

<h3>Log</h3>

<pre>public EFloat Log​(EContext ctx)
</pre>

<p>Finds the natural logarithm of this object, that is, the power (exponent)
 that e (the base of natural logarithms) must be raised to in order
 to equal this object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the ln function&#39;s results are generally not
exact.</i> (Unlike in the General Binary Arithmetic Specification,
any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Ln(this object). Signals the flag FlagInvalid and returns NaN if
this object is less than 0 (the result would be a complex number
with a real part equal to Ln of this object&#39;s absolute value and an
imaginary part equal to pi, but the return value is still NaN.).
Signals FlagInvalid and returns not-a-number (NaN) if the parameter
<code>ctx</code> is null or the precision is unlimited (the context&#39;s
Precision property is 0). Signals no flags and returns negative
infinity if this object&#39;s value is 0.</li>
</ul>

<h3>Log10</h3>

<pre>public EFloat Log10​(EContext ctx)
</pre>

<p>Finds the base-10 logarithm of this object, that is, the power (exponent)
 that the number 10 must be raised to in order to equal this object&#39;s
 value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the ln function&#39;s results are generally not
exact.</i> (Unlike in the General Binary Arithmetic Specification,
any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Ln(this object)/Ln(10). Signals the flag FlagInvalid and returns
not-a-number (NaN) if this object is less than 0. Signals
FlagInvalid and returns not-a-number (NaN) if the parameter <code>
ctx</code> is null or the precision is unlimited (the context&#39;s Precision
property is 0).</li>
</ul>

<h3>MovePointLeft</h3>

<pre>public EFloat MovePointLeft​(int places)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>places</code> - The number of binary digit places to move the radix point to
the left. If this number is negative, instead moves the radix point
to the right by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointLeft</h3>

<pre>public EFloat MovePointLeft​(int places, EContext ctx)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>places</code> - The number of binary digit places to move the radix point to
the left. If this number is negative, instead moves the radix point
to the right by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointLeft</h3>

<pre>public EFloat MovePointLeft​(EInteger bigPlaces)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the left. If this number is negative, instead moves the radix
point to the right by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>MovePointLeft</h3>

<pre>public EFloat MovePointLeft​(EInteger bigPlaces, EContext ctx)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the left. If this number is negative, instead moves the radix
point to the right by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre>public EFloat MovePointRight​(int places)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>places</code> - The number of binary digit places to move the radix point to
the right. If this number is negative, instead moves the radix point
to the left by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre>public EFloat MovePointRight​(int places, EContext ctx)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>places</code> - The number of binary digit places to move the radix point to
the right. If this number is negative, instead moves the radix point
to the left by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre>public EFloat MovePointRight​(EInteger bigPlaces)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the right. If this number is negative, instead moves the radix
point to the left by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre>public EFloat MovePointRight​(EInteger bigPlaces, EContext ctx)
</pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the right. If this number is negative, instead moves the radix
point to the left by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>Multiply</h3>

<pre>public EFloat Multiply​(EFloat otherValue)
</pre>

<p>Multiplies two binary floating-point numbers. The resulting exponent will be
 the sum of the exponents of the two binary floating-point numbers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - Another binary float.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two binary floating-point numbers.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>otherValue</code> is null.</li>
</ul>

<h3>Multiply</h3>

<pre>public EFloat Multiply​(EFloat op, EContext ctx)
</pre>

<p>Multiplies two binary floating-point numbers. The resulting scale will be
 the sum of the scales of the two binary floating-point numbers. The
 result&#39;s sign is positive if both operands have the same sign, and
 negative if they have different signs.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>op</code> - Another binary float.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>MultiplyAndAdd</h3>

<pre>public EFloat MultiplyAndAdd​(EFloat multiplicand, EFloat augend)
</pre>

<p>Multiplies by one binary float, and then adds another binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>multiplicand</code> - The value to multiply.</p></li>
<li><p><code>augend</code> - The value to add.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>MultiplyAndAdd</h3>

<pre>public EFloat MultiplyAndAdd​(EFloat op, EFloat augend, EContext ctx)
</pre>

<p>Multiplies by one value, and then adds another value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>op</code> - The value to multiply.</p></li>
<li><p><code>augend</code> - The value to add.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed. If
the precision doesn&#39;t indicate a simplified arithmetic, rounding and
precision.Divide(exponent) adjustment is done only once, namely,
after multiplying and adding.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result thisValue * multiplicand + augend.</li>
</ul>

<h3>MultiplyAndSubtract</h3>

<pre>public EFloat MultiplyAndSubtract​(EFloat op, EFloat subtrahend, EContext ctx)
</pre>

<p>Multiplies by one value, and then subtracts another value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>op</code> - The value to multiply.</p></li>
<li><p><code>subtrahend</code> - The value to subtract.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed. If
the precision doesn&#39;t indicate a simplified arithmetic, rounding and
precision.Divide(exponent) adjustment is done only once, namely,
after multiplying and subtracting.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result thisValue * multiplicand - subtrahend.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>op</code> or <code>subtrahend</code>
is null.</li>
</ul>

<h3>Negate</h3>

<pre>public EFloat Negate()
</pre>

<p>Gets an object with the same value as this one, but with the sign reversed.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number. If this value
is positive zero, returns negative zero. Returns signaling NaN if
this value is signaling NaN. (In this sense, this method is similar
to the &quot;copy-negate&quot; operation in the General Decimal Arithmetic
Specification, except this method does not necessarily return a copy
of this object.).</li>
</ul>

<h3>Negate</h3>

<pre>public EFloat Negate​(EContext context)
</pre>

<p>Returns a binary float with the same value as this object but with the sign
 reversed.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>context</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number. If this value
is positive zero, returns positive zero. Signals FlagInvalid and
returns quiet NaN if this value is signaling NaN.</li>
</ul>

<h3>NextMinus</h3>

<pre>public EFloat NextMinus​(EContext ctx)
</pre>

<p>Finds the largest value that&#39;s smaller than the given value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context object to control the precision and
exponent range of the result. The rounding mode from this context is
ignored. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Returns the largest value that&#39;s less than the given value. Returns
negative infinity if the result is negative infinity. Signals
FlagInvalid and returns not-a-number (NaN) if the parameter <code>
ctx</code> is null, the precision is 0, or <code>ctx</code> has an unlimited
exponent range.</li>
</ul>

<h3>NextPlus</h3>

<pre>public EFloat NextPlus​(EContext ctx)
</pre>

<p>Finds the smallest value that&#39;s greater than the given value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context object to control the precision and
exponent range of the result. The rounding mode from this context is
ignored. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Returns the smallest value that&#39;s greater than the given
value.Signals FlagInvalid and returns not-a-number (NaN) if the
parameter <code>ctx</code> is null, the precision is 0, or <code>ctx</code>
has an unlimited exponent range.</li>
</ul>

<h3>NextToward</h3>

<pre>public EFloat NextToward​(EFloat otherValue, EContext ctx)
</pre>

<p>Finds the next value that is closer to the other object&#39;s value than this
 object&#39;s value. Returns a copy of this value with the same sign as
 the other value if both values are equal.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - An arbitrary-precision binary float that the return value
will approach.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision and
exponent range of the result. The rounding mode from this context is
ignored. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Returns the next value that is closer to the other object&#39; s value
than this object&#39;s value. Signals FlagInvalid and returns NaN if the
parameter <code>ctx</code> is null, the precision is 0, or <code>ctx</code>
has an unlimited exponent range.</li>
</ul>

<h3>Plus</h3>

<pre>public EFloat Plus​(EContext ctx)
</pre>

<p>Rounds this object&#39;s value to a given precision, using the given rounding
 mode and range of exponent, and also converts negative zero to
 positive zero.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - A context for controlling the precision, rounding mode, and
exponent range. Can be null, in which case the precision is
unlimited and rounding isn&#39;t needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest value to this object&#39;s value, rounded to the specified
precision. Returns the same value as this object if <code>ctx</code> is
null or the precision and exponent range are unlimited.</li>
</ul>

<h3>Pow</h3>

<pre>public EFloat Pow​(EFloat exponent, EContext ctx)
</pre>

<p>Raises this object&#39;s value to the given exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - An arbitrary-precision binary float expressing the exponent
to raise this object&#39;s value to.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This^exponent. Signals the flag FlagInvalid and returns NaN if this
object and exponent are both 0; or if this value is less than 0 and
the exponent either has a fractional part or is infinity. Signals
FlagInvalid and returns not-a-number (NaN) if the parameter <code>
ctx</code> is null or the precision is unlimited (the context&#39;s Precision
property is 0), and the exponent has a fractional part.</li>
</ul>

<h3>Pow</h3>

<pre>public EFloat Pow​(int exponentSmall, EContext ctx)
</pre>

<p>Raises this object&#39;s value to the given exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponentSmall</code> - The exponent to raise this object&#39;s value to.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This^exponent. Signals the flag FlagInvalid and returns NaN if this
object and exponent are both 0.</li>
</ul>

<h3>Pow</h3>

<pre>public EFloat Pow​(int exponentSmall)
</pre>

<p>Raises this object&#39;s value to the given exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>exponentSmall</code> - The exponent to raise this object&#39;s value to.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This^exponent. Returns not-a-number (NaN) if this object and
exponent are both 0.</li>
</ul>

<h3>Precision</h3>

<pre>public EInteger Precision()
</pre>

<p>Finds the number of digits in this number&#39;s mantissa (significand). Returns
 1 if this value is 0, and 0 if this value is infinity or
 not-a-number (NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<h3>Quantize</h3>

<pre>public EFloat Quantize​(EInteger desiredExponent, EContext ctx)
</pre>

<p>Returns a binary float with the same value but a new exponent. <p>Note that
 this is not always the same as rounding to a given number of binary
 digit places, since it can fail if the difference between this
 value&#39;s exponent and the desired exponent is too big, depending on
 the maximum precision. If rounding to a number of binary digit
 places is desired, it&#39;s better to use the RoundToExponent and
 RoundToIntegral methods instead.</p> <p><b>Remark:</b> This method
 can be used to implement fixed-point binary arithmetic, in which
 each binary float has a fixed number of digits after the radix
 point. The following code example returns a fixed-point number with
 up to 20 digits before and exactly 5 digits after the radix
 point:</p> <pre> /* After performing arithmetic
 operations, adjust /* the number to 5 //
 <em>/</em>/ digits after the radix point number =
 number.Quantize(EInteger.FromInt32(-5), /* five digits
 after the radix point<em>/ EContext.ForPrecision(25)
 /</em> 25-digit precision);*/</pre> <p>A
 fixed-point binary arithmetic in which no digits come after the
  radix point (a desired exponent of 0) is considered an &quot;integer
  arithmetic&quot;.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>desiredExponent</code> - The desired exponent for the result. The exponent is
the number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the
thousandth (10^-3, 0.0001), and 3 means round to the thousand (10^3,
1000). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags). Can be null, in which case the default
rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as this object but with the
exponent changed. Signals FlagInvalid and returns not-a-number (NaN)
if this object is infinity, if the rounded result can&#39;t fit the
given precision, or if the context defines an exponent range and the
given exponent is outside that range.</li>
</ul>

<h3>Quantize</h3>

<pre>public EFloat Quantize​(int desiredExponentInt, EContext ctx)
</pre>

<p>Returns a binary float with the same value but a new exponent. <p>Note that
 this is not always the same as rounding to a given number of binary
 digit places, since it can fail if the difference between this
 value&#39;s exponent and the desired exponent is too big, depending on
 the maximum precision. If rounding to a number of binary digit
 places is desired, it&#39;s better to use the RoundToExponent and
 RoundToIntegral methods instead.</p> <p><b>Remark:</b> This method
 can be used to implement fixed-point binary arithmetic, in which
 each binary float has a fixed number of digits after the radix
 point. The following code example returns a fixed-point number with
 up to 20 digits before and exactly 5 digits after the radix
 point:</p> <pre> /* After performing arithmetic
 operations, adjust /* the number to
 5<em>/</em>/ digits after the radix point number =
 number.Quantize(-5, /* five digits<em>/ after the
 radix point EContext.ForPrecision(25) /</em> 25-digit
 precision);*/</pre> <p>A fixed-point binary arithmetic in
 which no digits come after the radix point (a desired exponent of 0)
  is considered an &quot;integer arithmetic&quot;.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>desiredExponentInt</code> - The desired exponent for the result. The exponent
is the number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the
thousandth (10^-3, 0.0001), and 3 means round to the thousand (10^3,
1000). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags). Can be null, in which case the default
rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as this object but with the
exponent changed. Signals FlagInvalid and returns not-a-number (NaN)
if this object is infinity, if the rounded result can&#39;t fit the
given precision, or if the context defines an exponent range and the
given exponent is outside that range.</li>
</ul>

<h3>Quantize</h3>

<pre>public EFloat Quantize​(EFloat otherValue, EContext ctx)
</pre>

<p>Returns a binary float with the same value as this object but with the same
 exponent as another binary float. <p>Note that this is not always
 the same as rounding to a given number of binary digit places, since
 it can fail if the difference between this value&#39;s exponent and the
 desired exponent is too big, depending on the maximum precision. If
 rounding to a number of binary digit places is desired, it&#39;s better
 to use the RoundToExponent and RoundToIntegral methods instead.</p>
 <p><b>Remark:</b> This method can be used to implement fixed-point
 binary arithmetic, in which a fixed number of digits come after the
 radix point. A fixed-point binary arithmetic in which no digits come
 after the radix point (a desired exponent of 0) is considered an
  &quot;integer arithmetic&quot; .</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - A binary float containing the desired exponent of the
result. The mantissa (significand) is ignored. The exponent is the
number of fractional digits in the result, expressed as a negative
number. Can also be positive, which eliminates lower-order places
from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags). Can be null, in which case the default
rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as this object but with the
exponent changed. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding, or if
the arithmetic context defines an exponent range and the given
exponent is outside that range.</li>
</ul>

<h3>Reduce</h3>

<pre>public EFloat Reduce​(EContext ctx)
</pre>

<p>Returns an object with the same numerical value as this one but with
 trailing zeros removed from its mantissa (significand). For example,
 1.00 becomes 1. <p>If this object&#39;s value is 0, changes the exponent
 to 0.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This value with trailing zeros removed. Note that if the result has
a very high exponent and the context says to clamp high exponents,
there may still be some trailing zeros in the mantissa
(significand).</li>
</ul>

<h3>Remainder</h3>

<pre>public EFloat Remainder​(EFloat divisor, EContext ctx)
</pre>

<p>Finds the remainder that results when dividing two arbitrary-precision
 binary floating-point numbers. The remainder is the value that
 remains when the absolute value of this object is divided by the
 absolute value of the other object; the remainder has the same sign
 (positive or negative) as this object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary floating-point number.</p></li>
<li><p><code>ctx</code> - The parameter <code>ctx</code> is an EContext object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The remainder of the two numbers. Signals FlagInvalid and returns
not-a-number (NaN) if the divisor is 0, or if the result doesn&#39;t fit
the given precision.</li>
</ul>

<h3>RemainderNoRoundAfterDivide</h3>

<pre>public EFloat RemainderNoRoundAfterDivide​(EFloat divisor, EContext ctx)
</pre>

<p>Finds the remainder that results when dividing two arbitrary-precision
 binary floating-point numbers. The remainder is the value that
 remains when the absolute value of this object is divided by the
 absolute value of the other object; the remainder has the same sign
 (positive or negative) as this object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary floating-point number.</p></li>
<li><p><code>ctx</code> - The parameter <code>ctx</code> is an EContext object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The remainder of the two numbers. Signals FlagInvalid and returns
not-a-number (NaN) if the divisor is 0, or if the result doesn&#39;t fit
the given precision.</li>
</ul>

<h3>RemainderNaturalScale</h3>

<pre>public EFloat RemainderNaturalScale​(EFloat divisor)
</pre>

<p>Calculates the remainder of a number by the formula <code>&quot;this&quot; - ((&quot;this&quot; /
  &quot;divisor&quot;) * &quot;divisor&quot;)</code>.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>RemainderNaturalScale</h3>

<pre>public EFloat RemainderNaturalScale​(EFloat divisor, EContext ctx)
</pre>

<p>Calculates the remainder of a number by the formula &quot;this&quot; - ((&quot;this&quot; /
  &quot;divisor&quot;) * &quot;divisor&quot;).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the result. This context will be used only in
the division portion of the remainder calculation; as a result, it&#39;s
possible for the return value to have a higher precision than given
in this context. Flags will be set on the given context only if the
context&#39;s <code>HasFlags</code> is true and the integer part of the
division result doesn&#39;t fit the precision and exponent range without
rounding. Can be null, in which the precision is unlimited and no
additional rounding, other than the rounding down to an integer
after division, is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>RemainderNear</h3>

<pre>public EFloat RemainderNear​(EFloat divisor, EContext ctx)
</pre>

<p>Finds the distance to the closest multiple of the given divisor, based on
 the result of dividing this object&#39;s value by another object&#39;s
 value. <ul> <li>If this and the other object divide evenly, the
 result is 0.</li> <li>If the remainder&#39;s absolute value is less than
 half of the divisor&#39;s absolute value, the result has the same sign
 as this object and will be the distance to the closest
 multiple.</li> <li>If the remainder&#39;s absolute value is more than
 half of the divisor&#39; s absolute value, the result has the opposite
 sign of this object and will be the distance to the closest
 multiple.</li> <li>If the remainder&#39;s absolute value is exactly half
 of the divisor&#39;s absolute value, the result has the opposite sign of
 this object if the quotient, rounded down, is odd, and has the same
 sign as this object if the quotient, rounded down, is even, and the
 result&#39;s absolute value is half of the divisor&#39;s absolute
  value.</li></ul> This function is also known as the &quot;IEEE Remainder&quot;
 function.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision. The
rounding and exponent range settings of this context are ignored
(the rounding mode is always treated as HalfEven). If <code>
HasFlags</code> of the context is true, will also store the flags
resulting from the operation (the flags are in addition to the
pre-existing flags). Can be null, in which the precision is
unlimited.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The distance of the closest multiple. Signals FlagInvalid and
returns not-a-number (NaN) if the divisor is 0, or either the result
of integer division (the quotient) or the remainder wouldn&#39;t fit the
given precision.</li>
</ul>

<h3>RoundToExponent</h3>

<pre>public EFloat RoundToExponent​(EInteger exponent, EContext ctx)
</pre>

<p>Returns a binary float with the same value as this object but rounded to a
 new exponent if necessary. The resulting number&#39;s Exponent property
 will not necessarily be the given exponent; use the Quantize method
 instead to give the result a particular exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the
thousandth (10^-3, 0.0001), and 3 means round to the thousand (10^3,
1000). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the arithmetic context defines an exponent
range, the new exponent must be changed to the given exponent when
rounding, and the given exponent is outside of the valid range of
the arithmetic context.</li>
</ul>

<h3>RoundToExponent</h3>

<pre>public EFloat RoundToExponent​(int exponentSmall, EContext ctx)
</pre>

<p>Returns a binary float with the same value as this object but rounded to a
 new exponent if necessary. The resulting number&#39;s Exponent property
 will not necessarily be the given exponent; use the Quantize method
 instead to give the result a particular exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponentSmall</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the
thousandth (10^-3, 0.0001), and 3 means round to the thousand (10^3,
1000). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the arithmetic context defines an exponent
range, the new exponent must be changed to the given exponent when
rounding, and the given exponent is outside of the valid range of
the arithmetic context.</li>
</ul>

<h3>RoundToExponentExact</h3>

<pre>public EFloat RoundToExponentExact​(EInteger exponent, EContext ctx)
</pre>

<p>Returns a binary float with the same value as this object but rounded to the
 given exponent, and signals an inexact flag if the result would be
 inexact. The resulting number&#39;s Exponent property will not
 necessarily be the given exponent; use the Quantize method instead
 to give the result a particular exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the
thousandth (10^-3, 0.0001), and 3 means round to the thousand (10^3,
1000). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding.
Signals FlagInvalid and returns not-a-number (NaN) if the arithmetic
context defines an exponent range, the new exponent must be changed
to the given exponent when rounding, and the given exponent is
outside of the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToExponentExact</h3>

<pre>public EFloat RoundToExponentExact​(EInteger exponent, ERounding rounding)
</pre>

<p>Returns a binary number with the same value as this object but rounded to
 the given exponent. The resulting number&#39;s Exponent property will
 not necessarily be the given exponent; use the Quantize method
 instead to give the result a particular exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the eighth
(10^-1, 1/8), and 3 means round to the eight (2^3, 8). A value of 0
rounds the number to an integer.</p></li>
<li><p><code>rounding</code> - Desired mode for rounding this object&#39;s value.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary number rounded to the closest value representable in the
given precision.</li>
</ul>

<h3>RoundToExponentExact</h3>

<pre>public EFloat RoundToExponentExact​(int exponentSmall, EContext ctx)
</pre>

<p>Returns a binary float with the same value as this object but rounded to the
 given exponent represented as a 32-bit signed integer, and signals
 an inexact flag if the result would be inexact. The resulting
 number&#39;s Exponent property will not necessarily be the given
 exponent; use the Quantize method instead to give the result a
 particular exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponentSmall</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the
thousandth (10^-3, 0.0001), and 3 means round to the thousand (10^3,
1000). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding.
Signals FlagInvalid and returns not-a-number (NaN) if the arithmetic
context defines an exponent range, the new exponent must be changed
to the given exponent when rounding, and the given exponent is
outside of the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToIntegerExact</h3>

<pre>public EFloat RoundToIntegerExact​(EContext ctx)
</pre>

<p>Returns a binary float with the same value as this object but rounded to an
 integer, and signals an inexact flag if the result would be inexact.
 The resulting number&#39;s Exponent property will not necessarily be 0;
 use the Quantize method instead to give the result an exponent of 0.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding.
Signals FlagInvalid and returns not-a-number (NaN) if the arithmetic
context defines an exponent range, the new exponent must be changed
to 0 when rounding, and 0 is outside of the valid range of the
arithmetic context.</li>
</ul>

<h3>RoundToIntegerNoRoundedFlag</h3>

<pre>public EFloat RoundToIntegerNoRoundedFlag​(EContext ctx)
</pre>

<p>Returns a binary float with the same value as this object but rounded to an
 integer, without adding the <code>FlagInexact</code> or <code>FlagRounded</code>
 flags. The resulting number&#39;s Exponent property will not necessarily
 be 0; use the Quantize method instead to give the result an exponent
 of 0.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags), except that this function will never add
the <code>FlagRounded</code> and <code>FlagInexact</code> flags (the only
difference between this and RoundToExponentExact). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the arithmetic context defines an exponent
range, the new exponent must be changed to 0 when rounding, and 0 is
outside of the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToIntegralExact</h3>

<pre>@Deprecated public EFloat RoundToIntegralExact​(EContext ctx)
</pre>

<p>Deprecated.
Renamed to RoundToIntegerExact.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding.
Signals FlagInvalid and returns not-a-number (NaN) if the arithmetic
context defines an exponent range, the new exponent must be changed
to 0 when rounding, and 0 is outside of the valid range of the
arithmetic context.</li>
</ul>

<h3>RoundToIntegralNoRoundedFlag</h3>

<pre>@Deprecated public EFloat RoundToIntegralNoRoundedFlag​(EContext ctx)
</pre>

<p>Deprecated.
Renamed to RoundToIntegerNoRoundedFlag.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags), except that this function will never add
the <code>FlagRounded</code> and <code>FlagInexact</code> flags (the only
difference between this and RoundToExponentExact). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the arithmetic context defines an exponent
range, the new exponent must be changed to 0 when rounding, and 0 is
outside of the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToPrecision</h3>

<pre>public EFloat RoundToPrecision​(EContext ctx)
</pre>

<p>Rounds this object&#39;s value to a given precision, using the given rounding
 mode and range of exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest value to this object&#39;s value, rounded to the specified
precision. Returns the same value as this object if <code>ctx</code> is
null or the precision and exponent range are unlimited.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre>public EFloat ScaleByPowerOfTwo​(int places)
</pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>places</code> - The parameter <code>places</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre>public EFloat ScaleByPowerOfTwo​(int places, EContext ctx)
</pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>places</code> - The parameter <code>places</code> is a 32-bit signed integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre>public EFloat ScaleByPowerOfTwo​(EInteger bigPlaces)
</pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigPlaces</code> - An arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>bigPlaces</code>.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre>public EFloat ScaleByPowerOfTwo​(EInteger bigPlaces, EContext ctx)
</pre>

<p>Returns a number similar to this number but with its scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bigPlaces</code> - An arbitrary-precision integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>bigPlaces</code> is null.</li>
</ul>

<h3>Sqrt</h3>

<pre>public EFloat Sqrt​(EContext ctx)
</pre>

<p>Finds the square root of this object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the square root function&#39;s results are generally
not exact for many inputs.</i> (Unlike in the General Binary
Arithmetic Specification, any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The square root. Signals the flag FlagInvalid and returns NaN if
this object is less than 0 (the square root would be a complex
number, but the return value is still NaN). Signals FlagInvalid and
returns not-a-number (NaN) if the parameter <code>ctx</code> is null or
the precision is unlimited (the context&#39;s Precision property is 0).</li>
</ul>

<h3>SquareRoot</h3>

<pre>@Deprecated public EFloat SquareRoot​(EContext ctx)
</pre>

<p>Deprecated.
Renamed to Sqrt.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the square root function&#39;s results are generally
not exact for many inputs.</i> (Unlike in the General Binary
Arithmetic Specification, any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The square root. Signals the flag FlagInvalid and returns NaN if
this object is less than 0 (the square root would be a complex
number, but the return value is still NaN). Signals FlagInvalid and
returns not-a-number (NaN) if the parameter <code>ctx</code> is null or
the precision is unlimited (the context&#39;s Precision property is 0).</li>
</ul>

<h3>Subtract</h3>

<pre>public EFloat Subtract​(EFloat otherValue)
</pre>

<p>Subtracts an arbitrary-precision binary float from this instance and returns
 the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - The number to subtract from this instance&#39;s value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference of the two objects.</li>
</ul>

<h3>Subtract</h3>

<pre>public EFloat Subtract​(EFloat otherValue, EContext ctx)
</pre>

<p>Subtracts an arbitrary-precision binary float from this instance.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - The number to subtract from this instance&#39;s value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>otherValue</code> is null.</li>
</ul>

<h3>ToDouble</h3>

<pre>public double ToDouble()
</pre>

<p>Converts this value to a 64-bit floating-point number.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 64-bit floating-point number.</li>
</ul>

<h3>ToEDecimal</h3>

<pre>public EDecimal ToEDecimal()
</pre>

<p>Converts this value to an arbitrary-precision decimal number.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to an arbitrary-precision decimal number.</li>
</ul>

<h3>ToEInteger</h3>

<pre>public EInteger ToEInteger()
</pre>

<p>Converts this value to an arbitrary-precision integer. Any fractional part
 of this value will be discarded when converting to an
 arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This object&#39;s value is infinity or not-a-number
(NaN).</li>
</ul>

<h3>ToEIntegerExact</h3>

<pre>@Deprecated public EInteger ToEIntegerExact()
</pre>

<p>Deprecated.
Renamed to ToEIntegerIfExact.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This object&#39;s value is infinity or not-a-number
(NaN).</li>
</ul>

<h3>ToEIntegerIfExact</h3>

<pre>public EInteger ToEIntegerIfExact()
</pre>

<p>Converts this value to an arbitrary-precision integer, checking whether the
 value contains a fractional part.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This object&#39;s value is infinity or not-a-number
(NaN).</li>
</ul>

<h3>ToEngineeringString</h3>

<pre>public java.lang.String ToEngineeringString()
</pre>

<p>Converts this value to an arbitrary-precision decimal number, then returns
 the value of that decimal&#39;s ToEngineeringString method.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A text string.</li>
</ul>

<h3>ToExtendedDecimal</h3>

<pre>@Deprecated public EDecimal ToExtendedDecimal()
</pre>

<p>Deprecated.
Renamed to ToEDecimal.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision decimal number.</li>
</ul>

<h3>ToPlainString</h3>

<pre>public java.lang.String ToPlainString()
</pre>

<p>Converts this value to a string, but without exponential notation.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A text string.</li>
</ul>

<h3>ToShortestString</h3>

<pre>public java.lang.String ToShortestString​(EContext ctx)
</pre>

<p>Returns a string representation of this number&#39;s value after rounding to the
 given precision (using the given arithmetic context). If the number
 after rounding is neither infinity nor not-a-number (NaN), returns
 the shortest decimal form (in terms of nonzero decimal digits) of
 this number&#39;s value that results in the rounded number after the
 decimal form is converted to binary floating-point format (using the
 given arithmetic context).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision (in bits), rounding,
and exponent range of the rounded number. If <code>HasFlags</code> of the
context is true, will also store the flags resulting from the
operation (the flags are in addition to the pre-existing flags). Can
be null. If this parameter is null or defines no maximum precision,
returns the same value as the toString() method.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Shortest decimal form of this number&#39;s value for the given
arithmetic context. The text string will be in exponential notation
if the number&#39;s first nonzero decimal digit is more than five digits
after the decimal point, or if the number&#39;s exponent is greater than
0 and its value is 10, 000, 000 or greater.</li>
</ul>

<h3>ToSingle</h3>

<pre>public float ToSingle()
</pre>

<p>Converts this value to its closest equivalent as 32-bit floating-point
 number. The half-even rounding mode is used. <p>If this value is a
 NaN, sets the high bit of the 32-bit floating point number&#39;s
 significand area for a quiet NaN, and clears it for a signaling NaN.
 Then the other bits of the significand area are set to the lowest
 bits of this object&#39;s unsigned mantissa (significand), and the
 next-highest bit of the significand area is set if those bits are
 all zeros and this is a signaling NaN. Unfortunately, in the.getNET()
 implementation, the return value of this method may be a quiet NaN
 even if a signaling NaN would otherwise be generated.</p></p>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest 32-bit binary floating-point number to this value. The
return value can be positive infinity or negative infinity if this
value exceeds the range of a 32-bit floating point number.</li>
</ul>

<h3>toString</h3>

<pre>public java.lang.String toString()
</pre>

<p>Converts this number&#39;s value to a text string.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>toString</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A string representation of this object. The value is converted to
decimal and the decimal form of this number&#39;s value is returned. The
text string will be in exponential notation if the converted
number&#39;s scale is positive or if the number&#39;s first nonzero decimal
digit is more than five digits after the decimal point.</li>
</ul>

<h3>Ulp</h3>

<pre>public EFloat Ulp()
</pre>

<p>Returns the unit in the last place. The mantissa (significand) will be 1 and
 the exponent will be this number&#39;s exponent. Returns 1 with an
 exponent of 0 if this number is infinity or not-a-number (NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary floating-point number.</li>
</ul>

<h3>ToByteChecked</h3>

<pre>public byte ToByteChecked()
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
 byte (from 0 to 255) after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a byte (from 0 to 255).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, or the
truncated integer is less than 0 or greater than 255.</li>
</ul>

<h3>ToByteUnchecked</h3>

<pre>public byte ToByteUnchecked()
</pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a byte (from
 0 to 255).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a byte (from 0 to 255). Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToByteIfExact</h3>

<pre>public byte ToByteIfExact()
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
 byte (from 0 to 255) without rounding to a different numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a byte (from 0 to 255).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than 0 or greater than 255.</li>
</ul>

<h3>FromByte</h3>

<pre>public static EFloat FromByte​(byte inputByte)
</pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision binary
 floating-point number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputByte</code> - The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary floating-point
number.</li>
</ul>

<h3>ToInt16Checked</h3>

<pre>public short ToInt16Checked()
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
 16-bit signed integer after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a 16-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, or the
truncated integer is less than -32768 or greater than 32767.</li>
</ul>

<h3>ToInt16Unchecked</h3>

<pre>public short ToInt16Unchecked()
</pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a 16-bit
 signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 16-bit signed integer. Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToInt16IfExact</h3>

<pre>public short ToInt16IfExact()
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
 16-bit signed integer without rounding to a different numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a 16-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than -32768 or greater than 32767.</li>
</ul>

<h3>FromInt16</h3>

<pre>public static EFloat FromInt16​(short inputInt16)
</pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision binary
 floating-point number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputInt16</code> - The number to convert as a 16-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary floating-point
number.</li>
</ul>

<h3>ToInt32Checked</h3>

<pre>public int ToInt32Checked()
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
 32-bit signed integer after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a 32-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, or the
truncated integer is less than -2147483648 or greater than
2147483647.</li>
</ul>

<h3>ToInt32Unchecked</h3>

<pre>public int ToInt32Unchecked()
</pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a 32-bit
 signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 32-bit signed integer. Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToInt32IfExact</h3>

<pre>public int ToInt32IfExact()
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
 32-bit signed integer without rounding to a different numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a 32-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than -2147483648 or greater than
2147483647.</li>
</ul>

<h3>FromBoolean</h3>

<pre>public static EFloat FromBoolean​(boolean boolValue)
</pre>

<p>Converts a boolean value (either true or false) to an arbitrary-precision
 binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>boolValue</code> - Either true or false.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 1 if <code>boolValue</code> is true, otherwise, 0.</li>
</ul>

<h3>FromInt32</h3>

<pre>public static EFloat FromInt32​(int inputInt32)
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision binary
 floating-point number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputInt32</code> - The number to convert as a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary floating-point
number.</li>
</ul>

<h3>ToInt64Checked</h3>

<pre>public long ToInt64Checked()
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
 64-bit signed integer after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a 64-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, or the
truncated integer is less than -9223372036854775808 or greater than
9223372036854775807.</li>
</ul>

<h3>ToInt64Unchecked</h3>

<pre>public long ToInt64Unchecked()
</pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a 64-bit
 signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 64-bit signed integer. Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToInt64IfExact</h3>

<pre>public long ToInt64IfExact()
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
 64-bit signed integer without rounding to a different numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a 64-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than -9223372036854775808 or greater
than 9223372036854775807.</li>
</ul>

<h3>FromInt64</h3>

<pre>public static EFloat FromInt64​(long inputInt64)
</pre>

<p>Converts a 64-bit signed integer to an arbitrary-precision binary
 floating-point number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputInt64</code> - The number to convert as a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary floating-point
number.</li>
</ul>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
