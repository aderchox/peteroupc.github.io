<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>com.upokecenter.numbers.EFloat</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>com.upokecenter.numbers.EFloat</h1>

<h1>com.upokecenter.numbers.EFloat</h1>

<pre><code>public final class EFloat extends Object implements Comparable&lt;EFloat&gt;
</code></pre>

<p>Represents an arbitrary-precision binary floating-point number. (The &quot;E&quot;
 stands for &quot;extended&quot;, meaning that instances of this class can be
 values other than numbers proper, such as infinity and not-a-number.)
 Each number consists of an integer mantissa (significand) and an
 integer exponent, both arbitrary-precision. The value of the number
 equals mantissa (significand) * 2^exponent. This class also supports
 values for negative zero, not-a-number (NaN) values, and infinity.
 <p>Passing a signaling NaN to any arithmetic operation shown here
 will signal the flag FlagInvalid and return a quiet NaN, even if
 another operand to that operation is a quiet NaN, unless noted
 otherwise.</p> <p>Passing a quiet NaN to any arithmetic operation
 shown here will return a quiet NaN, unless noted otherwise.</p>
 <p>Unless noted otherwise, passing a null arbitrary-precision binary
 float argument to any method here will throw an exception.</p>
 <p>When an arithmetic operation signals the flag FlagInvalid,
 FlagOverflow, or FlagDivideByZero, it will not throw an exception
 too, unless the operation&#39;s trap is enabled in the precision context
 (see EContext&#39;s Traps property).</p> <p>An arbitrary-precision binary
 float value can be serialized in one of the following ways:</p> <ul>
 <li>By calling the toString() method. However, not all strings can be
 converted back to an arbitrary-precision binary float without loss,
 especially if the string has a fractional part.</li> <li>By calling
 the UnsignedMantissa, Exponent, and IsNegative properties, and
 calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods. The
 return values combined will uniquely identify a particular
 arbitrary-precision binary float value.</li></ul> <p>If an operation
 requires creating an intermediate value that might be too big to fit
 in memory (or might require more than 2 gigabytes of memory to store
 -- due to the current use of a 32-bit integer internally as a
 length), the operation may signal an invalid-operation flag and
 return not-a-number (NaN). In certain rare cases, the compareTo
 method may throw OutOfMemoryError (called OutOfMemoryError in
 Java) in the same circumstances.</p> <p><b>Thread safety</b></p>
 <p>Instances of this class are immutable, so they are inherently safe
 for use by multiple threads. Multiple instances of this object with
 the same properties are interchangeable, so they should not be
 compared using the &quot;==&quot; operator (which might only check if each side
 of the operator is the same instance).</p> <p><b>Comparison
 considerations</b></p> <p>This class&#39;s natural ordering (under the
 compareTo method) is not consistent with the Equals method. This
 means that two values that compare as equal under the compareTo
 method might not be equal under the Equals method. The compareTo
 method compares the mathematical values of the two instances passed
 to it (and considers two different NaN values as equal), while two
 instances with the same mathematical value, but different exponents,
 will be considered unequal under the Equals method.</p></p>

<h2>Fields</h2>

<ul>
<li><code>static EFloat NaN</code><br>
A not-a-number value.</li>
<li><code>static EFloat NegativeInfinity</code><br>
Negative infinity, less than any other number.</li>
<li><code>static EFloat NegativeZero</code><br>
Represents the number negative zero.</li>
<li><code>static EFloat One</code><br>
Represents the number 1.</li>
<li><code>static EFloat PositiveInfinity</code><br>
Positive infinity, greater than any other number.</li>
<li><code>static EFloat SignalingNaN</code><br>
A not-a-number value that signals an invalid operation flag when it&#39;s
passed as an argument to any arithmetic operation in
arbitrary-precision binary float.</li>
<li><code>static EFloat Ten</code><br>
Represents the number 10.</li>
<li><code>static EFloat Zero</code><br>
Represents the number 0.</li>
</ul>

<h2>Methods</h2>

<ul>
<li><code>EFloat Abs()</code><br>
Finds the absolute value of this object (if it&#39;s negative, it becomes
positive).</li>
<li><code>EFloat Abs(EContext context)</code><br>
Finds the absolute value of this object (if it&#39;s negative, it becomes
positive).</li>
<li><code>EFloat Add(EFloat otherValue)</code><br>
Adds this object and another binary float and returns the result.</li>
<li><code>EFloat Add(EFloat otherValue,
EContext ctx)</code><br>
Finds the sum of this object and another object.</li>
<li><code>int compareTo(EFloat other)</code><br>
Compares the mathematical values of this object and another object,
accepting NaN values.</li>
<li><code>EFloat CompareToSignal(EFloat other,
           EContext ctx)</code><br>
Compares the mathematical values of this object and another object, treating
quiet NaN as signaling.</li>
<li><code>int CompareToTotal(EFloat other)</code><br>
Compares the values of this object and another object, imposing a total
ordering on all possible values.</li>
<li><code>int CompareToTotal(EFloat other,
          EContext ctx)</code><br>
Compares the values of this object and another object, imposing a total
ordering on all possible values.</li>
<li><code>int CompareToTotalMagnitude(EFloat other)</code><br>
Compares the absolute values of this object and another object, imposing a
total ordering on all possible values (ignoring their signs).</li>
<li><code>EFloat CompareToWithContext(EFloat other,
                EContext ctx)</code><br>
Compares the mathematical values of this object and another object.</li>
<li><code>EFloat CopySign(EFloat other)</code><br>
Returns a number with the same value as this one, but copying the sign
(positive or negative) of another number.</li>
<li><code>static EFloat Create(EInteger mantissa,
  EInteger exponent)</code><br>
Creates a number with the value exponent*2^mantissa (significand).</li>
<li><code>static EFloat Create(int mantissaSmall,
  int exponentSmall)</code><br>
Creates a number with the value exponent*2^mantissa (significand).</li>
<li><code>static EFloat CreateNaN(EInteger diag)</code><br>
Creates a not-a-number arbitrary-precision binary float.</li>
<li><code>static EFloat CreateNaN(EInteger diag,
     boolean signaling,
     boolean negative,
     EContext ctx)</code><br>
Creates a not-a-number arbitrary-precision binary float.</li>
<li><code>EFloat Divide(EFloat divisor)</code><br>
Divides this object by another binary float and returns the result.</li>
<li><code>EFloat Divide(EFloat divisor,
  EContext ctx)</code><br>
Divides this arbitrary-precision binary float by another arbitrary-precision
binary float.</li>
<li><code>EFloat[] DivideAndRemainderNaturalScale(EFloat divisor)</code><br>
Deprecated.
Renamed to DivRemNaturalScale.
Renamed to DivRemNaturalScale.</li>
<li><code>EFloat[] DivideAndRemainderNaturalScale(EFloat divisor,
                          EContext ctx)</code><br>
Deprecated.
Renamed to DivRemNaturalScale.
Renamed to DivRemNaturalScale.</li>
<li><code>EFloat DivideToExponent(EFloat divisor,
            EInteger exponent,
            EContext ctx)</code><br>
Divides two arbitrary-precision binary floats, and gives a particular
exponent to the result.</li>
<li><code>EFloat DivideToExponent(EFloat divisor,
            EInteger desiredExponent,
            ERounding rounding)</code><br>
Divides two arbitrary-precision binary floats, and gives a particular
exponent to the result.</li>
<li><code>EFloat DivideToExponent(EFloat divisor,
            long desiredExponentSmall,
            EContext ctx)</code><br>
Divides two arbitrary-precision binary floats, and gives a particular
exponent to the result.</li>
<li><code>EFloat DivideToExponent(EFloat divisor,
            long desiredExponentSmall,
            ERounding rounding)</code><br>
Divides two arbitrary-precision binary floats, and gives a particular
exponent to the result.</li>
<li><code>EFloat DivideToIntegerNaturalScale(EFloat divisor)</code><br>
Divides two arbitrary-precision binary floats, and returns the integer part
of the result, rounded down, with the preferred exponent set to this
value&#39;s exponent minus the divisor&#39;s exponent.</li>
<li><code>EFloat DivideToIntegerNaturalScale(EFloat divisor,
                       EContext ctx)</code><br>
Divides this object by another object, and returns the integer part of the
result (which is initially rounded down), with the preferred exponent
set to this value&#39;s exponent minus the divisor&#39;s exponent.</li>
<li><code>EFloat DivideToIntegerZeroScale(EFloat divisor,
                    EContext ctx)</code><br>
Divides this object by another object, and returns the integer part of the
result, with the exponent set to 0.</li>
<li><code>EFloat DivideToSameExponent(EFloat divisor,
                ERounding rounding)</code><br>
Divides this object by another binary float and returns a result with the
same exponent as this object (the dividend).</li>
<li><code>EFloat[] DivRemNaturalScale(EFloat divisor)</code><br>
Calculates the quotient and remainder using the DivideToIntegerNaturalScale
and the formula in RemainderNaturalScale.</li>
<li><code>EFloat[] DivRemNaturalScale(EFloat divisor,
              EContext ctx)</code><br>
Calculates the quotient and remainder using the DivideToIntegerNaturalScale
and the formula in RemainderNaturalScale.</li>
<li><code>boolean equals(EFloat other)</code><br>
Determines whether this object&#39;s mantissa (significand), exponent, and
properties are equal to those of another object.</li>
<li><code>boolean equals(Object obj)</code><br>
Determines whether this object&#39;s mantissa (significand), exponent, and
properties are equal to those of another object and that other object
is an arbitrary-precision binary float.</li>
<li><code>boolean EqualsInternal(EFloat otherValue)</code><br>
Determines whether this object&#39;s mantissa (significand) and exponent
are equal to those of another object.</li>
<li><code>EFloat Exp(EContext ctx)</code><br>
Finds e (the base of natural logarithms) raised to the power of this
object&#39;s value.</li>
<li><code>static EFloat FromByte(byte inputByte)</code><br>
Converts a byte (from 0 to 255) to an arbitrary-precision binary float.</li>
<li><code>static EFloat FromDouble(double dbl)</code><br>
Creates a binary float from a 64-bit floating-point number.</li>
<li><code>static EFloat FromEInteger(EInteger bigint)</code><br>
Converts an arbitrary-precision integer to the same value as a binary float.</li>
<li><code>static EFloat FromInt16(short inputInt16)</code><br>
Converts a 16-bit signed integer to an arbitrary-precision binary float.</li>
<li><code>static EFloat FromInt32(int inputInt32)</code><br>
Converts a 32-bit signed integer to an arbitrary-precision binary float.</li>
<li><code>static EFloat FromInt64(long inputInt64)</code><br>
Converts a 64-bit signed integer to an arbitrary-precision binary float.</li>
<li><code>static EFloat FromSingle(float flt)</code><br>
Creates a binary float from a 32-bit floating-point number.</li>
<li><code>static EFloat FromString(String str)</code><br>
Not documented yet.</li>
<li><code>static EFloat FromString(String str,
      EContext ctx)</code><br>
Creates a binary float from a text string that represents a number.</li>
<li><code>static EFloat FromString(String str,
      int offset,
      int length)</code><br>
Creates a binary float from a text string that represents a number.</li>
<li><code>static EFloat FromString(String str,
      int offset,
      int length,
      EContext ctx)</code><br>
Creates a binary float from a text string that represents a number.</li>
<li><code>EInteger getExponent()</code><br>
Gets this object&#39;s exponent.</li>
<li><code>EInteger getMantissa()</code><br>
Gets this object&#39;s unscaled value.</li>
<li><code>EInteger getUnsignedMantissa()</code><br>
Gets the absolute value of this object&#39;s unscaled value.</li>
<li><code>int hashCode()</code><br>
Calculates this object&#39;s hash code.</li>
<li><code>boolean isFinite()</code><br>
Gets a value indicating whether this object is finite (not infinity or NaN).</li>
<li><code>boolean IsInfinity()</code><br>
Gets a value indicating whether this object is positive or negative
infinity.</li>
<li><code>boolean IsNaN()</code><br>
Gets a value indicating whether this object is not a number (NaN).</li>
<li><code>boolean isNegative()</code><br>
Gets a value indicating whether this object is negative, including negative
zero.</li>
<li><code>boolean IsNegativeInfinity()</code><br>
Returns whether this object is negative infinity.</li>
<li><code>boolean IsPositiveInfinity()</code><br>
Returns whether this object is positive infinity.</li>
<li><code>boolean IsQuietNaN()</code><br>
Gets a value indicating whether this object is a quiet not-a-number value.</li>
<li><code>boolean IsSignalingNaN()</code><br>
Gets a value indicating whether this object is a signaling not-a-number
value.</li>
<li><code>boolean isZero()</code><br>
Gets a value indicating whether this object&#39;s value equals 0.</li>
<li><code>EFloat Log(EContext ctx)</code><br>
Finds the natural logarithm of this object, that is, the power (exponent)
that e (the base of natural logarithms) must be raised to in order to
equal this object&#39;s value.</li>
<li><code>EFloat Log10(EContext ctx)</code><br>
Finds the base-10 logarithm of this object, that is, the power (exponent)
that the number 10 must be raised to in order to equal this
object&#39;s value.</li>
<li><code>static EFloat Max(EFloat first,
EFloat second)</code><br>
Gets the greater value between two binary floats.</li>
<li><code>static EFloat Max(EFloat first,
EFloat second,
EContext ctx)</code><br>
Gets the greater value between two binary floats.</li>
<li><code>static EFloat MaxMagnitude(EFloat first,
        EFloat second)</code><br>
Gets the greater value between two values, ignoring their signs.</li>
<li><code>static EFloat MaxMagnitude(EFloat first,
        EFloat second,
        EContext ctx)</code><br>
Gets the greater value between two values, ignoring their signs.</li>
<li><code>static EFloat Min(EFloat first,
EFloat second)</code><br>
Gets the lesser value between two binary floats.</li>
<li><code>static EFloat Min(EFloat first,
EFloat second,
EContext ctx)</code><br>
Gets the lesser value between two binary floats.</li>
<li><code>static EFloat MinMagnitude(EFloat first,
        EFloat second)</code><br>
Gets the lesser value between two values, ignoring their signs.</li>
<li><code>static EFloat MinMagnitude(EFloat first,
        EFloat second,
        EContext ctx)</code><br>
Gets the lesser value between two values, ignoring their signs.</li>
<li><code>EFloat MovePointLeft(EInteger bigPlaces)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointLeft(EInteger bigPlaces,
         EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointLeft(int places)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointLeft(int places,
         EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the left.</li>
<li><code>EFloat MovePointRight(EInteger bigPlaces)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat MovePointRight(EInteger bigPlaces,
          EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat MovePointRight(int places)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat MovePointRight(int places,
          EContext ctx)</code><br>
Returns a number similar to this number but with the radix point moved to
the right.</li>
<li><code>EFloat Multiply(EFloat otherValue)</code><br>
Multiplies two binary floats.</li>
<li><code>EFloat Multiply(EFloat op,
    EContext ctx)</code><br>
Multiplies two binary floats.</li>
<li><code>EFloat MultiplyAndAdd(EFloat multiplicand,
          EFloat augend)</code><br>
Multiplies by one binary float, and then adds another binary float.</li>
<li><code>EFloat MultiplyAndAdd(EFloat op,
          EFloat augend,
          EContext ctx)</code><br>
Multiplies by one value, and then adds another value.</li>
<li><code>EFloat MultiplyAndSubtract(EFloat op,
               EFloat subtrahend,
               EContext ctx)</code><br>
Multiplies by one value, and then subtracts another value.</li>
<li><code>EFloat Negate()</code><br>
Gets an object with the same value as this one, but with the sign reversed.</li>
<li><code>EFloat Negate(EContext context)</code><br>
Returns a binary float with the same value as this object but with the sign
reversed.</li>
<li><code>EFloat NextMinus(EContext ctx)</code><br>
Finds the largest value that&#39;s smaller than the given value.</li>
<li><code>EFloat NextPlus(EContext ctx)</code><br>
Finds the smallest value that&#39;s greater than the given value.</li>
<li><code>EFloat NextToward(EFloat otherValue,
      EContext ctx)</code><br>
Finds the next value that is closer to the other object&#39;s value than
this object&#39;s value.</li>
<li><code>static EFloat PI(EContext ctx)</code><br>
Finds the constant π, the circumference of a circle divided by its
diameter.</li>
<li><code>EFloat Plus(EContext ctx)</code><br>
Rounds this object&#39;s value to a given precision, using the given
rounding mode and range of exponent, and also converts negative zero
to positive zero.</li>
<li><code>EFloat Pow(EFloat exponent,
EContext ctx)</code><br>
Raises this object&#39;s value to the given exponent.</li>
<li><code>EFloat Pow(int exponentSmall)</code><br>
Raises this object&#39;s value to the given exponent.</li>
<li><code>EFloat Pow(int exponentSmall,
EContext ctx)</code><br>
Raises this object&#39;s value to the given exponent.</li>
<li><code>EInteger Precision()</code><br>
Finds the number of digits in this number&#39;s mantissa (significand).</li>
<li><code>EFloat Quantize(EFloat otherValue,
    EContext ctx)</code><br>
Returns a binary float with the same value as this object but with the same
exponent as another binary float.</li>
<li><code>EFloat Quantize(EInteger desiredExponent,
    EContext ctx)</code><br>
Returns a binary float with the same value but a new exponent.</li>
<li><code>EFloat Quantize(int desiredExponentInt,
    EContext ctx)</code><br>
Returns a binary float with the same value but a new exponent.</li>
<li><code>EFloat Reduce(EContext ctx)</code><br>
Removes trailing zeros from this object&#39;s mantissa (significand).</li>
<li><code>EFloat Remainder(EFloat divisor,
     EContext ctx)</code><br>
Finds the remainder that results when dividing two arbitrary-precision
binary floats.</li>
<li><code>EFloat RemainderNaturalScale(EFloat divisor) &quot;this&quot; - ((&quot;this&quot; /
&quot;divisor&quot;) * &quot;divisor&quot;)</code><br>
Calculates the remainder of a number by the formula &quot;this&quot; - ((&quot;this&quot; /
&quot;divisor&quot;) * &quot;divisor&quot;)</li>
<li><code>EFloat RemainderNaturalScale(EFloat divisor,
                 EContext ctx)</code><br>
Calculates the remainder of a number by the formula &quot;this&quot; - ((&quot;this&quot; /
&quot;divisor&quot;) * &quot;divisor&quot;).</li>
<li><code>EFloat RemainderNear(EFloat divisor,
         EContext ctx)</code><br>
Finds the distance to the closest multiple of the given divisor, based on
the result of dividing this object&#39;s value by another
object&#39;s value.</li>
<li><code>EFloat RoundToExponent(EInteger exponent,
           EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to a
new exponent if necessary.</li>
<li><code>EFloat RoundToExponent(int exponentSmall,
           EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to a
new exponent if necessary.</li>
<li><code>EFloat RoundToExponentExact(EInteger exponent,
                EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to the
given exponent, and signals an inexact flag if the result would be
inexact.</li>
<li><code>EFloat RoundToExponentExact(EInteger exponent,
                ERounding rounding)</code><br>
Returns a binary number with the same value as this object but rounded to
the given exponent.</li>
<li><code>EFloat RoundToExponentExact(int exponentSmall,
                EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to an
integer, and signals an inexact flag if the result would be inexact.</li>
<li><code>EFloat RoundToIntegerExact(EContext ctx)</code><br>
Returns a binary float with the same value as this object but rounded to an
integer, and signals an inexact flag if the result would be inexact.</li>
<li><code>EFloat RoundToIntegerNoRoundedFlag(EContext ctx) FlagInexact FlagRounded</code><br>
Returns a binary float with the same value as this object but rounded to an
integer, without adding the FlagInexact or FlagRounded
flags.</li>
<li><code>EFloat RoundToIntegralExact(EContext ctx)</code><br>
Deprecated.
Renamed to RoundToIntegerExact.
Renamed to RoundToIntegerExact.</li>
<li><code>EFloat RoundToIntegralNoRoundedFlag(EContext ctx)</code><br>
Deprecated.
Renamed to RoundToIntegerNoRoundedFlag.
Renamed to RoundToIntegerNoRoundedFlag.</li>
<li><code>EFloat RoundToPrecision(EContext ctx)</code><br>
Rounds this object&#39;s value to a given precision, using the given
rounding mode and range of exponent.</li>
<li><code>EFloat ScaleByPowerOfTwo(EInteger bigPlaces)</code><br>
Returns a number similar to this number but with the scale adjusted.</li>
<li><code>EFloat ScaleByPowerOfTwo(EInteger bigPlaces,
             EContext ctx)</code><br>
Returns a number similar to this number but with its scale adjusted.</li>
<li><code>EFloat ScaleByPowerOfTwo(int places)</code><br>
Returns a number similar to this number but with the scale adjusted.</li>
<li><code>EFloat ScaleByPowerOfTwo(int places,
             EContext ctx)</code><br>
Returns a number similar to this number but with the scale adjusted.</li>
<li><code>int signum()</code><br>
Gets this value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</li>
<li><code>EFloat Sqrt(EContext ctx)</code><br>
Finds the square root of this object&#39;s value.</li>
<li><code>EFloat SquareRoot(EContext ctx)</code><br>
Deprecated.
Renamed to Sqrt.
Renamed to Sqrt.</li>
<li><code>EFloat Subtract(EFloat otherValue)</code><br>
Subtracts an arbitrary-precision binary float from this instance and returns
the result.</li>
<li><code>EFloat Subtract(EFloat otherValue,
    EContext ctx)</code><br>
Subtracts an arbitrary-precision binary float from this instance.</li>
<li><code>byte ToByteChecked()</code><br>
Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
byte (from 0 to 255) after truncating to an integer.</li>
<li><code>byte ToByteIfExact()</code><br>
Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
byte (from 0 to 255) without rounding to a different numerical value.</li>
<li><code>byte ToByteUnchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a byte (from 0
to 255).</li>
<li><code>double ToDouble()</code><br>
Not documented yet.</li>
<li><code>EDecimal ToEDecimal()</code><br>
Converts this value to an arbitrary-precision decimal number.</li>
<li><code>EInteger ToEInteger()</code><br>
Converts this value to an arbitrary-precision integer.</li>
<li><code>EInteger ToEIntegerExact()</code><br>
Deprecated.
Renamed to ToEIntegerIfExact.
Renamed to ToEIntegerIfExact.</li>
<li><code>EInteger ToEIntegerIfExact()</code><br>
Converts this value to an arbitrary-precision integer, checking whether the
value contains a fractional part.</li>
<li><code>String ToEngineeringString()</code><br>
Converts this value to an arbitrary-precision decimal number, then returns
the value of that decimal&#39;s ToEngineeringString method.</li>
<li><code>EDecimal ToExtendedDecimal()</code><br>
Deprecated.
Renamed to ToEDecimal.
Renamed to ToEDecimal.</li>
<li><code>short ToInt16Checked()</code><br>
Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
16-bit signed integer after truncating to an integer.</li>
<li><code>short ToInt16IfExact()</code><br>
Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
16-bit signed integer without rounding to a different numerical
value.</li>
<li><code>short ToInt16Unchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a 16-bit
signed integer.</li>
<li><code>int ToInt32Checked()</code><br>
Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
32-bit signed integer after truncating to an integer.</li>
<li><code>int ToInt32IfExact()</code><br>
Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
32-bit signed integer without rounding to a different numerical
value.</li>
<li><code>int ToInt32Unchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a 32-bit
signed integer.</li>
<li><code>long ToInt64Checked()</code><br>
Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
64-bit signed integer after truncating to an integer.</li>
<li><code>long ToInt64IfExact()</code><br>
Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
64-bit signed integer without rounding to a different numerical
value.</li>
<li><code>long ToInt64Unchecked()</code><br>
Truncates this number&#39;s value to an integer and returns the
least-significant bits of its two&#39;s-complement form as a 64-bit
signed integer.</li>
<li><code>String ToPlainString()</code><br>
Converts this value to a string, but without exponential notation.</li>
<li><code>String ToShortestString(EContext ctx)</code><br>
Returns a string representation of this number&#39;s value after rounding to the
given precision (using the given arithmetic context).</li>
<li><code>float ToSingle()</code><br>
Converts this value to its closest equivalent as 32-bit floating-point
number.</li>
<li><code>String toString()</code><br>
Converts this number&#39;s value to a text string.</li>
<li><code>EFloat Ulp()</code><br>
Returns the unit in the last place.</li>
</ul>

<h2>Field Details</h2>

<h3>NaN</h3>

<pre><code>public static final EFloat NaN
</code></pre>

<p>A not-a-number value.</p>

<h3>NegativeInfinity</h3>

<pre><code>public static final EFloat NegativeInfinity
</code></pre>

<p>Negative infinity, less than any other number.</p>

<h3>NegativeZero</h3>

<pre><code>public static final EFloat NegativeZero
</code></pre>

<p>Represents the number negative zero.</p>

<h3>One</h3>

<pre><code>public static final EFloat One
</code></pre>

<p>Represents the number 1.</p>

<h3>PositiveInfinity</h3>

<pre><code>public static final EFloat PositiveInfinity
</code></pre>

<p>Positive infinity, greater than any other number.</p>

<h3>SignalingNaN</h3>

<pre><code>public static final EFloat SignalingNaN
</code></pre>

<p>A not-a-number value that signals an invalid operation flag when it&#x27;s
 passed as an argument to any arithmetic operation in
 arbitrary-precision binary float.</p>

<h3>Ten</h3>

<pre><code>public static final EFloat Ten
</code></pre>

<p>Represents the number 10.</p>

<h3>Zero</h3>

<pre><code>public static final EFloat Zero
</code></pre>

<p>Represents the number 0.</p>

<h2>Method Details</h2>

<h3>getExponent</h3>

<pre><code>public final EInteger getExponent()
</code></pre>

<p>Gets this object&#x27;s exponent. This object&#x27;s value will be an
 integer if the exponent is positive or zero.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39;s exponent. This object&#39;s value will be an integer if
the exponent is positive or zero.</li>
</ul>

<h3>isFinite</h3>

<pre><code>public final boolean isFinite()
</code></pre>

<p>Gets a value indicating whether this object is finite (not infinity or NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is finite (not infinity or not-a-number
(NaN)); otherwise, <code>false</code>.</li>
</ul>

<h3>isNegative</h3>

<pre><code>public final boolean isNegative()
</code></pre>

<p>Gets a value indicating whether this object is negative, including negative
 zero.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is negative, including negative zero;
otherwise, <code>false</code>.</li>
</ul>

<h3>isZero</h3>

<pre><code>public final boolean isZero()
</code></pre>

<p>Gets a value indicating whether this object&#x27;s value equals 0.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value equals 0; otherwise, . <code>false</code>.</li>
</ul>

<h3>getMantissa</h3>

<pre><code>public final EInteger getMantissa()
</code></pre>

<p>Gets this object&#x27;s unscaled value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39;s unscaled value. Will be negative if this object&#39;s
value is negative (including a negative NaN).</li>
</ul>

<h3>signum</h3>

<pre><code>public final int signum()
</code></pre>

<p>Gets this value&#x27;s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</li>
</ul>

<h3>getUnsignedMantissa</h3>

<pre><code>public final EInteger getUnsignedMantissa()
</code></pre>

<p>Gets the absolute value of this object&#x27;s unscaled value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The absolute value of this object&#39;s unscaled value.</li>
</ul>

<h3>Create</h3>

<pre><code>public static EFloat Create(int mantissaSmall, int exponentSmall)
</code></pre>

<p>Creates a number with the value exponent*2^mantissa (significand).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>mantissaSmall</code> - The parameter <code>mantissaSmall</code> is not documented
yet.</p></li>
<li><p><code>exponentSmall</code> - The parameter <code>exponentSmall</code> is not documented
yet.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>Create</h3>

<pre><code>public static EFloat Create(EInteger mantissa, EInteger exponent)
</code></pre>

<p>Creates a number with the value exponent*2^mantissa (significand).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>mantissa</code> - The parameter <code>mantissa</code> is not documented yet.</p></li>
<li><p><code>exponent</code> - The parameter <code>exponent</code> is not documented yet.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>NullPointerException</code> - The parameter &quot;mantissa (significand)&quot;
or <code>exponent</code> is null.</li>
</ul>

<h3>CreateNaN</h3>

<pre><code>public static EFloat CreateNaN(EInteger diag)
</code></pre>

<p>Creates a not-a-number arbitrary-precision binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>diag</code> - A number to use as diagnostic information associated with this
object. If none is needed, should be zero.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A quiet not-a-number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>NullPointerException</code> - The parameter <code>diag</code> is null.</p></li>
<li><p><code>IllegalArgumentException</code> - The parameter <code>diag</code> is less than 0.</p></li>
</ul>

<h3>CreateNaN</h3>

<pre><code>public static EFloat CreateNaN(EInteger diag, boolean signaling, boolean negative, EContext ctx)
</code></pre>

<p>Creates a not-a-number arbitrary-precision binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>diag</code> - A number to use as diagnostic information associated with this
object. If none is needed, should be zero.</p></li>
<li><p><code>signaling</code> - Whether the return value will be signaling (true) or quiet
(false).</p></li>
<li><p><code>negative</code> - Whether the return value is negative.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control the precision (in bits) of the
diagnostic information. The rounding and exponent range of this
context will be ignored. Can be null. The only flag that can be
signaled in this context is FlagInvalid, which happens if diagnostic
information needs to be truncated and too much memory is required to
do so.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>NullPointerException</code> - The parameter <code>diag</code> is null.</p></li>
<li><p><code>IllegalArgumentException</code> - The parameter <code>diag</code> is less than 0.</p></li>
</ul>

<h3>FromDouble</h3>

<pre><code>public static EFloat FromDouble(double dbl)
</code></pre>

<p>Creates a binary float from a 64-bit floating-point number. This method
 computes the exact value of the floating point number, not an
 approximation, as is often the case by converting the floating point
 number to a string first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>dbl</code> - A 64-bit floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as <code>dbl</code>.</li>
</ul>

<h3>FromEInteger</h3>

<pre><code>public static EFloat FromEInteger(EInteger bigint)
</code></pre>

<p>Converts an arbitrary-precision integer to the same value as a binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigint</code> - An arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>FromSingle</h3>

<pre><code>public static EFloat FromSingle(float flt)
</code></pre>

<p>Creates a binary float from a 32-bit floating-point number. This method
 computes the exact value of the floating point number, not an
 approximation, as is often the case by converting the floating point
 number to a string first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>flt</code> - A 32-bit floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as <code>flt</code>.</li>
</ul>

<h3>FromString</h3>

<pre><code>public static EFloat FromString(String str, int offset, int length, EContext ctx)
</code></pre>

<p>Creates a binary float from a text string that represents a number. Note
 that if the string contains a negative exponent, the resulting value
 might not be exact, in which case the resulting binary float will be
 an approximation of this decimal number&#39;s value. <p>The format of the
 string generally consists of:</p> <ul> <li>An optional plus sign (&quot;+&quot;
 , U+002B) or minus sign (&quot;-&quot;, U+002D) (if &#39;-&#39; , the value is
 negative.)</li> <li>One or more digits, with a single optional
 decimal point after the first digit and before the last digit.</li>
 <li>Optionally, &quot;E+&quot;/&quot;e+&quot; (positive exponent) or &quot;E-&quot;/&quot;e-&quot; (negative
 exponent) plus one or more digits specifying the exponent.</li></ul>
 <p>The string can also be &quot;-INF&quot;, &quot;-Infinity&quot;, &quot;Infinity&quot;, &quot;INF&quot;,
 quiet NaN (&quot;NaN&quot;) followed by any number of digits, or signaling NaN
 (&quot;sNaN&quot;) followed by any number of digits, all in any combination of
 upper and lower case.</p> <p>All characters mentioned above are the
 corresponding characters in the Basic Latin range. In particular, the
 digits must be the basic digits 0 to 9 (U + 0030 to U + 0039). The string
 is not allowed to contain white space characters, including
 spaces.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string.</p></li>
<li><p><code>offset</code> - A zero-based index showing where the desired portion of <code>str</code> begins.</p></li>
<li><p><code>length</code> - The length, in code units, of the desired portion of <code>str</code> (but not more than <code>str</code> &#39;s length).</p></li>
<li><p><code>ctx</code> - An EContext object specifying the precision, rounding, and
exponent range (in bits) to apply to the parsed number. Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The parsed number, converted to arbitrary-precision binary float.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>IllegalArgumentException</code> - Either <code>offset</code> or <code>length</code> is
less than 0 or greater than <code>str</code> &#39;s length, or <code>str</code> &#39; s
length minus <code>offset</code> is less than <code>length</code>.</p></li>
</ul>

<h3>FromString</h3>

<pre><code>public static EFloat FromString(String str)
</code></pre>

<p>Not documented yet.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>str</code> - The parameter <code>str</code> is not documented yet.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An EFloat object.</li>
</ul>

<h3>FromString</h3>

<pre><code>public static EFloat FromString(String str, EContext ctx)
</code></pre>

<p>Creates a binary float from a text string that represents a number. For more
 information, see the FromString(String, int, int, EContext) method.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string.</p></li>
<li><p><code>ctx</code> - An EContext object specifying the precision, rounding, and
exponent range to apply to the parsed number. Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The parsed number, converted to arbitrary-precision binary float.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>NullPointerException</code> - The parameter <code>str</code> is null.</li>
</ul>

<h3>FromString</h3>

<pre><code>public static EFloat FromString(String str, int offset, int length)
</code></pre>

<p>Creates a binary float from a text string that represents a number. For more
 information, see the <code>FromString(String, int, int, EContext)</code>
 method.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string.</p></li>
<li><p><code>offset</code> - A zero-based index showing where the desired portion of <code>str</code> begins.</p></li>
<li><p><code>length</code> - The length, in code units, of the desired portion of <code>str</code> (but not more than <code>str</code> &#39;s length).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>IllegalArgumentException</code> - Either <code>offset</code> or <code>length</code> is
less than 0 or greater than <code>str</code> &#39;s length, or <code>str</code> &#39; s
length minus <code>offset</code> is less than <code>length</code>.</p></li>
</ul>

<h3>Max</h3>

<pre><code>public static EFloat Max(EFloat first, EFloat second, EContext ctx)
</code></pre>

<p>Gets the greater value between two binary floats.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The larger value of the two numbers.</li>
</ul>

<h3>Max</h3>

<pre><code>public static EFloat Max(EFloat first, EFloat second)
</code></pre>

<p>Gets the greater value between two binary floats.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - An arbitrary-precision binary float.</p></li>
<li><p><code>second</code> - Another arbitrary-precision binary float.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The larger value of the two numbers.</li>
</ul>

<h3>MaxMagnitude</h3>

<pre><code>public static EFloat MaxMagnitude(EFloat first, EFloat second, EContext ctx)
</code></pre>

<p>Gets the greater value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Max.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>MaxMagnitude</h3>

<pre><code>public static EFloat MaxMagnitude(EFloat first, EFloat second)
</code></pre>

<p>Gets the greater value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Max.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>Min</h3>

<pre><code>public static EFloat Min(EFloat first, EFloat second, EContext ctx)
</code></pre>

<p>Gets the lesser value between two binary floats.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The smaller value of the two numbers.</li>
</ul>

<h3>Min</h3>

<pre><code>public static EFloat Min(EFloat first, EFloat second)
</code></pre>

<p>Gets the lesser value between two binary floats.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The smaller value of the two numbers.</li>
</ul>

<h3>MinMagnitude</h3>

<pre><code>public static EFloat MinMagnitude(EFloat first, EFloat second, EContext ctx)
</code></pre>

<p>Gets the lesser value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Min.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>MinMagnitude</h3>

<pre><code>public static EFloat MinMagnitude(EFloat first, EFloat second)
</code></pre>

<p>Gets the lesser value between two values, ignoring their signs. If the
 absolute values are equal, has the same effect as Min.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first value to compare.</p></li>
<li><p><code>second</code> - The second value to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>PI</h3>

<pre><code>public static EFloat PI(EContext ctx)
</code></pre>

<p>Finds the constant &#x3c0;, the circumference of a circle divided by its
 diameter.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as &#x3c0; can never be represented exactly.</i>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The constant π rounded to the given precision. Signals FlagInvalid
and returns not-a-number (NaN) if the parameter <code>ctx</code> is null
or the precision is unlimited (the context&#39;s Precision property is
0).</li>
</ul>

<h3>Abs</h3>

<pre><code>public EFloat Abs()
</code></pre>

<p>Finds the absolute value of this object (if it&#x27;s negative, it becomes
 positive).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float. Returns signaling NaN if this
value is signaling NaN.</li>
</ul>

<h3>Abs</h3>

<pre><code>public EFloat Abs(EContext context)
</code></pre>

<p>Finds the absolute value of this object (if it&#x27;s negative, it becomes
 positive).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>context</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The absolute value of this object. Signals FlagInvalid and returns
quiet NaN if this value is signaling NaN.</li>
</ul>

<h3>Add</h3>

<pre><code>public EFloat Add(EFloat otherValue)
</code></pre>

<p>Adds this object and another binary float and returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - An arbitrary-precision binary float.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The sum of the two objects.</li>
</ul>

<h3>Add</h3>

<pre><code>public EFloat Add(EFloat otherValue, EContext ctx)
</code></pre>

<p>Finds the sum of this object and another object. The result&#x27;s exponent
 is set to the lower of the exponents of the two operands.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - The number to add to.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The sum of thisValue and the other object.</li>
</ul>

<h3>compareTo</h3>

<pre><code>public int compareTo(EFloat other)
</code></pre>

<p>Compares the mathematical values of this object and another object,
 accepting NaN values. <p>This method is not consistent with the
 Equals method because two different numbers with the same
 mathematical value, but different exponents, will compare as
 equal.</p> <p>In this method, negative zero and positive zero are
 considered equal.</p> <p>If this object or the other object is a
 quiet NaN or signaling NaN, this method will not trigger an error.
 Instead, NaN will compare greater than any other number, including
 infinity. Two different NaN values will be considered equal.</p></p>

<p><strong>Specified by:</strong></p>

<ul>
<li><code>compareTo</code>&nbsp;in interface&nbsp;<code>Comparable&lt;EFloat&gt;</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary float.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Less than 0 if this object&#39;s value is less than the other value, or
greater than 0 if this object&#39;s value is greater than the other value
or if <code>other</code> is null, or 0 if both values are equal.</li>
</ul>

<h3>CompareToSignal</h3>

<pre><code>public EFloat CompareToSignal(EFloat other, EContext ctx)
</code></pre>

<p>Compares the mathematical values of this object and another object, treating
 quiet NaN as signaling. <p>In this method, negative zero and positive
 zero are considered equal.</p> <p>If this object or the other object
 is a quiet NaN or signaling NaN, this method will return a quiet NaN
 and will signal a FlagInvalid flag.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>other</code> - An arbitrary-precision binary float.</p></li>
<li><p><code>ctx</code> - An arithmetic context. The precision, rounding, and exponent
range are ignored. If <code>HasFlags</code> of the context is true, will
store the flags resulting from the operation (the flags are in
addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Quiet NaN if this object or the other object is NaN, or 0 if both
objects have the same value, or -1 if this object is less than the
other value, or 1 if this object is greater.</li>
</ul>

<h3>CompareToTotal</h3>

<pre><code>public int CompareToTotal(EFloat other, EContext ctx)
</code></pre>

<p>Compares the values of this object and another object, imposing a total
 ordering on all possible values. In this method: <ul> <li>For objects
 with the same value, the one with the higher exponent has a greater
 &quot;absolute value&quot;.</li> <li>Negative zero is less than positive
 zero.</li> <li>Quiet NaN has a higher &quot;absolute value&quot; than signaling
 NaN. If both objects are quiet NaN or both are signaling NaN, the one
 with the higher diagnostic information has a greater &quot;absolute
 value&quot;.</li> <li>NaN has a higher &quot;absolute value&quot; than
 infinity.</li> <li>Infinity has a higher &quot;absolute value&quot; than any
 finite number.</li> <li>Negative numbers are less than positive
 numbers.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>other</code> - An arbitrary-precision binary float to compare with this one.</p></li>
<li><p><code>ctx</code> - An arithmetic context. Flags will be set in this context only if
<code>HasFlags</code> and <code>IsSimplified</code> of the context are true and
only if an operand needed to be rounded before carrying out the
operation. Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 0 if both objects have the same value, or -1 if this
object is less than the other value, or 1 if this object is greater.
Does not signal flags if either value is signaling NaN.</li>
</ul>

<h3>CompareToTotal</h3>

<pre><code>public int CompareToTotal(EFloat other)
</code></pre>

<p>Compares the values of this object and another object, imposing a total
 ordering on all possible values. In this method: <ul> <li>For objects
 with the same value, the one with the higher exponent has a greater
 &quot;absolute value&quot;.</li> <li>Negative zero is less than positive
 zero.</li> <li>Quiet NaN has a higher &quot;absolute value&quot; than signaling
 NaN. If both objects are quiet NaN or both are signaling NaN, the one
 with the higher diagnostic information has a greater &quot;absolute
 value&quot;.</li> <li>NaN has a higher &quot;absolute value&quot; than
 infinity.</li> <li>Infinity has a higher &quot;absolute value&quot; than any
 finite number.</li> <li>Negative numbers are less than positive
 numbers.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary float to compare with this one.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 0 if both objects have the same value, or -1 if this
object is less than the other value, or 1 if this object is greater.</li>
</ul>

<h3>CompareToTotalMagnitude</h3>

<pre><code>public int CompareToTotalMagnitude(EFloat other)
</code></pre>

<p>Compares the absolute values of this object and another object, imposing a
 total ordering on all possible values (ignoring their signs). In this
 method: <ul> <li>For objects with the same value, the one with the
 higher exponent has a greater &quot;absolute value&quot;.</li> <li>Negative
 zero and positive zero are considered equal.</li> <li>Quiet NaN has a
 higher &quot;absolute value&quot; than signaling NaN. If both objects are quiet
 NaN or both are signaling NaN, the one with the higher diagnostic
 information has a greater &quot;absolute value&quot;.</li> <li>NaN has a higher
 &quot;absolute value&quot; than infinity.</li> <li>Infinity has a higher
 &quot;absolute value&quot; than any finite number.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary float to compare with this one.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 0 if both objects have the same value, or -1 if this
object is less than the other value, or 1 if this object is greater.</li>
</ul>

<h3>CompareToWithContext</h3>

<pre><code>public EFloat CompareToWithContext(EFloat other, EContext ctx)
</code></pre>

<p>Compares the mathematical values of this object and another object. <p>In
 this method, negative zero and positive zero are considered
 equal.</p> <p>If this object or the other object is a quiet NaN or
 signaling NaN, this method returns a quiet NaN, and will signal a
 FlagInvalid flag if either is a signaling NaN.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>other</code> - An arbitrary-precision binary float.</p></li>
<li><p><code>ctx</code> - An arithmetic context. The precision, rounding, and exponent
range are ignored. If <code>HasFlags</code> of the context is true, will
store the flags resulting from the operation (the flags are in
addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Quiet NaN if this object or the other object is NaN, or 0 if both
objects have the same value, or -1 if this object is less than the
other value, or 1 if this object is greater.</li>
</ul>

<h3>CopySign</h3>

<pre><code>public EFloat CopySign(EFloat other)
</code></pre>

<p>Returns a number with the same value as this one, but copying the sign
 (positive or negative) of another number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - A number whose sign will be copied.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>NullPointerException</code> - The parameter <code>other</code> is null.</li>
</ul>

<h3>Divide</h3>

<pre><code>public EFloat Divide(EFloat divisor)
</code></pre>

<p>Divides this object by another binary float and returns the result. When
 possible, the result will be exact.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - An arbitrary-precision binary float to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two numbers. Returns infinity if the divisor is
0 and the dividend is nonzero. Returns not-a-number (NaN) if the
divisor and the dividend are 0. Returns NaN if the result can&#39;t be
exact because it would have a nonterminating binary expansion.</li>
</ul>

<h3>Divide</h3>

<pre><code>public EFloat Divide(EFloat divisor, EContext ctx)
</code></pre>

<p>Divides this arbitrary-precision binary float by another arbitrary-precision
 binary float. The preferred exponent for the result is this
 object&#x27;s exponent minus the divisor&#x27;s exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary float to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor and
the dividend are 0; or, either <code>ctx</code> is null or <code>ctx</code> &#39;s
precision is 0, and the result would have a nonterminating binary
expansion; or, the rounding mode is ERounding.None and the result is
not exact.</li>
</ul>

<h3>DivideAndRemainderNaturalScale</h3>

<pre><code>@Deprecated public EFloat[] DivideAndRemainderNaturalScale(EFloat divisor)
</code></pre>

<p>Deprecated.&nbsp;Renamed to DivRemNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - An arbitrary-precision binary float to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>DivideAndRemainderNaturalScale</h3>

<pre><code>@Deprecated public EFloat[] DivideAndRemainderNaturalScale(EFloat divisor, EContext ctx)
</code></pre>

<p>Deprecated.&nbsp;Renamed to DivRemNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary float to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the result. This context will be used only in
the division portion of the remainder calculation; as a result, it&#39;s
possible for the remainder to have a higher precision than given in
this context. Flags will be set on the given context only if the
context&#39;s <code>HasFlags</code> is true and the integer part of the
division result doesn&#39;t fit the precision and exponent range without
rounding. Can be null, in which the precision is unlimited and no
additional rounding, other than the rounding down to an integer after
division, is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>DivideToExponent</h3>

<pre><code>public EFloat DivideToExponent(EFloat divisor, long desiredExponentSmall, EContext ctx)
</code></pre>

<p>Divides two arbitrary-precision binary floats, and gives a particular
 exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary float to divide by.</p></li>
<li><p><code>desiredExponentSmall</code> - The desired exponent. A negative number places
the cutoff point to the right of the usual radix point (so a negative
number means the number of binary digit places to round to). A
positive number places the cutoff point to the left of the usual
radix point.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the rounding mode to use
if the result must be scaled down to have the same exponent as this
value. If the precision given in the context is other than 0, calls
the Quantize method with both arguments equal to the result of the
operation (and can signal FlagInvalid and return NaN if the result
doesn&#39;t fit the given precision). If <code>HasFlags</code> of the context
is true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor and
the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the context defines an exponent range and the desired
exponent is outside that range. Signals FlagInvalid and returns
not-a-number (NaN) if the rounding mode is ERounding.None and the
result is not exact.</li>
</ul>

<h3>DivideToExponent</h3>

<pre><code>public EFloat DivideToExponent(EFloat divisor, long desiredExponentSmall, ERounding rounding)
</code></pre>

<p>Divides two arbitrary-precision binary floats, and gives a particular
 exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary float to divide by.</p></li>
<li><p><code>desiredExponentSmall</code> - The desired exponent. A negative number places
the cutoff point to the right of the usual radix point (so a negative
number means the number of binary digit places to round to). A
positive number places the cutoff point to the left of the usual
radix point.</p></li>
<li><p><code>rounding</code> - The rounding mode to use if the result must be scaled down
to have the same exponent as this value.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor and
the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the rounding mode is ERounding.None and the result is not
exact.</li>
</ul>

<h3>DivideToExponent</h3>

<pre><code>public EFloat DivideToExponent(EFloat divisor, EInteger exponent, EContext ctx)
</code></pre>

<p>Divides two arbitrary-precision binary floats, and gives a particular
 exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary float to divide by.</p></li>
<li><p><code>exponent</code> - The desired exponent. A negative number places the cutoff
point to the right of the usual radix point (so a negative number
means the number of binary digit places to round to). A positive
number places the cutoff point to the left of the usual radix point.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the rounding mode to use
if the result must be scaled down to have the same exponent as this
value. If the precision given in the context is other than 0, calls
the Quantize method with both arguments equal to the result of the
operation (and can signal FlagInvalid and return NaN if the result
doesn&#39;t fit the given precision). If <code>HasFlags</code> of the context
is true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor and
the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the context defines an exponent range and the desired
exponent is outside that range. Signals FlagInvalid and returns
not-a-number (NaN) if the rounding mode is ERounding.None and the
result is not exact.</li>
</ul>

<h3>DivideToExponent</h3>

<pre><code>public EFloat DivideToExponent(EFloat divisor, EInteger desiredExponent, ERounding rounding)
</code></pre>

<p>Divides two arbitrary-precision binary floats, and gives a particular
 exponent to the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary float to divide by.</p></li>
<li><p><code>desiredExponent</code> - The desired exponent. A negative number places the
cutoff point to the right of the usual radix point (so a negative
number means the number of binary digit places to round to). A
positive number places the cutoff point to the left of the usual
radix point.</p></li>
<li><p><code>rounding</code> - The rounding mode to use if the result must be scaled down
to have the same exponent as this value.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Returns not-a-number (NaN) if the divisor and the dividend are 0.
Returns NaN if the rounding mode is ERounding.None and the result is
not exact.</li>
</ul>

<h3>DivideToIntegerNaturalScale</h3>

<pre><code>public EFloat DivideToIntegerNaturalScale(EFloat divisor)
</code></pre>

<p>Divides two arbitrary-precision binary floats, and returns the integer part
 of the result, rounded down, with the preferred exponent set to this
 value&#x27;s exponent minus the divisor&#x27;s exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - An arbitrary-precision binary float to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer part of the quotient of the two objects. Signals
FlagDivideByZero and returns infinity if the divisor is 0 and the
dividend is nonzero. Signals FlagInvalid and returns not-a-number
(NaN) if the divisor and the dividend are 0.</li>
</ul>

<h3>DivideToIntegerNaturalScale</h3>

<pre><code>public EFloat DivideToIntegerNaturalScale(EFloat divisor, EContext ctx)
</code></pre>

<p>Divides this object by another object, and returns the integer part of the
 result (which is initially rounded down), with the preferred exponent
 set to this value&#x27;s exponent minus the divisor&#x27;s exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the integer part of the result. Flags will be
set on the given context only if the context&#39;s <code>HasFlags</code> is
true and the integer part of the result doesn&#39;t fit the precision and
exponent range without rounding. Can be null, in which the precision
is unlimited and no additional rounding, other than the rounding down
to an integer after division, is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer part of the quotient of the two objects. Signals
FlagInvalid and returns not-a-number (NaN) if the return value would
overflow the exponent range. Signals FlagDivideByZero and returns
infinity if the divisor is 0 and the dividend is nonzero. Signals
FlagInvalid and returns not-a-number (NaN) if the divisor and the
dividend are 0. Signals FlagInvalid and returns not-a-number (NaN) if
the rounding mode is ERounding.None and the result is not exact.</li>
</ul>

<h3>DivideToIntegerZeroScale</h3>

<pre><code>public EFloat DivideToIntegerZeroScale(EFloat divisor, EContext ctx)
</code></pre>

<p>Divides this object by another object, and returns the integer part of the
 result, with the exponent set to 0.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision. The
rounding and exponent range settings of this context are ignored. If
<code>HasFlags</code> of the context is true, will also store the flags
resulting from the operation (the flags are in addition to the
pre-existing flags). Can be null, in which case the precision is
unlimited.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer part of the quotient of the two objects. The exponent
will be set to 0. Signals FlagDivideByZero and returns infinity if
the divisor is 0 and the dividend is nonzero. Signals FlagInvalid and
returns not-a-number (NaN) if the divisor and the dividend are 0, or
if the result doesn&#39;t fit the given precision.</li>
</ul>

<h3>DivideToSameExponent</h3>

<pre><code>public EFloat DivideToSameExponent(EFloat divisor, ERounding rounding)
</code></pre>

<p>Divides this object by another binary float and returns a result with the
 same exponent as this object (the dividend).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>rounding</code> - The rounding mode to use if the result must be scaled down
to have the same exponent as this value.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two numbers. Signals FlagDivideByZero and
returns infinity if the divisor is 0 and the dividend is nonzero.
Signals FlagInvalid and returns not-a-number (NaN) if the divisor and
the dividend are 0. Signals FlagInvalid and returns not-a-number
(NaN) if the rounding mode is ERounding.None and the result is not
exact.</li>
</ul>

<h3>DivRemNaturalScale</h3>

<pre><code>public EFloat[] DivRemNaturalScale(EFloat divisor)
</code></pre>

<p>Calculates the quotient and remainder using the DivideToIntegerNaturalScale
 and the formula in RemainderNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - An arbitrary-precision binary float to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>DivRemNaturalScale</h3>

<pre><code>public EFloat[] DivRemNaturalScale(EFloat divisor, EContext ctx)
</code></pre>

<p>Calculates the quotient and remainder using the DivideToIntegerNaturalScale
 and the formula in RemainderNaturalScale.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - An arbitrary-precision binary float to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the result. This context will be used only in
the division portion of the remainder calculation; as a result, it&#39;s
possible for the remainder to have a higher precision than given in
this context. Flags will be set on the given context only if the
context&#39;s <code>HasFlags</code> is true and the integer part of the
division result doesn&#39;t fit the precision and exponent range without
rounding. Can be null, in which the precision is unlimited and no
additional rounding, other than the rounding down to an integer after
division, is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 2 element array consisting of the quotient and remainder in that
order.</li>
</ul>

<h3>equals</h3>

<pre><code>public boolean equals(EFloat other)
</code></pre>

<p>Determines whether this object&#x27;s mantissa (significand), exponent, and
 properties are equal to those of another object. Not-a-number values
 are considered equal if the rest of their properties are equal.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - An arbitrary-precision binary float.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s mantissa (significand) and exponent
are equal to those of another object; otherwise, <code>false</code>.</li>
</ul>

<h3>equals</h3>

<pre><code>public boolean equals(Object obj)
</code></pre>

<p>Determines whether this object&#x27;s mantissa (significand), exponent, and
 properties are equal to those of another object and that other object
 is an arbitrary-precision binary float. Not-a-number values are
 considered equal if the rest of their properties are equal.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>equals</code>&nbsp;in class&nbsp;<code>Object</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>obj</code> - An arbitrary object.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the objects are equal; otherwise, <code>false</code>.</li>
</ul>

<h3>EqualsInternal</h3>

<pre><code>public boolean EqualsInternal(EFloat otherValue)
</code></pre>

<p>Determines whether this object&#x27;s mantissa (significand) and exponent
 are equal to those of another object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - An arbitrary-precision binary float.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s mantissa (significand) and exponent
are equal to those of another object; otherwise, <code>false</code>.</li>
</ul>

<h3>Exp</h3>

<pre><code>public EFloat Exp(EContext ctx)
</code></pre>

<p>Finds e (the base of natural logarithms) raised to the power of this
 object&#x27;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the exponential function&#39;s results are generally
not exact.</i> (Unlike in the General Binary Arithmetic
Specification, any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Exponential of this object. If this object&#39;s value is 1, returns an
approximation to &quot; e&quot; within the given precision. Signals FlagInvalid
and returns not-a-number (NaN) if the parameter <code>ctx</code> is null
or the precision is unlimited (the context&#39;s Precision property is
0).</li>
</ul>

<h3>hashCode</h3>

<pre><code>public int hashCode()
</code></pre>

<p>Calculates this object&#x27;s hash code. No application or process IDs are
 used in the hash code calculation.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>hashCode</code>&nbsp;in class&nbsp;<code>Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39;s hash code.</li>
</ul>

<h3>IsInfinity</h3>

<pre><code>public boolean IsInfinity()
</code></pre>

<p>Gets a value indicating whether this object is positive or negative
 infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is positive or negative infinity;
otherwise, <code>false</code>.</li>
</ul>

<h3>IsNaN</h3>

<pre><code>public boolean IsNaN()
</code></pre>

<p>Gets a value indicating whether this object is not a number (NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is not a number (NaN); otherwise, <code>false</code>.</li>
</ul>

<h3>IsNegativeInfinity</h3>

<pre><code>public boolean IsNegativeInfinity()
</code></pre>

<p>Returns whether this object is negative infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is negative infinity; otherwise, <code>false</code>.</li>
</ul>

<h3>IsPositiveInfinity</h3>

<pre><code>public boolean IsPositiveInfinity()
</code></pre>

<p>Returns whether this object is positive infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is positive infinity; otherwise, <code>false</code>.</li>
</ul>

<h3>IsQuietNaN</h3>

<pre><code>public boolean IsQuietNaN()
</code></pre>

<p>Gets a value indicating whether this object is a quiet not-a-number value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is a quiet not-a-number value;
otherwise, <code>false</code>.</li>
</ul>

<h3>IsSignalingNaN</h3>

<pre><code>public boolean IsSignalingNaN()
</code></pre>

<p>Gets a value indicating whether this object is a signaling not-a-number
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is a signaling not-a-number value;
otherwise, <code>false</code>.</li>
</ul>

<h3>Log</h3>

<pre><code>public EFloat Log(EContext ctx)
</code></pre>

<p>Finds the natural logarithm of this object, that is, the power (exponent)
 that e (the base of natural logarithms) must be raised to in order to
 equal this object&#x27;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the ln function&#39;s results are generally not
exact.</i> (Unlike in the General Binary Arithmetic Specification,
any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Ln(this object). Signals the flag FlagInvalid and returns NaN if
this object is less than 0 (the result would be a complex number with
a real part equal to Ln of this object&#39;s absolute value and an
imaginary part equal to pi, but the return value is still NaN.).
Signals FlagInvalid and returns not-a-number (NaN) if the parameter
<code>ctx</code> is null or the precision is unlimited (the context&#39;s
Precision property is 0). Signals no flags and returns negative
infinity if this object&#39;s value is 0.</li>
</ul>

<h3>Log10</h3>

<pre><code>public EFloat Log10(EContext ctx)
</code></pre>

<p>Finds the base-10 logarithm of this object, that is, the power (exponent)
 that the number 10 must be raised to in order to equal this
 object&#x27;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the ln function&#39;s results are generally not
exact.</i> (Unlike in the General Binary Arithmetic Specification,
any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Ln(this object)/Ln(10). Signals the flag FlagInvalid and returns
not-a-number (NaN) if this object is less than 0. Signals FlagInvalid
and returns not-a-number (NaN) if the parameter <code>ctx</code> is null
or the precision is unlimited (the context&#39;s Precision property is
0).</li>
</ul>

<h3>MovePointLeft</h3>

<pre><code>public EFloat MovePointLeft(int places)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>places</code> - The number of binary digit places to move the radix point to
the left. If this number is negative, instead moves the radix point
to the right by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointLeft</h3>

<pre><code>public EFloat MovePointLeft(int places, EContext ctx)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>places</code> - The number of binary digit places to move the radix point to
the left. If this number is negative, instead moves the radix point
to the right by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointLeft</h3>

<pre><code>public EFloat MovePointLeft(EInteger bigPlaces)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the left. If this number is negative, instead moves the radix
point to the right by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>MovePointLeft</h3>

<pre><code>public EFloat MovePointLeft(EInteger bigPlaces, EContext ctx)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the left.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the left. If this number is negative, instead moves the radix
point to the right by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is decreased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre><code>public EFloat MovePointRight(int places)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>places</code> - The number of binary digit places to move the radix point to
the right. If this number is negative, instead moves the radix point
to the left by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre><code>public EFloat MovePointRight(int places, EContext ctx)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>places</code> - The number of binary digit places to move the radix point to
the right. If this number is negative, instead moves the radix point
to the left by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>places</code>, but not to
more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre><code>public EFloat MovePointRight(EInteger bigPlaces)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the right. If this number is negative, instead moves the radix
point to the left by this number&#39;s absolute value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>MovePointRight</h3>

<pre><code>public EFloat MovePointRight(EInteger bigPlaces, EContext ctx)
</code></pre>

<p>Returns a number similar to this number but with the radix point moved to
 the right.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bigPlaces</code> - The number of binary digit places to move the radix point
to the right. If this number is negative, instead moves the radix
point to the left by this number&#39;s absolute value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>bigPlaces</code>, but not
to more than 0.</li>
</ul>

<h3>Multiply</h3>

<pre><code>public EFloat Multiply(EFloat otherValue)
</code></pre>

<p>Multiplies two binary floats. The resulting exponent will be the sum of the
 exponents of the two binary floats.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - Another binary float.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two binary floats.</li>
</ul>

<h3>Multiply</h3>

<pre><code>public EFloat Multiply(EFloat op, EContext ctx)
</code></pre>

<p>Multiplies two binary floats. The resulting scale will be the sum of the
 scales of the two binary floats. The result&#x27;s sign is positive
 if both operands have the same sign, and negative if they have
 different signs.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>op</code> - Another binary float.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two binary floats.</li>
</ul>

<h3>MultiplyAndAdd</h3>

<pre><code>public EFloat MultiplyAndAdd(EFloat multiplicand, EFloat augend)
</code></pre>

<p>Multiplies by one binary float, and then adds another binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>multiplicand</code> - The value to multiply.</p></li>
<li><p><code>augend</code> - The value to add.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result this * <code>multiplicand</code> + <code>augend</code>.</li>
</ul>

<h3>MultiplyAndAdd</h3>

<pre><code>public EFloat MultiplyAndAdd(EFloat op, EFloat augend, EContext ctx)
</code></pre>

<p>Multiplies by one value, and then adds another value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>op</code> - The value to multiply.</p></li>
<li><p><code>augend</code> - The value to add.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed. If
the precision doesn&#39;t indicate a simplified arithmetic, rounding and
precision/exponent adjustment is done only once, namely, after
multiplying and adding.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result thisValue * multiplicand + augend.</li>
</ul>

<h3>MultiplyAndSubtract</h3>

<pre><code>public EFloat MultiplyAndSubtract(EFloat op, EFloat subtrahend, EContext ctx)
</code></pre>

<p>Multiplies by one value, and then subtracts another value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>op</code> - The value to multiply.</p></li>
<li><p><code>subtrahend</code> - The value to subtract.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed. If
the precision doesn&#39;t indicate a simplified arithmetic, rounding and
precision/exponent adjustment is done only once, namely, after
multiplying and subtracting.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result thisValue * multiplicand - subtrahend.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>NullPointerException</code> - The parameter <code>op</code> or <code>subtrahend</code> is null.</li>
</ul>

<h3>Negate</h3>

<pre><code>public EFloat Negate()
</code></pre>

<p>Gets an object with the same value as this one, but with the sign reversed.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float. If this value is positive zero,
returns negative zero. Returns signaling NaN if this value is
signaling NaN.</li>
</ul>

<h3>Negate</h3>

<pre><code>public EFloat Negate(EContext context)
</code></pre>

<p>Returns a binary float with the same value as this object but with the sign
 reversed.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>context</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float. If this value is positive zero,
returns positive zero. Signals FlagInvalid and returns quiet NaN if
this value is signaling NaN.</li>
</ul>

<h3>NextMinus</h3>

<pre><code>public EFloat NextMinus(EContext ctx)
</code></pre>

<p>Finds the largest value that&#x27;s smaller than the given value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context object to control the precision and
exponent range of the result. The rounding mode from this context is
ignored. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Returns the largest value that&#39;s less than the given value. Returns
negative infinity if the result is negative infinity. Signals
FlagInvalid and returns not-a-number (NaN) if the parameter <code>ctx</code> is null, the precision is 0, or <code>ctx</code> has an unlimited
exponent range.</li>
</ul>

<h3>NextPlus</h3>

<pre><code>public EFloat NextPlus(EContext ctx)
</code></pre>

<p>Finds the smallest value that&#x27;s greater than the given value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context object to control the precision and
exponent range of the result. The rounding mode from this context is
ignored. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Returns the smallest value that&#39;s greater than the given
value.Signals FlagInvalid and returns not-a-number (NaN) if the
parameter <code>ctx</code> is null, the precision is 0, or <code>ctx</code> has
an unlimited exponent range.</li>
</ul>

<h3>NextToward</h3>

<pre><code>public EFloat NextToward(EFloat otherValue, EContext ctx)
</code></pre>

<p>Finds the next value that is closer to the other object&#x27;s value than
 this object&#x27;s value. Returns a copy of this value with the same
 sign as the other value if both values are equal.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - An arbitrary-precision binary float that the return value
will approach.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision and
exponent range of the result. The rounding mode from this context is
ignored. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Returns the next value that is closer to the other object&#39; s value
than this object&#39;s value. Signals FlagInvalid and returns NaN if the
parameter <code>ctx</code> is null, the precision is 0, or <code>ctx</code> has
an unlimited exponent range.</li>
</ul>

<h3>Plus</h3>

<pre><code>public EFloat Plus(EContext ctx)
</code></pre>

<p>Rounds this object&#x27;s value to a given precision, using the given
 rounding mode and range of exponent, and also converts negative zero
 to positive zero.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - A context for controlling the precision, rounding mode, and
exponent range. Can be null, in which case the precision is unlimited
and rounding isn&#39;t needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest value to this object&#39;s value, rounded to the specified
precision. Returns the same value as this object if <code>ctx</code> is
null or the precision and exponent range are unlimited.</li>
</ul>

<h3>Pow</h3>

<pre><code>public EFloat Pow(EFloat exponent, EContext ctx)
</code></pre>

<p>Raises this object&#x27;s value to the given exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - An arbitrary-precision binary float expressing the exponent
to raise this object&#39;s value to.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This^exponent. Signals the flag FlagInvalid and returns NaN if this
object and exponent are both 0; or if this value is less than 0 and
the exponent either has a fractional part or is infinity. Signals
FlagInvalid and returns not-a-number (NaN) if the parameter <code>ctx</code> is null or the precision is unlimited (the context&#39;s Precision
property is 0), and the exponent has a fractional part.</li>
</ul>

<h3>Pow</h3>

<pre><code>public EFloat Pow(int exponentSmall, EContext ctx)
</code></pre>

<p>Raises this object&#x27;s value to the given exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponentSmall</code> - The exponent to raise this object&#39;s value to.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This^exponent. Signals the flag FlagInvalid and returns NaN if this
object and exponent are both 0.</li>
</ul>

<h3>Pow</h3>

<pre><code>public EFloat Pow(int exponentSmall)
</code></pre>

<p>Raises this object&#x27;s value to the given exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>exponentSmall</code> - The exponent to raise this object&#39;s value to.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This^exponent. Returns not-a-number (NaN) if this object and
exponent are both 0.</li>
</ul>

<h3>Precision</h3>

<pre><code>public EInteger Precision()
</code></pre>

<p>Finds the number of digits in this number&#39;s mantissa (significand). Returns
 1 if this value is 0, and 0 if this value is infinity or not-a-number
 (NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<h3>Quantize</h3>

<pre><code>public EFloat Quantize(EInteger desiredExponent, EContext ctx)
</code></pre>

<p>Returns a binary float with the same value but a new exponent. <p>Note that
 this is not always the same as rounding to a given number of binary
 digit places, since it can fail if the difference between this
 value&#39;s exponent and the desired exponent is too big, depending on
 the maximum precision. If rounding to a number of binary digit places
 is desired, it&#39;s better to use the RoundToExponent and
 RoundToIntegral methods instead.</p> <p><b>Remark:</b> This method
 can be used to implement fixed-point binary arithmetic, in which each
 binary float has a fixed number of digits after the radix point. The
 following code example returns a fixed-point number with up to 20
 digits before and exactly 5 digits after the radix point:</p> <code>
  // After performing arithmetic operations, adjust  // the number to 5
  // digits after the radix point number = number.Quantize(
 EInteger.FromInt32(-5),  // five digits after the radix point
 EContext.ForPrecision(25)  // 25-digit precision); </code> <p>A
 fixed-point binary arithmetic in which no digits come after the radix
 point (a desired exponent of 0) is considered an &quot;integer
 arithmetic&quot;.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>desiredExponent</code> - The desired exponent for the result. The exponent is
the number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags). Can be null, in which case the default
rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as this object but with the
exponent changed. Signals FlagInvalid and returns not-a-number (NaN)
if this object is infinity, if the rounded result can&#39;t fit the given
precision, or if the context defines an exponent range and the given
exponent is outside that range.</li>
</ul>

<h3>Quantize</h3>

<pre><code>public EFloat Quantize(int desiredExponentInt, EContext ctx)
</code></pre>

<p>Returns a binary float with the same value but a new exponent. <p>Note that
 this is not always the same as rounding to a given number of binary
 digit places, since it can fail if the difference between this
 value&#39;s exponent and the desired exponent is too big, depending on
 the maximum precision. If rounding to a number of binary digit places
 is desired, it&#39;s better to use the RoundToExponent and
 RoundToIntegral methods instead.</p> <p><b>Remark:</b> This method
 can be used to implement fixed-point binary arithmetic, in which each
 binary float has a fixed number of digits after the radix point. The
 following code example returns a fixed-point number with up to 20
 digits before and exactly 5 digits after the radix point:</p> <code>
  // After performing arithmetic operations, adjust  // the number to 5
 digits after the radix point number = number.Quantize(-5,  // five
 digits after the radix point EContext.ForPrecision(25)  // 25-digit
 precision); </code> <p>A fixed-point binary arithmetic in which no
 digits come after the radix point (a desired exponent of 0) is
 considered an &quot;integer arithmetic&quot;.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>desiredExponentInt</code> - The desired exponent for the result. The exponent
is the number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags). Can be null, in which case the default
rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as this object but with the
exponent changed. Signals FlagInvalid and returns not-a-number (NaN)
if this object is infinity, if the rounded result can&#39;t fit the given
precision, or if the context defines an exponent range and the given
exponent is outside that range.</li>
</ul>

<h3>Quantize</h3>

<pre><code>public EFloat Quantize(EFloat otherValue, EContext ctx)
</code></pre>

<p>Returns a binary float with the same value as this object but with the same
 exponent as another binary float. <p>Note that this is not always the
 same as rounding to a given number of binary digit places, since it
 can fail if the difference between this value&#39;s exponent and the
 desired exponent is too big, depending on the maximum precision. If
 rounding to a number of binary digit places is desired, it&#39;s better
 to use the RoundToExponent and RoundToIntegral methods instead.</p>
 <p><b>Remark:</b> This method can be used to implement fixed-point
 binary arithmetic, in which a fixed number of digits come after the
 radix point. A fixed-point binary arithmetic in which no digits come
 after the radix point (a desired exponent of 0) is considered an
 &quot;integer arithmetic&quot;.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - A binary float containing the desired exponent of the
result. The mantissa (significand) is ignored. The exponent is the
number of fractional digits in the result, expressed as a negative
number. Can also be positive, which eliminates lower-order places
from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags). Can be null, in which case the default
rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float with the same value as this object but with the
exponent changed. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding, or if
the arithmetic context defines an exponent range and the given
exponent is outside that range.</li>
</ul>

<h3>Reduce</h3>

<pre><code>public EFloat Reduce(EContext ctx)
</code></pre>

<p>Removes trailing zeros from this object&#x27;s mantissa (significand). For
 example, 1.00 becomes 1. <p>If this object&#39;s value is 0, changes the
 exponent to 0.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and rounding isn&#39;t needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This value with trailing zeros removed. Note that if the result has
a very high exponent and the context says to clamp high exponents,
there may still be some trailing zeros in the mantissa (significand).</li>
</ul>

<h3>Remainder</h3>

<pre><code>public EFloat Remainder(EFloat divisor, EContext ctx)
</code></pre>

<p>Finds the remainder that results when dividing two arbitrary-precision
 binary floats. The remainder is the value that remains when the
 absolute value of this object is divided by the absolute value of the
 other object; the remainder has the same sign (positive or negative)
 as this object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the result. This context will be used both in
the division portion and in the remainder portion of the remainder
calculation. If <code>HasFlags</code> of the context is true, will also
store the flags resulting from the operation (the flags are in
addition to the pre-existing flags). Can be null, in which case the
precision is unlimited and no additional rounding (other than the
rounding from integer division) is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The remainder of the two numbers. Signals FlagInvalid and returns
not-a-number (NaN) if the divisor is 0, or if the result doesn&#39;t fit
the given precision.</li>
</ul>

<h3>RemainderNaturalScale</h3>

<pre><code>public EFloat RemainderNaturalScale(EFloat divisor)
</code></pre>

<p>Calculates the remainder of a number by the formula <code>&quot;this&quot; - ((&quot;this&quot; /
 &quot;divisor&quot;) * &quot;divisor&quot;)</code></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>RemainderNaturalScale</h3>

<pre><code>public EFloat RemainderNaturalScale(EFloat divisor, EContext ctx)
</code></pre>

<p>Calculates the remainder of a number by the formula &quot;this&quot; - ((&quot;this&quot; /
 &quot;divisor&quot;) * &quot;divisor&quot;).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision, rounding,
and exponent range of the result. This context will be used only in
the division portion of the remainder calculation; as a result, it&#39;s
possible for the return value to have a higher precision than given
in this context. Flags will be set on the given context only if the
context&#39;s <code>HasFlags</code> is true and the integer part of the
division result doesn&#39;t fit the precision and exponent range without
rounding. Can be null, in which the precision is unlimited and no
additional rounding, other than the rounding down to an integer after
division, is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>RemainderNear</h3>

<pre><code>public EFloat RemainderNear(EFloat divisor, EContext ctx)
</code></pre>

<p>Finds the distance to the closest multiple of the given divisor, based on
 the result of dividing this object&#x27;s value by another
 object&#x27;s value. <ul> <li>If this and the other object divide
 evenly, the result is 0.</li> <li>If the remainder&#39;s absolute value
 is less than half of the divisor&#39;s absolute value, the result has the
 same sign as this object and will be the distance to the closest
 multiple.</li> <li>If the remainder&#39;s absolute value is more than
 half of the divisor&#39; s absolute value, the result has the opposite
 sign of this object and will be the distance to the closest
 multiple.</li> <li>If the remainder&#39;s absolute value is exactly half
 of the divisor&#39;s absolute value, the result has the opposite sign of
 this object if the quotient, rounded down, is odd, and has the same
 sign as this object if the quotient, rounded down, is even, and the
 result&#39;s absolute value is half of the divisor&#39;s absolute
 value.</li></ul> This function is also known as the &quot;IEEE Remainder&quot;
 function.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>divisor</code> - The number to divide by.</p></li>
<li><p><code>ctx</code> - An arithmetic context object to control the precision. The
rounding and exponent range settings of this context are ignored (the
rounding mode is always treated as HalfEven). If <code>HasFlags</code> of
the context is true, will also store the flags resulting from the
operation (the flags are in addition to the pre-existing flags). Can
be null, in which the precision is unlimited.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The distance of the closest multiple. Signals FlagInvalid and
returns not-a-number (NaN) if the divisor is 0, or either the result
of integer division (the quotient) or the remainder wouldn&#39;t fit the
given precision.</li>
</ul>

<h3>RoundToExponent</h3>

<pre><code>public EFloat RoundToExponent(EInteger exponent, EContext ctx)
</code></pre>

<p>Returns a binary float with the same value as this object but rounded to a
 new exponent if necessary.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the precision context defines an exponent
range, the new exponent must be changed to the given exponent when
rounding, and the given exponent is outside of the valid range of the
arithmetic context.</li>
</ul>

<h3>RoundToExponent</h3>

<pre><code>public EFloat RoundToExponent(int exponentSmall, EContext ctx)
</code></pre>

<p>Returns a binary float with the same value as this object but rounded to a
 new exponent if necessary.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponentSmall</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the precision context defines an exponent
range, the new exponent must be changed to the given exponent when
rounding, and the given exponent is outside of the valid range of the
arithmetic context.</li>
</ul>

<h3>RoundToExponentExact</h3>

<pre><code>public EFloat RoundToExponentExact(EInteger exponent, EContext ctx)
</code></pre>

<p>Returns a binary float with the same value as this object but rounded to the
 given exponent, and signals an inexact flag if the result would be
 inexact.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding. Signals
FlagInvalid and returns not-a-number (NaN) if the arithmetic context
defines an exponent range, the new exponent must be changed to the
given exponent when rounding, and the given exponent is outside of
the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToExponentExact</h3>

<pre><code>public EFloat RoundToExponentExact(EInteger exponent, ERounding rounding)
</code></pre>

<p>Returns a binary number with the same value as this object but rounded to
 the given exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponent</code> - An arbitrary-precision integer.</p></li>
<li><p><code>rounding</code> - An ERounding object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary number rounded to the closest value representable in the
given precision.</li>
</ul>

<h3>RoundToExponentExact</h3>

<pre><code>public EFloat RoundToExponentExact(int exponentSmall, EContext ctx)
</code></pre>

<p>Returns a binary float with the same value as this object but rounded to an
 integer, and signals an inexact flag if the result would be inexact.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>exponentSmall</code> - The minimum exponent the result can have. This is the
maximum number of fractional digits in the result, expressed as a
negative number. Can also be positive, which eliminates lower-order
places from the number. For example, -3 means round to the sixteenth
(10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3,
1000b). A value of 0 rounds the number to an integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest value representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding. Signals
FlagInvalid and returns not-a-number (NaN) if the arithmetic context
defines an exponent range, the new exponent must be changed to the
given exponent when rounding, and the given exponent is outside of
the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToIntegerExact</h3>

<pre><code>public EFloat RoundToIntegerExact(EContext ctx)
</code></pre>

<p>Returns a binary float with the same value as this object but rounded to an
 integer, and signals an inexact flag if the result would be inexact.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding. Signals
FlagInvalid and returns not-a-number (NaN) if the arithmetic context
defines an exponent range, the new exponent must be changed to 0 when
rounding, and 0 is outside of the valid range of the arithmetic
context.</li>
</ul>

<h3>RoundToIntegerNoRoundedFlag</h3>

<pre><code>public EFloat RoundToIntegerNoRoundedFlag(EContext ctx)
</code></pre>

<p>Returns a binary float with the same value as this object but rounded to an
 integer, without adding the <code>FlagInexact</code> or <code>FlagRounded</code>
 flags.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags), except that this function will never add the
<code>FlagRounded</code> and <code>FlagInexact</code> flags (the only
difference between this and RoundToExponentExact). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the precision context defines an exponent
range, the new exponent must be changed to 0 when rounding, and 0 is
outside of the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToIntegralExact</h3>

<pre><code>@Deprecated public EFloat RoundToIntegralExact(EContext ctx)
</code></pre>

<p>Deprecated.&nbsp;Renamed to RoundToIntegerExact.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. Signals FlagInvalid and returns not-a-number (NaN)
if the result can&#39;t fit the given precision without rounding. Signals
FlagInvalid and returns not-a-number (NaN) if the arithmetic context
defines an exponent range, the new exponent must be changed to 0 when
rounding, and 0 is outside of the valid range of the arithmetic
context.</li>
</ul>

<h3>RoundToIntegralNoRoundedFlag</h3>

<pre><code>@Deprecated public EFloat RoundToIntegralNoRoundedFlag(EContext ctx)
</code></pre>

<p>Deprecated.&nbsp;Renamed to RoundToIntegerNoRoundedFlag.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision and rounding of the
result. If <code>HasFlags</code> of the context is true, will also store
the flags resulting from the operation (the flags are in addition to
the pre-existing flags), except that this function will never add the
<code>FlagRounded</code> and <code>FlagInexact</code> flags (the only
difference between this and RoundToExponentExact). Can be null, in
which case the default rounding mode is HalfEven.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A binary float rounded to the closest integer representable in the
given precision. If the result can&#39;t fit the precision, additional
digits are discarded to make it fit. Signals FlagInvalid and returns
not-a-number (NaN) if the precision context defines an exponent
range, the new exponent must be changed to 0 when rounding, and 0 is
outside of the valid range of the arithmetic context.</li>
</ul>

<h3>RoundToPrecision</h3>

<pre><code>public EFloat RoundToPrecision(EContext ctx)
</code></pre>

<p>Rounds this object&#x27;s value to a given precision, using the given
 rounding mode and range of exponent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest value to this object&#39;s value, rounded to the specified
precision. Returns the same value as this object if <code>ctx</code> is
null or the precision and exponent range are unlimited.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre><code>public EFloat ScaleByPowerOfTwo(int places)
</code></pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>places</code> - A 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre><code>public EFloat ScaleByPowerOfTwo(int places, EContext ctx)
</code></pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>places</code> - A 32-bit signed integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre><code>public EFloat ScaleByPowerOfTwo(EInteger bigPlaces)
</code></pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigPlaces</code> - An arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>bigPlaces</code>.</li>
</ul>

<h3>ScaleByPowerOfTwo</h3>

<pre><code>public EFloat ScaleByPowerOfTwo(EInteger bigPlaces, EContext ctx)
</code></pre>

<p>Returns a number similar to this number but with its scale adjusted.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bigPlaces</code> - An arbitrary-precision integer.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A number whose exponent is increased by <code>bigPlaces</code>.</li>
</ul>

<h3>Sqrt</h3>

<pre><code>public EFloat Sqrt(EContext ctx)
</code></pre>

<p>Finds the square root of this object&#x27;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the square root function&#39;s results are generally
not exact for many inputs.</i> (Unlike in the General Binary
Arithmetic Specification, any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The square root. Signals the flag FlagInvalid and returns NaN if
this object is less than 0 (the square root would be a complex
number, but the return value is still NaN). Signals FlagInvalid and
returns not-a-number (NaN) if the parameter <code>ctx</code> is null or
the precision is unlimited (the context&#39;s Precision property is 0).</li>
</ul>

<h3>SquareRoot</h3>

<pre><code>@Deprecated public EFloat SquareRoot(EContext ctx)
</code></pre>

<p>Deprecated.&nbsp;Renamed to Sqrt.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). <i>This parameter
can&#39;t be null, as the square root function&#39;s results are generally
not exact for many inputs.</i> (Unlike in the General Binary
Arithmetic Specification, any rounding mode is allowed.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The square root. Signals the flag FlagInvalid and returns NaN if
this object is less than 0 (the square root would be a complex
number, but the return value is still NaN). Signals FlagInvalid and
returns not-a-number (NaN) if the parameter <code>ctx</code> is null or
the precision is unlimited (the context&#39;s Precision property is 0).</li>
</ul>

<h3>Subtract</h3>

<pre><code>public EFloat Subtract(EFloat otherValue)
</code></pre>

<p>Subtracts an arbitrary-precision binary float from this instance and returns
 the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>otherValue</code> - The number to subtract from this instance&#39;s value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference of the two objects.</li>
</ul>

<h3>Subtract</h3>

<pre><code>public EFloat Subtract(EFloat otherValue, EContext ctx)
</code></pre>

<p>Subtracts an arbitrary-precision binary float from this instance.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>otherValue</code> - The number to subtract from this instance&#39;s value.</p></li>
<li><p><code>ctx</code> - An arithmetic context to control precision, rounding, and
exponent range of the result. If <code>HasFlags</code> of the context is
true, will also store the flags resulting from the operation (the
flags are in addition to the pre-existing flags). Can be null, in
which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference of the two objects.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>NullPointerException</code> - The parameter <code>otherValue</code> is
null.</li>
</ul>

<h3>ToDouble</h3>

<pre><code>public double ToDouble()
</code></pre>

<p>Not documented yet.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 64-bit floating-point number.</li>
</ul>

<h3>ToEDecimal</h3>

<pre><code>public EDecimal ToEDecimal()
</code></pre>

<p>Converts this value to an arbitrary-precision decimal number.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision decimal number.</li>
</ul>

<h3>ToEInteger</h3>

<pre><code>public EInteger ToEInteger()
</code></pre>

<p>Converts this value to an arbitrary-precision integer. Any fractional part
 of this value will be discarded when converting to an
 arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This object&#39;s value is infinity or
not-a-number (NaN).</li>
</ul>

<h3>ToEIntegerExact</h3>

<pre><code>@Deprecated public EInteger ToEIntegerExact()
</code></pre>

<p>Deprecated.&nbsp;Renamed to ToEIntegerIfExact.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>ArithmeticException</code> - This object&#39;s value is infinity or
not-a-number (NaN).</p></li>
<li><p><code>ArithmeticException</code> - This object&#39;s value is not an exact integer.</p></li>
</ul>

<h3>ToEIntegerIfExact</h3>

<pre><code>public EInteger ToEIntegerIfExact()
</code></pre>

<p>Converts this value to an arbitrary-precision integer, checking whether the
 value contains a fractional part.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>ArithmeticException</code> - This object&#39;s value is infinity or
not-a-number (NaN).</p></li>
<li><p><code>ArithmeticException</code> - This object&#39;s value is not an exact integer.</p></li>
</ul>

<h3>ToEngineeringString</h3>

<pre><code>public String ToEngineeringString()
</code></pre>

<p>Converts this value to an arbitrary-precision decimal number, then returns
 the value of that decimal&#39;s ToEngineeringString method.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A text string.</li>
</ul>

<h3>ToExtendedDecimal</h3>

<pre><code>@Deprecated public EDecimal ToExtendedDecimal()
</code></pre>

<p>Deprecated.&nbsp;Renamed to ToEDecimal.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision decimal number.</li>
</ul>

<h3>ToPlainString</h3>

<pre><code>public String ToPlainString()
</code></pre>

<p>Converts this value to a string, but without exponential notation.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A text string.</li>
</ul>

<h3>ToShortestString</h3>

<pre><code>public String ToShortestString(EContext ctx)
</code></pre>

<p>Returns a string representation of this number&#39;s value after rounding to the
 given precision (using the given arithmetic context). If the number
 after rounding is neither infinity nor not-a-number (NaN), returns
 the shortest decimal form (in terms of nonzero decimal digits) of
 this number&#39;s value that results in the rounded number after the
 decimal form is converted to binary floating-point format (using the
 given arithmetic context).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>ctx</code> - An arithmetic context to control precision (in bits), rounding,
and exponent range of the rounded number. If <code>HasFlags</code> of the
context is true, will also store the flags resulting from the
operation (the flags are in addition to the pre-existing flags). Can
be null. If this parameter is null or defines no maximum precision,
returns the same value as the toString() method.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Shortest decimal form of this number&#39;s value for the given
arithmetic context. The text string will be in exponential notation
if the number&#39;s first nonzero decimal digit is more than five digits
after the decimal point, or if the number&#39;s exponent is greater than
0 and its value is 10, 000, 000 or greater.</li>
</ul>

<h3>ToSingle</h3>

<pre><code>public float ToSingle()
</code></pre>

<p>Converts this value to its closest equivalent as 32-bit floating-point
 number. The half-even rounding mode is used. <p>If this value is a
 NaN, sets the high bit of the 32-bit floating point number&#39;s
 significand area for a quiet NaN, and clears it for a signaling NaN.
 Then the other bits of the significand area are set to the lowest
 bits of this object&#39;s unsigned mantissa (significand), and the
 next-highest bit of the significand area is set if those bits are all
 zeros and this is a signaling NaN. Unfortunately, in the .NET
 implementation, the return value of this method may be a quiet NaN
 even if a signaling NaN would otherwise be generated.</p></p>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest 32-bit floating-point number to this value. The return
value can be positive infinity or negative infinity if this value
exceeds the range of a 32-bit floating point number.</li>
</ul>

<h3>toString</h3>

<pre><code>public String toString()
</code></pre>

<p>Converts this number&#39;s value to a text string.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>toString</code>&nbsp;in class&nbsp;<code>Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A string representation of this object. The value is converted to
decimal and the decimal form of this number&#39;s value is returned. The
text string will be in exponential notation if the converted number&#39;s
scale is positive or if the number&#39;s first nonzero decimal digit is
more than five digits after the decimal point.</li>
</ul>

<h3>Ulp</h3>

<pre><code>public EFloat Ulp()
</code></pre>

<p>Returns the unit in the last place. The mantissa (significand) will be 1 and
 the exponent will be this number&#39;s exponent. Returns 1 with an
 exponent of 0 if this number is infinity or not-a-number (NaN).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision binary float.</li>
</ul>

<h3>ToByteChecked</h3>

<pre><code>public byte ToByteChecked()
</code></pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
 byte (from 0 to 255) after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a byte (from 0 to 255).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, or
the truncated integer is less than 0 or greater than 255.</li>
</ul>

<h3>ToByteUnchecked</h3>

<pre><code>public byte ToByteUnchecked()
</code></pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a byte (from 0
 to 255).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a byte (from 0 to 255). Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToByteIfExact</h3>

<pre><code>public byte ToByteIfExact()
</code></pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
 byte (from 0 to 255) without rounding to a different numerical value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a byte (from 0 to 255).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than 0 or greater than 255.</li>
</ul>

<h3>FromByte</h3>

<pre><code>public static EFloat FromByte(byte inputByte)
</code></pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputByte</code> - The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary float.</li>
</ul>

<h3>ToInt16Checked</h3>

<pre><code>public short ToInt16Checked()
</code></pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
 16-bit signed integer after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a 16-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, or
the truncated integer is less than -32768 or greater than 32767.</li>
</ul>

<h3>ToInt16Unchecked</h3>

<pre><code>public short ToInt16Unchecked()
</code></pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a 16-bit
 signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 16-bit signed integer. Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToInt16IfExact</h3>

<pre><code>public short ToInt16IfExact()
</code></pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
 16-bit signed integer without rounding to a different numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a 16-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than -32768 or greater than 32767.</li>
</ul>

<h3>FromInt16</h3>

<pre><code>public static EFloat FromInt16(short inputInt16)
</code></pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputInt16</code> - The number to convert as a 16-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary float.</li>
</ul>

<h3>ToInt32Checked</h3>

<pre><code>public int ToInt32Checked()
</code></pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
 32-bit signed integer after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a 32-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, or
the truncated integer is less than -2147483648 or greater than
2147483647.</li>
</ul>

<h3>ToInt32Unchecked</h3>

<pre><code>public int ToInt32Unchecked()
</code></pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a 32-bit
 signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 32-bit signed integer. Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToInt32IfExact</h3>

<pre><code>public int ToInt32IfExact()
</code></pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a
 32-bit signed integer without rounding to a different numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a 32-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than -2147483648 or greater than
2147483647.</li>
</ul>

<h3>FromInt32</h3>

<pre><code>public static EFloat FromInt32(int inputInt32)
</code></pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputInt32</code> - The number to convert as a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary float.</li>
</ul>

<h3>ToInt64Checked</h3>

<pre><code>public long ToInt64Checked()
</code></pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
 64-bit signed integer after truncating to an integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value, truncated to a 64-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, or
the truncated integer is less than -9223372036854775808 or greater
than 9223372036854775807.</li>
</ul>

<h3>ToInt64Unchecked</h3>

<pre><code>public long ToInt64Unchecked()
</code></pre>

<p>Truncates this number&#39;s value to an integer and returns the
 least-significant bits of its two&#39;s-complement form as a 64-bit
 signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 64-bit signed integer. Returns 0 if this
value is infinity or not-a-number.</li>
</ul>

<h3>ToInt64IfExact</h3>

<pre><code>public long ToInt64IfExact()
</code></pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in a
 64-bit signed integer without rounding to a different numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a 64-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>ArithmeticException</code> - This value is infinity or not-a-number, is not
an exact integer, or is less than -9223372036854775808 or greater
than 9223372036854775807.</li>
</ul>

<h3>FromInt64</h3>

<pre><code>public static EFloat FromInt64(long inputInt64)
</code></pre>

<p>Converts a 64-bit signed integer to an arbitrary-precision binary float.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputInt64</code> - The number to convert as a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision binary float.</li>
</ul>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHfwYJKoZIhvcNAQcEoIIHcDCCB2wCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYBTEjVSqAfM9cTLwXVwxBqNI8r1Il0SJNqahKnIJrEIZOdmziEnZsYS8kifxxbWCBrNGl1S/eO5kcMG6WO50eBSxFlNpweevNYIs0dIdfQZtiWcRD2yYzaWHBkHu3PmCCLmc3pPT5QaOc949w2dPcg+syabMOSwN94Mk67Wh//7pTELMAkGBSsOAwIaBQAwgfwGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIm7w2yVS0zOeAgdhYAX/keBkbLTGS2k5QcVstRROvRVuMlDL7sy/YUie0YlEJKDFTFE7n6LP15AFfODDattjmqKJ7UZ+6hY9sqJhayUNqdl/rA/RYgPVKGWTM1l68+KFdz2SO3IHvBUJIAwnHFX1JVyNUAofSxWj+3eoN5MnQzskA4cKe/RFWB04oXxZS7/WCOHL3q3mlwFDSK83C3Wcqro7S18YnVxfJ4XGUQ7nlx1C9K0Xq+JbCGEC4D8yjQHzm9w3LqUOogiI3l9VVlXxuqcAdq+iBkAGIt3y4TXABMtXEFG2gggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xMzA4MTAxMzA4NDBaMCMGCSqGSIb3DQEJBDEWBBQImRl0rdSM38l1aTcRhxgiKb7ipTANBgkqhkiG9w0BAQEFAASBgE0IsEWvN+n6QuwDFkBMQO9C4z5uf7wAvoMDgifDKBCyGFmpYZPsKawkYVcS/kASDtyq6aWU3lqP+KweyA+0xfpAyE3R8/7p80uqGGs8bHGicxkl2pEkX95R23HGRa1pEDHFF1XQNkhns558WioFipI2RvmAAEaMgZQ1p+SV/cdu-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
