<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Color Topics for Programmers</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Color Topics for Programmers</h1>

<p><a href="mailto:poccil14@gmail.com">Peter Occil</a></p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This document presents an overview of many common color topics that are of general interest to programmers and that can be implemented in many different programming languages.   Many of the topics contain pseudocode that shows their implementation. In particular, this document discusses&mdash;</p>

<ul>
<li>popular formats for red-green-blue (RGB) colors,</li>
<li>several color models of practical interest, including conversion methods,</li>
<li>how to generate colors with certain properties,</li>
<li>color differences,</li>
<li>color mixing,</li>
<li>color maps, and</li>
<li>how to find the dominant colors of an image.</li>
</ul>

<p>In general, topics that are specific to a programming language or application-programming interface are out of the scope of this document.  Moreover, the following topics are beyond this page&#39;s scope:</p>

<ul>
<li><p>Procedures to change or set the color used&mdash;</p>

<ul>
<li>in text, foregrounds, or backgrounds of user interface elements (such as buttons, text boxes, and windows),</li>
<li>in text or backgrounds of documents (such as HTML documents), or</li>
<li>when generating graphics (such as plots and charts),</li>
</ul>

<p>are beyond the scope of this document because they generally vary depending on the specific application
programming interface, document format, or plotting or charting technology.</p></li>
<li>Determining which colors are used, or used by default, in user interface elements or documents.</li>
<li>Color pickers, including how to choose colors with them.</li>
<li>Specifics on retrieving colors (including pixel and palette colors) from images or screenshots (besides finding dominant colors).</li>
<li>Setting colors (including pixel colors) on images.</li>
<li>Colorization of command line outputs (or terminal or shell outputs) beyond describing the ANSI color codes.</li>
</ul>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Contents">Contents</a></li>
<li><a href="#Notation_and_Definitions">Notation and Definitions</a>

<ul>
<li><a href="#Utility_Functions">Utility Functions</a></li>
</ul></li>
<li><a href="#RGB_Color_Model">RGB Color Model</a>

<ul>
<li><a href="#RGB_Colors_and_the_0_1_Format">RGB Colors and the 0-1 Format</a></li>
<li><a href="#Integer_Component_Formats">Integer Component Formats</a></li>
<li><a href="#HTML_Related_Color_Formats">HTML-Related Color Formats</a></li>
<li><a href="#sRGB_and_Linearized_RGB">sRGB and Linearized RGB</a></li>
</ul></li>
<li><a href="#Other_Color_Models">Other Color Models</a>

<ul>
<li><a href="#HSV">HSV</a></li>
<li><a href="#HSL">HSL</a></li>
<li><a href="#HWB">HWB</a></li>
<li><a href="#CIE_L_a_b">CIE L*a*b*</a></li>
<li><a href="#CMYK">CMYK</a></li>
<li><a href="#YCbCr">YCbCr</a></li>
</ul></li>
<li><a href="#Modifying_Existing_Colors">Modifying Existing Colors</a>

<ul>
<li><a href="#Shades_Tints_and_Tones">Shades, Tints, and Tones</a></li>
<li><a href="#Luminance_Grayscale">Luminance (Grayscale)</a></li>
<li><a href="#Color_Schemes">Color Schemes</a></li>
<li><a href="#Color_Matrices">Color Matrices</a></li>
<li><a href="#Blending_and_Alpha_Compositing">Blending and Alpha Compositing</a></li>
<li><a href="#Miscellaneous">Miscellaneous</a></li>
</ul></li>
<li><a href="#Color_Difference_and_Nearest_Colors">Color Difference and Nearest Colors</a>

<ul>
<li><a href="#Examples">Examples</a></li>
</ul></li>
<li><a href="#Generating_a_Random_Color">Generating a Random Color</a></li>
<li><a href="#Dominant_Colors_of_an_Image">Dominant Colors of an Image</a></li>
<li><a href="#Color_Mixture">Color Mixture</a></li>
<li><a href="#Color_Maps">Color Maps</a>

<ul>
<li><a href="#Named_Colors">Named Colors</a></li>
<li><a href="#Visually_Distinct_Colors">Visually Distinct Colors</a></li>
</ul></li>
<li><a href="#Other_Color_Topics">Other Color Topics</a>

<ul>
<li><a href="#Colorblindness">Colorblindness</a></li>
<li><a href="#Terminal_Colors">Terminal Colors</a></li>
</ul></li>
<li><a href="#Conclusion">Conclusion</a></li>
<li><a href="#Notes">Notes</a></li>
<li><a href="#License">License</a></li>
</ul>

<p><a id=Notation_and_Definitions></a></p>

<h2>Notation and Definitions</h2>

<p>In this document:</p>

<ul>
<li>The same notation and conventions that apply to my article on <a href="https://peteroupc.github.io/randomfunc.html#Notes_and_Definitions">random number generation methods</a> apply to this document as well.</li>
<li><code>RNDNUMRANGE</code>, <code>RNDU01</code>, and <code>RNDINT</code> are as defined in my article on <a href="https://peteroupc.github.io/randomfunc.html">random number generation methods</a>.</li>
<li><code>atan2(y, x)</code> is&mdash;

<ul>
<li>the inverse tangent of <code>y/x</code> if <code>x &gt; 0</code>,</li>
<li>&pi; plus the inverse tangent of <code>y/x</code> if <code>x &lt; 0</code>,</li>
<li><code>-pi / 2</code> if <code>y &lt; 0 and x == 0</code>,</li>
<li><code>pi / 2</code> if <code>y &gt; 0 and x == 0</code>, and</li>
<li>0 if <code>y == 0 and x == 0</code>.</li>
</ul></li>
<li><code>min(a, b)</code> is the smaller of <code>a</code> and <code>b</code>.</li>
<li><code>max(a, b)</code> is the larger of <code>a</code> and <code>b</code>.</li>
<li>The term <em>RGB</em> means red-green-blue.</li>
<li>The term <em>linearized</em> refers to RGB colors with a linear relationship of emitted light (rather than perceived light).</li>
<li>The term <em>nonlinearized</em> or <em>companded</em> refers to RGB colors that are not linearized (generally with a fairly linear relationship of perceived light).</li>
</ul>

<p><a id=Utility_Functions></a></p>

<h3>Utility Functions</h3>

<p>In the pseudocode below, the utility function&mdash;</p>

<ul>
<li><code>Lerp3</code>, returns a blended form of two lists of three numbers (<code>list1</code> and <code>list2</code>); here, <code>fac</code> is 0 or greater and 1 or less, where 0 means equal to <code>list1</code> and 1 means equal to <code>list2</code>, and <code>Lerp3</code> is equivalent to <code>mix</code> in GLSL (OpenGL Shading Language);</li>
<li><code>Clamp</code> returns <code>minimum</code> if the given value is less than <code>minimum</code>, <code>maximum</code> if greater than <code>maximum</code>,
or <code>value</code> otherwise, and is equivalent to <code>clamp</code> in GLSL;</li>
<li><code>Clamp3</code> applies the <code>Clamp</code> function separately to each item of a three-element list; here, <code>value</code>, <code>minimum</code>,
and <code>maximum</code> are each three-element lists;</li>
<li><code>MeanAngle</code> finds the average of one or more angles expressed in radians (which is important when averaging colors in hue-based color models, which contain hue components that are angles);</li>
<li><code>Min3</code> is the smallest of three numbers; and</li>
<li><code>Max3</code> is the largest of three numbers.</li>
</ul>

<p><strong>Note:</strong> For <code>Lerp3</code>, making <code>fac</code> the output of a function (for example, <code>Lerp3(list1, list2, FUNC(...))</code>,
where <code>FUNC</code> is an arbitrary function of one or more variables) can be done to achieve special nonlinear interpolations.
Detailing such interpolations is outside the scope of this document, but are described in further detail <a href="https://peteroupc.github.io/html3dutil/H3DU.Math.html#H3DU.Math.vec3lerp">in another page</a>.</p>

<pre>METHOD Lerp3(a, b, fac)
    return [a[0]+(b[0]-a[0])*fac, a[1]+(b[1]-a[1])*fac, a[2]+(b[2]-a[2])*fac]
END METHOD

METHOD Clamp(value, minimum, maximum)
    if value &lt; minimum: return minimum
    if value &gt; maximum: return maximum
    return value
END METHOD

METHOD Clamp3(value, minimum, maximum)
    return [Clamp(value[0],minimum[0], maximum[0]),
      Clamp(value[1],minimum[1], maximum[1]),
      Clamp(value[2],minimum[2], maximum[2])]
END METHOD

METHOD Min3(v1, v2, v3)
    if v1 &lt; v2 and v1 &lt; v3: return v1
    if v2 &lt; v3: return v2
    return v3
END METHOD

METHOD Max3(v1, v2, v3)
    if v1 &gt; v2 and v1 &gt; v3: return v1
    if v2 &gt; v3: return v2
    return v3
END METHOD

METHOD MeanAngle(angles)
    if size(angles)==0: return 0
    xm=0
    ym=0
    i=0
    while i &lt; size(angles)
        xm = xm + cos(angles[i])
        ym = ym + sin(angles[i])
        i = i + 1
    end
    return atan2(ym / size(angles), xm / size(angles))
END
</pre>

<p><a id=RGB_Color_Model></a></p>

<h2>RGB Color Model</h2>

<p>A <em>color model</em> describes, in general terms, the relationship of colors in a theoretical space.  A <em>color space</em> is a mapping from colors to numbers that follows a particular color model.</p>

<p>The <em>red-green-blue (RGB) color model</em> is based, at least theoretically, on the intensity that a set of tiny red, green, and blue light-emitting dots should have in order to reproduce a given color on an electronic display.<sup><a href="#Note10">(10)</a></sup> The RGB model is a three-dimensional cube with one vertex set to black, another vertex set to white, and the remaining vertices set to what are called the &quot;additive primaries&quot; red, green, and blue, and the &quot;subtractive primaries&quot; cyan, yellow, and magenta.</p>

<p>In general, <em>RGB color spaces</em> differ in what they consider pure red, green, blue, and white.  Because human color perception is nonlinear, RGB color spaces also differ in their <em>companding</em> conversions (conversions to and from linearized RGB).</p>

<p>The following details concepts related to the RGB color model.</p>

<p><a id=RGB_Colors_and_the_0_1_Format></a></p>

<h3>RGB Colors and the 0-1 Format</h3>

<p>In an RGB color space, an <em>RGB color</em> consists of three components.  Given <code>color</code>, which is an RGB color&mdash;</p>

<ul>
<li><code>color[0]</code> is the color&#39;s red component,</li>
<li><code>color[1]</code> is the color&#39;s green component, and</li>
<li><code>color[2]</code> is the color&#39;s blue component,</li>
</ul>

<p>and each component is 0 or greater and 1 or less, where brighter colors have higher-valued components in general. (The term <strong>0-1 format</strong> will be used in this document to describe this format.  All RGB colors in this document are in the 0-1 format unless noted otherwise.)</p>

<p>Some RGB colors also contain an alpha component, expressed as <code>color[3]</code> (the fourth item in <code>color</code>) and being 0 or greater and 1 or less, where 0 means fully transparent and 1 means fully opaque. Such RGB colors are called <em>RGBA colors</em> in this document.  RGB colors without an alpha component are generally considered to be fully opaque (and to have an implicit alpha component of 1).</p>

<p><strong>Note:</strong> An RGB color is white, black, or a shade of gray (<em>achromatic</em>) if it has equal red, green, and blue components. A collection of RGB colors (including a raster image) is achromatic if all its RGB colors are achromatic.</p>

<p><a id=Integer_Component_Formats></a></p>

<h3>Integer Component Formats</h3>

<p>RGB and RGBA colors are often expressed by packing their red, green, and blue components
(or those three components as well as alpha) as integers.</p>

<p>In this document, there are two general categories for such formats, described below.
In the pseudocode below, <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code> are the corresponding components
of the formats described below, and <code>color</code> is an RGB color in <a href="#0_1_Format">0-1 format</a>.</p>

<ul>
<li><strong>RN/GN/BN format:</strong> As integers that are (RN + GN + BN) bits long, where&mdash;

<ul>
<li>the red component is RN bits long and calculated as follows: <code>floor(color[0] * (pow(2, RN) - 1) + 0.5)</code>,</li>
<li>the green component is GN bits long and calculated as follows: <code>floor(color[1] * (pow(2, GN) - 1) + 0.5)</code>,</li>
<li>the blue component is BN bits long and calculated as follows: <code>floor(color[2] * (pow(2, BN) - 1)+ 0.5)</code>, and</li>
<li>the components are converted to 0-1 format as follows:
<code>[red/pow(2, RN) - 1, green/(pow(2, GN) - 1), blue/(pow(2, BN) - 1)]</code>,</li>
</ul></li>
<li><strong>RN/GN/BN/AN format:</strong> As integers that are (RN + GN + BN +AN) bits long, where&mdash;

<ul>
<li>the red component is RN bits long and calculated as follows: <code>floor(color[0] * (pow(2, RN)- 1) + 0.5)</code>,</li>
<li>the green component is GN bits long and calculated as follows: <code>floor(color[1] * (pow(2, GN)- 1) + 0.5)</code>,</li>
<li>the blue component is BN bits long and calculated as follows: <code>floor(color[2] * (pow(2, BN)- 1) + 0.5)</code>,</li>
<li>the alpha component is AN bits long and calculated as follows: <code>floor(color[3] *( pow(2, AN)- 1) + 0.5)</code>, and</li>
<li>the components are converted to 0-1 format as follows:
<code>[red/pow(2, RN) - 1, green/(pow(2, GN) - 1), blue/(pow(2, BN) - 1), alpha/(pow(2, AN) - 1)]</code>,</li>
</ul></li>
</ul>

<p>Special cases of these formats include the following:</p>

<ul>
<li><strong>4/4/4 format:</strong> As 12-bit integers (4 bits per component).</li>
<li><strong>5/5/5 format:</strong> As 15-bit integers (5 bits per component).</li>
<li><strong>5/6/5 format:</strong> As 16-bit integers (5 bits each for red and blue, and 6 bits for green).</li>
<li><strong>8/8/8 format:</strong> As 24-bit integers (8 bits per component).</li>
<li><strong>8/8/8/8 format:</strong> As 32-bit integers (8 bits each for red, green, blue, and alpha).</li>
<li><strong>16/16/16 format:</strong> As 48-bit integers (16 bits per component).</li>
</ul>

<p>How the RGB or RGBA color&#39;s components are packed into an integer varies considerably.  Among
other possibilities, they can be packed in any of the following orders from lowest to highest bits:</p>

<ul>
<li><em>RN/GN/BN format</em>: Red, green, blue.</li>
<li><em>RN/GN/BN format</em>: Blue, green, red.</li>
<li><em>RN/GN/BN/AN format</em>: Red, green, blue, alpha.</li>
<li><em>RN/GN/BN/AN format</em>: Alpha, red, green, blue.</li>
<li><em>RN/GN/BN/AN format</em>: Blue, green, red, alpha.</li>
<li><em>RN/GN/BN/AN format</em>: Alpha, blue, green, red.</li>
</ul>

<p>(Little-endian/big-endian issues and other considerations when storing colors as a series of bytes are outside the scope of this document, and so is a thorough survey of the integer color formats in common use.)</p>

<p>The following pseudocode contains methods for converting RGB colors to and from different color formats (where the red component is stored in the low bits of each RGB color number):</p>

<pre>METHOD Upscale(v, c)
   return floor(c * v + 0.5)
END METHOD

// Converts 0-1 format to N/N/N format as an integer
METHOD ToNNN(rgb, scale)
   sm1 = scale - 1
   return Upscale(rgb[2], sm1) * scale * scale + Upscale(rgb[1], sm1) * scale +
         Upscale(rgb[0], sm1)
END METHOD

// Converts N/N/N integer format to 0-1 format
METHOD FromNNN(rgb, scale)
   sm1 = scale - 1
   r = mod(rgb, scale)
   g = mod(floor(rgb / scale), scale)
   b = mod(floor(rgb / (scale * scale)), scale)
   return [ r / sm1, g / sm1, b / sm1]
END METHOD

METHOD To444(rgb): return ToNNN(rgb, 16)
METHOD To555(rgb): return ToNNN(rgb, 32)
METHOD To888(rgb): return ToNNN(rgb, 256)
METHOD To161616(rgb): return ToNNN(rgb, 65536)
METHOD From444(rgb): return FromNNN(rgb, 16)
METHOD From555(rgb): return FromNNN(rgb, 32)
METHOD From888(rgb): return FromNNN(rgb, 256)
METHOD From161616(rgb): return FromNNN(rgb, 65536)

METHOD To565(rgb, scale)
   return Upscale(rgb[2], 31) * 32 * 64 + Upscale(rgb[1], 63) * 32 +
         Upscale(rgb[0], 31)
END METHOD

METHOD From565(rgb, scale)
   r = mod(rgb, 32)
   g = mod(floor(rgb / 32.0), 64)
   b = mod(floor(rgb / (32.0 * 64.0)), 32)
   return [ r / 31.0, g / 63.0, b / 31.0]
END METHOD
</pre>

<p><a id=HTML_Related_Color_Formats></a></p>

<h3>HTML-Related Color Formats</h3>

<p>A color string in the <em>HTML color format</em> (also known as &quot;hex&quot; format), which expresses RGB colors in 8/8/8 format as a string, consists of&mdash;</p>

<ul>
<li>the character &quot;#&quot;,</li>
<li>followed by the two base-16 (hexadecimal) digits<sup><a href="#Note1">(1)</a></sup> of the red component,</li>
<li>followed by the two base-16 digits of the green component,</li>
<li>followed by the two base-16 digits of the blue component.</li>
</ul>

<p>For example, the HTML color <code>#003F86</code> expresses the RGB color whose red, green, and blue components in 8/8/8 format are (0, 63, 134).<sup><a href="#Note6">(6)</a></sup></p>

<p>The <a href="https://www.w3.org/TR/css3-color/#rgb-color">CSS Color Module Level 3</a>, which specifies the HTML color format, also mentions a 3-digit format, consisting of &quot;#&quot; followed by one base-16 digit each for the red, green, and blue components, respectively. Conversion to the 6-digit format involves replicating each base-16 component (for example, &quot;#345&quot; is the same as &quot;#334455&quot; in the 6-digit format).</p>

<p>An 8-digit variant used in the Android operating system consists of &quot;#&quot; followed by two base-16 digits each for the alpha, red, green, and blue components, respectively.  This variant thus describes 8/8/8/8 RGBA colors.</p>

<p>The following pseudocode presents methods to convert RGB colors (actually lists of text
characters) to and from the HTML color format or the 3-digit format.</p>

<pre>METHOD NumToHex(x)
    if hex &lt; 0 or hex &gt;= 16: return error
    hexlist=[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;]
    return hexlist[x]
END METHOD

METHOD HexToNum(x)
    hexlist=[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;]
    hexdown=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
    i = 0
    while i &lt; 16
            if hexlist[i] == x: return i
            i = i + 1
    end
    i = 0
    while i &lt; 6
            if hexdown[i] == x: return 10 + i
            i = i + 1
    end
    return -1
END METHOD

METHOD ColorToHtml(rgb)
   // NOTE: Upscale method is given earlier in &quot;Integer
   // Component Formats&quot;
   r = Upscale(rgb[0], 255)
   g = Upscale(rgb[1], 255)
   b = Upscale(rgb[2], 255)
   return [&quot;#&quot;,
     NumToHex(mod(floor(r/16),16)), NumToHex(mod(r, 16)),
     NumToHex(mod(floor(g/16),16)), NumToHex(mod(g, 16)),
     NumToHex(mod(floor(b/16),16)), NumToHex(mod(b, 16)),
   ]
END METHOD

METHOD HtmlToColor(colorString)
    if string[0]!=&quot;#&quot;: return error
    if size(colorString)==7
            r1=HexToNum(colorString[1])
            r2=HexToNum(colorString[2])
            g1=HexToNum(colorString[3])
            g2=HexToNum(colorString[4])
            b1=HexToNum(colorString[5])
            b2=HexToNum(colorString[6])
            if r1&lt;0 or r2&lt;0 or g1&lt;0 or g2&lt;0 or
                    b1&lt;0 or b2&lt;0: return error
            return [(r1*16+r2)/255.0,
                    (g1*16+g2)/255.0,
                    (b1*16+b2)/255.0]
    end
    if size(colorString)==4
            r=HexToNum(colorString[1])
            g=HexToNum(colorString[2])
            b=HexToNum(colorString[3])
            if r&lt;0 or g&lt;0 or b&lt;0: return error
            return [(r*16+r)/255.0,
                    (g*16+g)/255.0,
                    (b*16+b)/255.0]
    end
    return error
END METHOD
</pre>

<p><strong>Note:</strong> As used in the <a href="http://www.w3.org/TR/css3-color/">CSS color module level 3</a>, for example, colors in the HTML color format or the 3-digit format are in the (nonlinearized) <a href="#sRGB_and_Linearized_RGB"><em>sRGB color space</em></a>.</p>

<p><a id=sRGB_and_Linearized_RGB></a></p>

<h3>sRGB and Linearized RGB</h3>

<p>Among RGB color spaces, one of the most popular is the <em>sRGB color space</em>. The <em>sRGB color space</em> is a nonlinear &quot;working space&quot; for describing red-green-blue colors and is based on the color output of cathode-ray-tube monitors.  (For background, see the <a href="https://www.w3.org/Graphics/Color/sRGB">sRGB proposal</a>.)</p>

<p>Although most RGB working spaces are linearized by <em>gamma encoding</em>, sRGB is different; the formula to use to linearize sRGB colors is similar to, but is not, applying a gamma exponent of 2.2.<sup><a href="#Note3">(3)</a></sup> (Microsoft documentation, especially for Windows Presentation Foundation, uses the term <em>scRGB</em> to refer above all to linearized sRGB colors in the 0-1 format<sup><a href="#Note9">(9)</a>.)</p>

<p>The following methods linearize and de-linearize sRGB colors.</p>

<pre>// Convert a color component from sRGB to linearized RGB
METHOD LinearFromsRGB(c)
  if c &lt;= 0.04045: return c / 12.92
  return pow((0.055 + c) / 1.055, 2.4)
END METHOD

// Convert a color component from linearized RGB to sRGB
METHOD LinearTosRGB(c)
  if c &lt;= 0.0031308: return 12.92 * c
  return pow(c, 1.0 / 2.4) * 1.055 - 0.055
END METHOD

// Convert a color from sRGB to linearized RGB
METHOD LinearFromsRGB3(c)
   return [LinearFromsRGB(c[0]), LinearFromsRGB(c[1]), LinearFromsRGB(c[2])]
END METHOD

// Convert a color from linearized RGB to sRGB
METHOD LinearTosRGB3(c)
   return [LinearTosRGB(c[0]), LinearTosRGB(c[1]), LinearTosRGB(c[2])]
END METHOD
</pre>

<p><a id=Other_Color_Models></a></p>

<h2>Other Color Models</h2>

<p>The following discusses several color models, other than RGB, that are of practical interest.</p>

<p><a id=HSV></a></p>

<h3>HSV</h3>

<p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV</a>  (also known as HSB), is a color model that transforms RGB colors to make them easier to manipulate and reason with.  An HSV color consists of three components, in the following order:</p>

<ul>
<li><em>Hue</em>, or angle in the color wheel, is in radians and is 0 or greater and less than 2&pi; (from red at 0 to yellow to green to cyan to blue to magenta to red).</li>
<li><em>Saturation</em>, the distance of the color from gray and white (but not necessarily from black),
is 0 or greater and 1 or less.</li>
<li>A component variously called &quot;value&quot; or &quot;brightness&quot; is the distance of the color from black and is 0 or greater and 1 or less.</li>
</ul>

<p>The following pseudocode converts colors between RGB and HSV. Each RGB color is in 0-1 format.
The transformation is independent of RGB color space, but should be done using <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB</em> colors</a>.</p>

<pre>METHOD RgbToHsv(rgb)
    mx=Max3(rgb[0],rgb[1],rgb[2])
    mn=Min3(rgb[0],rgb[1],rgb[2])
    if mx==mn: return [0,0,mx]
    s=(mx-mn)/mx
    h=0
    if rgb[0]==mx
            h=(rgb[1]-rgb[2])/(mx-mn)
    else if rgb[1]==mx
            h=2+(rgb[2]-rgb[0])/(mx-mn)
    else
            h=4+(rgb[0]-rgb[1])/(mx-mn)
    end
    if h &lt; 6: h = 6 - mod(-h, 6)
    if h &gt;= 6: h = mod(h, 6)
    return [h * (pi / 3), s, mx]
END METHOD

METHOD HsvToRgb(hsv)
    hue=hsv[0]
    sat=hsv[1]
    val=hsv[2]
    if hue &lt; 0: hue = pi * 2 - mod(-hue, pi * 2)
    if hue &gt;= pi * 2: hue = mod(hue, pi * 2)
    hue60 = hue * 3 / pi
    hi = floor(hue60)
    f = hue60 - hi
    c = val * (1 - sat)
    a = val * (1 - sat * f)
    e = val * (1 - sat * (1 - f))
    if hi == 0: return [val, e, c]
    if hi == 1: return [a, val, c]
    if hi == 2: return [c, val, e]
    if hi == 3: return [c, a, val]
    if hi == 4: return [e, c, val]
    return [val, c, a]
END METHOD
</pre>

<p>In the rest of this document&mdash;</p>

<ul>
<li><strong><code>HSVHue(color)</code></strong> is the HSV &quot;hue&quot; component of a color, that is, <code>RgbToHsv(color)[0]</code>,</li>
<li><strong><code>HSVSat(color)</code></strong> is the HSV saturation component of a color, that is, <code>RgbToHsv(color)[1]</code>, and</li>
<li><strong><code>HSVVal(color)</code></strong> is the HSV brightness or &quot;value&quot; component of a color, that is, <code>RgbToHsv(color)[2]</code>.</li>
</ul>

<p><strong>Note:</strong></p>

<ul>
<li>In most applications, hue is in degrees and is 0 or greater and less than 360.</li>
</ul>

<p><a id=HSL></a></p>

<h3>HSL</h3>

<p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSL</a> (also known as HLS), like HSV, is a color model that transforms RGB colors to ease intuition.  An HSL color consists of three components, in the following order:</p>

<ul>
<li><em>Hue</em>, or angle in the color wheel, is in radians and is 0 or greater and less than 2&pi; (from red at 0 to yellow to green to cyan to blue to magenta to red).</li>
<li>A component called &quot;saturation&quot; is the distance of the color from gray (but not necessarily from
black or white), which is 0 or greater and 1 or less.</li>
<li>A component variously called &quot;lightness&quot;, &quot;luminance&quot;, or &quot;luminosity&quot;, is roughly the amount
of black or white mixed with the color and which is 0 or greater and 1 or less, where 0 is black, 1 is white, and 0.5 is neither black nor white.</li>
</ul>

<p>The following pseudocode converts colors between RGB and HSL. Each RGB color is in 0-1 format.  The transformation is independent of RGB color space, but should be done using <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB</em> colors</a>.</p>

<pre>METHOD RgbToHsl(rgb)
    vmax = Max3(rgb[0], rgb[1], rgb[2])
    vmin = Min3(rgb[0], rgb[1], rgb[2])
    vadd = vmax + vmin
    // NOTE: Lightness is the midpoint between
    // the greatest and least RGB component
    lt = vadd / 2.0
    if vmax==vmin: return [0, 0, lt]
    vd = vmax - vmin
    divisor = vadd
    if lt &gt; 0.5: divisor = 2.0 - vadd
    s = vd / divisor
    h = 0
    hvd = vd / 2.0
    deg60 = pi / 3
    if rgb[0]==vmax
            h=((vmax-rgb[2])*deg60 + hvd) / vd
            h = h - ((vmax-rgb[1])*deg60+hvd) / vd
    else if rgb[2]==vmax
            h=pi * 4 / 3 + ((vmax-rgb[1])*deg60 + hvd) / vd
            h = h - ((vmax-rgb[0])*deg60+hvd) / vd
    else
            h=pi * 2 / 3 + ((vmax-rgb[0])*deg60 + hvd) / vd
            h = h - ((vmax-rgb[2])*deg60+hvd) / vd
    end
    if h &lt; 0: h = pi * 2 - mod(-h, pi * 2)
    if h &gt;= pi * 2: h = mod(h, pi * 2)
    return [h, s, lt]
END METHOD

METHOD HslToRgb(hsl)
    if hsl[1]==0: return [hsl[2],hsl[2],hsl[2]]
    lum = hsl[2]
    sat = hsl[1]
    if lum &lt;= 0.5: bb = lum * (1.0 + sat)
    if lum &gt; 0.5: bb= lum + sat - (lum * sat)
    a = lum * 2 - bb
    r = a
    g = a
    b = a
    hueval = hsl[0]
    if hueval &lt; 0: hueval = pi * 2 - mod(-hueval, pi * 2)
    if hueval &gt;= pi * 2: hueval = mod(hueval, pi * 2)
    hue = hueval + pi * 2 / 3
    deg60 = pi / 3
    deg240 = pi * 4 / 3
    if hue &gt;= pi * 2: hue = hue - pi * 2
    if hue &lt; deg60: r = a + (bb - a) * hue / deg60
    else if hue &lt; pi: r = bb
    else if hue &lt; deg240
            r = a + (bb - a) * (deg240 - hue) / deg60
    end
    hue = hueval
    if hue &lt; deg60: g = a + (bb - a) * hue / deg60
    else if hue &lt; pi: g = bb
    else if hue &lt; deg240
            g = a + (bb - a) * (deg240 - hue) / deg60
    end
    hue = hueval - pi * 2 / 3
    if hue &lt; 0: hue = hue + pi * 2
    if hue &lt; deg60: b = a + (bb - a) * hue / deg60
    else if hue &lt; pi: b = bb
    else if hue &lt; deg240
            b = a + (bb - a) * (deg240 - hue) / deg60
    end
    return [r, g, b]
END METHOD
</pre>

<p>In the rest of this document&mdash;</p>

<ul>
<li><strong><code>HSLHue(color)</code></strong> is the HSL &quot;hue&quot; component of a color, that is, <code>RgbToHsl(color)[0]</code>,</li>
<li><strong><code>HSLSat(color)</code></strong> is the HSL &quot;saturation&quot; component of a color, that is, <code>RgbToHsl(color)[1]</code>, and</li>
<li><strong><code>HSLLgt(color)</code></strong> is the HSL &quot;lightness&quot; component of a color, that is, <code>RgbToHsl(color)[2]</code>.</li>
</ul>

<p><strong>Notes:</strong></p>

<ul>
<li>In some applications and specifications, especially where this color model is called HLS, the HSL color&#39;s &quot;lightness&quot; component comes before &quot;saturation&quot;.  This is not the case in this document, though.</li>
<li>In most applications, hue is in degrees and is 0 or greater and less than 360.</li>
</ul>

<p><a id=HWB></a></p>

<h3>HWB</h3>

<p>In 1996, the HWB model, which seeks to be more intuitive than HSV or HSL, was published (Smith and Lyons 1996).  An HWB color consists of three components in the following order:</p>

<ul>
<li><em>Hue</em> is the same as in <a href="#HSV">HSV</a>.</li>
<li><em>Whiteness</em> is the amount of white in the color.</li>
<li><em>Blackness</em> is the amount of black in the color.</li>
</ul>

<p>The conversion is relatively simple given HSV conversion methods:</p>

<ul>
<li>To convert an RGB color <code>color</code> to HWB, generate <code>[HSVHue(color), Min3(color[0], color[1], color[2]), 1 - Max3(color[0], color[1], color[2])]</code>.</li>
<li>To convert an HWB color <code>hwb</code> to RGB, generate <code>HsvToRgb([hwb[0], 1 - hwb[1]/(1-hwb[2]), 1 - hwb[2]])</code> if <code>hwb[2] &lt; 1</code>, or <code>[0, 0, 0]</code> otherwise.</li>
</ul>

<p><a id=CIE_L_a_b></a></p>

<h3>CIE L*a*b*</h3>

<p>CIE L*a*b* is a color model designed for color comparisons.<sup><a href="#Note11">(11)</a></sup>  It arranges colors in three-dimensional space such that colors that appear similar will generally be close in space, and places white at the origin of the space.  In general, L*a*b* color spaces differ in what they consider white (also called a <em>reference white point</em>).</p>

<p>A color in CIE L*a*b* consists of three components, in the following order:</p>

<ul>
<li>L*, or <em>lightness</em> of a color, ranges from 0 (black) to 100 (white).  The L*a*b* color <code>[100, 0, 0]</code> is the same as the reference white point (such as the D50 or D65 reference white point).</li>
<li>a* ranges from about -79.2 to about 93.5 for sRGB.</li>
<li>b* ranges from about -112 to about 93.4 for sRGB.</li>
</ul>

<p>In the following pseudocode, which converts an RGB color between nonlinearized sRGB and CIE L*a*b*&mdash;</p>

<ul>
<li>the <code>SRGBToLab</code> method convers a nonlinearized sRGB color to CIE L*a*b*,</li>
<li>the <code>SRGBFromLab</code> method performs the opposite conversion, and</li>
<li>the L*a*b* color is relative to the white point determined by the CIE 1931 2-degree color matching function and the D65 illuminant (the comments show how to get a L*a*b* color relative to the D50/2-degree white point instead).</li>
</ul>

<p>The pseudocode follows.</p>

<pre>// Converts XYZ (pre-divided by the reference white) to Lab
METHOD NormXYZToLab(xyz)
    i=0
    while i &lt; 3
       if xyz[i] &gt; 216.0 / 24389 // See BruceLindbloom.com
          xyz[i]=pow(xyz[i], 1.0/3.0)
       else
           kappa=24389.0/27 // See BruceLindbloom.com
           xyz[i]=(16.0 + kappa*xyz[i]) / 116
       end
       i=i+1
    end
    return [116.0*xyz[1] - 16,
        500 * (xyz[0] - xyz[1]),
        200 * (xyz[1] - xyz[2])]
END METHOD

// Converts Lab to nonpredivided XYZ
METHOD LabToNormXYZ(xyz)
    fy=(lab[0]+16)/116.0
    fx=fy+lab[1]/500.0
    fz=fy-lab[2]/200.0
    fxcb=fx*fx*fx
    fzcb=fz*fz*fz
    xyz=[fxcb, 0, fzcb]
    eps=216.0/24389 // See BruceLindbloom.com
    if fxcb &lt;= eps: xyz[0]=(108.0*fx/841)-432.0/24389
    if fzcb &lt;= eps: xyz[2]=(108.0*fz/841)-432.0/24389
    if lab[0] &gt; 8 // See BruceLindbloom.com
            xyz[1]=pow(((lab[0]+16)/116.0), 3.0)
    else
            xyz[1]=lab[0]*27/24389.0 // See BruceLindbloom.com
    end
    return xyz
END METHOD

// Converts RGB to nonprediv. XYZ given a matrix and destination ref.
// white point (in the form of capital-X and capital-Z values)
METHOD RGBToNormXYZ(rgb, xyzmatrix, whitex, whitez)
    x=rgb[0]*xyzmatrix[0]+rgb[1]*xyzmatrix[1]+rgb[2]*xyzmatrix[2]
    y=rgb[0]*xyzmatrix[3]+rgb[1]*xyzmatrix[4]+rgb[2]*xyzmatrix[5]
    z=rgb[0]*xyzmatrix[6]+rgb[1]*xyzmatrix[7]+rgb[2]*xyzmatrix[8]
    return [x/whitex, y, z/whitez]
END METHOD

METHOD NormXYZToRGB(xyz, xyzmatrix, whitex, whitez)
    x=xyz[0]*whitex
    y=xyz[1]
    z=xyz[2]*whitez
    r=x*xyzmatrix[0]+y*xyzmatrix[1]+z*xyzmatrix[2]
    g=x*xyzmatrix[3]+y*xyzmatrix[4]+z*xyzmatrix[5]
    b=x*xyzmatrix[6]+y*xyzmatrix[7]+z*xyzmatrix[8]
    return [r,g,b]
END METHOD

METHOD SRGBToLab(rgb)
    lin=LinearFromsRGB3(rgb)
    // XYZ conversion for D65 reference white.
    xyz=RGBToNormXYZ(lin, [0.4124564, 0.3575761, 0.1804375,
      0.2126729, 0.7151522, 0.07217499, 0.01933390,
      0.1191920, 0.9503041], 0.95047, 1.08883)
    // Note: For an XYZ conversion for the D50 reference white,
    // for use in International Color Consortium (ICC) v2 profiles,
    // for example, use the following line instead:
    // xyz=RGBToNormXYZ(lin, [0.4360747, 0.3850649, 0.1430804,
    //    0.2225045, 0.7168786, 0.06061694, 0.01393218,
    //    0.09710454, 0.7141733], 0.96422, 0.82521)
    return NormXYZToLab(xyz)
END METHOD

METHOD SRGBFromLab(lab)
    xyz=LabToNormXYZ(lab)
    // XYZ conversion for D65 reference white.
    rgb=NormXYZToRGB(xyz, [3.240454, -1.537139, -0.4985314,
      -0.9692660, 1.876011, 0.04155602, 0.05564343,
      -0.2040259, 1.057225], 0.95047, 1.08883)
    // Note: For an XYZ conversion for the D50 reference white,
    // for use in ICC v2 profiles, for example, use the following line instead:
    // rgb=NormXYZToRGB(xyz, [3.133856, -1.616867, -0.4906146,
    //    -0.9787684, 1.916141, 0.03345398, 0.07194529,
    //    -0.2289914, 1.405243], 0.96422, 0.82521)
    return LinearTosRGB3(rgb)
END METHOD
</pre>

<p>A color&#39;s <em>chroma</em> (or relative colorfulness) can be derived from a L*a*b* color
with a method demonstrated in the following pseudocode.
For sRGB, chroma ranges from 0 to about 145.9.  The closer chroma
is to 0 &mdash; or the closer the point (a*, b*) is to the origin (0, 0) &mdash;
the closer the color is to the &quot;gray&quot; line.</p>

<pre>METHOD LabToChroma(lab)
    return sqrt(lab[1]*lab[1] + lab[2]*lab[2])
END METHOD
</pre>

<p>A color&#39;s <a href="https://en.wikipedia.org/wiki/Colorfulness"><em>saturation</em></a> can be derived from a L*a*b* color
with a method demonstrated in the following pseudocode.  Saturation is
0 or greater and less than 1.  The closer saturation
is to 0, the closer the color is to the &quot;gray&quot; line.</p>

<pre>METHOD LabToSaturation(lab)
    chromasq=lab[1]*lab[1] + lab[2]*lab[2]
    den=sqrt(lab[0]*lab[0]+chromasq)
    if den==0: return 0
    return sqrt(chromasq)/den
END METHOD
</pre>

<p>A color&#39;s <em>hue</em> (an angle in radians) can be derived from a L*a*b* color
with a method demonstrated in the following pseudocode. (Radians
can be converted to degrees by multiplying by <code>180 / pi</code>.)</p>

<pre>METHOD LabToHSLHue(lab)
    h = atan2(lab[2], lab[1])
    if h &lt; 0: h = h + pi * 2
    return h
END METHOD
</pre>

<p>The following method converts lightness, chroma, and hue to a
L*a*b* color.  It takes a list of those three elements in that order.</p>

<pre>METHOD LchToLab(lch)
   // NOTE: Assumes hue is in radians, not degrees
   return [lch[0], lch[1] * cos(lch[2]), lch[1] * sin(lch[2])]
END METHOD
</pre>

<p><a id=CMYK></a></p>

<h3>CMYK</h3>

<p>CMYK is a color model describing the amount and proportion of cyan, magenta, yellow, and black (K) inks to use to reproduce a given color on paper.  However, a proper conversion of a CMYK color to RGB, or vice versa, is not trivial, in part because&mdash;</p>

<ul>
<li>the conversion to RGB deals with color mixture of inks, which is not as simple as mixing abstract colors (see &quot;<a href="#Color_Mixture">Color Mixture</a>&quot;, later), and</li>
<li>the meaning of CMYK colors can vary depending on the specific inks used, since different inks have different light reflectances, as well as on the kind of paper that the color will be printed on.<sup><a href="#Note5">(5)</a></sup></li>
</ul>

<p><a id=YCbCr></a></p>

<h3>YCbCr</h3>

<p><a href="https://en.wikipedia.org/wiki/YCbCr">YCbCr</a> (also known as Y&prime;CbCr, YCrCb, or  Y&prime;CrCb) is a color model used above all in video encoding.  A color in YCbCr consists of three components in the following order:</p>

<ul>
<li>Y&prime;, or <em>luma</em>, specifies the brightness of the color, and is an integer 16 or greater and 235 or less: 16 for black, and 235 for white.</li>
<li>Cb, or <em>blue chroma</em>, is, theoretically, the scaled difference between blue and luma and is an integer 16 or greater and 240 or less.</li>
<li>Cr, or <em>red chroma</em>, is, theoretically, the scaled difference between red and luma and is an integer 16 or greater and 240 or less.</li>
</ul>

<p>The following pseudocode converts colors between RGB and YCbCr.  Each RGB color is in 8/8/8 format with the components separated out. There are three variants shown here, namely&mdash;</p>

<ul>
<li>the ITU-R BT.601 variant (for digital standard-definition video), as the <code>YCbCrToRgb</code> and <code>RgbToYCbCr</code> methods,</li>
<li>the ITU-R BT.709 variant (for high-definition video), as the <code>YCbCrToRgb709</code> and <code>RgbToYCbCr709</code> methods, and</li>
<li>the JPEG variant (with all three components 0 or greater and 255 or less), as the <code>YCbCrToRgbJpeg</code> and <code>RgbToYCbCrJpeg</code> methods,</li>
</ul>

<p>For all these variants, the transformation should be done using <a href="#sRGB_and_Linearized_RGB"><em>nonlinearized RGB</em> colors</a>.   For efficiency reasons, however, YCbCr conversion is sometimes done using a series of lookup tables, rather than directly applying the conversion methods given below.</p>

<pre>METHOD RgbToYCbCr(rgb)
    y = floor(16.0+rgb[0]*0.25678824+rgb[1]*0.50412941+rgb[2]*0.097905882)
    cb = floor(128.0-rgb[0]*0.1482229-rgb[1]*0.29099279+rgb[2]*0.43921569)
    cr = floor(128.0+rgb[0]*0.43921569-rgb[1]*0.36778831-rgb[2]*0.071427373)
    return [y, cb, cr]
END METHOD

METHOD RgbToYCbCr709(rgb)
    y = floor(0.06200706*rgb[2] + 0.6142306*rgb[1] + 0.1825859*rgb[0] + 16.0)
    cb = floor(0.4392157*rgb[2] - 0.338572*rgb[1] - 0.1006437*rgb[0] + 128.0)
    cr = floor(-0.04027352*rgb[2] - 0.3989422*rgb[1] + 0.4392157*rgb[0] + 128.0)
    return [y, cb, cr]
END METHOD

METHOD RgbToYCbCrJpeg(rgb)
    y = floor(0.299*rgb[0] + 0.587*rgb[1] + 0.114*rgb[2])
    cb = floor(-0.1687359*rgb[0] - 0.3312641*rgb[1] + 0.5*rgb[2] + 128.0)
    cr = floor(0.5*rgb[0] - 0.4186876*rgb[1] - 0.08131241*rgb[2] + 128.0)
    return [y, cb, cr]
END METHOD

METHOD YCbCrToRgb(ycbcr)
    cb = ycbcr[1] - 128
    cr = ycbcr[2] - 128
    yp = 1.1643836 * (ycbcr[0] -16)
    r = yp + 1.5960268 * cr
    g = yp - 0.39176229 * cb - 0.81296765 * cr
    b = yp + 2.0172321 * cb
    return Clamp3([r, g, b], [0,0,0],[255,255,255])
END METHOD

METHOD YCbCrToRgb709(ycbcr)
    cb = ycbcr[1] - 128
    cr = ycbcr[2] - 128
    yp = 1.1643836 * (ycbcr[0] -16)
    r = yp + 1.7927411 * cr
    g = yp - 0.21324861 * cb - 0.53290933 * cr
    b = yp + 2.1124018 * cb
    return Clamp3([r, g, b], [0,0,0],[255,255,255])
END METHOD

METHOD YCbCrToRgbJpeg(ycbcr)
    cb = ycbcr[1] - 128
    cr = ycbcr[2] - 128
    yp = ycbcr[0]
    r = yp + 1.402 * cr
    g = yp - 0.34413629 * cb - 0.71413629 * cr
    b = yp + 1.772 * cb
    return Clamp3([r, g, b], [0,0,0],[255,255,255])
END METHOD
</pre>

<p><a id=Modifying_Existing_Colors></a></p>

<h2>Modifying Existing Colors</h2>

<p>The following techniques show how existing colors can be modified to create new colors.</p>

<p>Note that for best results, these techniques need to be carried out with <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB colors</em></a>, unless noted otherwise.</p>

<p><a id=Shades_Tints_and_Tones></a></p>

<h3>Shades, Tints, and Tones</h3>

<ul>
<li><strong>Shades</strong>: The idiom <code>Lerp3(color, [0, 0, 0], shading)</code> generates a <em>shade</em> of the given <code>color</code> (a mixing of <code>color</code>
with black).  The parameter <code>shading</code> is 0 or greater and 1 or less (0 means equal to <code>color</code> and 1 means equal to black); the greater the parameter, the darker the resulting color.</li>
<li><strong>Tints</strong>: The idiom <code>Lerp3(color, [1, 1, 1], tinting)</code> generates a <em>tint</em> of the given <code>color</code> (a mixing of <code>color</code>
with white).  The parameter <code>tinting</code> is 0 or greater and 1 or less (0 means equal to <code>color</code> and 1 means equal to white); the greater the parameter, the lighter the resulting color.</li>
<li><strong>Tones</strong>: The idiom <code>Lerp3(color, [0.5, 0.5, 0.5], toning)</code> generates a <em>tone</em> of the given <code>color</code> (a mixing of <code>color</code>
with gray).  The parameter <code>toning</code> is 0 or greater and 1 or less (0 means equal to <code>color</code> and 1 means equal to gray); the greater the parameter, the less saturated the resulting color.</li>
<li><p><strong>Lighten/Darken</strong>: A choice of&mdash;</p>

<ul>
<li><code>Clamp3([color[0]+value, color[1]+value, color[2]+value], [0, 0, 0], [1, 1, 1])</code>, or</li>
<li><code>HslToRgb(HSLHue(color), HSLSat(color), Clamp(HSLLgt(color) + value, 0, 1))</code>,</li>
</ul>

<p>generates a lighter version of <code>color</code> if <code>value</code> is positive, and a darker version if <code>value</code> is negative.</p></li>
<li><strong>Lighten/Darken (L*a*b*)</strong>: If <code>color</code> is a nonlinearized sRGB color, generate <code>lab = SRGBToLab(color)</code>, then generate <code>modifiedColor = SRGBFromLab(Clamp(lab[0] + value, 0, 100), lab[1], lab[2])</code>, where a positive <code>value</code> generates a lighter version of <code>color</code> and a negative <code>value</code>, a darker version.</li>
<li><strong>Saturate/Desaturate</strong>: Generate <code>hsv = RgbToHsv(color)</code>, then generate <code>modifiedColor = HsvToRgb(hsv[0], Clamp(hsv[1] + color, 0, 1), hsv[0])</code>; this procedure saturates <code>color</code> if <code>value</code> is positive, and desaturates that color if <code>value</code> is negative. (Note that HSL&#39;s &quot;saturation&quot; is inferior here.)</li>
</ul>

<p><a id=Luminance_Grayscale></a></p>

<h3>Luminance (Grayscale)</h3>

<p>Luminance is a single number, being 0 or greater and 1 or less, indicating how light or dark a color is; 0 means
black and 1 means white.  Some formulas for luminance follow:</p>

<ul>
<li><strong>Simple</strong>: <code>(color[0]+color[1]+color[2])/3.0</code>.</li>
<li><strong>HSL &quot;Lightness&quot;</strong>: <code>0.5 * (Min3(color[0], color[1], color[2]) + Max3(color[0], color[1], color[2]))</code>
(see J. Cook, <a href="https://www.johndcook.com/blog/2009/08/24/algorithms-convert-color-grayscale/">&quot;Converting color to grayscale&quot;</a>).</li>
<li><strong>CIE Y</strong>: <code>(color[0] * r +color[1] * g + color[2] * b)</code>, where <code>r</code>, <code>g</code>, and <code>b</code> are the upper-case-Y components of the RGB color space&#39;s red, green, and blue primaries, respectively<sup><a href="#Note2">(2)</a></sup>.  The following is a special case of this:

<ul>
<li><strong>ITU BT.709</strong> (<code>BT709(color)</code>): <code>(color[0] * 0.2126 + color[1] * 0.7152 + color[2] * 0.0722)</code> (sRGB Y primaries<sup><a href="#Note2">(2)</a></sup>).</li>
</ul></li>
</ul>

<p>In the sections that follow, the method <strong><a href="#Luminance_Grayscale"><code>Luminance(color)</code></a></strong> returns the luminance of the color <code>color</code>.</p>

<p>Two applications of luminance are the following:</p>

<ul>
<li><strong>Grayscale.</strong> A color, <code>color</code>, can be converted to grayscale by calculating <code>[Luminance(color), Luminance(color), Luminance(color)]</code>.</li>
<li><strong>Contrasting color.</strong> A <em>contrasting color</em> is a foreground (text) color with high contrast to the background color or vice versa.  For example, if <a href="#Luminance_Grayscale"><code>Luminance(color)</code></a> is 0.5 or less, select <code>[1, 1, 1]</code> (white) as a contrasting color; otherwise, select <code>[0, 0, 0]</code> (black) as a  contrasting color.

<ul>
<li><strong>Note:</strong> In the <a href="https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast">Web Content Accessibility Guidelines 2.0</a>, the <em>contrast ratio</em> of two colors is <code>(RelLum(brighter) + 0.05) / (RelLum(darker) + 0.05)</code>, where <code>RelLum(color)</code> is the <em>relative luminance</em> of a color, as defined in the guidelines<sup><a href="#Note4">(4)</a></sup>; <code>brighter</code> is the color with higher relative luminance; and <code>darker</code> is the other color.  In general, under those guidelines, a <em>contrasting color</em> is one whose contrast ratio with another color is 4.5 (or 7) or greater.</li>
</ul></li>
</ul>

<p><a id=Color_Schemes></a></p>

<h3>Color Schemes</h3>

<p>The following techniques generate new colors that are related to existing colors.</p>

<ul>
<li><strong>Color harmonies</strong> result by generating several related colors, such as with the idiom <code>HslToRgb(HSLHue(color) + X, HSLSat(color), HSLLgt(color))</code>, where X is the following for each color:

<ul>
<li><strong>Analogous</strong>: 0, Y, -Y, where Y is 2&pi;/3 or less. In general, <em>analogous colors</em> are colors spaced at equal hue intervals from a central color.</li>
<li><strong>Complementary</strong>: 0, &pi;.</li>
<li><strong>Two-tone</strong>: 0, Y, where Y is greater than -&pi;/2 and less than &pi;/2.</li>
<li><strong>Double complementary</strong>: 0, Y, &pi;, &pi; + Y, where Y is greater than 0 and &pi;/2 or less.</li>
<li><strong>Split complementary</strong>: 0, &pi; - Y, &pi; + Y, where Y is greater than 0 and &pi;/2 or less.</li>
<li><strong>Triadic</strong>: 0, 2&pi;/3, 4&pi;/3.</li>
</ul></li>
<li><strong>Monochrome colors</strong>: Generate one or more <code>HslToRgb(HSLHue(color), S, L)</code>, where <code>S</code> is an arbitrary &quot;saturation&quot; and <code>L</code> is an arbitrary &quot;lightness&quot;.</li>
<li><strong>HSL &quot;Lightness&quot; Adjustments</strong>: Generate one or more <code>HslToRgb(HSLHue(color), HSLSat(color), L)</code>, where <code>L</code> is an arbitrary &quot;lightness&quot; (less than 0.5 results in a color closer to black, and greater than 0.5 results in a color closer to white).</li>
<li><strong>HSL &quot;Saturation&quot; Adjustments</strong>: Generate one or more <code>HslToRgb(HSLHue(color), S, HSLLgt(color))</code>, where <code>S</code> is an arbitrary &quot;saturation&quot;.</li>
<li><strong>HSV Brightness Adjustments</strong>: Generate one or more <code>HsvToRgb(HSVHue(color), HSVSat(color), V)</code>, where <code>V</code> is an arbitrary brightness.</li>
<li><strong>HSV Saturation Adjustments</strong>: Generate one or more <code>HsvToRgb(HSVHue(color), S, HSVVal(color))</code>, where <code>S</code> is an arbitrary saturation.</li>
</ul>

<p><a id=Color_Matrices></a></p>

<h3>Color Matrices</h3>

<p>A <em>color matrix</em> is a 9-item (3x3) list for transforming colors.  As used in this document, an RGB color (<code>color</code>)
is transformed with a color matrix (<code>matrix</code>) as follows:</p>

<pre>newColor = Clamp3([
   color[0]*matrix[0]+color[1]*matrix[1]+color[2]*matrix[2],
   color[0]*matrix[3]+color[1]*matrix[4]+color[2]*matrix[5],
   color[0]*matrix[6]+color[1]*matrix[7]+color[2]*matrix[8]
], [0,0,0], [1,1,1])
</pre>

<p>Examples of matrices include:</p>

<ul>
<li><strong>Sepia</strong>: <code>[0.393, 0.769, 0.189, 0.349, 0.686, 0.168, 0.272, 0.534, 0.131]</code>.</li>
<li><strong>Saturate</strong>: <code>[s+(1-s)*r, (1-s)*g, (1-s)*b, (1-s)*r, s+(1-s)*g,(1-s)*b,(1-s)*r,(1-s)*g,s+(1-s)*b]</code>, where <code>s</code> is
a saturation factor (0 for totally saturated and 1 for totally unsaturated), and <code>r</code>, <code>g</code>, and <code>b</code> are the
upper-case-Y components of the RGB color space&#39;s red, green, and blue primaries,
respectively (see &quot;<a href="#Luminance_Grayscale">Luminance (Grayscale)</a>&quot;)<sup><a href="#Note2">(2)</a></sup>
(the source recommends different values for <code>r</code>, <code>g</code>, and <code>b</code> <sup><a href="#Note8">(8)</a></sup>).</li>
<li><strong>Hue rotate</strong>: <code>[-0.37124*sr + 0.7874*cr + 0.2126,  -0.49629*sr - 0.7152*cr + 0.7152, 0.86753*sr - 0.0722*cr + 0.0722, 0.20611*sr - 0.2126*cr + 0.2126, 0.08106*sr + 0.2848*cr + 0.7152, -0.28717*sr - 0.072199*cr + 0.0722, -0.94859*sr - 0.2126*cr + 0.2126, 0.65841*sr - 0.7152*cr + 0.7152, 0.29018*sr + 0.9278*cr + 0.0722]</code>, where <code>sr = sin(rotation)</code>, <code>cr = cos(rotation)</code>, and <code>rotation</code> is the hue rotation angle in radians.<sup><a href="#Note8">(8)</a></sup></li>
</ul>

<p><a id=Blending_and_Alpha_Compositing></a></p>

<h3>Blending and Alpha Compositing</h3>

<p><strong>General alpha blend</strong>: To get a blend of two colors, generate <code>Lerp3(color1, color2, alpha)</code>, where <code>color1</code> and <code>color2</code> are the two colors, and <code>alpha</code> is the <em>alpha component</em> being 0 or greater and 1 or less (0 means equal to <code>color1</code> and 1 means equal to <code>color2</code>).</p>

<ul>
<li>Shading is equivalent to alpha blending one color with black <code>[0, 0, 0]</code>.</li>
<li>Tinting is equivalent to alpha blending one color with white <code>[1, 1, 1]</code>.</li>
<li>Averaging two colors is equivalent to alpha blending with <code>alpha</code> set to 0.5.</li>
<li>Converting an RGBA color to an RGB color on white is equivalent to <code>Lerp3([color[0], color[1], color[2]], [1, 1, 1], color[3])</code>.</li>
<li>Converting an RGBA color to an RGB color over <code>color2</code>, another RGB color, is equivalent to <code>Lerp3([color[0], color[1], color[2]], color2, color[3])</code>.</li>
</ul>

<p><strong>Porter&ndash;Duff Formulas</strong>: Porter and Duff (1984) define twelve formulas for combining (compositing) two RGBA colors. In the formulas below, it is assumed that the two colors are in the 0-1 format and have been premultiplied (that is, their red, green, and blue components have been multiplied beforehand by their alpha component).  Given <code>src</code>, the source RGBA color, and <code>dst</code>, the destination RGBA color, the Porter&ndash;Duff formulas are as follows.</p>

<ul>
<li><strong>Source Over</strong>: <code>[src[0]-dst[0]*(src[3] - 1), src[1]-dst[1]*(src[3] - 1), src[2]-dst[2]*(src[3] - 1), src[3]-dst[3]*(src[3] - 1)]</code>.</li>
<li><strong>Source In</strong>: <code>[dst[3]*src[0], dst[3]*src[1], dst[3]*src[2], dst[3]*src[3]]</code>.</li>
<li><strong>Source Held Out</strong>: <code>[src[0]*(1 - dst[3]), src[1]*(1 - dst[3]), src[2]*(1 - dst[3]), src[3]*(1 - dst[3])]</code>.</li>
<li><strong>Source Atop</strong>: <code>[dst[0]*src[3] - src[0]*(dst[3] - 1), dst[1]*src[3] - src[1]*(dst[3] - 1), dst[2]*src[3] - src[2]*(dst[3] - 1), src[3]]</code>.</li>
<li><strong>Destination Over</strong>: <code>[dst[0] - src[0]*(dst[3] - 1), dst[1] - src[1]*(dst[3] - 1), dst[2] - src[2]*(dst[3] - 1), dst[3] - src[3]*(dst[3] - 1)]</code>.</li>
<li><strong>Destination In</strong>: <code>[dst[0]*src[3], dst[1]*src[3], dst[2]*src[3], dst[3]*src[3]]</code>.  Uses the destination color/alpha with the source alpha as the &quot;mask&quot;.</li>
<li><strong>Destination Held Out</strong>: <code>[dst[0]*(1 - src[3]), dst[1]*(1 - src[3]), dst[2]*(1 - src[3]), dst[3]*(1 - src[3])]</code>.</li>
<li><strong>Destination Atop</strong>: <code>[dst[3]*src[0] - dst[0]*(src[3] - 1), dst[3]*src[1] - dst[1]*(src[3] - 1), dst[3]*src[2] - dst[2]*(src[3] - 1), dst[3]]</code>.</li>
<li><strong>Source</strong>: <code>src</code>.</li>
<li><strong>Destination</strong>: <code>dst</code>.</li>
<li><strong>Clear</strong>: <code>[0, 0, 0, 0]</code>.</li>
<li><strong>Xor</strong>: <code>[-dst[3]*src[0] - dst[0]*src[3] + dst[0] + src[0], -dst[3]*src[1] - dst[1]*src[3] + dst[1] + src[1], -dst[3]*src[2] - dst[2]*src[3] + dst[2] + src[2], -2*dst[3]*src[3] + dst[3] + src[3]]</code>.</li>
</ul>

<p><strong>Blend Modes</strong>: Blend modes take a source color and destination color and blend them to create a new color.  The same blend mode, or different blend modes, can be applied to each component of a given color.  In the idioms below, <code>src</code> is one component of the source color, <code>dst</code> is the same component of the destination color (for example, <code>src</code> and <code>dst</code> can both be two RGB colors&#39; red components), and both components are assumed to be 0 or greater and 1 or less.  The following are examples of blend modes.</p>

<ul>
<li><strong>Normal</strong>: <code>src</code>.</li>
<li><strong>Lighten</strong>: <code>max(src, dst)</code>.</li>
<li><strong>Darken</strong>: <code>min(src, dst)</code>.</li>
<li><strong>Add</strong>: <code>min(1.0, src + dst)</code>.</li>
<li><strong>Subtract</strong>: <code>max(0.0, src - dst)</code>.</li>
<li><strong>Multiply</strong>: <code>(src + dst)</code>.</li>
<li><strong>Screen</strong>: <code>1 - (1 - dst) * (1 - src)</code>.</li>
<li><strong>Average</strong>: <code>(src + dst) * 0.5</code>.</li>
<li><strong>Difference</strong>: <code>abs(src - dst)</code>.</li>
<li><strong>Exclusion</strong>: <code>src - 2 * src * dst + dst</code>.</li>
</ul>

<p><a id=Miscellaneous></a></p>

<h3>Miscellaneous</h3>

<ul>
<li><strong>Invert (negative)</strong>: Generate <code>[1.0 - color[0], 1.0 - color[1], 1.0 - color[2]]</code>, where <code>color</code> is the given color.<sup><a href="#Note12">(12)</a></sup></li>
<li><strong>Colorize</strong>: Given a desired <code>color</code> and a source color <code>srcColor</code>, generate
<code>[color[0]*Luminance(srcColor), color[1]*Luminance(srcColor), color[2]*Luminance(srcColor)]</code>.</li>
<li><strong>Swap blue and red channels</strong>: Generate <code>[color[2], color[1], color[0]]</code>.</li>
</ul>

<p><strong>Note:</strong> Image processing techniques that replace one color with another color (or some modified version of the original color), but only if the color meets certain requirements, techniques that include <a href="https://en.wikipedia.org/wiki/Chroma_key"><em>chroma key</em></a>, are largely out of the scope of this document.</p>

<p><a id=Color_Difference_and_Nearest_Colors></a></p>

<h2>Color Difference and Nearest Colors</h2>

<p><em>Color difference</em> algorithms are used to determine if two colors are similar.  The <em>nearest color</em> algorithm is used, for example, to categorize colors or to reduce the number of colors used by an image.</p>

<p>In the pseudocode below:</p>

<ul>
<li>The method <code>NearestColorIndex</code> finds, for a given color (<code>color</code>), the index of the color nearest it in a given list (<code>list</code>) of colors.</li>
<li><code>COLORDIFF(color1, color2)</code> is a function that calculates a <a href="https://en.wikipedia.org/wiki/Color_difference"><em>color difference</em></a> between two colors, where the lower the number, the closer the two colors are.</li>
<li>The method <code>NearestColorIndex</code> is independent of color model; however, both <code>color</code> and each color in <code>list</code> must be in the same color space.</li>
</ul>

<p>The pseudocode follows.</p>

<pre>METHOD NearestColorIndex(color, list)
   if size(list) == 0: return error
   if size(list) == 1: return 0
   i = 0
   best = -1
   bestIndex = 0
   while i &lt; size(list)
       dist = COLORDIFF(color, list[i])
       if i == 0 or dist &lt; best
          best = dist
          bestIndex = i
       end
       i = i + 1
   end
   return bestIndex
END METHOD
</pre>

<p>Finding the nearest color in the list then proceeds as in the following example:</p>

<pre>nearestColor = list[NearestColorIndex(color, list)]
</pre>

<p>There are many ways to implement <code>COLORDIFF</code>, the color difference.  One simple way is to use the Euclidean distance of the two colors, as shown in the following pseudocode.</p>

<pre>METHOD COLORDIFF(color1, color2)
   d1=color2[0] - color1[0]
   d2=color2[1] - color1[1]
   d3=color2[2] - color1[2]
   sqdist=d1*d1+d2*d2+d3*d3
   return sqrt(sqdist)
END METHOD
</pre>

<p>Note that&mdash;</p>

<ul>
<li>the Euclidean distance can be used, for example, if the colors passed to <code>NearestColorIndex</code>&mdash;

<ul>
<li>are expressed in a <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB</em> color space</a>, or</li>
<li>are expressed in CIE L*a*b* (rather than in RGB), in which case the Euclidean distance method just given implements the 1976 Delta-E color difference method, where differences around 2.3 are just noticeable (Mahy et al., 1994), and</li>
</ul></li>
<li>if Euclidean distances are merely being compared (so that, for example, two distances are not added or multiplied), then the square root operation can be omitted.</li>
</ul>

<p>T. Riemersma suggests an algorithm for color difference to be applied to nonlinearized RGB colors in his article <a href="https://www.compuphase.com/cmetric.htm">&quot;Colour metric&quot;</a> (section &quot;A low-cost approximation&quot;).</p>

<p><a id=Examples></a></p>

<h3>Examples</h3>

<p>Sorting colors into <strong>color categories</strong> is equivalent to&mdash;</p>

<ul>
<li>defining a list of <em>representative colors</em> <code>repColors</code> (for example, representative colors for red, blue, black, white, and so on), then</li>
<li>for each color (<code>color</code>) to be categorized, finding the nearest color to that color among the representative colors (for example, by calling <code>NearestColorIndex(color, repColors)</code>).</li>
</ul>

<p><a id=Generating_a_Random_Color></a></p>

<h2>Generating a Random Color</h2>

<p>The following techniques can be used to generate random RGB colors.</p>

<p>Note that for best results, these techniques need to use <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB colors</em></a>, unless noted otherwise.</p>

<ul>
<li>Generating a random color in the <strong>8/8/8 format</strong> is equivalent to calling <code>From888(RNDINT(16777215))</code>, where <code>RNDINT(x)</code> returns a <a href="https://peteroupc.github.io/randomfunc.html#RNDINT_Core_Random_Integer_Method">random integer 0 or greater and <code>x</code> or less</a>.  This technique is independent of RGB color space.</li>
<li>Generating a random string in the <strong>HTML color format</strong> is equivalent to generating a <a href="https://peteroupc.github.io/randomfunc.html#Creating_a_Random_Character_String">random hexadecimal string</a> with length 6, then inserting the string &quot;#&quot; at the beginning of that string.
This technique is independent of RGB color space, but see the <a href="#HTML_Color_Format">note from earlier</a>.</li>
<li>Generating a random color in the <strong>0-1 format</strong> is equivalent to generating <code>[RNDU01(), RNDU01(), RNDU01()]</code>.</li>
<li>To generate a random <strong>dark color</strong>, either&mdash;

<ul>
<li>generate <code>color = [RNDU01(), RNDU01(), RNDU01()]</code> until <a href="#Luminance_Grayscale"><code>Luminance(color)</code></a> is less than a given threshold, e.g., 0.5, or</li>
<li>generate <code>color = [RNDU01() * maxComp, RNDU01() * maxComp, RNDU01() * maxComp]</code>, where <code>maxComp</code> is the
maximum value of each color component, e.g., 0.5.</li>
</ul></li>
<li>To generate a random <strong>light color</strong>, either&mdash;

<ul>
<li>generate <code>color = [RNDU01(), RNDU01(), RNDU01()]</code> until <a href="#Luminance_Grayscale"><code>Luminance(color)</code></a> is greater than a given threshold, e.g., 0.5, or</li>
<li>generate <code>color = [minComp + RNDU01() * (1.0 - minComp), minComp + RNDU01() * (1.0 - minComp), minComp + RNDU01() * (1.0 - minComp)]</code>, where <code>minComp</code> is the minimum value of each color component, e.g., 0.5.</li>
</ul></li>
<li>One way to generate a random <strong>pastel color</strong> is to generate <code>color = [RNDU01(), RNDU01(), RNDU01()]</code> until <a href="#Luminance_Grayscale"><code>Luminance(color)</code></a> is greater than 0.75 and less than 0.9.</li>
<li>To generate a <strong>random color at or between two others</strong> (<code>color1</code> and <code>color2</code>), generate <code>Lerp(color1, color2, RNDU01())</code>.</li>
<li>To generate a <strong>random shade</strong> of a given color, generate <code>Lerp(color1, [0, 0, 0], RNDNUMRANGE(0.2, 1.0))</code>.</li>
<li>To generate a <strong>random tint</strong> of a given color, generate <code>Lerp(color1, [1, 1, 1], RNDNUMRANGE(0.0, 0.9))</code>.</li>
<li>To generate a <strong>random monochrome color</strong>, generate <code>HslToRgb(H, RNDU01(),RNDU01())</code>, where <code>H</code> is an arbitrary hue.</li>
<li><strong>Random color sampling:</strong> If colors are to be selected at random from a <a href="#Color_Maps">color map</a>, see <a href="https://peteroupc.github.io/randomfunc.html#Choosing_a_Random_Item_from_a_List">Choosing a Random Item from a List</a> and <a href="https://peteroupc.github.io/randomfunc.html#Choosing_Several_Unique_Items">Choosing Several Unique Items</a>, for example.</li>
<li><strong>Similar random colors:</strong> Generating a random color that&#39;s similar to another is equivalent to generating a random color until <code>COLORDIFF(color1, color2)</code> (defined <a href="#Color_Difference_and_Nearest_Colors">earlier</a>) is less than a predetermined threshold, where <code>color2</code> is the color to compare.  For example, if a reddish color is to be generated, <code>color2</code> would have the linearized sRGB value (1.0, 0.0, 0.0), among other possibilities.</li>
<li><strong>Data hashing:</strong> A technique similar to generating random colors is to generate a color from arbitrary data (such as a sequence of bytes or a sequence of characters).  This can involve using a <em>hash function</em> to convert the data to a <em>hash code</em> (with at least 24 bits), then taking the lowest 24 bits of the hash code as an 8/8/8 RGB color.  Any such hash function should be designed such that every bit of the input affects every bit of the output without a clear preference for 0 or 1 (the so-called &quot;avalanche&quot; property).</li>
</ul>

<p><a id=Dominant_Colors_of_an_Image></a></p>

<h2>Dominant Colors of an Image</h2>

<p>There are several methods of finding the kind or kinds of colors that appear most prominently in a collection of colors (including a raster image).</p>

<p>One simple way to do so (called <em>averaging</em>) is to add all the RGB colors (or a sample of them) in the collection of colors, then divide the result by the number of pixels added this way. (For RGB colors, adding two colors means adding each of their components individually.)  Note that for best results, this technique needs to be carried out with <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB colors</em></a>.</p>

<p>A second, more complicated technique is called <a href="https://en.wikipedia.org/wiki/Color_quantization"><em>color quantization</em></a>, where the collection of colors is reduced to a small set of colors (for example, ten to twenty).  The quantization algorithm is too complicated to discuss in the document. Again, for best results, color quantization needs to be carried out with <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB colors</em></a>.</p>

<p>A third technique is called <em>histogram binning</em>.  To find the dominant colors using this technique (which is independent of color model):</p>

<ul>
<li>Generate a list of colors that cover the space of colors well.  This is the <em>color palette</em>. A good example is the list of <a href="https://peteroupc.github.io/html3dutil/tutorial-colors.html#What_Do_Some_Colors_Look_Like">&quot;web-safe colors&quot;</a>.</li>
<li>Create a list with as many zeros as the number of colors in the palette.  This is the <em>histogram</em>.</li>
<li>For each color in the collection of colors, find the <a href="#Color_Difference_and_Nearest_Colors">nearest color</a> in the color palette to that pixel&#39;s color, and add 1 to the nearest color&#39;s corresponding value in the histogram.</li>
<li>Find the color or colors in the color palette with the highest histogram values, and return those colors as the dominant colors in the image.</li>
</ul>

<p>For all three techniques, in the case of a raster image, an implementation can resize that image before proceeding to find its dominant colors.  Algorithms to resize or &quot;resample&quot; images are out of scope for this page, however.</p>

<p><strong>Notes:</strong></p>

<ul>
<li>Reducing the number of colors in an image usually involves finding that image&#39;s dominant colors and either&mdash;

<ul>
<li>applying a &quot;nearest neighbor&quot; approach (replacing that image&#39;s colors with their <a href="#Color_Difference_and_Nearest_Colors">nearest dominant colors</a>), or</li>
<li>applying a <a href="https://en.wikipedia.org/wiki/Dither">&quot;dithering&quot;</a> technique (especially to reduce undesirable color &quot;banding&quot; in certain cases), which is outside the scope of this document, however.</li>
</ul></li>
<li>Finding the number of <em>unique</em> colors in an image is equivalent to storing those colors as keys in a hash table, then counting the number of keys stored this way. (How to implement hash tables is beyond the scope of this page.)</li>
</ul>

<p><a id=Color_Mixture></a></p>

<h2>Color Mixture</h2>

<p>In general, mixing colors in a similar way to mixing paint is not as simple as
averaging two colors in an RGB color space or another color space.  In a <a href="http://scottburns.us/subtractive-color-mixture/">Web article</a>, Scott A. Burns (who uses the term <em>subtractive color mixture</em> for this kind of mixing) indicates that two pigments or colors
can be mixed this way by&mdash;</p>

<ul>
<li>finding the <em>reflectance curves</em> of the pigments or colors (a <em>reflectance curve</em> specifies the degree
to which a pigment or color reflects light at each point of the visible spectrum),</li>
<li>generating a mixed reflectance curve by the <em>weighted geometric mean</em> of the source curves, which
takes into account the relative proportions of the colors or pigments in the mixture, and</li>
<li>converting the mixed reflectance curve to an RGB color.</li>
</ul>

<p>This algorithm, though, is too complicated to present in this document.</p>

<p><a id=Color_Maps></a></p>

<h2>Color Maps</h2>

<p>A <em>color map</em> (or <em>color palette</em>) is a list of colors (which are usually related). Note that for best results, each color in a color map needs to be a <a href="#sRGB_and_Linearized_RGB"><em>linearized RGB</em> color</a> rather than a nonlinearized one, but all the colors in a color map can be in any color space.</p>

<ul>
<li>To extract a <strong>continuous color</strong> from an <code>N</code>-color color map given a number 0 or greater and 1 or less (<code>value</code>)&mdash;

<ul>
<li>generate <code>index = (value * (N - 1)) - floor(value * (N - 1))</code>, then</li>
<li>generate <code>color = Lerp3(colormap[index], colormap[index+1], (value * (N - 1)) - index)</code>.</li>
</ul></li>
<li>To extract a <strong>discrete color</strong> from an <code>N</code>-color color map given a number 0 or greater and 1 or less (<code>value</code>),
generate <code>color = colormap[floor(value * (N - 1) + 0.5)]</code>.</li>
<li><p>A <strong>rainbow color map</strong> uses the following <a href="#HSV">HSV</a> colors (<code>numColors</code> in total):</p>

<pre>  list = NewList()
  i = 0
  for i &lt; numColors
    AddItem(list, [i * (pi * 2) / (numColors - 1), 1.0, 1.0])
    i = i + 1
  end
</pre></li>
<li><p>The <a href="http://colorbrewer2.org/"><em>ColorBrewer 2.0</em></a> Web site contains many helpful suggestions for color maps.  The suggested color maps are designed above all to show discrete categories of data on land maps.</p></li>
</ul>

<p><a id=Named_Colors></a></p>

<h3>Named Colors</h3>

<p>If each color in a color map has a name associated with it, the color map is also called a <em>named color list</em>.  Examples of names are &quot;red&quot;, &quot;blue&quot;, and &quot;orange&quot;.  In general, lists of named colors are outside the scope of this document, but some of them are discussed in some detail in my <a href="https://peteroupc.github.io/html3dutil/tutorial-colors.html#What_Do_Some_Colors_Look_Like">colors tutorial for the HTML 3D Library</a>.  Although names are usually associated with RGB colors, the colors can be in any color space.</p>

<p>Converting a color (such as an RGB color) to a color name is equivalent to&mdash;</p>

<ul>
<li>retrieving the name keyed to that color in a hash table, or returning an error if that color doesn&#39;t exist in the hash table, or</li>
<li>finding the <a href="#Color_Difference_and_Nearest_Colors">nearest color</a> to that color among the named colors, and returning the color found this way (and/or that color&#39;s name).</li>
</ul>

<p>Converting a color name to a color is equivalent to retrieving the color keyed to that name in a hash table, or returning an error if that name (or optionally, its lower-cased form) doesn&#39;t exist in the hash table.</p>

<p><strong>Note:</strong> As used in the <a href="http://www.w3.org/TR/css3-color/">CSS color module level 3</a>, for example, named colors defined in that module are in the (nonlinearized) <a href="#sRGB_and_Linearized_RGB"><em>sRGB color space</em></a>.</p>

<p><a id=Visually_Distinct_Colors></a></p>

<h3>Visually Distinct Colors</h3>

<p>Color maps can be used to list colors used to identify different items. Because of this
use, many applications need to use colors that are easily distinguishable by humans.  In this respect&mdash;</p>

<ul>
<li>K. Kelly (1965) proposed a list of &quot;twenty two colors of maximum contrast&quot;<sup><a href="#Note7">(7)</a></sup>, the first nine of which
were intended for readers with normal and defective color vision, and</li>
<li>R. Boynton (1989) revealed a list of &quot;eleven colors that are almost never confused&quot;, namely,
black, white, gray, magenta, pink, red, green, blue, yellow, orange, and brown.</li>
</ul>

<p>In general, more than 22 colors (the number of colors in Kelly&#39;s list) are hard to distinguish from each other.
Any application that needs to distinguish more than 22 items should use other means in addition to color
(or rather than color) to help users identify them. (Note that under the
<a href="https://www.w3.org/TR/2008/REC-WCAG20-20081211/">Web Content Accessibility Guidelines 2.0</a>,
color should generally not be the only means to call attention to information.)</p>

<p>In general, any method that seeks to choose colors that are maximally distant in a particular
color space (that is, where the smallest color difference, or <code>COLORDIFF</code>,
between them is maximized as much as feasible) can be used to select visually
distinct colors.  Such colors can be pregenerated or generated at runtime.</p>

<p>The following method can be used to generate a color map of randomly generated
distinguishable RGB colors; <code>numColors</code> is the number of colors to generate. <code>MINDIST</code> is the
minimum distance between colors that should be attempted; for
RGB colors in 0-1 format, this value should be about 0.2.</p>

<pre>METHOD RandomColorList(numColors)
    list = NewList()
    attempts = 0
    while size(list) &lt; numColors
        // Generate a random RGB color
        color = [RNDU01(), RNDU01(), RNDU01()]
        dist = 0
        j = 0
        while j &lt; size(list)
            newdist = COLORDIFF(list[j], color)
            if newdist &lt; dist or j == 0: newdist = dist
            j = j + 1
        end
        if dist &gt; MINDIST or size(list) == 0 or attempts &gt; 500
           AddItem(list, color)
     attempts=0
        end
    end
    return list
END METHOD
</pre>

<p><a id=Other_Color_Topics></a></p>

<h2>Other Color Topics</h2>

<p>This section discusses miscellaneous topics related to colors.</p>

<p><a id=Colorblindness></a></p>

<h3>Colorblindness</h3>

<p>What is generally known as <a href="https://en.wikipedia.org/wiki/Color_blindness">&quot;colorblindness&quot;</a> results from a lack of one or more cones in the retina of each eye and affects a small portion of people, usually males.</p>

<p>Each human retina usually has three kinds of cones (L, M, and S), and eyes sense different colors by the relative degree to which all three kinds of cones respond to a light stimulus.  Usually, at least two of these three kinds of cones will respond to light this way.  The most common forms of colorblindness, <em>protanopia</em> and <em>deuteranopia</em>, result from a lack of the L or M cones, respectively, so that for a person with either condition, colors where the S and M or S and L cones, respectively, respond similarly (usually magenta-red and green-cyan hues) are harder to distinguish.</p>

<p>However, &quot;effective luminance contrast [that is, <a href="#Luminance_Grayscale">color contrast</a>] can generally be computed without regard to specific color deficiency, except for the use of predominantly long wavelength colors [such as magenta and red] against darker colors ... for [people with] protanopia&quot; (see &quot;<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">Understanding WCAG 2.0</a>&quot;).</p>

<p><a id=Terminal_Colors></a></p>

<h3>Terminal Colors</h3>

<p>Some command-line shells support coloring the background or foreground of text.  In shells that support <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI color codes</a> (generally in the category &quot;select graphic rendition&quot;, or SGR), the sequence U+001B (escape character) followed by &quot;[&quot; followed by a semicolon-separated sequence of numbers (given below) followed by &quot;m&quot; is a graphic control sequence:</p>

<ul>
<li>&quot;0&quot;: Reset the foreground and background color and other graphic properties to default.  (U+001B followed by &quot;[m&quot; has the same effect.)</li>
<li>&quot;1&quot;: Set the color of the following text in bold.</li>
<li>&quot;2&quot;: Use a slightly dimmer foreground color than usual.</li>
<li>&quot;3&quot;: Set the color of the following text in italics.</li>
<li>&quot;4&quot;: Set the color of the following text underlined.</li>
<li>&quot;7&quot;: Reverse the meaning of &quot;foreground&quot; and &quot;background&quot; in the following text.</li>
<li>&quot;8&quot;: Hide text while still taking up space.</li>
<li>&quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;27&quot;, &quot;28&quot;: Turns off the feature mentioned earlier in &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;7&quot;, or &quot;8&quot;, respectively.</li>
<li>&quot;3&quot; followed by one of the <em>color numbers</em> below: Dimmer foreground color.</li>
<li>&quot;4&quot; followed by color number: Dimmer background color.</li>
<li>&quot;10&quot; followed by color number: Brighter foreground color.</li>
<li>&quot;11&quot; followed by color number: Brighter background color.</li>
</ul>

<p>The <em>color number</em> is one of the following, whose RGB color value can vary with the implementation: &quot;0&quot; (black), &quot;1&quot; (red), &quot;2&quot; (green), &quot;3&quot; (yellow), &quot;4&quot; (blue), &quot;5&quot; (magenta), &quot;6&quot; (cyan), or &quot;7&quot; (white).  Note that not all shells support all the ANSI SGR codes given here.</p>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>This page discussed many topics on color that are generally relevant in programming.</p>

<p>If there is interest, the following topics may be discussed in future versions of this document:</p>

<ul>
<li>Getting the RGBA color for a given RGB color on a given RGB background.</li>
<li>Spectrum curves to RGB colors.</li>
</ul>

<p>Feel free to send comments. They may help improve this page.  In particular, corrections to any method given on
this page are welcome.</p>

<p>I acknowledge the CodeProject user Mike-MadBadger, who suggested additional clarification on color spaces and color models.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><sup id=Note1>(1)</sup> The base-16 digits, in order, are 0 through 9, followed by A through F. The digits A to F can be uppercase or lowercase.</p>

<p><sup id=Note2>(2)</sup> Working spaces other than sRGB (such as Adobe RGB and NTSC), as well as how to convert between RGB working spaces, are not discussed in detail in this document.  B. Lindbloom, &quot;<a href="http://www.brucelindbloom.com/index.html?WorkingSpaceInfo.html">RGB Working Space Information</a>&quot;, contains further information on RGB working spaces.</p>

<p><sup id=Note3>(3)</sup> J. Novak, in &quot;<a href="http://blog.johnnovak.net/2016/09/21/what-every-coder-should-know-about-gamma/">What every coder should know about gamma</a>&quot;, uses the terms <em>physically linear</em> and <em>perceptually linear</em> to refer to what are called <em>linearized</em> and <em>nonlinearized</em> RGB color spaces, respectively, in this document.</p>

<p><sup id=Note4>(4)</sup> For nonlinearized sRGB 8/8/8 colors this is effectively equivalent to <code>BT709(LinearFromsRGB3(From888(color)))</code>.  Note that the guidelines use a different version of <code>LinearFromsRGB</code>, with 0.03928 (the value used in the sRGB proposal) rather than 0.04045, but this difference doesn&#39;t affect the result for such 8/8/8 colors.  <code>RelLum(color)</code> is equivalent to <a href="#Luminance_Grayscale"><code>Luminance(color)</code></a> whenever conformance to the guidelines is not important.</p>

<p><sup id=Note5>(5)</sup> A very rough approximation of an RGB color (<code>color</code>) to a CMYK color involves generating <code>k = Min(1.0 - color[0], 1.0 - color[1], 1.0 - color[2])</code>, then generating <code>[0, 0, 0, 1]</code> if <code>k</code> is 1, or <code>[((1.0 - color[0]) - k) / (1 - k), ((1.0 - color[2]) - k) / (1 - k), ((1.0 - color[2]) - k) / (1 - k), k]</code> otherwise.  A very rough approximation of a CMYK color (<code>color</code>) to an RGB color involves generating <code>[(1 - color[0]) * ik, (1 - color[1]) * ik, (1 - color[2]) * ik]</code>, where <code>ik = 1 - color[3]</code>.</p>

<p><sup id=Note6>(6)</sup> A <a href="http://www.w3.org/TR/2016/WD-css-color-4-20160705/#hex-notation">Working Draft</a> of the CSS Color Module Level 4 mentions two additional formats, namely&mdash;</p>

<ul>
<li>an 8-digit format, consisting of &quot;#&quot; followed by two base-16 digits each for the red, green, blue, and alpha components, respectively, and</li>
<li>a 4-digit format, consisting of &quot;#&quot; followed by one base-16 digit each for the red, green, blue, and alpha components, respectively (where, for example, &quot;#345F&quot; is the same as &quot;#334455FF&quot; in the 8-digit format).</li>
</ul>

<p><sup id=Note7>(7)</sup> An approximation of the colors to nonlinearized sRGB, in order, is (in HTML color format): &quot;#F0F0F1&quot;, &quot;#181818&quot;, &quot;#F7C100&quot;, &quot;#875392&quot;, &quot;#F78000&quot;, &quot;#9EC9EF&quot;, &quot;#C0002D&quot;, &quot;#C2B280&quot;, &quot;#838382&quot;, &quot;#008D4B&quot;, &quot;#E68DAB&quot;, &quot;#0067A8&quot;, &quot;#F99178&quot;, &quot;#5E4B97&quot;, &quot;#FBA200&quot;, &quot;#B43E6B&quot;, &quot;#DDD200&quot;, &quot;#892610&quot;, &quot;#8DB600&quot;, &quot;#65421B&quot;, &quot;#E4531B&quot;, &quot;#263A21&quot;. The list was generated by converting the Munsell renotations (and a similar renotation for black) to sRGB using the Python <code>colour-science</code> package.</p>

<p><sup id=Note8>(8)</sup> P. Haeberli, <a href="http://www.graficaobscura.com/matrix/index.html">&quot;Matrix Operations for Image Processing&quot;</a>, 1993.  The hue rotation matrix given was generated using the technique in the section &quot;Hue Rotation While Preserving Luminance&quot;, with constants rounded to five significant digits and with <code>rwgt=0.2126</code>, <code>gwgt=0.7152</code>, and <code>bwgt = 0.0722</code>, the sRGB capital-Y values for the red, green, and blue primaries.</p>

<p><sup id=Note9>(9)</sup> B. Crow, <a href="https://blogs.msdn.microsoft.com/billcrow/2007/10/25/hdr-and-color-spaces/">&quot;HDR and Color Spaces&quot;</a>.  According to that article, the <em>scRGB</em> color profile was created because &quot;other color profiles ... rel[ied] on unsigned integers&quot; to define colors, and scRGB&#39;s floating-point format is supposedly intended to &quot;allow color values that are beyond the gamut limits&quot; of the sRGB color space.</p>

<p><sup id=Note10>(10)</sup> Although most electronic color displays used three dots per pixel (red, green, and blue), this may hardly be the case today.  Nowadays, recent electronic displays are likely to use four dots per pixel (red, green, blue, and white, or RGBW), and color spaces following the <em>RGBW color model</em> describe, roughly, the intensity those four dots should have in order to reproduce a given color.  Such color spaces, though, are not yet of practical interest to most programmers outside of display hardware and display driver development.</p>

<p><sup id=Note11>(11)</sup> Although the L*a*b* color model is also often called &quot;perceptually uniform&quot;, it wasn&#39;t designed that way, according to <a href="http://www.brucelindbloom.com/index.html?UPLab.html">B. Lindbloom</a>.</p>

<p><sup id=Note12>(12)</sup> This is often called the &quot;CMY&quot; (cyan-magenta-yellow) version of the RGB color, (although the resulting color is not necessarily a proportion of cyan, magenta, and yellow inks; see also &quot;<a href="#CMYK">CMYK</a>&quot;).  If such an operation is used, the conversions between &quot;CMY&quot; and RGB are exactly the same.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero</a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
