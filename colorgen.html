<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Color Topics for Programmers</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Color Topics for Programmers</h1>

<p><a href="mailto:poccil14@gmail.com">Peter Occil</a></p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This document presents an overview of many common color topics that are of general interest to programmers and that can be implemented in many different programming languages. <strong><a href="https://peteroupc.github.io/colorutil.py">Sample Python code</a> that implements many of the methods in this document is available.</strong>  <a href="https://peteroupc.github.io/suppcolor.html">Supplemental topics</a> are listed in another open-source page.</p>

<p><strong>Topics this document covers include:</strong></p>

<ul>
<li>Red-green-blue (RGB) and other color models of practical interest.</li>
<li>How to generate colors with certain properties.</li>
<li>Color differences, color maps, and color mixing.</li>
<li>Dominant colors of an image.</li>
<li>Colors as spectral curves.</li>
</ul>

<p><strong>This document does not cover:</strong></p>

<ul>
<li>How to change or set colors used&mdash;

<ul>
<li>in text, foregrounds, or backgrounds of user interface elements (such as buttons, text boxes, and windows),</li>
<li>in text or backgrounds of documents (such as HTML documents), or</li>
<li>when generating graphics (such as plots and charts).</li>
</ul></li>
<li>Determining which colors are used, or used by default, in user interface elements or documents.</li>
<li>Color pickers, including how to choose colors with them.</li>
<li>Specifics on setting and getting pixel, palette, and other colors in images (including screenshots) with the exception of finding dominant colors.</li>
<li>Colorization of command line outputs, or terminal or shell outputs. <a href="https://peteroupc.github.io/suppcolor.html#Terminal_Graphics">ANSI graphic codes</a> are discussed elsewhere.</li>
<li>In general, topics that are specific to a programming language or application programming interface.</li>
</ul>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Contents">Contents</a></li>
<li><a href="#Notation_and_Definitions">Notation and Definitions</a></li>
<li><a href="#Specifying_Colors">Specifying Colors</a></li>
<li><a href="#RGB_Color_Model">RGB Color Model</a>

<ul>
<li><a href="#RGB_Integer_Formats">RGB Integer Formats</a></li>
<li><a href="#HTML_Related_Color_Formats">HTML-Related Color Formats</a></li>
<li><a href="#Linear_RGB_and_Companded_RGB">Linear RGB and Companded RGB</a></li>
<li><a href="#sRGB">sRGB</a></li>
</ul></li>
<li><a href="#Other_Color_Models">Other Color Models</a>

<ul>
<li><a href="#HSV">HSV</a></li>
<li><a href="#HSL">HSL</a></li>
<li><a href="#HWB">HWB</a></li>
<li><a href="#CIE_XYZ">CIE XYZ</a>

<ul>
<li><a href="#Chromaticity_Coordinates">Chromaticity Coordinates</a></li>
</ul></li>
<li><a href="#CIELAB">CIELAB</a></li>
<li><a href="#CIELUV">CIELUV</a></li>
<li><a href="#Y_prime_C_B_C_R">Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub></a></li>
<li><a href="#CMYK_and_Other_Ink_Mixture_Color_Models">CMYK and Other Ink-Mixture Color Models</a></li>
</ul></li>
<li><a href="#Modifying_Existing_Colors">Modifying Existing Colors</a>

<ul>
<li><a href="#Relative_Luminance_Grayscale">Relative Luminance (Grayscale)</a></li>
<li><a href="#Color_Schemes">Color Schemes</a></li>
<li><a href="#Alpha_Blending">Alpha Blending</a></li>
<li><a href="#Porter_ndash_Duff_Formulas">Porter&ndash;Duff Formulas</a></li>
<li><a href="#Blend_Modes">Blend Modes</a></li>
<li><a href="#Color_Matrices">Color Matrices</a></li>
<li><a href="#Miscellaneous">Miscellaneous</a></li>
</ul></li>
<li><a href="#Color_Differences">Color Differences</a>

<ul>
<li><a href="#Nearest_Colors">Nearest Colors</a></li>
</ul></li>
<li><a href="#Dominant_Colors_of_an_Image">Dominant Colors of an Image</a></li>
<li><a href="#Color_Maps">Color Maps</a>

<ul>
<li><a href="#Kinds_of_Color_Maps">Kinds of Color Maps</a></li>
<li><a href="#Color_Collections">Color Collections</a></li>
<li><a href="#Visually_Distinct_Colors">Visually Distinct Colors</a></li>
<li><a href="#Pseudocode">Pseudocode</a></li>
</ul></li>
<li><a href="#Generating_a_Random_Color">Generating a Random Color</a></li>
<li><a href="#Spectral_Color_Functions">Spectral Color Functions</a>

<ul>
<li><a href="#Color_Temperature">Color Temperature</a></li>
<li><a href="#Color_Mixture">Color Mixture</a></li>
</ul></li>
<li><a href="#Conclusion">Conclusion</a>

<ul>
<li><a href="#Questions_for_This_Document">Questions for This Document</a></li>
</ul></li>
<li><a href="#Notes">Notes</a></li>
<li><a href="#License">License</a></li>
</ul>

<p><a id=Notation_and_Definitions></a></p>

<h2>Notation and Definitions</h2>

<ul>
<li>The <a href="https://peteroupc.github.io/pseudocode.html"><strong>pseudocode conventions</strong></a> apply to this document.</li>
<li><strong>CIE.</strong> French initials for the International Commission on Illumination.</li>
<li><strong>Color model.</strong> Describes, in general terms, the relationship of colors in a theoretical space.</li>
<li><strong>Color space.</strong> A mapping from colors to numbers that follows a particular color model.</li>
<li><strong>D50 illuminant.</strong> CIE illuminant that approximates sunrise daylight (correlated color temperature about 5000 kelvins).</li>
<li><strong>D50 white point.</strong> The white point determined by the D50 illuminant and the CIE 1931 standard observer.</li>
<li><strong>D65 illuminant.</strong> CIE illuminant that approximates noon daylight (correlated color temperature about 6500 kelvins).<sup><a href="#Note1">(1)</a></sup></li>
<li><strong>D65 white point.</strong> The white point determined by the D65 illuminant and the CIE 1931 standard observer.</li>
<li><strong>IEC.</strong> International Electrotechnical Commission.</li>
<li><strong>ISO.</strong> International Organization for Standardization.</li>
<li><strong>ITU.</strong> International Telecommunications Union.</li>
<li><strong>Light source.</strong> Means a <a href="http://eilv.cie.co.at/term/982"><em>primary light source</em></a> or an <a href="http://eilv.cie.co.at/term/554"><em>illuminant</em></a>, as defined by the CIE.  Roughly means an emitter of light, or radiation describing an emitter of light.</li>
<li><strong>RGB.</strong> Red-green-blue.</li>
<li><strong><code>RNDNUMRANGE</code>, <code>RNDU01</code>, <code>RNDINT</code>, <code>RNDINTEXC</code>.</strong> These methods are defined in my article on <a href="https://peteroupc.github.io/randomfunc.html">random number generation methods</a>.</li>
<li><strong>SPD.</strong> Spectral power distribution.</li>
</ul>

<p><a id=Specifying_Colors></a></p>

<h2>Specifying Colors</h2>

<p>A color can be specified in one of two ways:</p>

<ul>
<li><strong>As a point in space</strong>, that is, as a small set of numbers (usually three numbers) showing where the color lies in a color space. This is what mostly happens in practice. Some color spaces include the following:

<ul>
<li><a href="#RGB_Color_Model">RGB</a> color spaces describe proportions of red, green, and blue dots of light.</li>
<li><a href="#HSV">HSV</a>, <a href="#HSL">HSL</a>, and <a href="#HWB">HWB</a> color spaces transform RGB colors to make their presentation more intuitive, but are not perception-based.</li>
<li><a href="#CIE_XYZ">XYZ</a>, <a href="#CIELAB">CIELAB</a>, and <a href="#CIELUV">CIELUV</a> color spaces are based on human color perception.</li>
<li><a href="#CMYK_and_Other_Ink_Mixture_Color_Models">CMYK</a> color spaces are especially used to describe proportions of four specific kinds of ink.</li>
<li><a href="#Y_prime_C_B_C_R">Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub></a> color spaces are especially used in video encoding.</li>
</ul></li>
<li><strong>As a <em>spectral curve</em></strong>, which gives the behavior of light across the electromagnetic spectrum (see &quot;<a href="#Spectral_Color_Functions">Spectral Color Functions</a>&quot;).  Colors given as spectral curves, unlike colors in RGB or other color spaces, have the advantage that they are not specific to a lighting condition, whereas colors in a given color space assume a specific lighting, viewing, or printing condition.</li>
</ul>

<p><a id=RGB_Color_Model></a></p>

<h2>RGB Color Model</h2>

<p>The <strong>red-green-blue (RGB) color model</strong> is the most commonly seen color model in mainstream computer programming.</p>

<p>The RGB model is ideally based on the intensity that red, green, and blue dots of light should have in order to reproduce certain colors on electronic displays.<sup><a href="#Note2">(2)</a></sup> The RGB model is a cube with one vertex set to black, the opposite vertex set to white, and the remaining vertices set to red, green, blue, cyan, yellow, and magenta.</p>

<p><strong>RGB color spaces</strong> generally differ in their red, green, blue, and white points<sup><a href="#Note3">(3)</a></sup> as well as in their <a href="#Linear_RGB_and_Companded_RGB"><em>color component transfer functions</em></a>.</p>

<p>An <strong>RGB color</strong> (in a given RGB color space) consists of&mdash;</p>

<ul>
<li>a <code>red</code> component,</li>
<li>a <code>green</code> component, and</li>
<li>a <code>blue</code> component,</li>
</ul>

<p>in that order, and each component is 0 or greater and 1 or less. (In this document, this format is called the  <strong>0-1 format</strong> and all RGB colors are in this format unless noted otherwise.)</p>

<p><strong>RGBA Colors:</strong> Some RGB colors also contain a fourth component, called the <em>alpha component</em>, which is 0 greater and 1 or less (from fully transparent to fully opaque). Such RGB colors are called <em>RGBA colors</em> in this document.  RGB colors without an alpha component are generally considered to be fully opaque (and to have an implicit alpha component of 1).</p>

<blockquote>
<p><strong>Note:</strong> An RGB color&mdash;</p>

<ul>
<li>is white, black, or a shade of gray (<em>achromatic</em>) if it has equal red, green, and blue components, and</li>
<li>is a <a href="http://en.wikipedia.org/wiki/Web_colors">&quot;Web safe&quot; color</a> if its red, green, and blue components are each a multiple of 0.2.</li>
</ul>

<p>A raster image (or other color content data) is achromatic or &quot;Web safe&quot; if all the colors it uses are achromatic or &quot;Web safe&quot;, respectively.</p>
</blockquote>

<p><a id=RGB_Integer_Formats></a></p>

<h3>RGB Integer Formats</h3>

<p>RGB and RGBA colors are often expressed by packing their components as integers. This document recognizes two general categories of RGB integer formats:</p>

<ul>
<li><strong>RN/GN/BN format:</strong> With an RN-bit red component, a GN-bit green, and a BN-bit blue, resulting in an integer that&#39;s (RN + GN + BN) bits long.</li>
<li><strong>RN/GN/BN/AN format:</strong> With an RN-bit red component, a GN-bit green, a BN-bit blue, and an AN-bit alpha, resulting in an integer that&#39;s (RN + GN + BN + AN) bits long.</li>
</ul>

<p>For both format categories, the lowest value of each component is 0, and its highest value is 2<sup>B</sup> - 1, where B is that component&#39;s size in bits.</p>

<p>The following are examples of these formats:</p>

<ul>
<li><strong>5/5/5 format:</strong> As 15-bit integers (5 bits per component).</li>
<li><strong>5/6/5 format:</strong> As 16-bit integers (5 bits each for red and blue, and 6 bits for green).</li>
<li><strong>8/8/8 format:</strong> As 24-bit integers (8 bits per component).</li>
<li><strong>10/10/10 format:</strong> As 30-bit integers (10 bits per component).</li>
<li><strong>8/8/8/8 format:</strong> As 32-bit integers (8 bits each for red, green, blue, and alpha).</li>
<li><strong>16/16/16 format:</strong> As 48-bit integers (16 bits per component).</li>
</ul>

<p>There are many ways to store RGB and RGBA colors in these formats as integers or as a series of bytes.  For example, the RGB color&#39;s components can be in &quot;little endian&quot; or &quot;big endian&quot; byte order, or RN/GN/BN colors can be packed red/green/blue, in that order from lowest to highest bits, or in a different order of those components.  A thorough survey of the integer color formats in common use is outside the scope of this document.</p>

<p>The following pseudocode contains methods for converting RGB colors to and from different color formats (where RGB color integers are packed red/green/blue, in that order from lowest to highest bits):</p>

<pre>// Converts 0-1 format to N/N/N format as an integer.
METHOD ToNNN(rgb, scale)
   sm1 = scale - 1
   return round(rgb[2]*sm1) * scale * scale + round(rgb[1]*sm1) * scale +
         round(rgb[0]*sm1)
END METHOD

// Converts N/N/N integer format to 0-1 format
METHOD FromNNN(rgb, scale)
   sm1 = scale - 1
   r = mod(rgb, scale)
   g = mod(floor(rgb / scale), scale)
   b = mod(floor(rgb / (scale * scale)), scale)
   return [ r / sm1, g / sm1, b / sm1]
END METHOD

METHOD To444(rgb): return ToNNN(rgb, 16)
METHOD To555(rgb): return ToNNN(rgb, 32)
METHOD To888(rgb): return ToNNN(rgb, 256)
METHOD To161616(rgb): return ToNNN(rgb, 65536)
METHOD From444(rgb): return FromNNN(rgb, 16)
METHOD From555(rgb): return FromNNN(rgb, 32)
METHOD From888(rgb): return FromNNN(rgb, 256)
METHOD From161616(rgb): return FromNNN(rgb, 65536)

METHOD To565(rgb, scale)
   return round(rgb[2] * 31) * 32 * 64 + round(rgb[1] * 63) * 32 +
         round(rgb[0] * 31)
END METHOD

METHOD From565(rgb, scale)
   r = mod(rgb, 32)
   g = mod(floor(rgb / 32.0), 64)
   b = mod(floor(rgb / (32.0 * 64.0)), 32)
   return [ r / 31.0, g / 63.0, b / 31.0]
END METHOD
</pre>

<p><a id=HTML_Related_Color_Formats></a></p>

<h3>HTML-Related Color Formats</h3>

<p>A color string in the <strong>HTML color format</strong> (also known as &quot;hex&quot; format), which expresses RGB colors in 8/8/8 format as text strings, consists of&mdash;</p>

<ol>
<li>the character &quot;#&quot;, followed by</li>
<li>six base-16 (hexadecimal) digits<sup><a href="#Note4">(4)</a></sup>, two each for the red, green, and blue components, in that order.</li>
</ol>

<p>For example, the HTML color <code>#003F86</code> expresses the RGB color whose red, green, and blue components in 8/8/8 format are (0, 63, 134).</p>

<p>Other variants of the HTML color format<sup><a href="#Note5">(5)</a></sup>:</p>

<ul>
<li>The <a href="https://www.w3.org/TR/css3-color/#rgb-color">CSS Color Module Level 3</a>, which specifies this format, also mentions a <strong>3-digit variant</strong>, consisting of &quot;#&quot; followed by three base-16 digits, one each for the red, green, and blue components, in that order. Conversion to the 6-digit format involves replicating each base-16 component (for example, &quot;#345&quot; is the same as &quot;#334455&quot; in the 6-digit format).</li>
<li>An <strong>8-digit variant</strong> used in the Android operating system consists of &quot;#&quot; followed by eight base-16 digits, two each for the alpha, red, green, and blue components, in that order.  This variant thus describes 8/8/8/8 RGBA colors.</li>
</ul>

<p>The following pseudocode presents methods to convert RGB colors to and from the HTML color format or the 3-digit variant.</p>

<pre>METHOD NumToHex(x)
    if hex &lt; 0 or hex &gt;= 16: return error
    hexlist=[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;]
    return hexlist[x]
END METHOD

METHOD HexToNum(x)
    hexlist=[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;]
    hexdown=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
    i = 0
    while i &lt; 16
            if hexlist[i] == x: return i
            i = i + 1
    end
    i = 0
    while i &lt; 6
            if hexdown[i] == x: return 10 + i
            i = i + 1
    end
    return -1
END METHOD

METHOD ColorToHtml(rgb)
   r = round(rgb[0] * 255)
   g = round(rgb[1] * 255)
   b = round(rgb[2] * 255)
   return [&quot;#&quot;,
     NumToHex(mod(floor(r/16),16)), NumToHex(mod(r, 16)),
     NumToHex(mod(floor(g/16),16)), NumToHex(mod(g, 16)),
     NumToHex(mod(floor(b/16),16)), NumToHex(mod(b, 16)),
   ]
END METHOD

METHOD HtmlToColor(colorString)
    if string[0]!=&quot;#&quot;: return error
    if size(colorString)==7
            r1=HexToNum(colorString[1])
            r2=HexToNum(colorString[2])
            g1=HexToNum(colorString[3])
            g2=HexToNum(colorString[4])
            b1=HexToNum(colorString[5])
            b2=HexToNum(colorString[6])
            if r1&lt;0 or r2&lt;0 or g1&lt;0 or g2&lt;0 or
                    b1&lt;0 or b2&lt;0: return error
            return [(r1*16+r2)/255.0,
                    (g1*16+g2)/255.0,
                    (b1*16+b2)/255.0]
    end
    if size(colorString)==4
            r=HexToNum(colorString[1])
            g=HexToNum(colorString[2])
            b=HexToNum(colorString[3])
            if r&lt;0 or g&lt;0 or b&lt;0: return error
            return [(r*16+r)/255.0,
                    (g*16+g)/255.0,
                    (b*16+b)/255.0]
    end
    return error
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> As used in the <a href="http://www.w3.org/TR/css3-color/">CSS color module level 3</a>, for example, colors in the HTML color format or its 3-digit variant are in the <a href="#sRGB"><em>sRGB color space</em></a> (as companded colors).</p>
</blockquote>

<p><a id=Linear_RGB_and_Companded_RGB></a></p>

<h3>Linear RGB and Companded RGB</h3>

<p>In a given RGB color space:</p>

<ul>
<li>A <em>linear</em> RGB color has a linear relationship of emitted light (as opposed to perceived light).</li>
<li>A <em>companded</em> RGB color has been encoded using that color space&#39;s <em>color component transfer function</em>, also known as <em>companding</em> (one example is the <code>LinearTosRGB3</code> method <a href="#sRGB">defined later</a>). For many RGB color spaces, companded RGB colors have a more or less linear relationship of perceived light, since human color perception is nonlinear.  RGB colors encoded in images and video or specified in documents are usually in companded form.</li>
</ul>

<p>For many RGB color spaces (but not sRGB, described below), the <em>color component transfer function</em> is a simple power function, such as <em>c</em><sup>1/<em>&gamma;</em></sup>, where <em>c</em> is the red, green, or blue component and <em>&gamma;</em> is a positive number. (In this case, that function is also called <em>gamma encoding</em>.)</p>

<p>In this document, all techniques involving RGB colors apply to such colors in linear or companded form, unless noted otherwise.</p>

<p><a id=sRGB></a></p>

<h3>sRGB</h3>

<p>Among RGB color spaces, one of the most popular is the <em>sRGB color space</em>, a &quot;working space&quot; for describing RGB colors.  In sRGB&mdash;</p>

<ul>
<li>the red, green, and blue points were chosen to cover the range of colors displayed by typical cathode-ray-tube displays (as in the high-definition standard ITU BT-709),</li>
<li>the white point was chosen as the D65 white point, and</li>
<li>the color component transfer function was designed to be based on the gamma encoding used for cathode-ray-tube monitors.</li>
</ul>

<p>For background, see the <a href="https://www.w3.org/Graphics/Color/sRGB">sRGB proposal</a>.<sup><a href="#Note6">(6)</a></sup> The proposal recommends RGB image data in an unidentified RGB color space to be treated as sRGB.</p>

<p>The following methods convert colors between linear and companded sRGB.
(Note that the threshold <code>0.0031308</code> is that of IEC 61966-2-1, the official sRGB standard;
the sRGB proposal has a different value for this threshold.)</p>

<pre>// Convert a color component from companded to linear RGB
// NOTE: This is not gamma decoding; it&#39;s similar to, but
// not exactly, c^2.2.  This function was designed &quot;to
// allow for invertability in integer math&quot;, according to
// the sRGB proposal.
METHOD LinearFromsRGB(c)
 // NOTE: Threshold here would more properly be
 // 12.92 * 0.0031308 = 0.040449936, but I don&#39;t know
 // whether that is what the IEC standard uses, either explicitly
 // or implicitly (see the &quot;Conclusion&quot; on this page).
  if c &lt;= 0.04045: return c / 12.92
  return pow((0.055 + c) / 1.055, 2.4)
END METHOD

// Convert a color component from linear to companded sRGB
// NOTE: This is not gamma encoding; it&#39;s similar to, but
// not exactly, c^(1/2.2).
METHOD LinearTosRGB(c)
  if c &lt;= 0.0031308: return 12.92 * c
  return pow(c, 1.0 / 2.4) * 1.055 - 0.055
END METHOD

// Convert a color from companded to linear RGB
METHOD LinearFromsRGB3(c)
   return [LinearFromsRGB(c[0]), LinearFromsRGB(c[1]), LinearFromsRGB(c[2])]
END METHOD

// Convert a color from linear to companded sRGB
METHOD LinearTosRGB3(c)
   return [LinearTosRGB(c[0]), LinearTosRGB(c[1]), LinearTosRGB(c[2])]
END METHOD
</pre>

<p><a id=Other_Color_Models></a></p>

<h2>Other Color Models</h2>

<p>The following sections discuss several color models, other than RGB, that are of practical interest.</p>

<p><a id=HSV></a></p>

<h3>HSV</h3>

<p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV</a>  (also known as HSB) is a color model that transforms RGB colors to make them easier to manipulate and reason with.  An HSV color consists of three components, in the following order:</p>

<ul>
<li><em>Hue</em> is an angle from red at 0 to yellow to green to cyan to blue to magenta to red.<sup><a href="#Note7">(7)</a></sup></li>
<li>A component called &quot;saturation&quot;, the distance of the color from gray and white (but not necessarily from black),
is 0 or greater and 1 or less.</li>
<li>A component variously called &quot;value&quot; or &quot;brightness&quot; is the distance of the color from black and is 0 or greater and 1 or less.</li>
</ul>

<p>The following pseudocode converts colors between RGB and HSV.
The transformation is independent of RGB color space, but should be done using <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a>.</p>

<pre>METHOD RgbToHsv(rgb)
    mx = max(max(rgb[0], rgb[1]), rgb[2])
    mn = min(min(rgb[0], rgb[1]), rgb[2])
    // NOTE: &quot;Value&quot; is the highest of the
    // three components
    if mx==mn: return [0,0,mx]
    s=(mx-mn)/mx
    h=0
    if rgb[0]==mx
            h=(rgb[1]-rgb[2])/(mx-mn)
    else if rgb[1]==mx
            h=2+(rgb[2]-rgb[0])/(mx-mn)
    else
            h=4+(rgb[0]-rgb[1])/(mx-mn)
    end
    if h &lt; 6: h = 6 - mod(-h, 6)
    if h &gt;= 6: h = mod(h, 6)
    return [h * (pi / 3), s, mx]
END METHOD

METHOD HsvToRgb(hsv)
    hue=hsv[0]
    sat=hsv[1]
    val=hsv[2]
    if hue &lt; 0: hue = pi * 2 - mod(-hue, pi * 2)
    if hue &gt;= pi * 2: hue = mod(hue, pi * 2)
    hue60 = hue * 3 / pi
    hi = floor(hue60)
    f = hue60 - hi
    c = val * (1 - sat)
    a = val * (1 - sat * f)
    e = val * (1 - sat * (1 - f))
    if hi == 0: return [val, e, c]
    if hi == 1: return [a, val, c]
    if hi == 2: return [c, val, e]
    if hi == 3: return [c, a, val]
    if hi == 4: return [e, c, val]
    return [val, c, a]
END METHOD
</pre>

<p>In the rest of this document&mdash;</p>

<ul>
<li><strong><code>HSVHue(color)</code></strong> is the HSV &quot;hue&quot; component of a color, that is, <code>RgbToHsv(color)[0]</code>,</li>
<li><strong><code>HSVSat(color)</code></strong> is the HSV &quot;saturation&quot; component of a color, that is, <code>RgbToHsv(color)[1]</code>, and</li>
<li><strong><code>HSVVal(color)</code></strong> is the HSV &quot;brightness&quot; or &quot;value&quot; component of a color, that is, <code>RgbToHsv(color)[2]</code>.</li>
</ul>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>In most applications, hue is in degrees and is 0 or greater and less than 360.</li>
<li>The HSV color model is not perception-based, as acknowledged in (Smith and Lyons 1996).</li>
</ul>
</blockquote>

<p><a id=HSL></a></p>

<h3>HSL</h3>

<p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSL</a> (also known as HLS), like HSV, is a color model that transforms RGB colors to ease intuition.  An HSL color consists of three components, in the following order:</p>

<ul>
<li><em>Hue</em> is the same for a given RGB color as in <a href="#HSV">HSV</a>.</li>
<li>A component called &quot;saturation&quot; is the distance of the color from gray (but not necessarily from
black or white), which is 0 or greater and 1 or less.</li>
<li>A component variously called &quot;lightness&quot;, &quot;luminance&quot;, or &quot;luminosity&quot;, is roughly the amount
of black or white mixed with the color and is 0 or greater and 1 or less, where 0 is black, 1 is white, closer to 0 means closer to black, and closer to 1 means closer to white.</li>
</ul>

<p>The following pseudocode converts colors between RGB and HSL.  The transformation is independent of RGB color space, but should be done using <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a>.</p>

<pre>METHOD RgbToHsl(rgb)
    vmax = max(max(rgb[0], rgb[1]), rgb[2])
    vmin = min(min(rgb[0], rgb[1]), rgb[2])
    vadd = vmax + vmin
    // NOTE: &quot;Lightness&quot; is the midpoint between
    // the greatest and least RGB component
    lt = vadd / 2.0
    if vmax==vmin: return [0, 0, lt]
    vd = vmax - vmin
    divisor = vadd
    if lt &gt; 0.5: divisor = 2.0 - vadd
    s = vd / divisor
    h = 0
    hvd = vd / 2.0
    deg60 = pi / 3
    if rgb[0]==vmax
            h=((vmax-rgb[2])*deg60 + hvd) / vd
            h = h - ((vmax-rgb[1])*deg60+hvd) / vd
    else if rgb[2]==vmax
            h=pi * 4 / 3 + ((vmax-rgb[1])*deg60 + hvd) / vd
            h = h - ((vmax-rgb[0])*deg60+hvd) / vd
    else
            h=pi * 2 / 3 + ((vmax-rgb[0])*deg60 + hvd) / vd
            h = h - ((vmax-rgb[2])*deg60+hvd) / vd
    end
    if h &lt; 0: h = pi * 2 - mod(-h, pi * 2)
    if h &gt;= pi * 2: h = mod(h, pi * 2)
    return [h, s, lt]
END METHOD

METHOD HslToRgb(hsl)
    if hsl[1]==0: return [hsl[2],hsl[2],hsl[2]]
    lum = hsl[2]
    sat = hsl[1]
    bb = 0
    if lum &lt;= 0.5: bb = lum * (1.0 + sat)
    if lum &gt; 0.5: bb= lum + sat - (lum * sat)
    a = lum * 2 - bb
    hueval = hsl[0]
    if hueval &lt; 0: hueval = pi * 2 - mod(-hueval, pi * 2)
    if hueval &gt;= pi * 2: hueval = mod(hueval, pi * 2)
    deg60 = pi / 3
    deg240 = pi * 4 / 3
    hue = hueval + pi * 2 / 3
    hue2 = hueval - pi * 2 / 3
    if hue &gt;= pi * 2: hue = hue - pi * 2
    if hues2 &lt; 0: hues2 = hues2 + pi * 2
    rgb = [a, a, a]
    hues = [hue, hueval, hue2]
    i = 0
    while i &lt; 3
       if hues[i] &lt; deg60: rgb[i] = a + (bb - a) * hues[i] / deg60
       else if hues[i] &lt; pi: rgb[i] = bb
       else if hues[i] &lt; deg240
            rgb[i] = a + (bb - a) * (deg240 - hues[i]) / deg60
       end
       i = i + 1
    end
    return rgb
END METHOD
</pre>

<p>In the rest of this document&mdash;</p>

<ul>
<li><strong><code>HSLSat(color)</code></strong> is the HSL &quot;saturation&quot; component of a color, that is, <code>RgbToHsl(color)[1]</code>, and</li>
<li><strong><code>HSLLgt(color)</code></strong> is the HSL &quot;lightness&quot; component of a color, that is, <code>RgbToHsl(color)[2]</code>.</li>
</ul>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>In some applications and specifications, especially where this color model is called HLS, the HSL color&#39;s &quot;lightness&quot; component comes before &quot;saturation&quot;.  This is not the case in this document, though.</li>
<li>The HSL color model is not perception-based, as acknowledged in (Smith and Lyons 1996).</li>
</ul>
</blockquote>

<p><a id=HWB></a></p>

<h3>HWB</h3>

<p>In 1996, the HWB model, which seeks to be more intuitive than HSV or HSL, was published (Smith and Lyons 1996).  An HWB color consists of three components in the following order:</p>

<ul>
<li><em>Hue</em> is the same for a given RGB color as in <a href="#HSV">HSV</a>.</li>
<li><em>Whiteness</em>, the amount of white mixed to the color, is 0 or greater and 1 or less.</li>
<li><em>Blackness</em>, the amount of black mixed to the color, is 0 or greater and 1 or less.</li>
</ul>

<p>The conversions given below are independent of RGB color space, but should be done using <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a>.</p>

<ul>
<li>To convert an RGB color <code>color</code> to HWB, generate <code>[HSVHue(color), min(min(color[0], color[1]), color[2]), 1 - max(max(color[0], color[1]), color[2])]</code>.</li>
<li>To convert an HWB color <code>hwb</code> to RGB, generate <code>HsvToRgb([hwb[0], 1 - hwb[1]/(1-hwb[2]), 1 - hwb[2]])</code> if <code>hwb[2] &lt; 1</code>, or <code>[hwb[0], 0, 0]</code> otherwise.</li>
</ul>

<blockquote>
<p><strong>Note:</strong> The HWB color model is not perception-based, as acknowledged in (Smith and Lyons 1996).</p>
</blockquote>

<p><a id=CIE_XYZ></a></p>

<h3>CIE XYZ</h3>

<p>The <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">CIE 1931 standard colorimetric system</a> (called the <em>XYZ color model</em> in this document) describes a transformation of a distribution of light into a point in three-dimensional space, as further explained in &quot;<a href="#Spectral_Color_Functions">Spectral Color Functions</a>&quot;.  An XYZ color consists of three components, in the following order:</p>

<ul>
<li>X is a component without special meaning.</li>
<li>Y indicates the <a href="http://6degreesoffreedom.co/luminance-vs-illuminance/"><em>luminance</em></a> of the color.<sup><a href="#Note8">(8)</a></sup></li>
<li>Z is a component without special meaning.</li>
</ul>

<p>There are at least two conventions for XYZ colors:</p>

<ul>
<li>In one convention (&quot;absolute XYZ&quot;), the Y component represents an absolute luminance in candelas per square meter (cd/m<sup>2</sup>).</li>
<li>In another convention (&quot;relative XYZ&quot;), the three components are normalized to a given white point and black point (usually those of a <em>reference medium</em>), such that Y ranges from 0 for black to a known value for white.  Specifically, the relative XYZ color is the absolute XYZ color minus the black point, then divided by the absolute-Y difference between the white point and the black point, then multiplied by a normalizing factor such as 1 or 100.  In this sense, the black point is generally, but not always, the absolute XYZ color <code>[0, 0, 0]</code> (&quot;absolute black&quot;), that is, one having a Y component (absolute luminance) of 0 cd/m<sup>2</sup>.</li>
</ul>

<p>The following methods, in the pseudocode below, convert a companded sRGB color (<code>rgb</code>) to and from a relative XYZ color, where a Y of 0 means &quot;absolute black&quot;:</p>

<ul>
<li><code>XYZFromsRGB(rgb)</code> and  <code>XYZTosRGB(xyz)</code> treat a Y of 1 as the D65 white point.</li>
<li><code>XYZFromsRGBD50(rgb)</code> and  <code>XYZTosRGBD50(xyz)</code> treat a Y of 1 as the D50 white point (see note 2 later in this section)<sup><a href="#Note9">(9)</a></sup>.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD Clamp01(elements)
    return [min(max(elements[0],0), 1),
      min(max(elements[1],0), 1),
      min(max(elements[2],0), 1)]
END METHOD

// Applies a 3x3 matrix transformation
METHOD Apply3x3Matrix(xyz, xyzmatrix)
    r=xyz[0]*xyzmatrix[0]+xyz[1]*xyzmatrix[1]+xyz[2]*xyzmatrix[2]
    g=xyz[0]*xyzmatrix[3]+xyz[1]*xyzmatrix[4]+xyz[2]*xyzmatrix[5]
    b=xyz[0]*xyzmatrix[6]+xyz[1]*xyzmatrix[7]+xyz[2]*xyzmatrix[8]
    return [r,g,b]
END METHOD

METHOD XYZFromsRGBD50(rgb)
    lin=LinearFromsRGB3(rgb)
    return Apply3x3Matrix(lin, [0.4360657, 0.3851515, 0.1430784,
            0.2224932, 0.7168870, 0.06061981, 0.01392392,
            0.09708132, 0.7140994])
END METHOD

// NOTE: Clamps components less than 0 or greater than 1 to be 0 or 1,
// respectively.  If that&#39;s not
// desired, omit the use of Clamp01 in the method below.
METHOD XYZTosRGBD50(xyz)
    rgb=Apply3x3Matrix(xyz, [3.134136, -1.617386, -0.4906622,
             -0.9787955, 1.916254, 0.03344287, 0.07195539,
             -0.2289768, 1.405386])
    return Clamp01(LinearTosRGB3(rgb))
END METHOD

METHOD XYZFromsRGB(rgb)
    lin=LinearFromsRGB3(rgb)
    // NOTE: Official matrix is rounded to nearest 1/10000
    return Apply3x3Matrix(lin, [0.4123908, 0.3575843, 0.1804808,
            0.2126390, 0.7151687, 0.07219232, 0.01933082,
            0.1191948, 0.9505322])
END METHOD

// NOTE: Clamps components less than 0 or greater than 1 to be 0 or 1,
// respectively.  If that&#39;s not
// desired, omit the use of Clamp01 in the method below.
METHOD XYZTosRGB(xyz)
    rgb=Apply3x3Matrix(xyz, [3.240970, -1.537383, -0.4986108,
            -0.9692436, 1.875968, 0.04155506, 0.05563008,
            -0.2039770, 1.056972])
    return Clamp01(LinearTosRGB3(rgb))
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>In the pseudocode just given, 3x3 matrices are used to transform a linear RGB color to or from XYZ form. The matrix shown in <code>XYZTosRGB</code> or <code>XYZTosRGBD50</code> is the <a href="http://peteroupc.github.io/html3dutil/tutorial-matrixdetails.html#Matrix_Inversions">inverse of the matrix</a> shown in <code>XYZFromsRGB</code> or <code>XYZFromsRGBD50</code>, respectively.<sup><a href="#Note10">(10)</a></sup></li>
<li>Where the XYZ color will be relative to a different white point than the RGB color space&#39;s usual white point, a <a href="https://en.wikipedia.org/wiki/Chromatic_adaptation"><em>chromatic adaptation transform</em></a> from one white point to another (such as a linear Bradford transformation) needs to be done to the RGB-to-XYZ matrix.  The XYZ-to-RGB matrix is then the <a href="http://peteroupc.github.io/html3dutil/tutorial-matrixdetails.html#Matrix_Inversions">inverse</a> of the adapted matrix. The <code>XYZFromsRGBD50</code> and <code>XYZTosRGBD50</code> methods are examples of such adaptation.<sup><a href="#Note10">(10)</a></sup></li>
</ol>
</blockquote>

<p><a id=Chromaticity_Coordinates></a></p>

<h4>Chromaticity Coordinates</h4>

<p>In general, <em>chromaticity</em> is the aspect of a color apart from its luminance. Some kinds of <em>chromaticity coordinates</em> follow.</p>

<ul>
<li><strong><em>xy</em> chromaticity.</strong> The chromaticity coordinates <em>x</em>, <em>y</em>, and <em>z</em> are each the ratios of the corresponding component of an XYZ color to the sum of those components; therefore, those three coordinates sum to 1.  &quot;xyY&quot; form consists of <em>x</em> then <em>y</em> then the Y component of an XYZ color. &quot;Yxy&quot; form consists of the Y component then <em>x</em> then <em>y</em> of an XYZ color.</li>
<li><strong><em>u&prime;v&prime;</em> chromaticity.</strong>  <em>u&prime;</em> and <em>v&prime;</em> describe what are considered uniform chromaticity coordinates for light sources.<sup><a href="#Note11">(11)</a></sup> &quot;u&prime;v&prime;Y&quot; form consists of <em>u&prime;</em> then <em>v&prime;</em>  then  the Y component of an XYZ color.  &quot;Yu&prime;v&prime;&quot; form consists of the Y component then <em>u&prime;</em> then <em>v&prime;</em> of an XYZ color.</li>
<li><strong><em>rg</em> chromaticity</strong> (<em>r</em>, <em>g</em>, <em>b</em>) involves RGB colors rather than XYZ colors
and is calculated analogously to <em>xy</em> chromaticity.</li>
</ul>

<p>In the following pseudocode, <code>XYZToxyY</code> and <code>XYZFromxyY</code> convert XYZ colors to and from their &quot;xyY&quot; form, respectively, and <code>XYZTouvY</code> and <code>XYZFromuvY</code> convert XYZ colors to and from their &quot;u&prime;v&prime;Y&quot; form, respectively.</p>

<pre>    METHOD XYZToxyY(xyz)
            sum=xyz[0]+xyz[1]+xyz[2]
            if sum==0: return [0,0,0]
            return [xyz[0]/sum, xyz[1]/sum, xyz[1]]
    END METHOD

    METHOD XYZFromxyY(xyy)
            // NOTE: Results undefined if xyy[1]==0
            return [xyy[0]*xyy[2]/xyy[1], xyy[2], xyy[2]*(1 - xyy[0] - xyy[1])/xyy[1]]
    END METHOD

    METHOD XYZTouvY(xyz)
            sum=xyz[0]+xyz[1]*15.0+xyz[2]*3.0
            if sum==0: return [0,0,0]
            return [4.0*xyz[0]/sum,9.0*xyz[1]/sum,xyz[1]]
    END METHOD

    METHOD XYZFromuvY(uvy)
            // NOTE: Results undefined if uvy[1]==0
            su=uvy[2]/(uvy[1]/9.0)
            x=u*su/4.0
            z=(su/3.0)-(x/3.0)-5.0*uvy[2]
            return [x,uvy[2],z]
    END METHOD
</pre>

<p><a id=CIELAB></a></p>

<h3>CIELAB</h3>

<p><a href="https://en.wikipedia.org/wiki/Lab_color_space">CIELAB</a> (also known as CIE <em>L*a*b*</em> or CIE 1976 <em>L*a*b*</em>) is a three-dimensional color model designed for color comparisons.<sup><a href="#Note12">(12)</a></sup> In general, CIELAB color spaces differ in their white points.</p>

<p>A color in CIELAB consists of three components, in the following order:</p>

<ul>
<li><em>L*</em>, or <em>lightness</em> of a color (how bright that color appears in comparison to white), is 0 or greater and 100 or less, where 0 is black and 100 is white.</li>
<li><em>a*</em> is a coordinate of the red/green axis; the positive <em>a*</em> axis points to red (actually magenta)
and the negative <em>a*</em> axis points to green.</li>
<li><em>b*</em> is a coordinate of the yellow/blue axis; the positive <em>b*</em> axis points to yellow
and the negative <em>b*</em> axis points to blue.<sup><a href="#Note13">(13)</a></sup></li>
</ul>

<p>In the following pseudocode:</p>

<ul>
<li>The following methods convert a companded sRGB color to and from CIELAB:

<ul>
<li><code>SRGBToLab</code> and <code>SRGBFromLab</code> treat white as the D65 white point.</li>
<li><code>SRGBToLabD50</code> and <code>SRGBFromLabD50</code> treat white as the D50 white point.<sup><a href="#Note9">(9)</a></sup></li>
</ul></li>
<li><code>XYZToLab(xyz, wpoint)</code> and <code>LabToXYZ(lab, wpoint)</code> convert an XYZ color to or from CIELAB, respectively, treating <code>wpoint</code> (an XYZ color) as the white point.</li>
<li><code>LabToChroma(lab)</code> finds a CIELAB color&#39;s <em>chroma</em> (<em>C*</em>), or distance of that color from the &quot;gray&quot; line.<sup><a href="#Note14">(14)</a></sup></li>
<li><code>LabToHue(lab)</code> finds a CIELAB color&#39;s <em>hue</em> (<em>h</em>, an angle)<sup><a href="#Note7">(7)</a></sup>. Hue ranges from magenta at roughly 0 to red to yellow to green to cyan to blue to magenta.</li>
<li><code>LchToLab(lch)</code> finds a CIELAB color given a 3-item list of lightness, chroma, and hue (<em>L*C*h</em>), in that order.</li>
<li><code>LabHueDifference(lab1, lab2)</code> finds the <em>metric hue difference</em> (<em>&Delta;H*</em>) between two CIELAB colors.  The return value can be positive or negative, but in some cases, the absolute value of that return value can be important.</li>
<li><code>LabChromaHueDifference(lab1, lab2)</code> finds the <em>chromaticness difference</em> (&Delta;<em>C</em><sub>h</sub>) between two CIELAB colors, as given, for example, in ISO 13655.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD XYZToLab(xyzval, wpoint)
    xyz=[xyzval[0]/wpoint[0],xyzval[1]/wpoint[1],xyzval[2]/wpoint[2]]
    i=0
    while i &lt; 3
       if xyz[i] &gt; 216.0 / 24389 // See BruceLindbloom.com
          xyz[i]=pow(xyz[i], 1.0/3.0)
       else
           kappa=24389.0/27 // See BruceLindbloom.com
           xyz[i]=(16.0 + kappa*xyz[i]) / 116
       end
       i=i+1
    end
    return [116.0*xyz[1] - 16,
        500 * (xyz[0] - xyz[1]),
        200 * (xyz[1] - xyz[2])]
END METHOD

METHOD LabToXYZ(lab,wpoint)
    fy=(lab[0]+16)/116.0
    fx=fy+lab[1]/500.0
    fz=fy-lab[2]/200.0
    fxcb=fx*fx*fx
    fzcb=fz*fz*fz
    xyz=[fxcb, 0, fzcb]
    eps=216.0/24389 // See BruceLindbloom.com
    if fxcb &lt;= eps: xyz[0]=(108.0*fx/841)-432.0/24389
    if fzcb &lt;= eps: xyz[2]=(108.0*fz/841)-432.0/24389
    if lab[0] &gt; 8 // See BruceLindbloom.com
            xyz[1]=pow(((lab[0]+16)/116.0), 3.0)
    else
            xyz[1]=lab[0]*27.0/24389 // See BruceLindbloom.com
    end
    xyz[0]=xyz[0]*wpoint[0]
    xyz[1]=xyz[1]*wpoint[1]
    xyz[2]=xyz[2]*wpoint[2]
    return xyz
END METHOD

METHOD SRGBToLab(rgb)
    return XYZToLab(XYZFromsRGB(rgb), [0.9504559, 1, 1.089058])
END METHOD

METHOD SRGBFromLab(lab)
    return XYZTosRGB(LabToXYZ(lab, [0.9504559, 1, 1.089058]))
END METHOD

METHOD SRGBToLabD50(rgb)
    return XYZToLab(XYZFromsRGBD50(rgb), [0.9642957, 1, 0.8251046])
END METHOD

METHOD SRGBFromLabD50(lab)
    return XYZTosRGBD50(LabToXYZ(lab, [0.9642957, 1, 0.8251046]))
END METHOD

   // -- Derived values from CIELAB colors

METHOD LabToChroma(lab)
        return sqrt(lab[1]*lab[1] + lab[2]*lab[2])
END METHOD

    METHOD LabToHue(lab)
            h = atan2(lab[2], lab[1])
            if h &lt; 0: h = h + pi * 2
            return h
    END METHOD

    METHOD LchToLab(lch)
            return [lch[0], lch[1] * cos(lch[2]), lch[1] * sin(lch[2])]
    END METHOD

METHOD LabHueDifference(lab1, lab2)
  cmul=LabToChroma(lab1)*LabToChroma(lab2)
  h2=LabToHue(lab2)
  h1=LabToHue(lab1)
  hdiff=h2-h1
  if abs(hdiff)&gt;pi
        if h2&lt;=h1: hdiff=hdiff+math.pi*2
        else: hdiff=hdiff-math.pi*2
  end
  return sqrt(cmul)*sin(hdiff*0.5)*2
END METHOD

METHOD LabChromaHueDifference(lab1, lab2)
            da=lab1[1]-lab2[1]
            db=lab1[2]-lab2[2]
            return sqrt(da*da+db*db)
    END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> The difference in lightness, <em>a*</em>, <em>b*</em>, or chroma (<em>&Delta;L*</em>, <em>&Delta;a*</em>, <em>&Delta;b*</em>, or <em>&Delta;C*</em>, respectively) between two CIELAB colors is simply the difference between the corresponding value of the second CIELAB color and that of the first.</p>

<p><strong>Examples:</strong></p>

<ol>
<li>An application can consider a color <strong>dark</strong> if its lightness (<em>L*</em>) is lower than some threshold, say, 30.</li>
<li>An application can consider a color <strong>light</strong> if its lightness (<em>L*</em>) is greater than some threshold, say, 70.</li>
</ol>
</blockquote>

<p><a id=CIELUV></a></p>

<h3>CIELUV</h3>

<p>CIELUV (also known as CIE <em>L*u*v*</em> or CIE 1976 <em>L*u*v*</em>) is a second color model designed for color comparisons.   A CIELUV color has three components, namely, <em>L*</em>, or <em>lightness</em> (which is the same as in CIELAB), <em>u*</em>, and <em>v*</em>, in that order.  As <a href="http://www.handprint.com/HP/WCL/color7.html#CIELUV">B. MacEvoy explains</a>, &quot;CIELUV represents the additive mixture of two lights as a straight line&quot;, so that this color model is especially useful when working with colors of light sources.</p>

<p>In the following pseudocode&mdash;</p>

<ul>
<li>the <code>SRGBToLuv</code>, <code>SRGBFromLuv</code>, <code>SRGBToLuvD50</code>, <code>SRGBFromLuvD50</code>, <code>XYZToLuv</code>, and <code>LuvToXYZ</code> methods perform conversions involving CIELUV colors analogously to the similarly named methods for <a href="#CIELAB">CIELAB</a>, and</li>
<li>the <code>LuvToSaturation</code> method finds the <a href="https://en.wikipedia.org/wiki/Colorfulness"><em>saturation</em></a> (<em>s</em><sub>uv</sub>) of a CIELUV color.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD XYZToLuv(xyz, wpoint)
    lab=XYZToLab(xyz, wpoint)
    sum=xyz[0]+xyz[1]*15+xyz[2]*3
    lt=lab[0]
    if sum==0: return [lt, 0, 0]
    upr=4*xyz[0]/sum // U-prime chromaticity
    vpr=9*xyz[1]/sum // V-prime chromaticity
    sumwhite=wpoint[0]+15*wpoint[1]+wpoint[2]*3
    return [lt,
            lt*13*(upr - 4*wpoint[0]/sumwhite),
            lt*13*(vpr - 9.0*wpoint[1]/sumwhite)]
END METHOD

METHOD LuvToXYZ(luv, wpoint)
    if luv[0]==0: return [0, 0, 0]
    xyz=LabToXYZ([luv[0], 1, 1],wpoint)
    sumwhite=wpoint[0]+15*wpoint[1]+wpoint[2]*3
    u0=4*wpoint[0]/sumwhite
    v0=9.0*wpoint[1]/sumwhite
    lt=luv[0]
    a=(52*lt/(luv[1]+13*u0*lt)-1)/3.0
    d=xyz[1]*(39*lt/(luv[2]+13*v0*lt)-5)
    x=(d+5*xyz[1])/(a+1.0/3)
    z=x*a-5*xyz[1]
    return [x,xyz[1],z]
END METHOD

METHOD SRGBToLuv(rgb)
    return XYZToLuv(XYZFromsRGB(rgb), [0.9504559, 1, 1.089058])
END METHOD

METHOD SRGBFromLuv(luv)
    return XYZTosRGB(LuvToXYZ(luv, [0.9504559, 1, 1.089058]))
END METHOD

METHOD SRGBToLuvD50(rgb)
    return XYZToLuv(XYZFromsRGBD50(rgb), [0.9642957, 1, 0.8251046])
END METHOD

METHOD SRGBFromLuvD50(luv)
    return XYZTosRGBD50(LuvToXYZ(luv, [0.9642957, 1, 0.8251046]))
END METHOD

METHOD LuvToSaturation(luv)
    if luv[0]==0: return 0
    return sqrt(luv[1]*luv[1]+luv[2]*luv[2])/luv[0]
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>Hue and chroma can be derived from a CIELUV color in a similar way as from a CIELAB color, with <em>u*</em> and <em>v*</em> used instead of <em>a*</em> and <em>b*</em>, respectively. The <code>LabToHue</code>, <code>LabToChroma</code>, <code>LabHueDifference</code>, <code>LabChromaHueDifference</code>, and <code>LchToLab</code> methods from the previous section work with CIELUV colors analogously to CIELAB colors.</li>
<li>The difference in lightness, <em>u*</em>, <em>v*</em>, chroma, or saturation (<em>&Delta;L*</em>, <em>&Delta;u*</em>, <em>&Delta;v*</em>,  <em>&Delta;C*</em><sub>uv</sub>, or <em>&Delta;s</em><sub>uv</sub>, respectively) between two CIELUV colors is simply the difference between the corresponding value of the second CIELUV color and that of the first.</li>
</ul>
</blockquote>

<p><a id=Y_prime_C_B_C_R></a></p>

<h3>Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub></h3>

<p><a href="https://en.wikipedia.org/wiki/YCbCr">Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub></a> (also known as YCbCr, YCrCb, or  Y&prime;CrCb) is a color model used above all in video encoding.  A color in Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub> consists of three components in the following order:</p>

<ul>
<li>Y&prime;, or <em>luma</em>, is an integer 16 or greater and 235 or less: 16 for black, and 235 for white.<sup><a href="#Note15">(15)</a></sup></li>
<li>C<sub><em>B</em></sub>, or <em>blue chroma</em>, is based on the difference between blue and luma and is an integer 16 or greater and 240 or less.</li>
<li>C<sub><em>R</em></sub>, or <em>red chroma</em>, is, based on the difference between red and luma and is an integer 16 or greater and 240 or less.</li>
</ul>

<p>The following pseudocode converts colors between RGB and Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub>.  Each RGB color is in 8/8/8 format (rather than 0-1 format) with the components separated out (still 0 or greater and 255 or less). There are three variants shown here, namely&mdash;</p>

<ul>
<li>the ITU-R BT.601 variant (for standard-definition digital video), as the <code>YCbCrToRgb</code> and <code>RgbToYCbCr</code> methods,</li>
<li>the ITU-R BT.709 variant (for high-definition video), as the <code>YCbCrToRgb709</code> and <code>RgbToYCbCr709</code> methods, and</li>
<li>the <a href="https://www.w3.org/Graphics/JPEG/jfif3.pdf">JPEG File Interchange Format</a> variant (with all three components 0 or greater and 255 or less), as the <code>YCbCrToRgbJpeg</code> and <code>RgbToYCbCrJpeg</code> methods.<sup><a href="#Note16">(16)</a></sup></li>
</ul>

<p>For all these variants, the transformation should be done using <a href="#Linear_RGB_and_Companded_RGB"><em>companded RGB</em> colors</a>.<sup><a href="#Note17">(17)</a></sup></p>

<pre>// NOTE: Derived from scaled YPbPr using red/green/blue luminances
// in the NTSC color space
METHOD RgbToYCbCr(rgb)
    y = floor(16.0+rgb[0]*0.25678824+rgb[1]*0.50412941+rgb[2]*0.097905882)
    cb = floor(128.0-rgb[0]*0.1482229-rgb[1]*0.29099279+rgb[2]*0.43921569)
    cr = floor(128.0+rgb[0]*0.43921569-rgb[1]*0.36778831-rgb[2]*0.071427373)
    return [y, cb, cr]
END METHOD

// NOTE: Derived from scaled YPbPr using red/green/blue BT.709 luminances
METHOD RgbToYCbCr709(rgb)
    y = floor(0.06200706*rgb[2] + 0.6142306*rgb[1] + 0.1825859*rgb[0] + 16.0)
    cb = floor(0.4392157*rgb[2] - 0.338572*rgb[1] - 0.1006437*rgb[0] + 128.0)
    cr = floor(-0.04027352*rgb[2] - 0.3989422*rgb[1] + 0.4392157*rgb[0] + 128.0)
    return [y, cb, cr]
END METHOD

// NOTE: Derived from unscaled YPbPr using red/green/blue luminances
// in the NTSC color space
METHOD RgbToYCbCrJpeg(rgb)
    y = floor(0.299*rgb[0] + 0.587*rgb[1] + 0.114*rgb[2])
    cb = floor(-0.1687359*rgb[0] - 0.3312641*rgb[1] + 0.5*rgb[2] + 128.0)
    cr = floor(0.5*rgb[0] - 0.4186876*rgb[1] - 0.08131241*rgb[2] + 128.0)
    return [y, cb, cr]
END METHOD

METHOD YCbCrToRgb(yCbCr)
    cb = yCbCr[1] - 128
    cr = yCbCr[2] - 128
    yp = 1.1643836 * (yCbCr[0] - 16)
    r = yp + 1.5960268 * cr
    g = yp - 0.39176229 * cb - 0.81296765 * cr
    b = yp + 2.0172321 * cb
    return [min(max(r,0),255),min(max(g,0),255),min(max(b,0),255)]
END METHOD

METHOD YCbCrToRgb709(yCbCr)
    cb = yCbCr[1] - 128
    cr = yCbCr[2] - 128
    yp = 1.1643836 * (yCbCr[0] - 16)
    r = yp + 1.7927411 * cr
    g = yp - 0.21324861 * cb - 0.53290933 * cr
    b = yp + 2.1124018 * cb
    return [min(max(r,0),255),min(max(g,0),255),min(max(b,0),255)]
END METHOD

METHOD YCbCrToRgbJpeg(yCbCr)
    cb = yCbCr[1] - 128
    cr = yCbCr[2] - 128
    yp = yCbCr[0]
    r = yp + 1.402 * cr
    g = yp - 0.34413629 * cb - 0.71413629 * cr
    b = yp + 1.772 * cb
    return [min(max(r,0),255),min(max(g,0),255),min(max(b,0),255)]
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> A thorough survey of the various ways in which Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub> data has been encoded is outside the scope of this document; in general, such encodings take into account the human eye&#39;s normally greater spatial sensitivity to luminance (Y, as approximated by Y&prime;, luma) than chromatic sensitivity (C<sub><em>B</em></sub>, C<sub><em>R</em></sub>).</p>
</blockquote>

<p><a id=CMYK_and_Other_Ink_Mixture_Color_Models></a></p>

<h3>CMYK and Other Ink-Mixture Color Models</h3>

<p>The <em>CMYK color model</em>, ideally, describes the proportion of cyan, magenta, yellow, and black (K) inks to use to reproduce certain colors on paper.  However, since color mixture of inks is considerably complex (see &quot;<a href="#Color_Mixture">Color Mixture</a>&quot;, later), the proper interpretation of CMYK colors depends on the <em>printing condition</em> (as defined in ISO 12647-1), including what inks and paper are used.</p>

<p><strong>Characterization tables.</strong> In printing industry practice, a given printing condition is characterized by finding out how it forms colors using different mixtures of inks.  This is usually done by printing CMYK color &quot;patches&quot; and using a color measurement device to measure their <a href="#CIELAB">CIELAB</a> colors (or <a href="#Spectral_Color_Functions">spectral reflectance factors</a>) under standardized lighting and measurement conditions.</p>

<p>The International Color Consortium maintains a <a href="http://www.color.org/chardata/drsection1.xalter">list of standardized conversions</a> of CMYK color &quot;patches&quot;, usually to CIELAB colors relative to the D50 white point, for different standardized printing conditions.  Such conversions are generally known as <em>characterization data</em> or <em>characterization tables</em>.</p>

<p>Given a CMYK-to-CIELAB characterization table, a CMYK color can be converted to and from a CIELAB color by multidimensional interpolation of the table&#39;s &quot;patches&quot;; details of such interpolation are outside the scope of this page, but an example is SciPy&#39;s <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html"><code>griddata</code></a> method.</p>

<p><strong>Other ink mixtures.</strong> Just as with CMYK, the interpretation of any recipe of inks as a color depends on the printing condition.  However, printing systems that use mixtures that include inks other than cyan, magenta, yellow, and black (notably &quot;extended gamut&quot; systems of six or more inks, and systems that use custom &quot;spot&quot; color inks) are not yet of general interest to programmers.</p>

<p><strong>Rough conversions.</strong> The following pseudocode shows <em>very rough</em> and <em>approximate</em> conversions between an RGB color (<code>color</code>) and a CMYK color (<code>cmyk</code>):</p>

<pre>    // RGB to CMYK
    k = min(min(1.0 - color[0], 1.0 - color[1]), 1.0 - color[2])
    cmyk=[0, 0, 0, 1]
    if k!=1:
       cmyk=[((1.0 - color[0]) - k) / (1 - k), ((1.0 - color[2]) - k) /
          (1 - k), ((1.0 - color[2]) - k) / (1 - k), k]
    end
    // CMYK to RGB
    ik = 1 - cmyk[3]
    color=[(1 - cmyk[0]) * ik, (1 - cmyk[1]) * ik, (1 - cmyk[2]) * ik]
</pre>

<p><a id=Modifying_Existing_Colors></a></p>

<h2>Modifying Existing Colors</h2>

<p>The following techniques show how existing colors can be modified to create new colors.</p>

<p>Note that for best results, these techniques need to be carried out with <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a>, unless noted otherwise.</p>

<p><a id=Relative_Luminance_Grayscale></a></p>

<h3>Relative Luminance (Grayscale)</h3>

<p><em>Relative luminance</em>&mdash;</p>

<ul>
<li>is called <strong><code>Luminance(color)</code></strong> in this document,</li>
<li>is a single number indicating a color&#39;s luminance relative to white, that is, how much light reaches the eyes when that color is viewed, in comparison to white,</li>
<li>is equivalent to the Y component of an <a href="#CIE_XYZ">XYZ color</a>, and</li>
<li>ranges from 0 for &quot;black&quot; to 1 for &quot;white&quot;.</li>
</ul>

<p>For <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a>, relative luminance is <code>(color[0] * r + color[1] * g + color[2] * b)</code>, where <code>r</code>, <code>g</code>, and <code>b</code> are the upper-case-Y components (relative luminances) of the RGB color space&#39;s red, green, and blue points, respectively<sup><a href="#Note6">(6)</a></sup><sup><a href="#Note18">(18)</a></sup>.  (If a different white point than the RGB color space&#39;s usual white point should have a relative luminance of 1, then <code>r</code>, <code>g</code>, and <code>b</code> are the corresponding components after a <a href="https://en.wikipedia.org/wiki/Chromatic_adaptation"><em>chromatic adaptation transform</em></a> from one white point to another.<sup><a href="#Note10">(10)</a></sup>)</p>

<p>Applying the formula just given to <em>companded RGB</em> colors results in a value more properly called <em>luma</em>, not (relative) luminance.<sup><a href="#Note19">(19)</a></sup></p>

<p>The following pseudocode implements <code>Luminance(color)</code> for companded sRGB colors (<code>LuminanceSRGB</code> and <code>LuminanceSRGBD50</code>)<sup><a href="#Note6">(6)</a></sup><sup><a href="#Note9">(9)</a></sup>.</p>

<pre>// Convert companded sRGB to relative luminance
METHOD LuminanceSRGB(color)
    c = LinearFromsRGB(color)
    return c[0] * 0.2126 + c[1] * 0.7152 + c[2] * 0.0722
END METHOD

// Convert companded sRGB (with D50 white point)
// to relative luminance
METHOD LuminanceSRGBD50(color)
    c = LinearFromsRGB(color)
    return c[0] * 0.2225 + c[1] * 0.7169 + c[2] * 0.0606
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li><strong>Grayscale.</strong> A color, <code>color</code>, can be converted to grayscale by calculating <code>[Luminance(color), Luminance(color), Luminance(color)]</code>.</li>
<li><strong>Black and white.</strong> Generate <code>[0, 0, 0]</code> (black) if <code>Luminance(color) &lt; 0.5</code>, or <code>[1, 1, 1]</code> (white) otherwise.</li>
<li><strong>Contrasting color.</strong> A <em>contrasting color</em> is a foreground (text) color with high contrast to the background color or vice versa.  For example, if <a href="#Relative_Luminance_Grayscale"><code>Luminance(color)</code></a> is 0.5 or less, select <code>[1, 1, 1]</code> (white) as a contrasting color; otherwise, select <code>[0, 0, 0]</code> (black) as a  contrasting color.<sup><a href="#Note20">(20)</a></sup></li>
<li>Finding the <strong>average relative luminance</strong> of a raster image (or other color content data) is often equivalent to&mdash;

<ul>
<li>adding all the relative luminances (<code>Luminance(color)</code>) of the colors used in that image or data (which can be duplicates), then</li>
<li>dividing the result by the number of such colors.</li>
</ul></li>
</ol>

<p><strong>Note:</strong> A value similar to relative luminance is a <a href="#CIELAB">CIELAB</a> or <a href="#CIELUV">CIELUV</a> color&#39;s lightness (<em>L*</em>) divided by 100.</p>
</blockquote>

<p><a id=Color_Schemes></a></p>

<h3>Color Schemes</h3>

<p>The following techniques generate new colors that are related to existing colors.</p>

<ul>
<li><strong>Color harmonies</strong><sup><a href="#Note21">(21)</a></sup> result by generating several colors that differ in hue (hue angle).  For each color harmony given below, the following numbers are added to a hue angle<sup><a href="#Note7">(7)</a></sup> to generate the hues for the colors that make up that harmony:

<ul>
<li><strong>Analogous</strong>: 0, Y, -Y, where Y is 2&pi;/3 or less. In general, <em>analogous colors</em> are colors spaced at equal hue intervals from a central color.</li>
<li><strong>Complementary</strong>: 0, &pi;.  This is the base hue with its opposite hue.</li>
<li><strong>Split complementary</strong>: 0, &pi; - Y, &pi; + Y, where Y is greater than 0 and &pi;/2 or less.  The base hue and two hues close to the opposite hue.</li>
<li><strong>Triadic</strong>: 0, 2&pi;/3, 4&pi;/3.  Base hue and the two hues at 120 degrees from that hue.</li>
<li><strong>Off-complementary</strong> (mentioned by B. MacEvoy): 0, 2&pi;/3. Alternatively, 0, -2&pi;/3.</li>
<li><strong>Two-tone</strong>: 0, Y, where Y is greater than -&pi;/2 and less than &pi;/2. This is the base hue and a close hue.</li>
<li><strong>Double complementary</strong>: 0, Y, &pi;, &pi; + Y, where Y is -&pi;/2 or greater and &pi;/2 or less.  The base hue and a close hue, as well as their opposite hues.</li>
</ul></li>
<li><strong>Monochrome colors</strong>: Colors with the same hue; for example, different <a href="#Alpha_Blending">shades, tints, and/or tones</a> of a given color are monochrome colors.</li>
</ul>

<p><a id=Alpha_Blending></a></p>

<h3>Alpha Blending</h3>

<p>The <code>Lerp3</code> function below gets an &quot;alpha blend&quot; of two colors, where <code>color1</code> and <code>color2</code> are the two colors, and <code>alpha</code> is the <em>alpha component</em> being 0 or greater and 1 or less (0 means equal to <code>color1</code> and 1 means equal to <code>color2</code>).<sup><a href="#Note22">(22)</a></sup></p>

<ul>
<li>Generating a <strong>shade</strong> of a color (mixing with black) is equivalent to alpha blending that color with black (such as <code>[0, 0, 0]</code> in RGB).</li>
<li>Generating a <strong>tint</strong> of a color (mixing with white) is equivalent to alpha blending that color with white (such as <code>[1, 1, 1]</code> in RGB).</li>
<li>Generating a <strong>tone</strong> of a color (mixing with gray) is equivalent to alpha blending that color with gray (such as <code>[0.5, 0.5, 0.5]</code> in RGB).</li>
<li>Averaging two colors is equivalent to alpha blending with <code>alpha</code> set to 0.5.</li>
<li>Converting an RGBA color to an RGB color on white is equivalent to <code>Lerp3([color[0], color[1], color[2]], [1, 1, 1], color[3])</code>.</li>
<li>Converting an RGBA color to an RGB color over <code>color2</code>, another RGB color, is equivalent to <code>Lerp3([color[0], color[1], color[2]], color2, color[3])</code>.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD Lerp3(color1, color2, alpha)
    return [color1[0]+(color2[0]-color1[0])*alpha, color1[1]+(color2[1]-color1[1])*alpha,
        color1[2]+(color2[2]-color1[2])*alpha]
END METHOD
</pre>

<p><a id=Porter_ndash_Duff_Formulas></a></p>

<h3>Porter&ndash;Duff Formulas</h3>

<p>Porter and Duff (1984) define twelve formulas for combining (compositing) two RGBA colors. In the formulas below, it is assumed that the two colors are in the 0-1 format and have been <em>premultiplied</em> (that is, their red, green, and blue components have been multiplied beforehand by their alpha component).  Given <code>src</code>, the source RGBA color, and <code>dst</code>, the destination RGBA color, the Porter&ndash;Duff formulas are as follows.</p>

<ul>
<li><strong>Source Over</strong>: <code>[src[0]-dst[0]*(src[3] - 1), src[1]-dst[1]*(src[3] - 1), src[2]-dst[2]*(src[3] - 1), src[3]-dst[3]*(src[3] - 1)]</code>.</li>
<li><strong>Source In</strong>: <code>[dst[3]*src[0], dst[3]*src[1], dst[3]*src[2], dst[3]*src[3]]</code>.</li>
<li><strong>Source Held Out</strong>: <code>[src[0]*(1 - dst[3]), src[1]*(1 - dst[3]), src[2]*(1 - dst[3]), src[3]*(1 - dst[3])]</code>.</li>
<li><strong>Source Atop</strong>: <code>[dst[0]*src[3] - src[0]*(dst[3] - 1), dst[1]*src[3] - src[1]*(dst[3] - 1), dst[2]*src[3] - src[2]*(dst[3] - 1), src[3]]</code>.</li>
<li><strong>Destination Over</strong>: <code>[dst[0] - src[0]*(dst[3] - 1), dst[1] - src[1]*(dst[3] - 1), dst[2] - src[2]*(dst[3] - 1), dst[3] - src[3]*(dst[3] - 1)]</code>.</li>
<li><strong>Destination In</strong>: <code>[dst[0]*src[3], dst[1]*src[3], dst[2]*src[3], dst[3]*src[3]]</code>.  Uses the destination color/alpha with the source alpha as the &quot;mask&quot;.</li>
<li><strong>Destination Held Out</strong>: <code>[dst[0]*(1 - src[3]), dst[1]*(1 - src[3]), dst[2]*(1 - src[3]), dst[3]*(1 - src[3])]</code>.</li>
<li><strong>Destination Atop</strong>: <code>[dst[3]*src[0] - dst[0]*(src[3] - 1), dst[3]*src[1] - dst[1]*(src[3] - 1), dst[3]*src[2] - dst[2]*(src[3] - 1), dst[3]]</code>.</li>
<li><strong>Source</strong>: <code>src</code>.</li>
<li><strong>Destination</strong>: <code>dst</code>.</li>
<li><strong>Clear</strong>: <code>[0, 0, 0, 0]</code>.</li>
<li><strong>Xor</strong>: <code>[-dst[3]*src[0] - dst[0]*src[3] + dst[0] + src[0], -dst[3]*src[1] - dst[1]*src[3] + dst[1] + src[1], -dst[3]*src[2] - dst[2]*src[3] + dst[2] + src[2], -2*dst[3]*src[3] + dst[3] + src[3]]</code>.</li>
</ul>

<p><a id=Blend_Modes></a></p>

<h3>Blend Modes</h3>

<p><a href="https://en.wikipedia.org/wiki/Blend_modes">Blend modes</a> take a source color and destination color and blend them to create a new color.  The same blend mode, or different blend modes, can be applied to each component of a given color.  In the idioms below, <code>src</code> is one component of the source color, <code>dst</code> is the same component of the destination color (for example, <code>src</code> and <code>dst</code> can both be two RGB colors&#39; red components), and both components are assumed to be 0 or greater and 1 or less.  The following are examples of blend modes.</p>

<ul>
<li><strong>Normal</strong>: <code>src</code>.</li>
<li><strong>Lighten</strong>: <code>max(src, dst)</code>.</li>
<li><strong>Darken</strong>: <code>min(src, dst)</code>.</li>
<li><strong>Add</strong>: <code>min(1.0, src + dst)</code>.</li>
<li><strong>Subtract</strong>: <code>max(0.0, src - dst)</code>.</li>
<li><strong>Multiply</strong>: <code>(src + dst)</code>.</li>
<li><strong>Screen</strong>: <code>1 - (1 - dst) * (1 - src)</code>.</li>
<li><strong>Average</strong>: <code>(src + dst) * 0.5</code>.</li>
<li><strong>Difference</strong>: <code>abs(src - dst)</code>.</li>
<li><strong>Exclusion</strong>: <code>src - 2 * src * dst + dst</code>.</li>
</ul>

<p><a id=Color_Matrices></a></p>

<h3>Color Matrices</h3>

<p>A <em>color matrix</em> is a 9-item (3x3) list for transforming colors.  As used in this document, an RGB color (<code>color</code>)
is transformed with a color matrix (<code>matrix</code>) as follows:</p>

<pre>newColor = [
   min(max(color[0]*matrix[0]+color[1]*matrix[1]+color[2]*matrix[2],0),1),
   min(max(color[0]*matrix[3]+color[1]*matrix[4]+color[2]*matrix[5],0),1),
   min(max(color[0]*matrix[6]+color[1]*matrix[7]+color[2]*matrix[8],0),1),
]
</pre>

<p>Examples of matrices include:</p>

<ul>
<li><strong>Sepia</strong>: <code>[0.393, 0.769, 0.189, 0.349, 0.686, 0.168, 0.272, 0.534, 0.131]</code>.</li>
<li><strong>Saturate</strong>: <code>[s+(1-s)*r, (1-s)*g, (1-s)*b, (1-s)*r, s+(1-s)*g,(1-s)*b,(1-s)*r,(1-s)*g,s+(1-s)*b]</code>, where <code>s</code> ranges
from 0 through 1 (the greater <code>s</code> is, the less saturated), and <code>r</code>, <code>g</code>, and <code>b</code> are as defined in the section &quot;<a href="#Relative_Luminance_Grayscale">Relative Luminance (Grayscale)</a>&quot;<sup><a href="#Note23">(23)</a></sup>.</li>
<li><strong>Hue rotate</strong>: <code>[-0.37124*sr + 0.7874*cr + 0.2126,  -0.49629*sr - 0.7152*cr + 0.7152, 0.86753*sr - 0.0722*cr + 0.0722, 0.20611*sr - 0.2126*cr + 0.2126, 0.08106*sr + 0.2848*cr + 0.7152, -0.28717*sr - 0.072199*cr + 0.0722, -0.94859*sr - 0.2126*cr + 0.2126, 0.65841*sr - 0.7152*cr + 0.7152, 0.29018*sr + 0.9278*cr + 0.0722]</code>, where <code>sr = sin(rotation)</code>, <code>cr = cos(rotation)</code>, and <code>rotation</code> is the hue rotation angle.<sup><a href="#Note24">(24)</a></sup><sup><a href="#Note23">(23)</a></sup></li>
</ul>

<p><a id=Miscellaneous></a></p>

<h3>Miscellaneous</h3>

<p>In the following formulas, <code>color</code> is the source color in 0-1 format.</p>

<ul>
<li><strong>Invert (&quot;film negative&quot;)</strong>: <code>[1.0 - color[0], 1.0 - color[1], 1.0 - color[2]]</code>.<sup><a href="#Note25">(25)</a></sup></li>
<li><p><strong>Lighten/Darken</strong>: A choice of&mdash;</p>

<ul>
<li><code>[min(max(color[0]+value,0),1), min(max(color[1]+value,0),1), min(max(color[2]+value,0),1)]</code>,</li>
<li><code>HslToRgb(HSVHue(color), HSLSat(color), min(max(HSLLgt(color) + value, 0), 1))</code>, or</li>
<li><code>SRGBFromLab(min(max(lab[0] + (value * 100), 0), 100), lab[1], lab[2])</code>, where <code>lab = SRGBToLab(color)</code> (for companded sRGB colors),</li>
</ul>

<p>generates a lighter version of <code>color</code> if <code>value</code> is positive, and a darker version if <code>value</code> is negative, where <code>value</code> is 0 or greater and 1 or less.</p></li>
<li><strong>Saturate/Desaturate</strong>: <code>HsvToRgb(hsv[0], min(max(hsv[1] + color, 0), 1), hsv[0])</code>, where <code>hsv = RgbToHsv(color)</code>; this procedure saturates <code>color</code> if <code>value</code> is positive, and desaturates that color if <code>value</code> is negative. (Note that HSL&#39;s &quot;saturation&quot; is inferior here.)  A color can also be desaturated by <a href="#Alpha_Blending">alpha blending</a> that color with its <a href="#Relative_Luminance_Grayscale">grayscale</a> version.</li>
<li><strong>Colorize</strong>: Given a desired <code>color</code> and a source color <code>srcColor</code>, generate
<code>[color[0]*Luminance(srcColor), color[1]*Luminance(srcColor), color[2]*Luminance(srcColor)]</code>.</li>
<li><strong>Swap blue and red channels</strong>: <code>[color[2], color[1], color[0]]</code>.</li>
<li><strong>Red channel</strong>: <code>[color[0], color[0], color[0]]</code>.</li>
<li><strong>Green channel</strong>: <code>[color[1], color[1], color[1]]</code>.</li>
<li><strong>Blue channel</strong>: <code>[color[2], color[2], color[2]]</code>.</li>
<li><strong>Maximum</strong>: <code>[c, c, c]</code>, where <code>c</code> is <code>max(max(color[0], color[1]), color[2])</code>.</li>
<li><strong>Minimum</strong>: <code>[c, c, c]</code>, where <code>c</code> is <code>min(min(color[0], color[1]), color[2])</code>.</li>
</ul>

<blockquote>
<p><strong>Note:</strong> Image processing techniques that replace one color with another color (or some modified version of the original color), but only if the color meets certain requirements, techniques that include <a href="https://en.wikipedia.org/wiki/Chroma_key"><em>chroma key</em></a>, are largely out of the scope of this document.</p>
</blockquote>

<p><a id=Color_Differences></a></p>

<h2>Color Differences</h2>

<p>Color difference algorithms are used to determine if two colors are similar.</p>

<p>In this document, <code>COLORDIFF(color1, color2)</code> is a function that calculates a <a href="https://en.wikipedia.org/wiki/Color_difference"><em>color difference</em></a> (also known as &quot;color distance&quot;) between two colors in the same color space, where the lower the number, the closer the two colors are.  In general, however, color differences calculated using different color spaces or <code>COLORDIFF</code> implementations cannot be converted to each other.  Some ways to implement <code>COLORDIFF</code> are given in this section.</p>

<p><strong>Euclidean distance.</strong> The following pseudocode implements the Euclidean distance of two colors.</p>

<pre>METHOD COLORDIFF(color1, color2)
   d1=color2[0] - color1[0]
   d2=color2[1] - color1[1]
   d3=color2[2] - color1[2]
   sqdist=d1*d1+d2*d2+d3*d3
   return sqrt(sqdist)
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>The Euclidean distance is independent of color model; however, <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a>, rather than companded RGB colors, should be used.</li>
<li>For CIELAB or CIELUV, the Euclidean distance method just given implements the 1976 <em>&Delta;E*</em><sub>ab</sub> (&quot;delta E a b&quot;) or <em>&Delta;E*</em><sub>uv</sub> color difference method, respectively (for the <em>&Delta;E*</em><sub>ab</sub> method, differences around 2.3 are just noticeable [Mahy and others 1994])<sup><a href="#Note26">(26)</a></sup>.</li>
<li>If Euclidean distances are merely being compared (so that, for example, two distances are not added or multiplied), then the square root operation can be omitted.</li>
</ul>
</blockquote>

<p><strong>Riemersma&#39;s method.</strong> T. Riemersma suggests an algorithm for color difference, to be applied to companded RGB colors, in his article <a href="https://www.compuphase.com/cmetric.htm">&quot;Colour metric&quot;</a> (section &quot;A low-cost approximation&quot;).</p>

<p><strong>CMC.</strong> The following pseudocode implements the Color Measuring Committee color difference formula published in 1984, used above all in the textile industry. Note that in this formula, the order of the two <a href="#CIELAB">CIELAB</a> colors is important (the first color is the reference, and the second color is the test). Here, the formula is referred to as CMC(<code>LPARAM</code>:<code>CPARAM</code>) where&mdash;</p>

<ul>
<li><code>LPARAM</code> is a lightness tolerance and is usually either 2 or 1, and</li>
<li><code>CPARAM</code> is a chroma tolerance and is usually 1.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD COLORDIFF(lab1, lab2)
    c1=LabToChroma(lab1)
    c2=LabToChroma(lab2)
    h1=LabToHue(lab1)
    dl=0.511
    if lab1[0]&gt;=16: dl=0.040975*lab1[0]/(1+0.01765*lab1[0])
    dc=0.0638+(0.0638*c1/(0.0131*c1+1))
    f4=pow(c1,4)
    f4=sqrt(f4/(f4+1900))
    dt=0
    if h1&gt;=41*pi/45 and h1&lt;=23*pi/12
       dt=0.56+abs(0.2*cos(h1+14*pi/15))
    else
       dt=0.36+abs(0.4*cos(h1+7*pi/36))
    end
    dh=(dt*f4+1-f4)*dc
    dl=dl*LPARAM
    dc=dc*CPARAM
    da=lab2[1]-lab1[1]
    db=lab2[2]-lab1[2]
    dchr=c2-c1
    dhue=sqrt(max(0,da*da+db*db-dchr*dchr))
    dl=((lab2[0]-lab1[0])/dl)
    dc=(dchr/dc)
    dh=(dhue/dh)
    return sqrt(dl*dl+dc*dc+dh*dh)
END METHOD
</pre>

<p><strong>CIE94.</strong> The following pseudocode implements the color difference formula published in 1994 by the CIE, called CIE94 or <em>&Delta;E*</em><sub>94</sub>, between two <a href="#CIELAB">CIELAB</a> colors.
Note that in this formula, the order of the two colors is important (the first color is the reference, and the second color is the test).  In the pseudocode below, <code>TEXTILES</code> is <code>true</code> for a color difference suitable for textile applications, and <code>false</code> otherwise.</p>

<pre>METHOD COLORDIFF(lab1, lab2)
    c1=LabToChroma(lab1)
    c2=LabToChroma(lab2)
    dl=1
    dc=1+0.045*c1
    dh=1+0.015*c1
    if TEXTILES
            dl=2
            dc=1+0.048*c1
            dh=1+0.014*c1
    end
    da=lab2[1]-lab1[1]
    db=lab2[2]-lab1[2]
    dchr=c2-c1
    dhue=sqrt(max(0,da*da+db*db-dchr*dchr))
    dl=((lab2[0]-lab1[0])/dl)
    dc=(dchr/dc)
    dh=(dhue/dh)
    return sqrt(dl*dl+dc*dc+dh*dh)
END METHOD
</pre>

<p><strong>CIEDE2000.</strong> The following pseudocode implements the color difference formula published in 2000 by the CIE, called CIEDE2000 or <em>&Delta;E*</em><sub>00</sub>, between two <a href="#CIELAB">CIELAB</a> colors.</p>

<pre>METHOD COLORDIFF(lab1, lab2)
    dl=lab2[0]-lab1[0]
    hl=lab1[0]+dl*0.5
    sqb1=lab1[2]*lab1[2]
    sqb2=lab2[2]*lab2[2]
    c1=sqrt(lab1[1]*lab1[1]+sqb1)
    c2=sqrt(lab2[1]*lab2[1]+sqb2)
    hc7=pow((c1+c2)*0.5,7)
    trc=sqrt(hc7/(hc7+6103515625.0))
    t2=1.5-trc*0.5
    ap1=lab1[1]*t2
    ap2=lab2[1]*t2
    c1=sqrt(ap1*ap1+sqb1)
    c2=sqrt(ap2*ap2+sqb2)
    dc=c2-c1
    hc=c1+dc*0.5
    hc7=pow(hc,7)
    trc=sqrt(hc7/(hc7+6103515625.0))
    h1=atan2(lab1[2],ap1)
    if h1&lt;0: h1=h1+pi*2
    h2=atan2(lab2[2],ap2)
    if h2&lt;0: h2=h2+pi*2
    hdiff=h2-h1
    hh=h1+h2
    if abs(hdiff)&gt;pi
            hh=hh+pi*2
            if h2&lt;=h1: hdiff=hdiff+pi*2
            else: hdiff=hdiff-pi*2
    end
    hh=hh*0.5
    t2=1-0.17*cos(hh-pi/6)+0.24*cos(hh*2)
    t2=t2+0.32*cos(hh*3+pi/30)
    t2=t2-0.2*cos(hh*4-pi*63/180)
    dh=2*sqrt(c1*c2)*sin(hdiff*0.5)
    sqhl=(hl-50)*(hl-50)
    fl=dl/(1+(0.015*sqhl/sqrt(20+sqhl)))
    fc=dc/(hc*0.045+1)
    fh=dh/(t2*hc*0.015+1)
    dt=30*exp(-pow(36*hh-55*pi,2)/(25*pi*pi))
    r=0-2*trc*sin(2*dt*pi/180)
    return sqrt(fl*fl+fc*fc+fh*fh+r*fc*fh)
END METHOD
</pre>

<p><a id=Nearest_Colors></a></p>

<h3>Nearest Colors</h3>

<p>The <strong>nearest color algorithm</strong> is used, for example, to categorize colors or to reduce the number of colors used by an image.</p>

<p>In the pseudocode below,the method <code>NearestColorIndex</code> finds, for a given color (<code>color</code>), the index of the color nearest it in a given list (<code>list</code>) of colors, all in the same color space as <code>color</code>.  <code>NearestColorIndex</code> is independent of color model.</p>

<pre>METHOD NearestColorIndex(color, list)
   if size(list) == 0: return error
   if size(list) == 1: return 0
   i = 0
   best = -1
   bestIndex = 0
   while i &lt; size(list)
       dist = COLORDIFF(color,list[i])
       if i == 0 or dist &lt; best
          best = dist
          bestIndex = i
       end
       i = i + 1
   end
   return bestIndex
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>To find the nearest color to <code>color</code> in a list of colors (<code>list</code>), generate <code>nearestColor = list[NearestColorIndex(color, list)]</code>.</li>
<li><p>Sorting colors into <strong>color categories</strong> can be done by&mdash;</p>

<ul>
<li>defining a list of <strong>representative colors</strong> <code>repColors</code> (for example, representative colors for red, blue, black, white, and so on), then</li>
<li>for each color (<code>color</code>) to be categorized, finding the nearest color to that color among the representative colors (for example, by calling <code>NearestColorIndex(color, repColors)</code>),</li>
</ul>

<p>or by using the <a href="http://aishack.in/tutorials/kmeans-clustering"><em>k</em>-means algorithm</a> starting with <em>k</em> color points chosen at random or <em>k</em> representative colors.</p></li>
</ol>
</blockquote>

<p><a id=Dominant_Colors_of_an_Image></a></p>

<h2>Dominant Colors of an Image</h2>

<p>There are several methods of finding the kind or kinds of colors that appear most prominently in a raster image (or other color content data).  (Note that in what follows, the colors used in that image or data can be duplicates.)</p>

<p><strong>Averaging.</strong>  To find the dominant color using this technique&mdash;</p>

<ul>
<li>add all the colors used in the image or data, or a sample of them (for RGB colors, adding two or more colors means adding each of their components individually), then</li>
<li>divide the result by the number of colors added this way.</li>
</ul>

<p>Note that for best results, this technique needs to be carried out with <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em></a> rather than companded RGB colors.</p>

<p><strong><a href="https://en.wikipedia.org/wiki/Color_quantization">Color quantization</a>.</strong> In this technique, the colors used in the image or data are reduced to a small set of colors (for example, ten to twenty).  There are several kinds of quantization algorithms, including <a href="https://en.wikipedia.org/wiki/K-means_clustering"><em>k</em>-means clustering</a> (which is a randomized algorithm). Again, for best results, color quantization needs to be carried out with <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em></a> rather than companded RGB colors.</p>

<p><strong>Histogram binning.</strong> To find the dominant colors using this technique (which is independent of color model):</p>

<ul>
<li>Generate or furnish a list of colors that cover the space of colors well.  This is the <em>color palette</em>. A good example is the list of <a href="#RGB_Colors_and_the_0_1_Format">&quot;Web safe colors&quot;</a>.</li>
<li>Create a list with as many zeros as the number of colors in the palette.  This is the <em>histogram</em>.</li>
<li>For each color used in the image or data, find its <a href="#Nearest_Colors">nearest color</a> in the color palette, and add 1 to the nearest color&#39;s corresponding value in the histogram.</li>
<li>Find the color or colors in the color palette with the highest histogram values, and return those colors as the dominant colors in the image.</li>
</ul>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>For all three techniques, in the case of a raster image, an implementation can scale down that image before proceeding to find its dominant colors.  Algorithms to resize or &quot;resample&quot; images are out of scope for this page, however.</li>
<li>Reducing the number of colors in an image usually involves finding that image&#39;s dominant colors and either&mdash;

<ul>
<li>applying a &quot;nearest neighbor&quot; approach (replacing that image&#39;s colors with their <a href="#Nearest_Colors">nearest dominant colors</a>), or</li>
<li>applying a <a href="https://en.wikipedia.org/wiki/Dither">&quot;dithering&quot;</a> technique (especially to reduce undesirable color &quot;banding&quot; in certain cases), which is outside the scope of this document, however.</li>
</ul></li>
<li>Finding the number of <em>unique</em> colors in an image is equivalent to storing those colors as keys in a hash table, then counting the number of keys stored this way.<sup><a href="#Note27">(27)</a></sup></li>
<li><strong>Extracting a scene&#39;s &quot;true colors&quot;</strong>: For applications where matching colors from the real world is important, colors need to be measured using a colorimeter or similar device, or be extracted from <a href="http://eilv.cie.co.at/term/567"><em>scene-referred</em> image data</a> (such as a raw image from a digital camera after camera compensation, but without color rendering).  PNG and many other image formats store image data commonly interpreted as <a href="#sRGB">sRGB</a> by default; however, sRGB is an <a href="http://eilv.cie.co.at/term/565"><em>output-referred</em></a> color space, not a scene-referred one (it&#39;s based on the color output of cathode-ray-tube monitors), making sRGB images unsuitable for real-world color-matching without more.<br>Getting scene-referred image data from a digital camera, including a smartphone camera, is not trivial and is not discussed in detail in this document.  It requires knowing, among other things, whether the camera offers access to raw image data, the format of that raw data, and possibly whether the camera does color rendering before generating output-referred image data.  A raw image&#39;s colors can be estimated by the use of a raw image of a color calibration chart (test target) or by another technique.  The ISO 17321 series and IEC 61966-9 touch on this subject.</li>
</ol>
</blockquote>

<p><a id=Color_Maps></a></p>

<h2>Color Maps</h2>

<p>A <em>color map</em> (or <em>color palette</em>) is a list of colors, which are usually related. All the colors in a color map can be in any one color space, but unless noted otherwise, <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a> should be used rather than companded RGB colors.</p>

<blockquote>
<p><strong>Example:</strong> A <strong>grayscale color map</strong> consists of the companded RGB colors <code>[[0, 0, 0], [0.5, 0.5, 0.5], [1, 1, 1]]</code>.</p>
</blockquote>

<p><a id=Kinds_of_Color_Maps></a></p>

<h3>Kinds of Color Maps</h3>

<p>The <a href="http://colorbrewer2.org/"><em>ColorBrewer 2.0</em></a> Web site&#39;s suggestions for color maps are designed above all for visualizing data on land maps.  For such purposes, C. Brewer, the creator of <em>ColorBrewer 2.0</em>, has identified <a href="http://colorbrewer2.org/learnmore/schemes_full.html">three kinds</a> of appropriate color maps:</p>

<ul>
<li><strong>Sequential color maps</strong> for showing &quot;ordered data that progress from low to high&quot;. Those found in <em>ColorBrewer 2.0</em> use varying tints of the same hue or of two close hues.</li>
<li><strong>Diverging color maps</strong> for showing continuous data with a clearly defined midpoint (the &quot;critical value&quot;) and where the distinction between low and high is also visually important. Those found in <em>ColorBrewer 2.0</em> use varying tints of two &quot;contrasting hues&quot;, one hue at each end, with lighter tints closer to the middle.  Where such color maps are used in 3D visualizations, K. Moreland <a href="http://www.kennethmoreland.com/color-advice/">recommends</a> &quot;limiting the color map to reasonably bright colors&quot;.</li>
<li><strong>Qualitative color maps</strong> for showing discrete categories of data (see also &quot;<a href="#Visually_Distinct_Colors">Visually Distinct Colors</a>&quot;). Those found in <em>ColorBrewer 2.0</em> use varying hues.</li>
</ul>

<blockquote>
<p><strong>Note:</strong> The fact that <em>ColorBrewer 2.0</em> identifies some of its color maps as being &quot;print friendly&quot;<sup><a href="#Note28">(28)</a></sup> and/or &quot;<a href="https://peteroupc.github.io/suppcolor.html#Defective_and_Animal_Color_Vision">color blind friendly</a>&quot; suggests that these two factors can be important when generating color maps of the three kinds just mentioned.</p>
</blockquote>

<p><a id=Color_Collections></a></p>

<h3>Color Collections</h3>

<p>If each color in a color map has a name, number, or code associated with it, the color map is also called a <em>color collection</em>.  Examples of names are &quot;red&quot;, &quot;vivid green&quot;, &quot;orange&quot;, and &quot;5RP 5/6&quot;<sup><a href="#Note29">(29)</a></sup>.  A survey of color collections or color atlases is not covered in this document, but some of them are discussed in some detail in my <a href="https://peteroupc.github.io/html3dutil/tutorial-colors.html#What_Do_Some_Colors_Look_Like">colors tutorial for the HTML 3D Library</a>.</p>

<p>Converting a color (such as an RGB color) to a color name is equivalent to&mdash;</p>

<ul>
<li>retrieving the name keyed to that color in a hash table (or returning an error if that color doesn&#39;t exist in the hash table), or</li>
<li>finding the <a href="#Nearest_Colors">nearest color</a> to that color among the named colors, and returning the color found this way (and/or that color&#39;s name).<sup><a href="#Note27">(27)</a></sup></li>
</ul>

<p>Converting a color name to a color is equivalent to retrieving the color keyed to that name (or optionally, its lower-cased form) in a hash table, or returning an error if no such color exists.<sup><a href="#Note27">(27)</a></sup></p>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>As used in the <a href="http://www.w3.org/TR/css3-color/">CSS color module level 3</a>, named colors defined in that module are in the <a href="#sRGB"><em>sRGB color space</em></a> (as companded colors).</li>
<li>If the color names identify points in a color space (as in the &quot;5RP 5/6&quot; example), converting a color name with a similar format (e.g., &quot;5.6PB 7.1/2.5&quot;) to a color can be done by multidimensional interpolation of the known color points, details of which are beyond the scope of this page.</li>
</ul>
</blockquote>

<p><a id=Visually_Distinct_Colors></a></p>

<h3>Visually Distinct Colors</h3>

<p>Color maps can list colors used to identify different items. Because of this
use, many applications need to use colors that are easily distinguishable by humans.  In this respect&mdash;</p>

<ul>
<li>K. Kelly (1965) proposed a list of &quot;twenty two colors of maximum contrast&quot;<sup><a href="#Note30">(30)</a></sup>, the first nine of which
were intended for readers with normal and <a href="https://peteroupc.github.io/suppcolor.html#Defective_and_Animal_Color_Vision">defective</a> color vision, and</li>
<li>B. Berlin and P. Kay, in a work published in 1969, identified eleven basic color terms: black, white, gray, purple, pink, red, green, blue, yellow, orange, and brown.</li>
</ul>

<p>In general, the greater the number of colors used, the harder it is to distinguish them from each other.  Any application that needs to distinguish many items (especially more than 22 items, the number of colors in Kelly&#39;s list) should use other visual means in addition to color
(or rather than color) to help users identify them. (Note that under the
<a href="https://www.w3.org/TR/2008/REC-WCAG20-20081211/">Web Content Accessibility Guidelines 2.0</a>,
color should not be <a href="http://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-without-color">&quot;the only visual means of conveying information&quot;</a>.)</p>

<p>In general, any method that seeks to choose colors that are maximally distant in a particular
color space (that is, where the smallest <a href="#Color_Differences">color difference</a> [<code>COLORDIFF</code>]
between them is maximized as much as feasible) can be used to select visually
distinct colors. Such colors can be pregenerated or generated at runtime, and such colors
can be limited to those in a particular <em>color gamut</em>. Here, the color difference method
should be <em>&Delta;E*</em><sub>ab</sub> or another color difference method that takes human color perception into account. (See also Tatarize, &quot;<a href="http://godsnotwheregodsnot.blogspot.com/2012/09/color-distribution-methodology.html">Color Distribution Methodology</a>&quot;.)</p>

<p><a id=Pseudocode></a></p>

<h3>Pseudocode</h3>

<p>In the following pseudocode&mdash;</p>

<ul>
<li><code>ColorMapContinuous</code> extracts a <strong>continuous color</strong> (blended color) from a color map (<code>colormap</code>), and</li>
<li><code>ColorMapDiscrete</code> extracts a <strong>discrete color</strong> (nearest color) from a color map (<code>colormap</code>),</li>
</ul>

<p>where <code>value</code> is a number 0 or greater and 1 or less (0 and 1 are the start and end of the color map, respectively).</p>

<pre>    METHOD ColorMapContinuous(colormap, value)
        nm1 = size(colormap) - 1
        index = (value * nm1) - floor(value * nm1)
        if index &gt;= nm1: return colormap[index]
        fac = (value * nm1) - index)
        list1 = colormap[index]
        list2 = colormap[index + 1]
        return [list1[0]+(list2[0]-list1[0])*fac, list1[1]+(list2[1]-list1[1])*fac,
            list1[2]+(list2[2]-list1[2])*fac]
    END METHOD

    METHOD ColorMapDiscrete(colormap, value)
       return colormap[round(value * (N - 1))]
    END METHOD
</pre>

<p><a id=Generating_a_Random_Color></a></p>

<h2>Generating a Random Color</h2>

<p>The following techniques can be used to generate random RGB colors. Note that for best results, these techniques need to use <a href="#Linear_RGB_and_Companded_RGB"><em>linear RGB</em> colors</a>, unless noted otherwise.</p>

<ul>
<li>Generating a random color in the <strong>8/8/8 format</strong> is equivalent to calling <code>From888(RNDINT(16777215))</code>.</li>
<li>Generating a random string in the <strong>HTML color format</strong> is equivalent to generating a <a href="https://peteroupc.github.io/randomfunc.html#Creating_a_Random_Character_String">random hexadecimal string</a> with length 6, then inserting the string &quot;#&quot; at the beginning of that string. But see the <a href="#HTML_Color_Format">note from earlier</a>.</li>
<li>Generating a random color in the <strong>0-1 format</strong> is equivalent to generating <code>[RNDU01(), RNDU01(), RNDU01()]</code>.</li>
<li>To generate a random <strong>dark color</strong>, either&mdash;

<ul>
<li>generate <code>color = [RNDU01(), RNDU01(), RNDU01()]</code> until <a href="#Relative_Luminance_Grayscale"><code>Luminance(color)</code></a> is less than a given threshold, e.g., 0.5, or</li>
<li>generate <code>color = [RNDU01() * maxComp, RNDU01() * maxComp, RNDU01() * maxComp]</code>, where <code>maxComp</code> is the
maximum value of each color component, e.g., 0.5.</li>
</ul></li>
<li>To generate a random <strong>light color</strong>, either&mdash;

<ul>
<li>generate <code>color = [RNDU01(), RNDU01(), RNDU01()]</code> until <a href="#Relative_Luminance_Grayscale"><code>Luminance(color)</code></a> is greater than a given threshold, e.g., 0.5, or</li>
<li>generate <code>color = [minComp + RNDU01() * (1.0 - minComp), minComp + RNDU01() * (1.0 - minComp), minComp + RNDU01() * (1.0 - minComp)]</code>, where <code>minComp</code> is the minimum value of each color component, e.g., 0.5.</li>
</ul></li>
<li>One way to generate a random <strong>pastel color</strong> is to generate <code>color = [RNDU01(), RNDU01(), RNDU01()]</code> until <a href="#Relative_Luminance_Grayscale"><code>Luminance(color)</code></a> is greater than 0.75 and less than 0.9.</li>
<li>To generate a <strong>random color at or between two others</strong> (<code>color1</code> and <code>color2</code>), generate <code>Lerp3(color1, color2, RNDU01())</code>.</li>
<li>To generate a <strong>random shade</strong> of a given color, generate <code>Lerp3(color1, [0, 0, 0], RNDNUMRANGE(0.2, 1.0))</code>.</li>
<li>To generate a <strong>random tint</strong> of a given color, generate <code>Lerp3(color1, [1, 1, 1], RNDNUMRANGE(0.0, 0.9))</code>.</li>
<li>To generate a <strong>random tone</strong> of a given color, generate <code>Lerp3(color1, [0.5, 0.5, 0.5], RNDNUMRANGE(0.0, 0.9))</code>.</li>
<li>To generate a <strong>random monochrome color</strong>, generate <code>HslToRgb(H, RNDU01(),RNDU01())</code>, where <code>H</code> is an arbitrary <a href="#HSV">hue</a>.</li>
<li><strong>Random color sampling:</strong>

<ul>
<li>To select a random continuous color from a color map (<code>colormap</code>): <code>ColorMapContinuous(colormap, RNDU01())</code>.</li>
<li>To select one random color from a color map (<code>colormap</code>): <code>colormap[RNDINTEXC(size(colormap))]</code>.  See also <a href="https://peteroupc.github.io/randomfunc.html#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List">&quot;Choosing a Random Item from a List&quot;</a>.</li>
<li>To select several random colors from a color map: See <a href="https://peteroupc.github.io/randomfunc.html#Sampling_Without_Replacement_Choosing_Several_Unique_Items">&quot;Choosing Several Unique Items&quot;</a>.</li>
</ul></li>
<li><strong>Similar random colors:</strong> Generating a random color that&#39;s similar to another is equivalent to generating a random color (<code>color1</code>) until <code>COLORDIFF(color1, color2)</code> (defined <a href="#Color_Differences">earlier</a>) is less than a predetermined threshold, where <code>color2</code> is the color to compare.</li>
<li><strong>Data hashing:</strong> A technique similar to generating random colors is to generate a color from arbitrary data using a <a href="https://peteroupc.github.io/random.html#Hash_Functions"><em>hash function</em></a>.</li>
</ul>

<p><a id=Spectral_Color_Functions></a></p>

<h2>Spectral Color Functions</h2>

<p>A color stimulus can be represented as a function (&quot;curve&quot;) that describes a distribution of radiation (such as light) across the electromagnetic spectrum.  There are three cases of objects that provoke a color sensation by light:</p>

<ul>
<li><strong>Light sources.</strong> A <em>spectral power distribution</em> (SPD) describes the intensity of a light source at each <a href="http://eilv.cie.co.at/term/1426">wavelength</a> within the electromagnetic spectrum.</li>
<li><strong>Reflective materials.</strong> A <em>(spectral) reflectance curve</em> describes the fraction of light reflected by a reflective (opaque) material.</li>
<li><strong>Transmissive materials.</strong> A <em>transmittance curve</em> describes the fraction of light that passes through a transmissive (translucent or transparent) material, such as a light filter.</li>
</ul>

<p>A material&#39;s perceived color depends on its reflectance or transmittance curve, the light source, and the viewer (whose visual response is modeled by three <em>color-matching functions</em>).  That curve, the light source&#39;s SPD, and the color-matching functions, are converted to three numbers (called <em>tristimulus values</em>) that uniquely identify that color.</p>

<p>The pseudocode below includes a <code>SpectrumToTristim</code> method for computing tristimulus values.  In the method:</p>

<ul>
<li><code>REFL(wl)</code>, <code>LIGHT(wl)</code>, and <code>CMF(wl)</code> are arbitrary functions further described later.  All three take a
wavelength (<code>wl</code>) in nanometers (nm) and return the corresponding values at that wavelength.
(<em>See also note 1 later in this section.</em>)</li>
<li><code>REFL(wl)</code> models the <strong>reflectance or transmittance curve</strong>. <code>REFL</code> returns the value of the curve at the wavelength <code>wl</code>; the value can be 0 or greater and, with the exception of fluorescent materials, 1 or less.  If <code>REFL</code> is <code>PerfectWhite</code> (below), then the tristimulus values calculated are the <em>adopted white</em> (and are those of the light source itself).</li>
<li><code>LIGHT(wl)</code> models a <strong>light source&#39;s SPD</strong>; it returns the source&#39;s relative intensity at the wavelength <code>wl</code>. Choices for <code>LIGHT</code> include&mdash;

<ul>
<li>a CIE daylight illuminant such as the D65 or D50 illuminant (see the <a href="https://peteroupc.github.io/colorutil.py">Python sample code</a> for implementation),</li>
<li>the blackbody spectral formula given in &quot;<a href="#Color_Temperature">Color Temperature</a>&quot;, and</li>
<li>the SPD for a light-emitting diode (LED), fluorescent, or other artificial light source.</li>
</ul></li>
<li><code>CMF(wl)</code> models three <strong>color-matching functions</strong> and returns a list of those functions&#39; values at the wavelength <code>wl</code>. The choice of <code>CMF</code> determines the kind of tristimulus values returned by <code>SpectrumToTristim</code>. Choices for <code>CMF</code> include&mdash;

<ul>
<li>the CIE 1931 (2-degree) standard observer<sup><a href="#Note1">(1)</a></sup><sup><a href="#Note31">(31)</a></sup>, which is used to generate <a href="#CIE_XYZ">XYZ colors</a> based on color stimuli seen at a 2-degree field of view, and</li>
<li>the  CIE 1964 (10-degree) standard observer<sup><a href="#Note1">(1)</a></sup>, which is used to generate XYZ colors based on color stimuli seen at a 10-degree field of view.</li>
</ul></li>
</ul>

<p>&nbsp;</p>

<pre>METHOD SpectrumToTristim()
    i = 360 // Start of relevant part of spectrum
    xyz=[0,0,0]
    weight = 0
    // Sample at 5 nm intervals
    while i &lt;= 830 // End of relevant part of spectrum
             cmf=CMF(i)
             refl=REFL(i)
             spec=LIGHT(i)
             weight=weight+cmf[1]*spec*5
             xyz[0]=xyz[0]+refl*spec*cmf[0]*5
             xyz[1]=xyz[1]+refl*spec*cmf[1]*5
             xyz[2]=xyz[2]+refl*spec*cmf[2]*5
             i = i + 5
    end
    if weight==0: return xyz
    // NOTE: Note that `weight` is constant for a given
    // color-matching function set and light source together,
    // so that `weight` can be precomputed if they will
    // not change.
    // NOTE: If `weight` is 1/683, `CMF` outputs XYZ
    // values, and `REFL` always returns 1, then SpectrumToTristim
    // will output XYZ values where Y is a value in cd/m^2.
    xyz[0] = xyz[0] / weight
    xyz[1] = xyz[1] / weight
    xyz[2] = xyz[2] / weight
    return xyz
END METHOD

// Models a perfect reflecting diffuser or
// perfect transmitting diffuser
METHOD PerfectWhite(wavelength)
    return 1
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>Although <code>REFL</code>, <code>LIGHT</code>, and <code>CMF</code> are actually continuous functions, in practice tristimulus values are calculated based on samples at discrete wavelengths.  For example, CIE Publication 15 recommends a 5-nm wavelength interval.  For spectral data at 10-nm and 20-nm intervals, the practice described in ISO 13655 or in ASTM International E308 and E2022 can be used to compute tristimulus values (in particular, E308 includes tables of weighting factors for common combinations of <code>CMF</code> and <code>LIGHT</code>).  For purposes of color reproduction, only wavelengths within the range 360-780 nm (0.36-0.78 &mu;m) are relevant in practice.</li>
<li>For applications where matching colors from the real world is important, reflectance and transmittance curves (<code>REFL</code>) can be less ambiguous than colors in the form of three tristimulus values (such as XYZ or RGB colors), because for a given combination of viewer (<code>CMF</code>) and light source (<code>LIGHT</code>)&mdash;

<ul>
<li>two different curves can match the same color (and be <em>metamers</em>) or match different colors, whereas</li>
<li>two identical curves match the same color (but are not called metamers).</li>
</ul></li>
</ol>

<p><strong>Example:</strong> If <code>LIGHT</code> and <code>CMF</code> are the D65 illuminant and the CIE 1931 standard observer, respectively (both used in the <a href="#sRGB">sRGB color space</a>)&mdash;</p>

<ul>
<li>the tristimulus values (e.g., from <code>SpectrumToTristim()</code>) will be a relative <a href="#CIE_XYZ">XYZ color</a> such that Y ranges from 0 for &quot;absolute black&quot; to 1 for the D65 white point,</li>
<li>the idiom <code>XYZTosRGB(SpectrumToTristim())</code> computes the companded sRGB color of the stimulus, and</li>
<li>the idiom <code>XYZTosRGB(CMF(wl))</code> computes the companded sRGB color of a light source that emits light only at the wavelength <code>wl</code> (a <em>monochromatic stimulus</em>), where the wavelength is expressed in nm.</li>
</ul>
</blockquote>

<p><a id=Color_Temperature></a></p>

<h3>Color Temperature</h3>

<p>A <em>blackbody</em> is an idealized material that emits light based only on its temperature.  The <code>Planckian</code> method shown below finds the SPD of a blackbody with the given temperature in kelvins (its <strong>color temperature</strong>). The <code>LIGHT</code> function below (for <code>SpectrumToTristim()</code>) uses that formula (where <code>TEMP</code> is the desired color temperature).<sup><a href="#Note32">(32)</a></sup></p>

<pre>METHOD Planckian(wavelength, temp)
    num = pow(wavelength, -5)
    // NOTE: 0.014... was calculated based on
    // 2017 versions of Planck and Boltzmann constants
    return num / (exp(0.0143877687750393/(wavelength*pow(10, -9)*temp)) - 1)
END METHOD

METHOD LIGHT(wavelength) # NOTE: Relative only
    t=TEMP
    if t&lt;60: t=60 # For simplicity, in very low temperature
    return Planckian(wavelength, t) * 100.0 /
        Planckian(560, wavelength)
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> If <code>TEMP</code> is 2856, the <code>LIGHT</code> function above is substantially equivalent to the CIE illuminant A.</p>
</blockquote>

<p>The following method (<code>XYZToCCT</code>) computes an approximate color temperature, in kelvins, from an
<a href="#CIE_XYZ">XYZ color</a>. Because of the limited range of chromaticities of blackbody light (namely red, orange, pale yellow, or sky blue), the color temperature found by this formula is often called <a href="http://eilv.cie.co.at/term/258"><em>correlated color temperature</em></a> (CCT).  The formula given here is based on the one found in McCamy 1992.</p>

<pre>METHOD XYZToCCT(xyz)
    xyy = XYZToxyY(xyz)
    c = (xyy[0] - 0.332) / (0.1858 - xyy[1])
    return ((449*c+3525)*c+6823.3)*c+5520.33
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> Color temperature, as used here, is not to be confused with the division of colors into <em>warm</em> (usually red, yellow, and orange) and <em>cool</em> (usually blue and blue green) categories, a subjective division which admits of much variation.  But in general, in the context of light sources, the lower the light&#39;s CCT, the &quot;warmer&quot; the light appears, and the higher the CCT, the &quot;cooler&quot;.</p>
</blockquote>

<p><a id=Color_Mixture></a></p>

<h3>Color Mixture</h3>

<p>In &quot;<a href="http://scottburns.us/subtractive-color-mixture/">Subtractive Color Mixture Computation</a>&quot;, Scott A. Burns indicates that the color mixture of two pigments, or the mixture of two colors that is similar to mixing two pigments with those colors, can be simulated by&mdash;</p>

<ol>
<li>finding the <a href="#Spectral_Color_Functions"><em>reflectance curves</em></a> of the pigments or colors,</li>
<li>generating a mixed reflectance curve by the <em>weighted geometric mean</em> of the source curves, which
takes into account the relative proportions of the pigments or colors in the mixture, and</li>
<li>converting the mixed reflectance curve to an RGB color.<sup><a href="#Note33">(33)</a></sup></li>
</ol>

<p>For convenience, the <code>WGM</code> method below computes the weighted geometric mean of one or more numbers, where <code>values</code> is a list of values (for example, reflectance factors of several curves at the same wavelength), and <code>weights</code> is a list of those values&#39; corresponding weights (for example, mixing proportions of those curves).</p>

<pre>METHOD WGM(values, weights)
    if size(values)!=size(weights): return error
    if size(values)==0: return values[0]
    sum=0
    i=0
    while i &lt; size(weights)
      sum=sum+weights[i]
      i=i+1
    end
    if sum&lt;=0: return error
    ret=1
    while i &lt; size(values)
      ret=ret*pow(values[i],weights[i]/sum)
      i=i+1
    end
    return ret
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>Finding a <em>representative</em> reflectance curve for an arbitrary (companded) RGB color can be done, for example, by the method described in <a href="http://www.cs.utah.edu/%7Ebes/papers/color/">Smits 1999</a> or the method described in <a href="http://scottburns.us/reflectance-curves-from-srgb/">Burns 2015</a>. (Note that <a href="http://www.handprint.com/HP/WCL/color18a.html#ctprin38">widely varying reflectance curves</a> can match the same RGB color.)</li>
<li>If the &quot;reflectance curves&quot; represent light passing through transmissive materials (such as light filters), rather than reflected from pigments, the <a href="http://www.handprint.com/HP/WCL/color3.html#mixprofile">simple product</a> of those curves, rather than the geometric mean as given in step 2, yields the mixed curve of their mixture, according to B. MacEvoy.</li>
<li>An alternative method of color formulation, based on the <em>Kubelka&ndash;Munk</em> theory, uses two curves for each colorant: an <em>absorption coefficient</em> curve (K curve) and a <em>scattering coefficient</em> curve (S curve).  The ratio of absorption to scattering (<em>K/S</em>) has a simple relationship to reflectance factors in the Kubelka&ndash;Munk theory.  The Python sample code implements the Kubelka&ndash;Munk equations.  One way to predict a color formula using this theory is described in a 1985 thesis by E. Walowit.  ISO 18314-2 is also a relevant document.</li>
</ul>
</blockquote>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>This page discussed many topics on color that are generally relevant in programming.</p>

<p>Feel free to send comments. They may help improve this page.  In particular, corrections to any method given on this page are welcome.</p>

<p>I acknowledge&mdash;</p>

<ul>
<li>the CodeProject user Mike-MadBadger, who suggested additional clarification on color spaces and color models,</li>
<li>&quot;RawConvert&quot; from the pixls.us discussion forum,</li>
<li>Elle Stone, and</li>
<li>Thomas Mansencal.</li>
</ul>

<p>The following topics may be added in the future based on reader interest:</p>

<ul>
<li>The CAM02 color appearance model.</li>
<li>Color rendering metrics for light sources, including color rendering index (CRI) and the metrics given in TM-30-15 by the Illuminating Engineering Society.</li>
</ul>

<p><a id=Questions_for_This_Document></a></p>

<h3>Questions for This Document</h3>

<p>Questions for this document:</p>

<ul>
<li>Are there color topics not covered by this document that should be covered?</li>
<li>Is the threshold for the sRGB inverse component transfer function, as specified in the latest version of the IEC standard, 0.04045 (truncated to five decimal places) or <code>12.92 * 0.0031308 = 0.040449936</code>?</li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> The CIE publishes <a href="http://www.cie.co.at/technical-work/technical-resources">tabulated data</a> for the D65 illuminant and the CIE 1931 and 1964 standard observers at its Web site.</small></p>

<p><small><sup id=Note2>(2)</sup> Although most electronic color displays in the past used three dots per pixel (red, green, and blue), this may hardly be the case today.  Nowadays, recent electronic displays and luminaires are likely to use more than three dots per pixel &mdash; such as red, green, blue, and white, or RGBW &mdash; and ideally, color spaces following the <em>RGBW color model</em>, or similar color models, describe the intensity those dots should have in order to reproduce certain colors.  Such color spaces, though, are not yet of practical interest to most programmers outside of hardware and driver development for light-emitting diodes, luminaires, or electronic displays.</small></p>

<p><small><sup id=Note3>(3)</sup> Although most RGB color spaces in common use define their red, green, and blue points as actual colors, this is not always the case.  For example, the <a href="http://www.oscars.org/science-technology/sci-tech-projects/aces">ACES2065-1 color space</a> of the Academy of Motion Picture Arts and Sciences covers almost all colors but has imaginary green and blue points. See also note 6.</small></p>

<p><small><sup id=Note4>(4)</sup> The base-16 digits, in order, are 0 through 9, followed by A through F. The digits A through F can be uppercase or lowercase.</small></p>

<p><small><sup id=Note5>(5)</sup> A <a href="http://www.w3.org/TR/2016/WD-css-color-4-20160705/#hex-notation">Working Draft</a> of the CSS Color Module Level 4 mentions two additional formats, namely&mdash;</p>

<ul>
<li>an 8-digit format, consisting of &quot;#&quot; followed by eight base-16 digits, two each for the red, green, blue, and alpha components, in that order, and</li>
<li>a 4-digit format, consisting of &quot;#&quot; followed by four base-16 digits, one each for the red, green, blue, and alpha components, in that order (where, for example, &quot;#345F&quot; is the same as &quot;#334455FF&quot; in the 8-digit format).</small></li>
</ul>

<p><small><sup id=Note6>(6)</sup> A thorough survey of working spaces other than sRGB, such as eciRGB and NTSC, as well as how to convert between RGB working spaces, are not discussed in detail in this document.  B. Lindbloom, &quot;<a href="http://www.brucelindbloom.com/index.html?WorkingSpaceInfo.html">RGB Working Space Information</a>&quot;, contains further information on RGB working spaces.</small></p>

<p><small><sup id=Note7>(7)</sup> The hue angle is in radians, and the angle is 0 or greater and less than 2&pi;. Radians can be converted to degrees by multiplying by <code>180 / pi</code>.  Degrees can be converted to radians by multiplying by <code>pi / 180</code>.</small></p>

<p><small><sup id=Note8>(8)</sup> In interior and architectural design, Y is also known as <em>light reflectance value</em> (LRV), provided the XYZ color is such that Y ranges from 0 for black to 100 for white.</small></p>

<p><small><sup id=Note9>(9)</sup> In some cases, the D50 white point can be more convenient than the D65 white point (which is otherwise usual for sRGB) because:</p>

<ul>
<li>Calculations relative to the D50 white point can improve interoperability with applications color-managed with International Color Consortium (ICC) version 2 or 4 profiles.</li>
<li>In the printing industry, the D50 illuminant and D50 white point are in wide use; for example, the CIELAB color space in use there is generally based on the D50 white point.</small></li>
</ul>

<p><small><sup id=Note10>(10)</sup> Further details on chromatic adaptation transforms are outside the scope of this document. (See also E. Stone, &quot;<a href="https://ninedegreesbelow.com/photography/srgb-luminance.html">The Luminance of an sRGB Color</a>&quot;, 2013.)</small></p>

<p><small><sup id=Note11>(11)</sup> <a href="http://www.cie.co.at/publications/technical-notes">CIE Technical Note 001:2014</a> says the chromaticity difference (<em>&Delta;<sub>u&prime;v&prime;</sub></em>) should be calculated as the <a href="#Color_Differences">Euclidean distance</a> between two <em>u&prime;v&prime;</em> pairs and that a chromaticity difference of 0.0013 is just noticeable &quot;at 50% probability&quot;.</p>

<p><em>uv</em> chromaticity, a former 1960 version of <em>u&prime;v&prime;</em> chromaticity, is found by taking <em>u</em> as <em>u&prime;</em> and <em>v</em> as (<em>v&prime;</em> * 2.0 / 3).</small></p>

<p><small><sup id=Note12>(12)</sup> Although the CIELAB color model is also often called &quot;perceptually uniform&quot;&mdash;</p>

<ul>
<li>CIELAB &quot;was not designed to have the perceptual qualities needed for gamut mapping&quot;, according to <a href="http://www.brucelindbloom.com/index.html?UPLab.html">B. Lindbloom</a>, and</li>
<li>such a claim &quot;is really only the case for very low spatial frequencies&quot;, according to P. Kovesi (P. Kovesi, &quot;Good Colour Maps: How to Design Them&quot;, arXiv:1509.03700 [cs.GR], 2015).</small></li>
</ul>

<p><small><sup id=Note13>(13)</sup> The placement of the <em>L*</em>, <em>a*</em>, and <em>b*</em> axes is related to the light/dark contrast, the <em>opponent signal</em> red vs. green, and the opponent signal yellow vs. blue, respectively, which are believed to be generated by the human visual system in response to a stimulus of light. (These three contrasts are largely associated with E. Hering&#39;s work.  See also the entry &quot;<a href="http://eilv.cie.co.at/term/542">hue</a>&quot; in the CIE&#39;s International Lighting Vocabulary.)</small></p>

<p><small><sup id=Note14>(14)</sup> The terms <em>lightness</em> and <em>chroma</em> are relative to an area appearing white.  The corresponding terms <em>brightness</em> and <em>saturation</em>, respectively, are subjective terms: <em>brightness</em> is the perceived degree of reflected or emitted light, and <em>saturation</em> is the perceived hue strength (<em>colorfulness</em>) compared to other colors of the same hue and brightness. (See also the CIE&#39;s International Lighting Vocabulary.) Note, however, that CIELAB has no formal saturation formula (see the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Colorfulness">colorfulness</a>).</small></p>

<p><small><sup id=Note15>(15)</sup> The prime symbol appears near Y because the conversion from RGB usually involves <a href="#Linear_RGB_and_Companded_RGB">companded RGB colors</a>, so that Y&prime; will be similar to luminance, but not the same as luminance (Y).  See C. Poynton, <a href="http://poynton.ca/PDFs/YUV_and_luminance_harmful.pdf">&quot;<em>YUV</em> and <em>luminance</em> considered harmful&quot;</a>.</small></p>

<p><small><sup id=Note16>(16)</sup> The prime symbol is left out in function names and other names in the pseudocode for convenience only.</small></p>

<p><small><sup id=Note17>(17)</sup> The BT.2020 standard defines a color model called <em>YcCbcCrc</em> for encoding ultra-high-definition video.  Unlike for Y&prime;C<sub><em>B</em></sub>C<sub><em>R</em></sub>, <em>linear RGB</em> colors, rather than companded ones, should be converted to and from YcCbcCrc.  However, YcCbcCrc is not yet of general interest to programmers.</small></p>

<p><small><sup id=Note18>(18)</sup> Other methods that have been used for approximating (but not quite yielding) relative luminance include&mdash;</p>

<ul>
<li>using the average, minimum, or maximum of the three color components (as shown on <a href="http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/">T. Helland&#39;s site</a>, for example),</li>
<li>using the <a href="#HSL">HSL</a> &quot;lightness&quot; (see J. Cook, <a href="https://www.johndcook.com/blog/2009/08/24/algorithms-convert-color-grayscale/">&quot;Converting color to grayscale&quot;</a>), and</li>
<li>using one of the three color components (also as seen on T. Helland&#39;s site).</small></li>
</ul>

<p><small><sup id=Note19>(19)</sup> See C. Poynton, <a href="http://poynton.ca/PDFs/YUV_and_luminance_harmful.pdf">&quot;<em>YUV</em> and <em>luminance</em> considered harmful&quot;</a>.</small></p>

<p><small><sup id=Note20>(20)</sup> In the <a href="https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast">Web Content Accessibility Guidelines 2.0</a>, the <em>contrast ratio</em> of two colors is <code>(RelLum(brighter) + 0.05) / (RelLum(darker) + 0.05)</code>, where <code>RelLum(color)</code> is the &quot;relative luminance&quot; of a color as defined in the guidelines, <code>brighter</code> is the color with higher <code>RelLum</code>; and <code>darker</code> is the other color.  In general, under those guidelines, a <em>contrasting color</em> is one whose contrast ratio with another color is 4.5 or greater (or 7 or greater for a stricter conformance level).</p>

<p>For companded sRGB 8/8/8 colors, <code>RelLum(color)</code> is effectively equivalent to <code>LuminanceSRGB(color)</code>, but with the guidelines using a different version of <code>LinearFromsRGB</code>, with 0.03928 (the value used in the sRGB proposal) rather than 0.04045, but this difference doesn&#39;t affect the result for such 8/8/8 colors.  <code>RelLum(color)</code> is equivalent to <a href="#Relative_Luminance_Grayscale"><code>Luminance(color)</code></a> whenever conformance to the guidelines is not important.</p>

<p>A small percentage of people have <a href="https://peteroupc.github.io/suppcolor.html#Defective_and_Animal_Color_Vision">defective color vision</a> and so may find certain colors harder to distinguish.  However, according to <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">&quot;Understanding WCAG 2.0&quot;</a>, &quot;effective <a href="#Relative_Luminance_Grayscale">luminance contrast</a> can generally be computed without regard to specific color deficiency, except for the use of predominantly long wavelength colors [such as red] against darker colors ... for [people with] protanopia&quot;.</small></p>

<p><small><sup id=Note21>(21)</sup> B. MacEvoy calls these <a href="http://www.handprint.com/HP/WCL/tech13.html#harmonies"><em>hue harmonies</em></a>.  See also his <a href="http://www.handprint.com/HP/WCL/tech13.html#harmonyoverview">summary of harmonious color relationships</a>.</small></p>

<p><small><sup id=Note22>(22)</sup> <code>Lerp3</code> is equivalent to <code>mix</code> in OpenGL Shading Language (GLSL).  Making <code>alpha</code> the output of a function (for example, <code>Lerp3(color1, color2, FUNC(...))</code>,
where <code>FUNC</code> is an arbitrary function of one or more variables) can be done to achieve special nonlinear blends.  Such blends (interpolations) are described in further detail <a href="https://peteroupc.github.io/html3dutil/H3DU.Math.html#H3DU.Math.vec3lerp">in another page</a>.</small></p>

<p><small><sup id=Note23>(23)</sup> P. Haeberli, <a href="http://www.graficaobscura.com/matrix/index.html">&quot;Matrix Operations for Image Processing&quot;</a>, 1993.  The hue rotation matrix given was generated using the technique in the section &quot;Hue Rotation While Preserving Luminance&quot;, with constants rounded to five significant digits and with <code>rwgt=0.2126</code>, <code>gwgt=0.7152</code>, and <code>bwgt = 0.0722</code>, the sRGB relative luminances for the red, green, and blue points.  For the saturation and hue rotation matrices, the sRGB relative luminances are used rather than the values recommended by the source.</small></p>

<p><small><sup id=Note24>(24)</sup> The hue rotation angle is in radians, and the angle is greater than -2&pi; and less than 2&pi;. Degrees can be converted to radians by multiplying by <code>pi / 180</code>.</small></p>

<p><small><sup id=Note25>(25)</sup> This is often called the &quot;CMY&quot; (cyan-magenta-yellow) version of the RGB color (although the resulting color is not necessarily based on a proportion of cyan, magenta, and yellow inks; see also &quot;<a href="#CMYK_and_Other_Ink_Mixture_Color_Models">CMYK and Other Ink-Mixture Color Models</a>&quot;).  If such an operation is used, the conversions between &quot;CMY&quot; and RGB are exactly the same.</small></p>

<p><small><sup id=Note26>(26)</sup> The &quot;E&quot; here stands for the German word <em>Empfindung</em>.</small></p>

<p><small><sup id=Note27>(27)</sup> How to implement hash tables is outside the scope of this document.</small></p>

<p><small><sup id=Note28>(28)</sup> In general, a color can be considered &quot;print friendly&quot; if it lies within the extent of colors (<em>color gamut</em>) that can be reproduced under a given or standardized printing condition (see also &quot;<a href="#CMYK_and_Other_Ink_Mixture_Color_Models">CMYK and Other Ink-Mixture Color Models</a>&quot;).</small></p>

<p><small><sup id=Note29>(29)</sup> An example from a famous color system and color space from the early 20th century.</small></p>

<p><small><sup id=Note30>(30)</sup> An approximation of the colors to companded sRGB, in order, is (in <a href="#HTML_Color_Format">HTML color format</a>): &quot;#F0F0F1&quot;, &quot;#181818&quot;, &quot;#F7C100&quot;, &quot;#875392&quot;, &quot;#F78000&quot;, &quot;#9EC9EF&quot;, &quot;#C0002D&quot;, &quot;#C2B280&quot;, &quot;#838382&quot;, &quot;#008D4B&quot;, &quot;#E68DAB&quot;, &quot;#0067A8&quot;, &quot;#F99178&quot;, &quot;#5E4B97&quot;, &quot;#FBA200&quot;, &quot;#B43E6B&quot;, &quot;#DDD200&quot;, &quot;#892610&quot;, &quot;#8DB600&quot;, &quot;#65421B&quot;, &quot;#E4531B&quot;, &quot;#263A21&quot;. The list was generated by converting the Munsell renotations (and a similar renotation for black) to sRGB using the Python <code>colour-science</code> package.</small></p>

<p><small><sup id=Note31>(31)</sup> In some cases, the CIE 1931 standard observer can be approximated using the methods given in <a href="http://jcgt.org/published/0002/02/01/">Wyman, Sloan, and Shirley 2013</a>.</small></p>

<p><small><sup id=Note32>(32)</sup> See also J. Walker, &quot;<a href="http://www.fourmilab.ch/documents/specrend/">Colour Rendering of Spectra</a>&quot;.</small></p>

<p><small><sup id=Note33>(33)</sup> As <a href="http://www.handprint.com/HP/WCL/color18a.html#compmatch">B. MacEvoy explains</a> (at &quot;Other Factors in Material Mixtures&quot;), things that affect the mixture of two colorants include their &quot;refractive index, particle size, crystal form, hiding power and tinting strength&quot; (see also his <a href="http://www.handprint.com/HP/WCL/color18a.html#ctprin39">principles 39 to 41</a>), and &quot;the material attributes of the support [e.g., the paper or canvas] and the paint application methods&quot; are also relevant here.  These factors, to the extent the reflectance curves don&#39;t take them into account, are not dealt with in this method.</small></p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero</a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
}
document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
