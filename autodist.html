<head>
<title>Code Generator for Discrete Distributions</title>
<meta charset=utf-8>
</head>
<h2>Code Generator for Discrete Distributions</h2>
<p>This page generates standalone programming code that samples from a discrete distribution.  That is, it chooses an integer in [0, n) at random where each of the n integers has a separate probability of occurring.  The idea for a code generator like this came from Leydold et al. (2001).  The generator supports generating either JavaScript or Ruby code.</p>

<p>The code generator is powered by the recently presented Fast Loaded Dice Roller (Saad et al. 2020).  The code generator is also powered by JavaScript, at least the kind supported by modern Web browsers.  Accordingly, the generator requires JavaScript (active scripting) to be enabled in the browser settings.</p>
<form action='javascript:void(null)'>
<p>In the text box below, enter a comma-separated list of integer weights.  Each weight must be 0 or greater.
Spaces can appear at the beginning and end of the value as well as around the commas.</p>

<p>In the following example <code>10, 30, 40</code>, 0 is chosen with probability (10/(10+30+40)) and 1 is chosen with probability (30/(10+30+40)).<br><input type=text id=probabilities /><br>
Name of generator: <input type=text id=genname value="discrete_gen"/><br>
Language of generated code: <select id=genlang>
<option value='javascript'>JavaScript</option>
<option value='ruby'>Ruby</option>
</select>
<div style='color: red' id=error>&nbsp;</div>
<div>The generated code will appear below.  No rights are claimed to the code generated by this page (it can be used and distributed freely).</div>
<textarea rows=30 cols=40 id=code></textarea>
</form>
<p>This is an <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/autodist.html">open-source generator</a> written by Peter Occil.  Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero</a>.  If you have comments or issues on this generator, send them to the <a href="https://github.com/peteroupc/peteroupc.github.io/issues">GitHub issues page</a>.</p>

<h3>References</h3>

<p>Saad, F.A., Freer C.E., et al. "The Fast Loaded Dice Roller: A Near-Optimal Exact Sampler for Discrete Probability Distributions", in _AISTATS 2020_ 108.</p>
<p>Leydold, et al., "An Automatic Code Generator for Nonuniform Random Variate Generation", 2001.</p>

<script>
function times(n) {
  let x=[]
  for(let i=0;i<n;i++){
    x.push(i)
  }
  return x
}
function min(a) {
  let x=a[0]
  for(let i=1;i<a.length;i++){
    x=Math.min(x, a[i])
  }
  return x
}
function sum(a) {
  let x=0
  for(let i=0;i<a.length;i++){
    x+=a[i]
  }
  return x
}
function zeros(n) {
  let x=[]
  for(let i=0;i<n;i++){
    x.push(0)
  }
  return x
}

function codegenruby(fldr,name) {
   name=name||"discrete_gen"
   ret="def "+name+"()\n"
        if (fldr[0]==null) {
           ret += "return " + fldr[2] + "\n"
        } else if(fldr[0][0].length==1) {
           // Special case of 2 items with equal probability
           ret += "  return rand(2) == 0 ? " +(fldr[0][1][0]-1) +" : " +
              (fldr[0][2][0]-1)+"\n"
        } else {
        ret += "  table = ["
        for (let i=0;i<fldr[0].length;i++){
            if(i > 0) {
                ret += ", "
            }
            ret += "["+fldr[0][i]+"]"
        }
        ret += "]\n\n"
        ret += "  x = 0\n"
        ret += "  y = 0\n"
        ret += "  while true\n"
        ret += "    x = rand(2) + (x * 2)\n"
        ret += "    leaves = table[0][y]\n"
        ret += "    if x < leaves\n"
        if (fldr[2]<fldr[1]) {
          // No rejection leaf
          ret += "        return table[x + 1][y] - 1\n"
        } else {
          ret += "        label = table[x + 1][y]\n"
          ret += "        if label <= "+fldr[1]+"\n"
          ret += "            return label - 1\n"
          ret += "        end\n"
          ret += "        x = 0\n"
          ret += "        y = 0\n"
        }
        ret += "    else\n"
        ret += "        x -= leaves\n"
        ret += "        y += 1\n"
        ret += "    end\n"
        ret += "  end\n"
        }
        ret+="end\n"
       return ret
}

function codegen(fldr,name) {
   name=name||"discrete_gen"
   ret="var "+name+" = (function() {\n"
        if (fldr[0]==null) {
           ret += "return function(){\n"
           ret += "  return " + fldr[2] + "\n"
        } else if(fldr[0][0].length==1) {
           // Special case of 2 items with equal probability
           ret += "return function(){\n"
           ret += "  return Math.random() < 0.5 ? " +(fldr[0][1][0]-1) +" : " +
              (fldr[0][2][0]-1)+"\n"
        } else {
        ret += "var table = ["
        for (let i=0;i<fldr[0].length;i++){
            if(i > 0) {
                ret += ", "
            }
            ret += "["+fldr[0][i]+"]"
        }
        ret += "]\n\n"
        ret += "return function(){\n"
        ret += "  let x = 0\n"
        ret += "  let y = 0\n"
        ret += "  while (true) {\n"
        ret += "    x = (Math.random() < 0.5 ? 0 : 1) + (x * 2)\n"
        ret += "    leaves = table[0][y]\n"
        ret += "    if(x < leaves){\n"
        if (fldr[2]<fldr[1]) {
          // No rejection leaf
          ret += "        return table[x + 1][y] - 1\n"
        } else {
          ret += "        label = table[x + 1][y]\n"
          ret += "        if (label <= "+fldr[1]+") {\n"
          ret += "            return label - 1\n"
          ret += "        }\n"
          ret += "        x = 0\n"
          ret += "        y = 0\n"
        }
        ret += "    } else {\n"
        ret += "        x -= leaves\n"
        ret += "        y += 1\n"
        ret += "}}\n"
        }
        ret+="}})();\n"
       return ret
}

function gcd(a, b) {
  if(a==0||b==0)return 0
  while(true){
    var c=Math.floor(a/b)
    var d=a-b*c
    a=b
    b=d
    if(b==0)return a
  }
}

function weightsgcd(weights){
  var lastgcd=-1
  for(var i=0;i<weights.length;i++){
    if(weights[i]!=0){
      if(lastgcd<0){
        lastgcd=weights[i]
      } else {
        lastgcd=gcd(lastgcd,weights[i])
      }
    }
  }
  return Math.max(1, lastgcd)
}

function fldr(weights) {
        // Initialize data for Fast Loaded Dice Roller
        let n = weights.length
        let weightBits = 0
        // Find GCD of all weights, to optimize the table's size
        let wgcd = weightsgcd(weights)
        weights=weights.map(o=>o/wgcd)
        let totalWeights = sum(weights)
        if(totalWeights==0)return null
        if(totalWeights < 0)
            throw new Error("Sum of weights is negative")
        let minWeight = min(weights)
        if(minWeight<0)return null
        let realLabels=null
        let rejectionLabel=n
        if(minWeight==0) {
          // Some weights are zero
          newWeights=[]
          realLabels=[]
          for(let i=0;i<weights.length;i++){
             if(weights[i]!=0) {
               newWeights.push(weights[i])
               realLabels.push(i + 1)
             }
          }
          realLabels.push(rejectionLabel + 1)
          weights=newWeights
          n=weights.length
        }
        if(weights.length==1) {
          // Degenerate case
          return [null, -1, realLabels ? (realLabels[0]-1) : 0]
        }
        let tmp = (totalWeights-1)
        while(tmp > 0) {
            tmp = Math.floor(tmp/2)
            weightBits += 1
        }
        let maxLeaf = 0
        let lasta = Math.pow(2, weightBits) - totalWeights
        let leavesAndLabels = times(n+2).map(o=>zeros(weightBits))
        let shift = weightBits - 1
        for (let j=0;j<weightBits;j++){
            let level = 1
            for (let i=0;i<n+1;i++){
                let ai = (i==n) ? lasta : weights[i]
                if (ai < 0) { return null; }
                let leaf = Math.floor(ai/Math.pow(2, shift)) & 1
                if (leaf > 0) {
                    // NOTE: Labels start at 1
                    leavesAndLabels[0][j] += leaf
                    label = realLabels ? realLabels[i] : i + 1
                    leavesAndLabels[level][j] = label
                    maxLeaf = Math.max(maxLeaf, label - 1)
                    level += 1
               }
            }
            shift -= 1
        }
        return [leavesAndLabels, rejectionLabel, maxLeaf]
}

var changefunc=function() {
     var curval=document.getElementById("probabilities").value+"|"+
        document.getElementById("genname").value+"|"+
        document.getElementById("genlang").value
     if(currentValue==curval)return
     currentValue=curval
     var weights=document.getElementById("probabilities").value
     if(weights.length==0)return
     var genname=document.getElementById("genname").value.replace(/[^A-Za-z0-9_]+/g,"_")
       .replace(/^[0-9]/,"_")
     weights=weights.replace(/^\s+/g,"")
     weights=weights.replace(/\s+$/g,"")
     weights=weights.replace(/,\s*$/g,"")
     weights=weights.split(/\s*,\s*/)
     var weightints=[]
     for(var i=0;i<weights.length;i++){
       if(!(/^\d+$/).test(weights[i])) {
         document.getElementById("error").innerHTML="Not a valid list of integer weights."
         return
       }
       num=Number.parseInt(weights[i],10)
       if(num>Number.MAX_SAFE_INTEGER) {
         document.getElementById("error").innerHTML="This generator does not "+
            "support weights greater than "+Number.MAX_SAFE_INTEGER+"."
         return
       }
       weightints.push(num)
     }
     if(weightints.length==0)return
     if(sum(weightints)>Number.MAX_SAFE_INTEGER){
         document.getElementById("error").innerHTML="This generator does not "+
            "support a sum of weights greater than "+Number.MAX_SAFE_INTEGER+"."
         return
     }
     var data=fldr(weightints)
     if(!data && document.getElementById("probabilities").value!="") {
       document.getElementById("error").innerHTML="Failed to generate code for these weights."
       return
     }
     var code=""
     var glang=document.getElementById("genlang").value
     if (glang=="javascript")code=codegen(data,genname)
     if (glang=="ruby")code=codegenruby(data,genname)
     document.getElementById("code").value=code
     document.getElementById("error").innerHTML=""
  }

var currentValue = null
document.getElementById("probabilities").addEventListener(
   "change",
  changefunc)
window.setInterval(function() {
  changefunc()
}, 200)

</script>
