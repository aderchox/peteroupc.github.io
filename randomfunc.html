<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generation Methods</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generation Methods</h1>

<p><a href="mailto:poccil14@gmail.com">Peter Occil</a></p>

<p>Begun on June 4, 2017; last updated on Sep. 9, 2017.</p>

<p>Discusses many ways in which applications can extract random numbers from an underlying RNG and includes pseudocode for most of them.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page discusses many ways applications can extract random numbers from an underlying random number generator (RNG) and includes pseudocode for most of them.</p>

<p>This methods described in this document can be categorized as follows:</p>

<ul>
<li>Methods to generate uniformly distributed random numbers from an underlying RNG (such as the <a href="#Core_Random_Generation_Method">core method, <code>RNDINT(N)</code></a>).</li>
<li>Common tasks to generate randomized content and conditions, such as <a href="#Boolean_Conditions">Boolean conditions</a>, <a href="#Shuffling">shuffling</a>, and <a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items">sampling unique items from a list</a>.</li>
<li>Methods to generate non-uniformly distributed random numbers, including <a href="#Discrete_Weighted_Choice">weighted choice</a>, the <a href="#Normal_Gaussian_Distribution">normal distribution</a>, and <a href="#Other_Non_Uniform_Distributions">other statistical distributions</a>.</li>
</ul>

<p><a href="https://peteroupc.github.io/randomgen.py">Sample Python code</a> that implements many of the methods in this document is available.</p>

<p>All the random number methods presented on this page&mdash;</p>

<ul>
<li>assume the existence of an underlying RNG,</li>
<li>do not assume any particular implementation of the underlying RNG (e.g., whether that RNG is a deterministic RNG or some other kind), and</li>
<li>do not assume, in general, any particular quality of the underlying RNG.</li>
</ul>

<p>In general, security, performance, quality, and other considerations will determine what underlying RNG to use in a particular application; I have written more on RNG recommendations in <a href="https://peteroupc.github.io/random.html">another document</a>.</p>

<p>In general, techniques that are specific to an application programming interface are outside the scope of this document.</p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Contents">Contents</a></li>
<li><a href="#Notation_and_Definitions">Notation and Definitions</a></li>
<li><a href="#Uniform_Random_Numbers">Uniform Random Numbers</a>

<ul>
<li><a href="#RNDINT_Random_Integers_in_0_N"><code>RNDINT</code>: Random Integers in [0, N]</a></li>
<li><a href="#RNDINTRANGE_Random_Integers_in_N_M"><code>RNDINTRANGE</code>: Random Integers in [N, M]</a></li>
<li><a href="#RNDU01_Random_Numbers_in_0_1"><code>RNDU01</code>: Random Numbers in [0, 1]</a></li>
<li><a href="#RNDNUMRANGE_Random_Numbers_in_X_Y"><code>RNDNUMRANGE</code>: Random Numbers in [X, Y]</a></li>
<li><a href="#RNDINTEXC_Random_Integers_in_0_N"><code>RNDINTEXC</code>: Random Integers in [0, N)</a></li>
<li><a href="#RNDINTEXCRANGE_Random_Integers_in_N_M"><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</a></li>
<li><a href="#RNDU01OneExc_RNDU01ZeroExc_and_RNDU01ZeroOneExc_Random_Numbers_in_0_1_0_1_or_0_1"><code>RNDU01OneExc</code>, <code>RNDU01ZeroExc</code>, and <code>RNDU01ZeroOneExc</code>: Random Numbers in [0, 1), (0, 1], or (0, 1)</a></li>
<li><a href="#RNDNUMEXCRANGE_Random_Numbers_in_X_Y"><code>RNDNUMEXCRANGE</code>: Random Numbers in [X, Y)</a></li>
<li><a href="#RNDBITS_Random_N_Bit_Integers"><code>RNDBITS</code>: Random N-Bit Integers</a></li>
<li><a href="#Special_Programming_Environments">Special Programming Environments</a></li>
</ul></li>
<li><a href="#Randomization_Techniques">Randomization Techniques</a>

<ul>
<li><a href="#Boolean_Conditions">Boolean Conditions</a></li>
<li><a href="#Shuffling">Shuffling</a></li>
<li><a href="#Creating_a_Random_Character_String">Creating a Random Character String</a></li>
<li><a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List">Sampling With Replacement: Choosing a Random Item from a List</a></li>
<li><a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items">Sampling Without Replacement: Choosing Several Unique Items</a></li>
<li><a href="#Almost_Random_Sampling">Almost-Random Sampling</a></li>
<li><a href="#Choosing_a_Random_Date_Time">Choosing a Random Date/Time</a></li>
<li><a href="#Generating_Random_Numbers_in_Sorted_Order">Generating Random Numbers in Sorted Order</a></li>
<li><a href="#Rejection_Sampling">Rejection Sampling</a></li>
</ul></li>
<li><a href="#Non_Uniform_Distributions">Non-Uniform Distributions</a>

<ul>
<li><a href="#Discrete_Weighted_Choice">Discrete Weighted Choice</a>

<ul>
<li><a href="#Weighted_Choice_Without_Replacement">Weighted Choice Without Replacement</a></li>
<li><a href="#Choosing_Multiple_Items">Choosing Multiple Items</a></li>
<li><a href="#Piecewise_Constant_Distribution">Piecewise Constant Distribution</a></li>
<li><a href="#Multinomial_Distribution">Multinomial Distribution</a></li>
</ul></li>
<li><a href="#Continuous_Weighted_Choice">Continuous Weighted Choice</a></li>
<li><a href="#Dice">Dice</a></li>
<li><a href="#Normal_Gaussian_Distribution">Normal (Gaussian) Distribution</a></li>
<li><a href="#Binomial_Distribution">Binomial Distribution</a></li>
<li><a href="#Poisson_Distribution">Poisson Distribution</a></li>
<li><a href="#Gamma_Distribution">Gamma Distribution</a></li>
<li><a href="#Negative_Binomial_Distribution">Negative Binomial Distribution</a></li>
<li><a href="#von_Mises_Distribution">von Mises Distribution</a></li>
<li><a href="#Stable_Distribution">Stable Distribution</a></li>
<li><a href="#Hypergeometric_Distribution">Hypergeometric Distribution</a></li>
<li><a href="#Multivariate_Normal_Distribution">Multivariate Normal Distribution</a></li>
<li><a href="#Dirichlet_Distribution_Random_Numbers_with_a_Given_Positive_Sum">Dirichlet Distribution: Random Numbers with a Given Positive Sum</a></li>
<li><a href="#Other_Non_Uniform_Distributions">Other Non-Uniform Distributions</a></li>
<li><a href="#Correlated_Random_Numbers">Correlated Random Numbers</a>

<ul>
<li><a href="#Gaussian_Copula">Gaussian Copula</a></li>
</ul></li>
<li><a href="#Generating_Random_Numbers_from_a_Distribution_of_Data_Points">Generating Random Numbers from a Distribution of Data Points</a></li>
<li><a href="#Generating_Random_Numbers_from_an_Arbitrary_Distribution">Generating Random Numbers from an Arbitrary Distribution</a></li>
<li><a href="#Truncation_and_Censoring">Truncation and Censoring</a></li>
<li><a href="#Random_Points_on_the_Surface_of_a_Hypersphere">Random Points on the Surface of a Hypersphere</a></li>
<li><a href="#Random_Points_Inside_a_Ball">Random Points Inside a Ball</a></li>
<li><a href="#Random_Latitude_and_Longitude">Random Latitude and Longitude</a></li>
</ul></li>
<li><a href="#Conclusion">Conclusion</a></li>
<li><a href="#Notes">Notes</a></li>
<li><a href="#License">License</a></li>
</ul>

<p><a id=Notation_and_Definitions></a></p>

<h2>Notation and Definitions</h2>

<p>In this document:</p>

<ul>
<li>The <a href="https://peteroupc.github.io/pseudocode.html"><strong>pseudocode conventions</strong></a> apply to this document.</li>
<li><strong>Intervals</strong>: The following notation is used for intervals:

<ul>
<li>[<code>a</code>, <code>b</code>) means &quot;<code>a</code> or greater, but less than <code>b</code>&quot;.</li>
<li>(<code>a</code>, <code>b</code>) means &quot;greater than<code>a</code>, but less than <code>b</code>&quot;.</li>
<li>(<code>a</code>, <code>b</code>] means &quot;greater than<code>a</code> and less than or equal to<code>b</code>&quot;.</li>
<li>[<code>a</code>, <code>b</code>] means &quot;<code>a</code> or greater and <code>b</code> or less&quot;.</li>
</ul></li>
<li>The term <em>random number generator</em>, or <em>RNG</em>, means a number generator that seeks to generate independent numbers that seem to occur by chance and that are approximately uniformly distributed.<sup><a href="#Note6">(6)</a></sup></li>
<li>The <em>norm</em> of one or more numbers is the square root of the sum of squares of those numbers, that is, <code>sqrt(num1 * num1 + num2 * num2 + ... + numN * numN)</code>.</li>
<li>The term <em>significand permutations</em>, with respect to a floating-point format, means the format&#39;s radix (number base) raised to the power of the format&#39;s precision (the maximum number of significant digits in the format). For example&mdash;

<ul>
<li>the 64-bit IEEE 754 binary floating-point format (e.g., Java <code>double</code>) has 2<sup>53</sup> (9007199254740992) significand permutations,</li>
<li>the 64-bit IEEE 754 decimal floating-point format has 10<sup>16</sup> significand permutations,</li>
<li>the 32-bit IEEE 754 binary floating-point format (e.g., Java <code>float</code>) has 2<sup>24</sup> (16777216) significand permutations, and</li>
<li>arbitrary-precision floating point numbers (e.g., Java <code>BigDecimal</code>) can have a theoretically arbitrary number of significand permutations.</li>
</ul></li>
</ul>

<p><a id=Uniform_Random_Numbers></a></p>

<h2>Uniform Random Numbers</h2>

<p>This section describes how an underlying RNG can be used to generate uniformly-distributed random numbers.  Here is an overview of the methods described in this section.</p>

<ul>
<li>Random Integers: <code>RNDINT</code>, <code>RNDINTEXC</code>, <code>RNDINTRANGE</code>, <code>RNDINTRANGEEXC</code>.</li>
<li>Random Bits: <code>RNDBITS</code>.</li>
<li>Random Numbers in 0-1 Bounded Interval: <code>RNDU01</code>, <code>RNDU01ZeroExc</code>, <code>RNDU01OneExc</code>, <code>RNDU01ZeroOneExc</code>.</li>
<li>Other Random Numbers: <code>RNDNUMRANGE</code>, <code>RNDNUMRANGEEXC</code>.</li>
</ul>

<p>One method, <code>RNDINT</code>, described next, can serve as the basis for the remaining methods.</p>

<p><a id=RNDINT_Random_Integers_in_0_N></a></p>

<h3><code>RNDINT</code>: Random Integers in [0, N]</h3>

<p>In this document, <strong><code>RNDINT(maxInclusive)</code></strong> is the core method for generating uniform random integers from an underlying RNG, which is called <strong><code>RNG()</code></strong> in this section. The random integer is <strong>in the interval [0, <code>maxInclusive</code>)</strong>.  This section explains how <code>RNDINT(maxInclusive)</code> can be implemented if <code>RNG()</code> returns&mdash;</p>

<ol>
<li>integers in the interval [0, positive <code>MODULUS</code>), or</li>
<li>floating-point numbers in the interval [0, 1).</li>
</ol>

<p><strong>Method 1</strong>: If <code>RNG()</code> outputs <strong>integers in the interval [0, positive <code>MODULUS</code>)</strong> (for example, less than 1,000,000 or less than 6), then <code>RNDINT(maxInclusive)</code> can be implemented as follows.  Note that all the variables in this method are unsigned integers.<sup><a href="#Note7">(7)</a></sup></p>

<pre>METHOD RndIntHelperNonPowerOfTwo(maxInclusive)
    cx = floor(maxInclusive / MODULUS) + 1
    while true
       ret = cx * RNG()
       // NOTE: If this method is implemented using a fixed-
       // precision type, the addition operation below should
       // check for overflow and should reject the number
       // if overflow would result.
       ret = ret + RNDINT(cx - 1)
       if ret &lt;= maxInclusive: return ret
    end
END METHOD

METHOD RndIntHelperPowerOfTwo(maxInclusive)
        // NOTE: Finds the number of bits minus 1 needed
        // to represent MODULUS. This will be a constant
        // here, though.
        modBits = ln(MODULUS)/ln(2)
        // Calculate the bit count of maxInclusive
        bitCount = 0
        tempnumber = maxInclusive
        while tempnumber &gt; 0
               // NOTE: If the programming language implements
               // division with two integers by truncating to an
               // integer, the division can be used as is without
               // calling a &quot;floor&quot; function.
               tempnumber = floor(tempnumber / 2)
               bitCount = bitCount + 1
        end
        while true
               // Build a number with `bitCount` bits
                tempnumber = 0
                while bitCount &gt; 0
                     wordBits = modBits
                     rngNumber = RNG()
                     if wordBits &gt; bitCount
                        wordBits = bitCount
                        // Truncate number to &#39;wordBits&#39; bits
                        // NOTE: If the programming language supports a bitwise
                        // AND operator, the mod operation can be implemented
                        // as &quot;rndNumber AND ((1 &lt;&lt; wordBits) - 1)&quot;
                        rngNumber = mod(rngNumber, (1 &lt;&lt; wordBits))
                     end
                     tempnumber = tempnumber &lt;&lt; wordBits
                     // NOTE: In programming languages that
                     // support the OR operator between two
                     // integers, that operator can replace the
                     // plus operator below.
                     tempnumber = tempnumber + rngNumber
                     bitCount = bitCount - wordBits
                end
                // Accept the number if allowed
                if tempnumber &lt;= maxInclusive: return tempnumber
         end
END METHOD

METHOD RNDINT(maxInclusive)
  // maxInclusive must be 0 or greater
  if maxInclusive &lt; 0: return error
  if maxInclusive == 0: return 0
  // N equals modulus
  if maxInclusive == MODULUS - 1: return RNG()
  // NOTE: Finds the number of bits minus 1 needed
  // to represent MODULUS (if it&#39;s a power of 2).
  // This will be a constant here, though.
  modBits=ln(MODULUS)/ln(2)
  // NOTE: The following condition checks if MODULUS
  // is a power of 2.  This will be a constant here, though.
  isPowerOfTwo=floor(modBits) == modBits
  // Special cases if MODULUS is a power of 2
  if isPowerOfTwo
       if maxInclusive == 1: return mod(RNG(), 2)
       if maxInclusive == 3 and modBits &gt;= 2: return mod(RNG(), 4)
       if maxInclusive == 255 and modBits &gt;= 8: return mod(RNG(), 256)
       if maxInclusive == 65535 and modBits &gt;=16: return mod(RNG(), 65535)
   end
  if maxInclusive &gt; MODULUS - 1:
     if isPowerOfTwo
       return RndIntHelperPowerOfTwo(maxInclusive)
     else
       return RndIntHelperNonPowerOfTwo(maxInclusive)
     end
  else
    // NOTE: If the programming language implements
    // division with two integers by truncating to an
    // integer, the division can be used as is without
    // calling a &quot;floor&quot; function.
          nPlusOne = maxInclusive + 1
          maxexc = floor((MODULUS - 1) / nPlusOne) * nPlusOne
          while true
                    ret = RNG()
                    if ret &lt; nPlusOne: return ret
                    if ret &lt; maxexc: return mod(ret, nPlusOne)
          end
  end
END METHOD
</pre>

<p><strong>Note:</strong> If <code>MODULUS</code> is a power of 2, calling <code>RNDINT</code> may result in unused bits (for example, when truncating a random number to <code>wordBits</code> bits or in the special cases at the start of the method).  How a more sophisticated implementation may save those bits for later reuse is beyond this page&#39;s scope.
Note that all the variables in this method are unsigned integers.</p>

<p><strong>Method 2</strong>: If <code>RNG()</code> outputs <strong>floating-point numbers in the interval [0, 1)</strong>, then find <code>s</code>, where <code>s</code> is the number of <em>significand permutations</em> for the floating-point format, and use Method 1 above, where <code>MODULUS</code> is <code>s</code> and <code>RNG()</code> is <code>floor(RNG() * s)</code> instead.  (If the RNG outputs arbitrary-precision floating-point numbers, <code>s</code> should be set to the number of different values that are possible by calling the underlying RNG.)</p>

<p><strong>Other RNGs:</strong> A detailed <code>RNDINT(maxInclusive)</code> implementation for other kinds of RNGs is not given here, since they seem to be lesser seen in practice.  Readers who know of an RNG that is in wide use and outputs numbers of a kind other than already described in this section should send me a comment.</p>

<p><strong>Notes:</strong></p>

<ul>
<li>To generate a random number that&#39;s either -1 or 1, the following idiom can be used: <code>(RNDINT(1) * 2 - 1)</code>.</li>
<li>To generate a random integer that&#39;s divisible by a positive integer (<code>DIV</code>), generate the integer with any method (such as <code>RNDINT</code>),
let <code>X</code> be that integer, then generate <code>X - mod(X, DIV)</code> if <code>X &gt;= 0</code>, or <code>X - (DIV - mod(abs(X), DIV))</code> otherwise. (Depending on the method, the resulting integer may be out of range, in which case this procedure is to be repeated.)</li>
</ul>

<p><a id=RNDINTRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTRANGE</code>: Random Integers in [N, M]</h3>

<p>The na&iuml;ve way of generating a <strong>random integer in the interval [<code>minInclusive</code>, <code>maxInclusive</code>]</strong>, shown below, works well for unsigned integers and arbitrary-precision integers.</p>

<pre> METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   return minInclusive + RNDINT(maxInclusive - minInclusive)
 END METHOD
</pre>

<p>The na&iuml;ve approach won&#39;t work as well, though, for signed integer formats if the difference between <code>maxInclusive</code> and <code>minInclusive</code> exceeds the highest possible integer for the format.  For fixed-length signed integer formats <a href="#Note1"><sup>(1)</sup></a>, such random integers can be generated using the following pseudocode.  In the pseudocode below, <code>INT_MAX</code> is the highest possible integer in the integer format.</p>

<pre>METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   if minInclusive == maxInclusive: return minInclusive
   if minInclusive==0: return RNDINT(maxInclusive)
   // Difference does not exceed maxInclusive
   if minInclusive &gt; 0 or minInclusive + INT_MAX &gt;= maxInclusive
       return minInclusive + RNDINT(maxInclusive - minInclusive)
   end
   while true
     ret = RNDINT(INT_MAX)
     // NOTE: If the signed integer format uses two&#39;s-complement
     // form, use the following line:
     if RNDINT(1) == 0: ret = -1 - ret
     // NOTE: If the signed integer format uses sign-magnitude
     // form (such as .NET&#39;s `System.Decimal`) or one&#39;s-complement
     // form,  use the following three lines instead of the preceding line;
     // here, zero will be rejected at a 50% chance because zero occurs
     // twice in both forms.
     // negative = RNDINT(1) == 0
     // if negative: ret = 0 - ret
     // if negative and ret == 0: continue
     if ret &gt;= minInclusive and ret &lt;= maxInclusive: return ret
   end
END METHOD
</pre>

<p><strong>Note:</strong></p>

<ul>
<li>To simulate rolling an N-sided die (N greater than 1), generate a random number in the interval [1, N] by calling <code>RNDINTRANGE(1, N)</code>.</li>
<li>Generating a random integer with one base-10 digit is equivalent to generating <code>RNDINTRANGE(0, 9)</code>.</li>
<li>Generating a random integer with N base-10 digits (where N is 2 or greater) is equivalent to generating <code>RNDINTRANGE(pow(10, N-1), pow(10, N) - 1)</code>.</li>
</ul>

<p><a id=RNDU01_Random_Numbers_in_0_1></a></p>

<h3><code>RNDU01</code>: Random Numbers in [0, 1]</h3>

<p>The idiom <code>RNDINT(X) / X</code> (called <strong><code>RNDU01()</code></strong> in this document), generates a <strong>random number in the interval [0, 1]</strong>, where <code>X</code> is the number of fractional parts between 0 and 1. (For fixed-precision floating-point number formats, <code>X</code> should equal the number of <em>significand permutations</em> for that format. See &quot;Generating uniform doubles in the unit interval&quot; in the <a href="http://xoroshiro.di.unimi.it/#remarks"><code>xoroshiro+</code> remarks page</a> for further discussion.)</p>

<p>For fixed-precision binary floating-point numbers with fixed exponent range (such as Java&#39;s <code>double</code> and <code>float</code>), the following pseudocode for <code>RNDU01()</code> can be used instead.  It&#39;s based on a <a href="http://allendowney.com/research/rand/">technique devised by Allen Downey</a>, who found that dividing a random number by a constant usually does not yield all representable binary floating-point numbers in the desired range.  In the pseudocode below, <code>SIGBITS</code> is the binary floating-point format&#39;s precision (for examples, see the <a href="#Notation_and_Definitions">note for &quot;significand permutations&quot;</a>).</p>

<pre>METHOD RNDU01()
    e=-SIGBITS
    while true
        if RNDINT(1)==0: e = e - 1
      else: break
    end
    sig = RNDINT((1 &lt;&lt; (SIGBITS - 1)) - 1)
    if sig==0 and RNDINT(1)==0: e = e + 1
    sig = sig + (1 &lt;&lt; (SIGBITS - 1))
    // NOTE: This multiplication should result in
    // a floating-point number; if `e` is sufficiently
    // small, the number will underflow to 0
    return sig * pow(2, e)
END METHOD
</pre>

<p><a id=RNDNUMRANGE_Random_Numbers_in_X_Y></a></p>

<h3><code>RNDNUMRANGE</code>: Random Numbers in [X, Y]</h3>

<p>The na&iuml;ve way of generating a <strong>random number in the interval [<code>minInclusive</code>, <code>maxInclusive</code>]</strong>, is shown in the following pseudocode, which generally works well only if the number format can&#39;t be negative or that format uses arbitrary precision.</p>

<pre>METHOD RNDNUMRANGE(minInclusive, maxInclusive)
    if minInclusive &gt; maxInclusive: return error
    return minInclusive + (maxInclusive - minInclusive) * RNDU01()
END
</pre>

<p>For fixed-point or floating-point number formats with fixed precision (such as Java&#39;s <code>double</code> and <code>float</code>), the pseudocode above can overflow if the difference between <code>maxInclusive</code> and <code>minInclusive</code> exceeds the maximum possible value for the format.  For such formats, the following pseudocode for <code>RNDU01()</code> can be used instead.  In the pseudocode below, <code>NUM_MAX</code> is the highest possible value for the number format.  The pseudocode assumes that the highest possible value is positive and the lowest possible value is negative.</p>

<pre>METHOD RNDNUMRANGE(minInclusive, maxInclusive)
   if minInclusive &gt; maxInclusive: return error
   if minInclusive == maxInclusive: return minInclusive
   // Difference does not exceed maxInclusive
   if minInclusive &gt;= 0 or minInclusive + NUM_MAX &gt;= maxInclusive
       return minInclusive + (maxInclusive - minInclusive) * RNDU01()
   end
   while true
     ret = RNDU01() * NUM_MAX
     // NOTE: If the number format uses sign-magnitude
     // representation, as is the case for Java `float` and
     // `double` and .NET&#39;s implementation of `System.Decimal`,
     // for example, use the following:
     negative = RNDINT(1) == 0
     if negative: ret = 0 - ret
     if negative and ret == 0: continue
     // NOTE: For fixed-precision fixed-point numbers implemented
     // using two&#39;s complement numbers (note 1), use the following line
     // instead of the preceding three lines, where `QUANTUM` is the
     // smallest representable positive number in the fixed-point format:
     // if RNDINT(1) == 0: ret = (0 - QUANTUM) - ret
     if ret &gt;= minInclusive and ret &lt;= maxInclusive: return ret
   end
END
</pre>

<p><a id=RNDINTEXC_Random_Integers_in_0_N></a></p>

<h3><code>RNDINTEXC</code>: Random Integers in [0, N)</h3>

<p><code>RNDINTEXC(maxExclusive)</code>, which generates a <strong>random number in the interval [0, <code>maxExclusive</code>)</strong>,
can be implemented as follows<sup><a href="#Note8">(8)</a></sup>:</p>

<pre> METHOD RNDINTEXC(maxExclusive)
    if maxExclusive &lt;= 0: return error
    return RNDINT(maxExclusive - 1)
 END METHOD
</pre>

<p><strong>Note:</strong> The following are alternative ways of generating a random integer in the interval [0, <code>maxExclusive</code>):</p>

<ul>
<li><code>floor(RNDNUMEXCRANGE(0, maxExclusive))</code>.</li>
<li>Generate <code>N = floor(RNDU01OneExc()*(maxExclusive))</code> until <code>N &lt; maxExclusive</code>. (The loop is needed because otherwise, rounding error due to the nature of certain floating-point formats can result in <code>maxExclusive</code> being returned in rare cases.<sup><a href="#Note5">(5)</a></sup>)</li>
</ul>

<p>These approaches, though, are recommended only if the programming language&mdash;</p>

<ul>
<li>supports floating-point number types and no other number types (an example is JavaScript),</li>
<li>is a dialect of SQL, or</li>
<li>doesn&#39;t support an integer type that is big enough to fit the number <code>maxExclusive - 1</code>.</li>
</ul>

<p><a id=RNDINTEXCRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</h3>

<p><strong><code>RNDINTEXCRANGE</code></strong> here, returns a **random integer in the interval [<code>minInclusive</code>, <code>maxExclusive</code>)**.  It can be implemented using <a href="#Random_Integers_Within_a_Range_Maximum_Inclusive"><code>RNDINTRANGE</code></a>, as the following pseudocode demonstrates.</p>

<pre>METHOD RNDINTEXCRANGE(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   // NOTE: For signed integer formats, replace the following line
   // with &quot;if minInclusive &gt;=0 or minInclusive + INT_MAX &gt;=
   // maxExclusive&quot;, where `INT_MAX` has the same meaning
   // as the pseudocode for `RNDINTRANGE`.
   if minInclusive &gt;=0
     return RNDINTRANGE(minInclusive, maxExclusive - 1)
   end
   while true
     ret = RNDINTRANGE(minInclusive, maxExclusive)
     if ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<p><a id=RNDU01OneExc_RNDU01ZeroExc_and_RNDU01ZeroOneExc_Random_Numbers_in_0_1_0_1_or_0_1></a></p>

<h3><code>RNDU01OneExc</code>, <code>RNDU01ZeroExc</code>, and <code>RNDU01ZeroOneExc</code>: Random Numbers in [0, 1), (0, 1], or (0, 1)</h3>

<p>Three methods related to <code>RNDU01()</code> can be implemented as follows, where
<code>X</code> is the number of fractional parts between 0 and 1 (see <code>RNDU01()</code> section).</p>

<ul>
<li><p><strong><code>RNDU01OneExc()</code>, interval [0, 1)</strong>, can be implemented in one of the following ways:</p>

<ul>
<li>Generate <code>RNDU01()</code> in a loop until a number other than 1.0 is generated this way.  This is preferred.</li>
<li><code>RNDINT(X - 1) / X</code>.</li>
<li><code>RNDINTEXC(X) / X</code>.</li>
</ul>

<p>Note that <code>RNDU01OneExc()</code> corresponds to <code>Math.random()</code> in Java and JavaScript.</p></li>
<li><strong><code>RNDU01ZeroExc()</code>, interval (0, 1]</strong>, can be implemented in one of the following ways:

<ul>
<li>Generate <code>RNDU01()</code> in a loop until a number other than 0.0 is generated this way.  This is preferred.</li>
<li><code>(RNDINT(X - 1) + 1) / X</code>.</li>
<li><code>(RNDINTEXC(X) + 1) / X</code>.</li>
<li><code>1.0 - RNDU01OneExc()</code> (but this is recommended only if the set of numbers <code>RNDU01OneExc()</code> could return &mdash; as opposed to their probability &mdash; is evenly distributed).</li>
</ul></li>
<li><strong><code>RNDU01ZeroOneExc()</code>, interval (0, 1)</strong>, can be implemented in one of the following ways:

<ul>
<li>Generate <code>RNDU01()</code> in a loop until a number other than 0.0 or 1.0 is generated this way.  This is preferred.</li>
<li><code>(RNDINT(X - 2) + 1) / X</code>.</li>
<li><code>(RNDINTEXC(X - 1) + 1) / X</code>.</li>
</ul></li>
</ul>

<p><a id=RNDNUMEXCRANGE_Random_Numbers_in_X_Y></a></p>

<h3><code>RNDNUMEXCRANGE</code>: Random Numbers in [X, Y)</h3>

<p><strong><code>RNDNUMEXCRANGE</code></strong> returns a  **random number in the interval [<code>minInclusive</code>, <code>maxExclusive</code>)**.
 It can be implemented using <a href="#Random_Integers_Within_a_Range_Maximum_Inclusive"><code>RNDNUMRANGE</code></a>, as the following pseudocode demonstrates.</p>

<pre>METHOD RNDNUMEXCRANGE(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   while true
     ret = RNDNUMRANGE(minInclusive, maxExclusive)
     if ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<p><a id=RNDBITS_Random_N_Bit_Integers></a></p>

<h3><code>RNDBITS</code>: Random N-Bit Integers</h3>

<p>The idiom <code>RNDINT((1 &lt;&lt; b) - 1)</code>, called <strong><code>RNDBITS(b)</code></strong> in this document, is a na&iuml;ve way of generating a <strong>uniformly distributed random <code>N</code>-bit integer</strong> (with maximum 2<sup><code>b</code> - 1</sup>).</p>

<p>Although this idiom works well for arbitrary-precision integers, it won&#39;t work well for the much more popular integer types called <em>fixed-length two&#39;s-complement signed integers</em> <a href="#Note1"><sup>(1)</sup></a>. For such signed integers as well as fixed-length unsigned integers, <code>RNDBITS(bits)</code> can be implemented using the pseudocode below.  In the pseudocode below, <code>BITCOUNT</code> is the number of bits used in the format.  Note that for such signed integers, <code>RNDBITS(bits)</code> can return a sequence of bits that resolves to a negative number.</p>

<pre>METHOD RNDBITS(bits)
     if bits&lt;0 or bits &gt; BITCOUNT: return error
     if bits==0: return 0
     if bits==1: return RNDINT(1)
     if bits==2 and BITCOUNT == 2
         return (RNDINT(1) &lt;&lt; 1) | RNDINT(1)
     end
     if bits==2: return RNDINT(3)
     bitsMinus2 = bits - 2
     // NOTE: The &quot;|&quot; below is the OR operator between
     // two integers.  The following line is implemented this
     // way to accommodate implementations that use
     // fixed-length two&#39;s-complement signed integers.
     ret = (RNDINT((1&lt;&lt;bitsMinus2) - 1) &lt;&lt; bitsMinus2) | RNDINT(3)
     // NOTE: If the implementation uses fixed-length
     // unsigned integers, the following line can replace
     // the preceding line.  Note that the implementation
     // avoids shifting an integer by BITCOUNT bits or more,
     // because such behavior is undefined in C and C++.
     // ret = RNDINT( (((1 &lt;&lt; (bits - 1)) - 1) &lt;&lt; 1) | 1 )
     // NOTE: Alternatively, a list containing powers-of-two
     // minus 1 can be generated (calculating `floor(pow(2,i)) - 1`
     // for each relevant index `i` of the list, assuming unlimited
     // precision) and the following line used instead of the
     // preceding (assuming `list` is
     // the list generated this way):
     // ret = RNDINT( list[bits] )
     return ret
END METHOD
</pre>

<p><a id=Special_Programming_Environments></a></p>

<h3>Special Programming Environments</h3>

<p>In certain programming environments it&#39;s often impractical to implement the uniform random number generation methods just described without recurring to other programming languages.  These include the following:</p>

<ul>
<li>Microsoft Windows batch files (newer versions of which, at least, include a <code>%RANDOM%</code> variable).</li>
<li><code>bash</code> and other shell scripts (some of which include a <code>$RANDOM</code> variable which returns a random integer in the interval [0, 32767)).</li>
<li><p>SQL dialects, such as&mdash;</p>

<ul>
<li>MySQL (which has a <code>RAND()</code> akin to <code>RNDU01OneExc()</code>),</li>
<li>T-SQL,</li>
<li>PL/SQL,</li>
<li>PostgreSQL, and</li>
<li>SQLite,</li>
</ul>

<p>especially within a single query.</p></li>
</ul>

<p>Readers aware of how these environments can support those uniform random number methods should send me a comment.</p>

<p><a id=Randomization_Techniques></a></p>

<h2>Randomization Techniques</h2>

<p>This section describes commonly used randomization techniques, such as shuffling, selection of several unique items, and creating random strings of text.</p>

<p><a id=Boolean_Conditions></a></p>

<h3>Boolean Conditions</h3>

<p>To generate a condition that is true at the specified probabilities, use
the following idioms in an <code>if</code> condition:</p>

<ul>
<li>True or false with equal probability: <code>RNDINT(1) == 0</code>.</li>
<li>True with X percent probability: <code>RNDINTEXC(100) &lt; X</code>.</li>
<li>True with probability X/Y: <code>RNDINTEXC(Y) &lt; X</code>.</li>
<li>True with probability X, where X is from 0 through 1 (a <em>Bernoulli trial</em>): <code>RNDU01OneExc() &lt; X</code>.</li>
<li><strong>Example:</strong> True with probability 3/8: <code>RNDINTEXC(8) &lt; 3</code>.</li>
<li><strong>Example:</strong> True with 20% probability: <code>RNDINTEXC(100) &lt; 20</code>.</li>
</ul>

<p><a id=Shuffling></a></p>

<h3>Shuffling</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle">Fisher&ndash;Yates shuffle method</a> shuffles a list (puts its items in a random order) such that all permutations (arrangements) of that list are equally likely to occur, assuming the RNG it uses can choose from among all permutations of that list.  However, that method is also easy to write incorrectly (see also Jeff Atwood, &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/">The danger of na&iuml;vet&eacute;</a>&quot;).  The following pseudocode is designed to shuffle a list&#39;s contents.</p>

<pre>METHOD Shuffle(list)
   // NOTE: Check size of the list early to prevent
   // `i` from being less than 0 if the list&#39;s size is 0 and
   // `i` is implemented using an unsigned type available
   // in certain programming languages.
   if size(list) &gt;= 2
      // Set i to the last item&#39;s index
      i = size(list) - 1
      while i &gt; 0
         // Choose an item ranging from the first item
         // up to the item given in `i`. Note that the item
         // at i+1 is excluded.
         k = RNDINTEXC(i + 1)
         // The following is wrong since it introduces biases:
         // k = RNDINTEXC(size(list))
         // The following is wrong since the algorithm won&#39;t
         // choose from among all possible permutations:
         // k = RNDINTEXC(i)
         // Swap item at index i with item at index k;
         // in this case, i and k may be the same
         tmp = list[i]
         list[i] = list[k]
         list[k] = tmp
         // Move i so it points to the previous item
         i = i - 1
      end
   end
   // NOTE: An implementation can return the
   // shuffled list, as is done here, but this is not required.
   return list
END METHOD
</pre>

<p>An important consideration with respect to shuffling is the nature of the underlying RNG, as I discuss in further detail in my <a href="https://peteroupc.github.io/random.html#Shuffling">RNG recommendation document on shuffling</a>.  It suffices to say here that in general, whenever a deterministic RNG is otherwise called for, such an RNG is good enough for shuffling a 52-item list if its period is 2<sup>226</sup> or greater. (The <em>period</em> is the maximum number of values in a generated sequence for a deterministic RNG before that sequence repeats.)</p>

<p><strong>Note:</strong> In simulation testing, shuffling is used to relabel items from a dataset at random, where each item in the dataset is assigned one of several labels.  In such testing&mdash;</p>

<ul>
<li>one or more statistics that involve the specific labeling of the original dataset&#39;s groups is calculated (such as the difference, maximum, or minimum of means or variances between groups), then</li>
<li>multiple simulated datasets are generated, where each dataset is generated by&mdash;

<ul>
<li>merging the groups,</li>
<li>shuffling the merged dataset, and</li>
<li>relabeling each item in order such that the number of items in each group for the simulated dataset is the same as for the original dataset, then</li>
</ul></li>
<li>for each simulated dataset, the same statistics are calculated as for the original dataset, then</li>
<li>the statistics for the simulated datasets are compared with those of the original.</li>
</ul>

<p><a id=Creating_a_Random_Character_String></a></p>

<h3>Creating a Random Character String</h3>

<p>Generate a random string of characters (usually a random <em>alphanumeric string</em>, or string of letters and digits) has two steps.</p>

<p><strong>First step:</strong> Generate a list of the letters, digits, and/or other characters the string can have.  For example, those characters can be&mdash;</p>

<ul>
<li>the basic digits &quot;0&quot; to &quot;9&quot; (U+0030-U+0039, nos. 48-57),</li>
<li>the basic upper case letters &quot;A&quot; to &quot;Z&quot; (U+0041-U+005A, nos. 65-90), and</li>
<li>the basic lower case letters &quot;a&quot; to &quot;z&quot; (U+0061-U+007A, nos. 96-122),</li>
</ul>

<p>as found in the Basic Latin block of the Unicode Standard.</p>

<p><strong>Second step</strong>: Build a new string whose characters are chosen from that character list.  The pseudocode below demonstrates this by creating a list, rather than a string, where the random characters will be held.  It also takes the number of characters as a parameter named <code>size</code>.  (Converting this list to a text string is programming-language-dependent, and the details of the conversion are outside the scope of this page.)</p>

<pre>  METHOD RandomString(characterList, stringSize)
       i = 0
       newString = NewList()
       while i &lt; stringSize
           // Choose a character from the list
           randomChar = characterList[RNDINTEXC(size(characterList))]
           // Add the character to the string
           AddItem(newString, randomChar)
           i = i + 1
        end
        return newString
  END METHOD
</pre>

<p><strong>Notes:</strong></p>

<ul>
<li>If the list of characters is fixed, the list can be statically created at runtime or compile time, or a string type as provided in the programming language can be used to store the list as a string.</li>
<li>Instead of individual characters, the list can consist of strings of one or more characters each.  In that case, storing the list of strings as a single string is usually not a clean way to store those strings.</li>
<li>Often applications need to generate a string of characters that&#39;s not only random, but also unique.  The best way to ensure uniqueness in this case is to store a list (such as a hash table) of strings already generated and to check newly generated strings against the list (or table).  Random number generators alone should not be relied on to deliver unique results.  Special considerations apply if the strings identify database records, file system paths, or other shared resources; such special considerations include the need to synchronize access, but are not discussed further in this document.</li>
<li>Generating a random hexadecimal string is equivalent to calling <code>RandomString(characterList, stringSize)</code>, where <code>characterList</code> is <code>[&quot;0&quot;, &quot;1&quot;, ..., &quot;9&quot;, &quot;A&quot;, ..., &quot;F&quot;]</code> or <code>[&quot;0&quot;, &quot;1&quot;, ..., &quot;9&quot;, &quot;a&quot;, ..., &quot;f&quot;]</code> (with ellipses used to save space), and <code>stringSize</code> is the desired size.</li>
<li>Generating a random base-10 digit string is equivalent to calling <code>RandomString(characterList, stringSize)</code>, where <code>characterList</code> is <code>[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]</code> and <code>stringSize</code> is the desired size.</li>
</ul>

<p><a id=Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List></a></p>

<h3>Sampling With Replacement: Choosing a Random Item from a List</h3>

<p>To choose a random item from a list&mdash;</p>

<ul>
<li>whose size is known in advance, use the idiom <code>list[RNDINTEXC(size(list))]</code>; or</li>
<li>whose size is not known in advance, generate <code>RandomKItemsFromFile(file, 1)</code>, in pseudocode given in a <a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items">later section</a> (the result will be a 1-item list or be an empty list if there are no items).</li>
</ul>

<p>Choosing an item this way is also known as <em>sampling with replacement</em>.</p>

<p><strong>Note:</strong> <a href="https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29"><em>Bootstrapping</em></a> is a method of creating a simulated dataset by choosing random items with replacement from an existing dataset until both datasets have the same size.  (The simulated dataset can contain duplicates this way.)  Usually, multiple simulated datasets are generated this way, one or more statistics, such as the mean, are calculated for each simulated dataset as well as the original dataset, and the statistics for the simulated datasets are compared with those of the original.</p>

<p><a id=Sampling_Without_Replacement_Choosing_Several_Unique_Items></a></p>

<h3>Sampling Without Replacement: Choosing Several Unique Items</h3>

<p>Often, the need arises to choose <code>k</code> unique items or values from among <code>n</code> available items or values. The following assumes that each item has an equal chance of being chosen, unless noted otherwise.  There are several techniques for doing this depending on whether <code>n</code> is known, how big <code>n</code> and <code>k</code> are, and other considerations:</p>

<ul>
<li><p><strong>If <code>n</code> is not known in advance:</strong> Use the <em>reservoir sampling</em> method, implemented below.  Although the pseudocode refers to files and lines, the technique applies to any situation when items are retrieved one at a time from a dataset or list whose size is not known in advance.  See the <code>RandomKItemsFromFile</code> method in the pseudocode below.</p></li>
<li><p><strong>If items are to be chosen in order:</strong></p>

<ul>
<li><strong>If <code>n</code> is relatively small,</strong> then the <code>RandomKItemsInOrder</code> method, in the pseudocode below, demonstrates a solution (based on a technique presented in Devroye 1986, p. 620).</li>
<li><strong>If <code>n</code> is relatively large,</strong> see the item &quot;If <code>n</code> is relatively large&quot;, later.</li>
</ul></li>
<li><strong>If <code>n</code> is relatively small (for example, if there are 200 available items, or there is a range of numbers from 0 to 200 to choose from):</strong> Do one of the following:

<ul>
<li>Store all the items in a list, <a href="#Shuffling">shuffle</a> that list, then choose the first <code>k</code> items from that list.</li>
<li>If the items are already stored in a list and the list&#39;s order can be changed, then shuffle that list and choose the first <code>k</code> items from the shuffled list.</li>
<li>If the items are already stored in a list and the list&#39;s order can&#39;t be changed, then store the indices to those items in another list, shuffle the latter list, then choose the first <code>k</code> indices (or the items corresponding to those indices) from the latter list.</li>
</ul></li>
<li><strong>If <code>k</code> is much smaller than <code>n</code> and the items are stored in a list whose order can be changed:</strong> Do a <em>partial shuffle</em> of that list, then choose the <em>last</em> <code>k</code> items from that list.  A <em>partial shuffle</em> proceeds as given in the section &quot;<a href="#Shuffling">Shuffling</a>&quot;, except the partial shuffle stops after <code>k</code> swaps have been made (where swapping one item with itself counts as a swap).</li>
<li><strong>If <code>k</code> is much smaller than <code>n</code> and <code>n</code> is not very large (for example, less than 5000):</strong> Do one of the following:

<ul>
<li>Store all the items in a list, do a <em>partial shuffle</em> of that list, then choose the <em>last</em> <code>k</code> items from that list.</li>
<li>If the items are already stored in a list and the list&#39;s order can&#39;t be changed, then store the indices to those items in another list, do a <em>partial shuffle</em> of the latter list, then choose the <em>last</em> <code>k</code> indices (or the items corresponding to those indices) from the latter list.</li>
</ul></li>
<li><strong>If <code>n</code> is relatively large (for example, if 32-bit or larger integers will be chosen so that <code>n</code> is 2<sup>32</sup> or is a greater power of 2):</strong> Create a <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a> storing the indices to items already chosen.  When a new index to an item is randomly chosen, check the hash table to see if it&#39;s there already.  If it&#39;s not there already, add it to the hash table.  Otherwise, choose a new random index.  Repeat this process until <code>k</code> indices were added to the hash table this way.  This technique can also be used for relatively small <code>n</code>, if some of the items have a higher probability of being chosen than others (see also <a href="#Discrete_Weighted_Choice">Discrete Weighted Choice</a>).  If the items are to be chosen in order, then a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red&ndash;black tree</a>, rather than a hash table, can be used to store the indices this way; after <code>k</code> indices are added to the tree, the indices (and the items corresponding to them) can be retrieved in sorted order.  Performance considerations involved in storing data in hash tables or red-black trees, and in retrieving data from them, are outside the scope of this document.</li>
</ul>

<p>Choosing several unique items as just described is also known as <em>sampling without replacement</em>.</p>

<p>The following pseudocode implements the <code>RandomKItemsFromFile</code> and <code>RandomKItemsInOrder</code> methods referred to in this section.</p>

<pre>    METHOD RandomKItemsFromFile(file, k)
       list = NewList()
       j = 0
       endOfFile = false
       while j &lt; k
          // Get the next line from the file
          item = GetNextLine(file)
          // The end of the file was reached, break
          if item == nothing:
             endOfFile = true
             break
          end
          AddItem(list, item)
          j = j + 1
       end
       i = 1 + k
       while endOfFile == false
          // Get the next line from the file
          item = GetNextLine(file)
          // The end of the file was reached, break
          if item == nothing: break
          j = RNDINTEXC(i)
          if j &lt; k: list[j] = item
          i = i + 1
       end
       // We shuffle at the end in case k or fewer
       // lines were in the file, since in that
       // case the items would appear in the same
       // order as they appeared in the file
       // if the list weren&#39;t shuffled.  This line
       // can be removed, however, if the items
       // in the returned list need not appear
       // in random order.
       Shuffle(list)
       return list
    end

   METHOD RandomKItemsInOrder(list, k)
           i = 0
           kk = k
           ret = NewList()
           n = size(list)
           while i  &lt; n and size(ret) &lt; k
             u = RNDINTEXC(n - i)
             if u &lt;= kk
              AddItem(ret, list[i])
              kk = kk - 1
             end
             i = i + 1
          end
          return ret
    END METHOD
</pre>

<p><a id=Almost_Random_Sampling></a></p>

<h3>Almost-Random Sampling</h3>

<p>Some applications (particularly some games) may find it important to control which random numbers appear, to make the random outcomes appear fairer to users.  Without this control, a user may experience long streaks of good outcomes or long streaks of bad outcomes, both of which are theoretically possible with a random number generator.  To implement this kind of &quot;almost-random&quot; sampling, do one of the following:</p>

<ul>
<li>Generate a list of possible outcomes (for example, the list can contain 10 items labeled &quot;good&quot; and three labeled &quot;bad&quot;) and <a href="#Shuffling">shuffle</a> that list.  Each time an outcome must be generated, choose the next unchosen outcome from the shuffled list.  Once all those outcomes are chosen, shuffle the list and continue.</li>
<li>Create two lists: one list with the different possible outcomes, and another list of the same size containing an integer weight 0 or greater for each outcome (for example, one list can contain the items &quot;good&quot; and &quot;bad&quot;, and the other list can contain the weights 10 and 3, respectively).  Each time an outcome must be generated, choose one outcome using the <a href="#Weighted_Choice_Without_Replacement">weighted choice without replacement</a> technique.  Once all of the weights are 0, re-fill the list of weights with the same weights the list had at the start, and continue.</li>
</ul>

<p>However, &quot;almost-random&quot; sampling techniques are not recommended&mdash;</p>

<ul>
<li>whenever computer or information security is involved, or</li>
<li>in cases (such as in multiplayer networked games) when predicting future random numbers would give a player or user a significant and unfair advantage.</li>
</ul>

<p><strong>Note:</strong> <a href="https://en.wikipedia.org/wiki/Monte_Carlo_integration">Monte Carlo integration</a> uses randomization to estimate a multidimensional integral. It involves evaluating a function at N random points in the domain, adding them up, then dividing the sum by N.  The <a href="http://mathworld.wolfram.com/Variance.html">&quot;Variance&quot; MathWorld article</a> gives methods for calculating the estimate&#39;s variance. (After calculating the error, or square root of variance, and the estimated integral, both can be multiplied by the volume of the domain.) Often <em>quasirandom sequences</em> (also known as <a href="https://en.wikipedia.org/wiki/Low-discrepancy_sequence"><em>low-discrepancy sequences</em></a>, such as Sobol and Halton sequences), often together with an RNG, provide the &quot;random&quot; numbers to sample the function more efficiently.  Unfortunately, the methods to produce such sequences are too complicated to show here.</p>

<p><a id=Choosing_a_Random_Date_Time></a></p>

<h3>Choosing a Random Date/Time</h3>

<p>Choosing a random date/time at or between two others is equivalent to&mdash;</p>

<ul>
<li>converting the two input date/times to an integer or number (here called <code>date1</code> and <code>date2</code>, where <code>date1</code> represents the earlier date/time and <code>date2</code> the other) at the required granularity, for instance, month, day, or hour granularity (the details of such conversion depend on the date/time format and are outside the scope of this document),</li>
<li>generating <code>newDate = RNDINTRANGE(date1, date2)</code> or <code>newDate = RNDNUMRANGE(date1, date2)</code>, respectively, and</li>
<li>converting <code>newDate</code> to a date/time.</li>
</ul>

<p>If either input date/time was generated as the random date, but that is not desired, the process just given can be repeated until such a date/time is not generated this way.</p>

<p><a id=Generating_Random_Numbers_in_Sorted_Order></a></p>

<h3>Generating Random Numbers in Sorted Order</h3>

<p>The following pseudocode describes a method that generates random numbers in the interval [0, 1] in sorted order.   <code>count</code> is the number of random numbers to generate this way. The method is based on an algorithm from Bentley and Saxe 1979.</p>

<pre> METHOD SortedRandom(count)
    list = NewList()
    k = count
    c = 1.0
    while k &gt; 0
        c = pow(RNDU01(), 1.0 / k) * c
        AddItem(list, c)
    end
    return list
 END METHOD
</pre>

<p>Alternatively, random numbers can be generated (using any method and where the numbers have any distribution and range) and stored in a list, and the list then sorted using a sorting algorithm.  Details on sorting algorithms, however, are beyond the scope of this document.</p>

<p><a id=Rejection_Sampling></a></p>

<h3>Rejection Sampling</h3>

<p><em>Rejection sampling</em> is a simple and flexible technique for generating random content that
meets certain requirements.  To implement rejection sampling&mdash;</p>

<ol>
<li>Generate the random content (such as a random number) by any method and with any distribution and range.</li>
<li>If the content doesn&#39;t meet predetermined criteria, go to step 1.</li>
</ol>

<p>Example criteria include checking whether a random number is prime, whether that number
is divisible or not by certain numbers, and/or whether that number is not included in a &quot;blacklist&quot; of numbers.
(Algorithms that check for prime numbers are outside the scope of this document.)</p>

<p><a id=Non_Uniform_Distributions></a></p>

<h2>Non-Uniform Distributions</h2>

<p>Some applications need to choose random items or numbers such that some of them are more likely to be chosen than others (a <em>non-uniform</em> distribution).
Most of the techniques in this section show how to use the <a href="#Uniform_Random_Numbers">uniform random number methods</a> to generate such random items or numbers.</p>

<p><a id=Discrete_Weighted_Choice></a></p>

<h3>Discrete Weighted Choice</h3>

<p>The discrete weighted choice method generates a random item from among a collection of them with separate probabilities of each item being chosen.</p>

<p>The following pseudocode takes a single list <code>weights</code>, and returns the index of a weight from that list.  The greater the weight, the more likely its index will be chosen. (Note that there are two possible ways to generate the random number depending on whether the weights are all integers or can be fractional numbers.) Each weight should be 0 or greater.</p>

<pre>METHOD DiscreteWeightedChoice(weights)
    if size(weights) == 0: return error
    sum = 0
    // Get the sum of all weights
    i = 0
    while i &lt; size(weights)
        sum = sum + weights[i]
        i = i + 1
    end
    // Choose a random integer/number from 0 to less than
    // the sum of weights.
    value = RNDINTEXC(sum)
    // NOTE: If the weights can be fractional numbers,
    // use this instead:
    // value = RNDNUMEXCRANGE(0, sum)
    // Choose the object according to the given value
    i = 0
    lastItem = size(weights) - 1
    runningValue = 0
    while i &lt; size(weights)
       if weights[i] &gt; 0
          newValue = runningValue + weights[i]
          // NOTE: Includes start, excludes end
          if value &lt; newValue: return i
          runningValue = newValue
          lastItem = i
       end
       i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return lastItem
END METHOD
</pre>

<p><strong>Example</strong>:</p>

<p>Assume we have the following list: <code>[&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;grapes&quot;]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  The weight for &quot;apples&quot; is 3, and the weight for &quot;oranges&quot; is 15.  Since &quot;oranges&quot; has a higher weight than &quot;apples&quot;, the index for &quot;oranges&quot; (1) is more likely to be chosen than the index for &quot;apples&quot; (0) with the <code>DiscreteWeightedChoice</code> method.  The following pseudocode implements how to get a randomly chosen item from the list with that method.</p>

<pre>    index = DiscreteWeightedChoice(weights)
    // Get the actual item
    item = list[index]
</pre>

<p>In the example above, the weights sum to 21.  However, the weights do not mean that when 21 items are selected, the index for &quot;apples&quot; will be chosen exactly 3 times, or the index for &quot;oranges&quot; exactly 15 times, for example.  Each call to <code>DiscreteWeightedChoice</code> is independent from the others, and each weight indicates only a <em>likelihood</em> that the corresponding index will be chosen rather than the other indices.  And this likelihood doesn&#39;t change no matter how many times <code>DiscreteWeightedChoice</code> is called with the same weights.  This is called a weighted choice <em>with replacement</em>, which can be thought of as drawing a ball, then putting it back.</p>

<p><a id=Weighted_Choice_Without_Replacement></a></p>

<h4>Weighted Choice Without Replacement</h4>

<p>To implement weighted choice <em>without replacement</em> (which can be thought of as drawing a ball <em>without</em> putting it back), call <code>DiscreteWeightedChoice</code>, and then decrease the weight for the chosen index by 1.  In this way, when items are selected repeatedly, each weight behaves like the number of &quot;copies&quot; of each item. This technique, though, will only work properly if all the weights are integers 0 or greater.  The pseudocode below is an example of this.</p>

<pre>// Get the sum of weights
// (NOTE: This code assumes that `weights` is
// a list that can be modified.  If the original weights
// are needed for something else, a copy of that
// list should be made first, but the copying process
// is not shown here.  This code also assumes that `list`,
// a list of items, was already declared earlier and
// has at least as many items as `weights`.)
totalWeight = 0
i = 0
while i &lt; size(weights)
    totalWeight = totalWeight + weights[i]
    i = i + 1
end
// Choose as many items as the sum of weights
i = 0
items = NewList()
while i &lt; totalWeight
    index = DiscreteWeightedChoice(weights)
    // Decrease weight by 1 to implement selection
    // without replacement.
    weights[index] = weights[index] - 1
    AddItem(items, list[index])
    i = i + 1
end
</pre>

<p>Alternatively, if all the weights are integers 0 or greater and their sum is relatively small, create a list with as many copies of each item as its weight, then <a href="#Shuffling">shuffle</a> that list.  The resulting list will be ordered in a way that corresponds to a weighted random choice without replacement.</p>

<p><a id=Choosing_Multiple_Items></a></p>

<h4>Choosing Multiple Items</h4>

<p>The discrete weighted choice method can also be used for choosing multiple items from a list, whether or not the items have the same probability of being chosen.  In this case, after choosing a random index, set the weight for that index to 0 to keep it from being chosen again.  The pseudocode below is an example of this.</p>

<pre>// (NOTE: This code assumes that `weights` is
// a list that can be modified.  If the original weights
// are needed for something else, a copy of that
// list should be made first, but the copying process
// is not shown here.  This code also assumes that `list`,
// a list of items, was already declared earlier and
// has at least as many items as `weights`.)
chosenItems = NewList()
i = 0
// Choose k items from the list
while i &lt; k or i &lt; size(weights)
    index = DiscreteWeightedChoice(weights)
    // Set the weight for the chosen index to 0
    // so it won&#39;t be chosen again
    weights[index] = 0
    // Add the item at the chosen index
    AddItem(chosenItems, list[index])
end
// `chosenItems` now contains the items chosen
</pre>

<p><a id=Piecewise_Constant_Distribution></a></p>

<h4>Piecewise Constant Distribution</h4>

<p>The discrete weighted choice method can also be used to implement a <a href="http://en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution"><em>piecewise constant distribution</em></a>, as in the following example. Assume we have the following list: <code>[0, 5, 10, 11, 15]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  Note that the weight list has one fewer item than the number list.  The weight for &quot;0 to 5&quot; (0 or greater, less than 5) is 3, and the weight for &quot;5 to 10&quot; is 15.  Since &quot;5 to 10&quot; has a higher weight than &quot;0 to 5&quot;, this distribution will choose a number from 5 to 10 more often than a number from 0 to 5.  The following pseudocode implements the piecewise constant distribution.</p>

<pre>// Choose a random index
index = DiscreteWeightedChoice(weights)
// Choose a random number in the chosen interval on the list
number = RNDNUMEXCRANGE(list[index], list[index + 1])
</pre>

<p>The code above implements the distribution <em>with replacement</em>.  Implementing the distribution <em>without replacement</em> is similar to implementing discrete weighted choice without replacement; the only change is to replace <code>AddItem(items, list[index])</code> with <code>AddItem(items, RNDNUMEXCRANGE(list[index], list[index + 1]))</code> in the pseudocode.</p>

<p><a id=Multinomial_Distribution></a></p>

<h4>Multinomial Distribution</h4>

<p>The discrete weighted choice method can also be used to implement a <em>multinomial distribution</em>.  This distribution models the number of times each of several mutually exclusive events happens among a given number of trials, where each event can have a separate probability of happening.  The pseudocode below is of a method that takes two parameters: <code>trials</code>, which is the number of trials, and <code>weights</code>, which are the relative probabilities of each event.  The method tallies the events as they happen and returns a list (with the same size as <code>weights</code>) containing the number of successes for each event.</p>

<pre>METHOD Multinomial(trials, weights)
    if trials &lt; 0: return error
    // create a list of successes
    list = NewList()
    i = 0
    while i &lt; size(weights)
       AddItem(list, 0)
       i = i + 1
    end
    i = 0
    while i &lt; trials
        // Choose an index
        index = DiscreteWeightedChoice(weights)
        // Tally the event at the chosen index
        list[index] = list[index] + 1
        i = i + 1
    end
    return list
END METHOD
</pre>

<p><a id=Continuous_Weighted_Choice></a></p>

<h3>Continuous Weighted Choice</h3>

<p>The continuous weighted choice method generates a random number that follows a continuous statistical distribution (here, a <a href="http://en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution"><em>piecewise linear distribution</em></a>).</p>

<p>The pseudocode below takes two lists as follows:</p>

<ul>
<li><code>list</code> is a list of numbers (which need not be integers). If the numbers are arranged in ascending order, which they should, the first number in this list can be returned exactly, but not the last item.</li>
<li><code>weights</code> is a list of weights for the given numbers (where each number and its weight have the same index in both lists).   The greater a number&#39;s weight, the more likely it is that a number close to that number will be chosen.  Each weight should be 0 or greater.</li>
</ul>

<hr>

<pre>METHOD ContinuousWeightedChoice(list, weights)
    if size(list) &lt;= 0 or size(weights) &lt; size(list): return error
    if size(list) == 1: return list[0]
    // Get the sum of all areas between weights
    sum = 0
    areas = NewList()
    i = 0
    while i &lt; size(list) - 1
      weightArea = abs((weights[i] + weights[i + 1]) * 0.5 *
            (list[i + 1] - list[i]))
      AddItem(areas, weightArea)
      sum = sum + weightArea
       i = i + 1
    end
    // Choose a random number
    value = RNDNUMEXCRANGE(0, sum)
    // Interpolate a number according to the given value
    i=0
    // Get the number corresponding to the random number
    runningValue = 0
    while i &lt; size(list) - 1
     area = areas[i]
     if area &gt; 0
      newValue = runningValue + area
      // NOTE: Includes start, excludes end
      if value &lt; newValue
       // NOTE: The following line can also read
       // &quot;interp = RNDU01OneExc()&quot;, that is, a new number is generated
       // within the chosen area rather than using the point
       // already generated.
       interp = (value - runningValue) / (newValue - runningValue)
       retValue = list[i] + (list[i + 1] - list[i]) * interp
       return retValue
      end
      runningValue = newValue
     end
     i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return list[size(list) - 1]
END METHOD
</pre>

<p><strong>Example</strong>: Assume <code>list</code> is the following: <code>[0, 1, 2, 2.5, 3]</code>, and <code>weights</code> is the following: <code>[0.2, 0.8, 0.5, 0.3, 0.1]</code>.  The weight for 2 is 0.5, and that for 2.5 is 0.3.  Since 2 has a higher weight than 2.5, numbers near 2 are more likely to be chosen than numbers near 2.5 with the <code>ContinuousWeightedChoice</code> method.</p>

<p><a id=Dice></a></p>

<h3>Dice</h3>

<p>The following method generates a random result of rolling virtual dice.  It takes three parameters: the number of dice (<code>dice</code>), the number of sides in each die (<code>sides</code>), and a number to add to the result (<code>bonus</code>) (which can be negative, but the result of the subtraction is 0 if that result is greater).</p>

<pre>METHOD DiceRoll(dice, sides, bonus)
    if dice &lt; 0 or sides &lt; 1: return error
    if dice == 0: return 0
    if sides == 1: return dice
    ret = 0
    if dice &gt; 50
        // If there are many dice to roll,
        // use a faster approach, noting that
        // the dice-roll distribution approaches
        // a &quot;discrete&quot; normal distribution as the
        // number of dice increases.
        mean = dice * (sides + 1) * 0.5
        sigma = sqrt(dice * (sides * sides - 1) / 12)
        ret = -1
        while ret &lt; dice or ret &gt; dice * sides
            ret = floor(Normal(mean, sigma) + 0.5)
        end
     else
         i = 0
         while i &lt; dice
              ret = ret + RNDINTRANGE(1, sides)
              i = i + 1
          end
     end
     ret = ret + bonus
     if ret &lt; 0: ret = 0
     return ret
END METHOD
</pre>

<p>As examples, the result of rolling&mdash;</p>

<ul>
<li>four six-sided virtual dice (&quot;4d6&quot;) is <code>DiceRoll(4,6,0)</code>,</li>
<li>three ten-sided virtual dice, with 4 added (&quot;3d10 + 4&quot;), is <code>DiceRoll(3,10,4)</code>, and</li>
<li>two six-sided virtual dice, with 2 subtracted (&quot;2d6 - 2&quot;), is <code>DiceRoll(2,6,-2)</code>.</li>
</ul>

<p>This section used the following sources:</p>

<ul>
<li>Red Blob Games, <a href="http://www.redblobgames.com/articles/probability/damage-rolls.html">&quot;Probability and Games: Dice Rolls&quot;</a> was the main source for the dice-roll distribution.  The method <code>random(N)</code> in that document corresponds to <code>RNDINTEXC(N)</code> in this document.</li>
<li>The <a href="http://mathworld.wolfram.com/Dice.html">MathWorld article &quot;Dice&quot;</a> provided the mean of the dice roll distribution.</li>
<li>S. Eger, &quot;Stirling&#39;s approximation for central extended binomial coefficients&quot;, 2014, helped suggest the variance of the dice roll distribution.</li>
</ul>

<p><a id=Normal_Gaussian_Distribution></a></p>

<h3>Normal (Gaussian) Distribution</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Normal_distribution">normal distribution</a> (also called the Gaussian distribution) can model many kinds of measurements or scores whose values are most likely around a given average and are less likely the farther away from that average on either side.</p>

<p>The pseudocode below uses the polar method <sup><a href="#Note2">(2)</a></sup> to generate two normally-distributed random numbers
using the following two parameters:</p>

<ul>
<li><code>mu</code> (&mu;) is the mean (average), or the peak of the distribution&#39;s &quot;bell curve&quot;.</li>
<li><code>sigma</code> (&sigma;), the standard deviation, affects how wide the normal distribution&#39;s &quot;bell curve&quot; appears. The
probability that a normally-distributed random number will be within one standard deviation from the mean is about 68.3%; within two standard deviations (2 times <code>sigma</code>), about 95.4%; and within three standard deviations, about 99.7%.</li>
</ul>

<hr>

<pre>METHOD Normal2(mu, sigma)
  while true
    a = RNDU01()
    b = RNDU01()
    if a != 0 and RNDINT(1) == 0: a = 0 - a
    if b != 0 and RNDINT(1) == 0: b = 0 - b
    c = a * a + b * b
    if c != 0 and c &lt;= 1
       c = sqrt(-2 * ln(c) / c)
       return [c * a, c * b]
    end
  end
END METHOD
</pre>

<p>Since <code>Normal2</code> returns two numbers instead of one, but many applications require only one number at a time, a problem arises on how to return one number while storing the other for later retrieval.  Ways to solve this problem are outside the scope of this page, however.  The name <code>Normal</code> will be used in this document to represent a method that returns only one normally-distributed random number rather than two.</p>

<p>Alternatively, or in addition, the following method (implementing a ratio-of-uniforms technique) can be used to generate normally distributed random numbers.</p>

<pre>METHOD Normal(mu, sigma)
    bmp = 0.8577638849607068 // sqrt(2/exp(1))
    while true
        a=RNDU01ZeroExc()
        b=RNDNUMRANGE(-bmp,bmp)
        if b*b &lt;= -a * a * 4 * ln(a)
            return (b * sigma / a) + mu
        end
    end
END METHOD
</pre>

<p><strong>Notes:</strong></p>

<ul>
<li>In a <em>standard normal distribution</em>, <code>mu</code> = 0 and <code>sigma</code> = 1.</li>
<li>Note that if variance is given, rather than standard deviation, the standard deviation (<code>sigma</code>) is the variance&#39;s square root.</li>
</ul>

<p><a id=Binomial_Distribution></a></p>

<h3>Binomial Distribution</h3>

<p>The following method generates a random integer that follows a binomial distribution.  This number&mdash;</p>

<ul>
<li>expresses the number of successes that have happened after a given number of independently performed trials
(expressed as <code>trials</code> below), where the probability of a success in each trial is <code>p</code> (which ranges from 0, never, to
1, always, and which can be 0.5, meaning an equal chance of success or failure), and</li>
<li>is also known as  <a href="https://en.wikipedia.org/wiki/Hamming_distance"><em>Hamming distance</em></a>, if each trial is treated
as a &quot;bit&quot; that&#39;s set to 1 for a success and 0 for a failure, and if <code>p</code> is 0.5.</li>
</ul>

<hr>

<pre>METHOD Binomial(trials, p)
    if trials &lt; 0: return error
    if trials == 0: return 0
    // Always succeeds
    if p &gt;= 1.0: return trials
    // Always fails
    if p &lt;= 0.0: return 0
    i = 0
    count = 0
    // Suggested by Saucier, R. in &quot;Computer
    // generation of statistical distributions&quot;, 2000, p. 49
    tp = trials * p
    if tp &gt; 25 or (tp &gt; 5 and p &gt; 0.1 and p &lt; 0.9)
         countval = -1
         // &quot;countval
         while countval &lt; 0 or countval &gt; trials
              countval = floor(Normal(tp, tp) + 0.5)
         end
         return countval
    end
    if p == 0.5
        while i &lt; trials
            if RNDINT(1) == 0
                // Success
                count = count + 1
            end
            i = i + 1
        end
    else
        while i &lt; trials
            if RNDU01OneExc() &lt; p
                // Success
                count = count + 1
            end
            i = i + 1
        end
    end
    return count
END METHOD
</pre>

<p><strong>Examples:</strong></p>

<ul>
<li>If <code>p</code> is 0.5, the binomial distribution models the task &quot;Flip N coins, then count the number of heads.&quot;</li>
<li>The idiom <code>Binomial(N, 0.5) &gt;= C</code> is true if at least C coins, among N coins flipped, show the successful outcome (for example, heads if heads is the successful outcome).</li>
<li>The idiom <code>Binomial(N, 1/S)</code> models the task &quot;Roll N S-sided dice, then count the number of dice that show the number S.&quot;</li>
</ul>

<p><a id=Poisson_Distribution></a></p>

<h3>Poisson Distribution</h3>

<p>In the following method, which generates a random integer that follows a <em>Poisson distribution</em>, the <code>mean</code> is the average number of independent events of a certain kind per fixed unit of time or space (for example, per day, hour, or square kilometer), and the method&#39;s return value gives a random number of such events during one such unit.</p>

<p>The random integer from the method below is such that the average of the random integers approaches the given mean number when this method is called repeatedly with the same mean.  Note that the mean can be an integer or a non-integer. The method given here is based on Knuth&#39;s method from 1969.</p>

<pre>METHOD Poisson(mean)
    if mean &lt; 0: return error
    if mean == 0: return 0
    p = 1.0
    // Suggested by Saucier, R. in &quot;Computer
    // generation of statistical distributions&quot;, 2000, p. 49
    if mean &gt; 9
        p = -1.0
        while p &lt; 0: p = floor(Normal(mean, mean) + 0.5)
        return p
    end
    pn = exp(-mean)
    count = 0
    while true
        count = count + 1
        p = p * RNDU01OneExc()
        if p &lt;= pn
                return count - 1
        end
    end
END METHOD
</pre>

<p><a id=Gamma_Distribution></a></p>

<h3>Gamma Distribution</h3>

<p>The following method generates a random number that follows a gamma distribution.
The gamma distribution models expected lifetimes. The method given here is based on Marsaglia and Tsang&#39;s method from 2000.</p>

<pre>METHOD GammaDist(meanLifetime)
    // Must be greater than 0
    if meanLifetime &lt;= 0: return error
    // Exponential distribution special case if
    // `meanLifetime` is 1 (see also
    // Devroye 1986, p. 405)
    if meanLifetime == 1: return -ln(RNDU01ZeroOneExc())
    d = meanLifetime
    v = 0
    if meanLifetime &lt; 1: d = d + 1
    d = d - (1.0 / 3) // NOTE: 1.0 / 3 must be a fractional number
    c = 1.0 / sqrt(9 * d)
    while true
        x = 0
        while true
           x = Normal(0, 1)
           v = c * x + 1;
           v = v * v * v
           if v &gt; 0: break
        end
        u = RNDU01ZeroExc()
        x2 = x * x
        if u &lt; 1 - (0.0331 * x2 * x2): break
        if ln(u) &lt; (0.5 * x2) + (d * (1 - v + ln(v))): break
    end
    ret = d * v
    if meanLifetime &lt; 1
       ret = ret * exp(ln(RNDU01ZeroExc()) / meanLifetime)
    end
    return ret
end
</pre>

<p>Extended versions of the gamma distribution:</p>

<ul>
<li>The two-parameter gamma distribution (<code>GammaDist2(a, b)</code>), where <code>b</code> is the scale, is <code>GammaDist(a) * b</code>.  Here, <code>a</code> can be seen as the mean lifetime in unspecified units of time, and <code>b</code> indicates the size of each unit of time.</li>
<li>The three-parameter gamma distribution (<code>GammaDist3(a, b, c)</code>), where <code>c</code> is another shape parameter, is <code>pow(GammaDist(a), 1.0 / c) * b</code>.</li>
<li>The four-parameter gamma distribution (<code>GammaDist4(a, b, c, d)</code>), where <code>d</code> is the minimum value, is <code>pow(GammaDist(a), 1.0 / c) * b + d</code>.</li>
</ul>

<p><a id=Negative_Binomial_Distribution></a></p>

<h3>Negative Binomial Distribution</h3>

<p>A random integer that follows a <em>negative binomial distribution</em> expresses the number of failures that have happened after seeing a given number of successes (expressed as <code>successes</code> below), where the probability of a success in each case is <code>p</code> (where <code>p &lt;= 0</code> means never, <code>p &gt;= 1</code> means always, and <code>p = 0.5</code> means an equal chance of success or failure).</p>

<p>If the negative binomial distribution allows <code>successes</code> to be a non-integer, the distribution is also called the <em>P&oacute;lya distribution</em>.</p>

<pre>METHOD NegativeBinomialInt(successes, p)
    // Must be 0 or greater
    if successes &lt; 0: return error
    // No failures if no successes or if always succeeds
    if successes == 0 or p &gt;= 1.0: return 0
    // Always fails (NOTE: infinity can be the maximum possible
    // integer value if NegativeBinomialInt is implemented to return
    // an integer)
    if p &lt;= 0.0: return infinity
    // NOTE: If &#39;successes&#39; can be an integer only,
    // omit the following three lines:
    if floor(successes) != successes
        return Poisson(GammaDist(successes) * (1 - p) / p)
    end
    count = 0
    total = 0
    if successes == 1
        if p == 0.5
          while RNDINT(1) == 0: count = count + 1
           return count
        end
        // Geometric distribution special case (see Saucier 2000)
        return floor(ln(RNDU01ZeroExc()) / ln(1.0 - p))
    end
    while true
        if RNDU01OneExc() &lt; p
            // Success
            total = total + 1
            if total &gt;= successes
                    return count
            end
        else
            // Failure
            count = count + 1
        end
    end
END METHOD
</pre>

<p><strong>Example:</strong> If <code>p</code> is 0.5 and <code>successes</code> is 1, the negative binomial distribution models the task &quot;Flip a coin until you get tails, then count the number of heads.&quot;</p>

<p><a id=von_Mises_Distribution></a></p>

<h3>von Mises Distribution</h3>

<p>The von Mises distribution describes a distribution of circular angles.  In the pseudocode below, the <code>mean</code> is the mean angle, <code>kappa</code> is a shape parameter, and the method can return a number within &pi; of that mean.  The algorithm below is the Best&ndash;Fisher algorithm from 1979 (as described in Devroye 1986 with errata incorporated).</p>

<pre>METHOD VonMises(mean, kappa)
    if kappa &lt; 0: return error
    if kappa == 0
        return RNDNUMEXCRANGE(mean-pi, mean+pi)
    end
    r = 1.0 + sqrt(4 * kappa * kappa + 1)
    rho = (r - sqrt(2 * r)) / (kappa * 2)
    s = (1 + rho * rho) / (2 * rho)
    while true
        u = RNDNUMEXCRANGE(-1, 1)
        v = RNDU01ZeroOneExc()
        z = cos(pi * u)
        w = (1 + s*z) / (s + z)
        y = kappa * (s - w)
        if y*(2 - y) - v &gt;=0 or ln(y / v) + 1 - y &gt;= 0
           if angle&lt;-1: angle=-1
           if angle&gt;1: angle=1
           angle = acos(w)
           if u &lt; 0: angle = -angle
           return mean + angle
        end
    end
END METHOD
</pre>

<p><a id=Stable_Distribution></a></p>

<h3>Stable Distribution</h3>

<p>As more and more independent and identically distributed random variables are added
together, their distribution tends to a <a href="https://en.wikipedia.org/wiki/Stable_distribution"><em>stable distribution</em></a>,
which resembles a curve with a single peak, but with generally &quot;fatter&quot; tails than the normal distribution.  The pseudocode below uses the Chambers&ndash;Mallows&ndash;Stuck algorithm.  The <code>Stable</code> method, implemented below, takes two parameters:</p>

<ul>
<li><code>alpha</code> is a stability index in the interval (0, 2].</li>
<li><code>beta</code> is a skewness in the interval [-1, 1]); if <code>beta</code> is 0, the curve is symmetric.</li>
</ul>

<hr>

<pre>METHOD Stable(alpha, beta)
     if alpha &lt;=0 or alpha &gt; 2: return error
     if beta &lt; -1 or beta &gt; 1: return error
    halfpi = pi * 0.5
    unif=RNDNUMEXCRANGE(-halfpi, halfpi)
    while unif==-halfpi: unif=RNDNUMEXCRANGE(-halfpi, halfpi)
    // Cauchy special case
    if alpha == 1 and beta == 0: return tan(unif)
    expo=-ln(RNDU01ZeroExc())
    c=cos(unif)
    if alpha == 1
            s=sin(unif)
            return 2.0*((unif*beta+halfpi)*s/c -
                beta * ln(halfpi*expo*c/(unif*beta+halfpi)))/pi
    end
    z=-tan(alpha*halfpi)*beta
    ug=unif+atan(-z)/alpha
    cpow=pow(c, -1.0 / alpha)
    return pow(1.0+z*z, 1.0 / (2*alpha))*
        (sin(alpha*ug)*cpow)*
        pow(cos(unif-alpha*ug)/expo, (1.0 - alpha) / alpha)
END METHOD
</pre>

<p>Extended versions of the stable distribution:</p>

<ul>
<li>The four-parameter stable distribution (<code>Stable4(alpha, beta, mu, sigma)</code>), where <code>mu</code> is the mean and <code>sigma</code> is the scale, is <code>Stable(alpha, beta) * sigma + mu</code>.</li>
<li>The &quot;type 0&quot; stable distribution (<code>StableType0(alpha, beta, mu, sigma)</code>) is <code>Stable(alpha, beta) * sigma + (mu - sigma * beta * x)</code>, where <code>x</code> is <code>ln(sigma)*2.0/pi</code> if <code>alpha</code> is 1, and <code>tan(pi*0.5*alpha)</code> otherwise.</li>
</ul>

<p><a id=Hypergeometric_Distribution></a></p>

<h3>Hypergeometric Distribution</h3>

<p>The following method generates a random integer that follows a hypergeometric distribution.
When a given number of items are drawn at random without replacement from a collection of items
each labeled either <code>1</code> or <code>0</code>,  the random integer expresses the number of items drawn
this way that are labeled <code>1</code>.  In the method below, <code>trials</code> is the number of items
drawn at random, <code>ones</code> is the number of items labeled <code>1</code> in the set, and <code>count</code> is
the number of items labeled <code>1</code> or <code>0</code> in that set.</p>

<pre>METHOD Hypergeometric(trials, ones, count)
    if ones &lt; 0 or count &lt; 0 or trials &lt; 0 or ones &gt; count or trials &gt; count
            return error
    end
    if ones == 0: return 0
   successes = 0
    i = 0
    currentCount = count
    currentOnes = ones
    while i &lt; trials and currentOnes &gt; 0
            if RNDINTEXC(currentCount) &lt; currentOnes
                    currentOnes = currentOnes - 1
                    successes = successes + 1
            end
            currentCount = currentCount - 1
            i = i + 1
    end
    return successes
END METHOD
</pre>

<p><strong>Example:</strong> In a 52-card deck of Anglo-American playing cards, 12 of the cards are face
cards (jacks, queens, or kings).  After the deck is shuffled and seven cards are drawn, the number
of face cards drawn this way follows a hypergeometric distribution where <code>trials</code> is 7, <code>ones</code> is
12, and <code>count</code> is 52.</p>

<p><a id=Multivariate_Normal_Distribution></a></p>

<h3>Multivariate Normal Distribution</h3>

<p>The following pseudocode calculates a random point in space that follows a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">multivariate normal distribution</a>.  The method <code>MultivariateNormal</code> takes the following parameters:</p>

<ul>
<li>A list, <code>mu</code>, which indicates the means
to add to each component of the random point. <code>mu</code> can be <code>nothing</code>, in which case each
component will have a mean of zero.</li>
<li>A list of lists <code>cov</code>, that specifies a <em>covariance matrix</em> (a symmetric positive definite NxN matrix with as many rows and as many columns as components of the random point.)</li>
</ul>

<p>For conciseness, the following pseudocode uses <code>for</code> loops, defined as follows. <code>for X=Y to Z; [Statements] ; end</code> is shorthand for <code>X = Y; while X &lt;= Z; [Statements]; X = X + 1; end</code>.</p>

<pre>METHOD Decompose(matrix)
  numrows = size(matrix)
  if matrix[0]!=numrows: return error
  // Does a Cholesky decomposition of a matrix
  // assuming it&#39;s positive definite and invertible
  ret=NewList()
  for i = 0 to numrows - 1
    submat = NewList()
    for j = 0 to numrows - 1
      AddItem(submat, 0)
    end
    AddItem(ret, submat)
  end
  s1 = sqrt(matrix[0][0])
  if s1==0: return ret // For robustness
  for i = 1 to numrows - 1
    ret[0][i]=matrix[0][i]*1.0/s1
  end
  for i = 1 to numrows - 1
    sum=0.0
    for j = 0 to i - 1
      sum = sum + ret[j][i]*ret[j][i]
    end
    sq=matrix[i][i]-sum
    if sq&lt;0: sq=0 // For robustness
    ret[i][i]=math.sqrt(sq)
  end
  for j = 1 to numrows - 1
    for i = j + 1 to numrows - 1
      // For robustness
      if ret[j][j]==0: ret[j][i]=0
      if ret[j][j]!=0
        sum=0
        for k = 0 to j - 1
          sum = sumret[k][i]*ret[k][j]
        end
        ret[j][i]=(matrix[j][i]-sum)*1.0/ret[j][j]
      end
    end
  end
  return ret
END METHOD

METHOD MultivariateNormal(mu, cov)
  mulen=size(cov)
  if mu != nothing
   mulen = size(mu)
    if mulen!=size(cov): return error
    if mulen!=size(cov[0]): return error
  end
  // NOTE: If multiple random points will
  // be generated using the same covariance
  // matrix, an implementation can consider
  // precalculating the decomposed matrix
  // in advance rather than calculating it here.
  cho=Decompose(cov)
  i=0
  ret=NewList()
  while i&lt;mulen
    nv=Normal(0,1)
    if mulen == nothing: sum = 0
    else: sum=mu[i]
    j=0
    while j&lt;mulen
      sum=sum+nv*cho[j][i]
      j=j+1
    end
    AddItem(ret, sum)
    i=i+1
  end
  return ret
end
</pre>

<p><a id=Dirichlet_Distribution_Random_Numbers_with_a_Given_Positive_Sum></a></p>

<h3>Dirichlet Distribution: Random Numbers with a Given Positive Sum</h3>

<p>The <em>Dirichlet distribution</em> models a distribution of N numbers that sum to a given positive number, <code>total</code>.  Generating N <code>GammaDist(total)</code> calls and dividing them by their sum will result in N random numbers that (approximately) sum to <code>total</code> (see the <a href="https://en.wikipedia.org/wiki/Dirichlet_distribution#Gamma_distribution">Wikipedia article</a>).  For example, if <code>total</code> is 1, the numbers will (approximately) sum to 1.  Note that in the exceptional case that all numbers are 0, the process should repeat. (A more general version of the Dirichlet distribution allows the parameter in <code>GammaDist</code> to vary for each random number.)</p>

<p>An alternative method, which can work better if random integers are to be generated instead of random numbers, is illustrated in the following pseudocode.  In the pseudocode below, <code>Sort(list)</code> sorts the items in <code>list</code> in ascending order. (Note that details on sort algorithms are outside the scope of this document.)</p>

<pre>METHOD NumbersWithSum(n, total)
    if n &lt;= 0 or total &lt;=0: return error
    list = NewList()
    i = 0
    while i &lt; n - 1
       AddItem(list, RNDNUMRANGE(0, total))
       // NOTE: If only integers are to be generated, the following
       // can be used instead of the preceding line:
       // AddItem(list, RNDINT(total))
       i = i + 1
     end
     AddItem(list, total)
     Sort(list)
     prev = list[0]
     i = 1
    while i &lt; n
         newValue = list[i] - prev
         prev = list[i]
         list[i] = newValue
         i = i + 1
    end
END METHOD
</pre>

<p><strong>Notes:</strong></p>

<ul>
<li>The problem of generating N random numbers with a given positive sum is equivalent to the problem of generating a uniformly distributed point
inside an (N-1) dimensional simplex (simplest convex figure) whose edges all have a length of one unit.</li>
<li>Generating <code>N</code> random numbers with a given positive average <code>avg</code> is equivalent to generating <code>N</code> random numbers
with the sum <code>N * avg</code>.</li>
</ul>

<p><a id=Other_Non_Uniform_Distributions></a></p>

<h3>Other Non-Uniform Distributions</h3>

<p>Most commonly used:</p>

<ul>
<li><strong>Beta distribution (<code>BetaDist(a, b)</code>)</strong>: <code>x / (x + GammaDist(b))</code>, where <code>x</code> is <code>GammaDist(a)</code> and <code>a</code> and <code>b</code> are
the two parameters of the beta distribution.  The range of the beta distribution is [0, 1).</li>
<li><strong>Cauchy (Lorentz) distribution</strong>: <code>scale * tan(pi * (RNDU01OneExc()-0.5)) + mu</code>, where <code>mu</code> and <code>scale</code>
are the two parameters of the Cauchy distribution.  This distribution is similar to the normal distribution, but with &quot;fatter&quot; tails.</li>
<li><strong>Chi-squared distribution</strong>: <code>GammaDist(df * 0.5) * 2</code>, where <code>df</code> is the number of degrees of
freedom.  This expresses a sum-of-squares of <code>df</code> random variables in the standard normal distribution.</li>
<li><strong>Exponential distribution</strong>: <code>-ln(RNDU01ZeroExc()) / lamda</code>, where <code>lamda</code> is the inverse scale. The <code>lamda</code> is usually the probability that an independent event of a given kind will occur in a given span of time (such as in a given day or year).  (This distribution is thus useful for modeling a <em>Poisson process</em>.) <code>1.0 / lamda</code> is the scale (mean), which is usually the average waiting time between two independent events of the same kind.</li>
<li><strong>Extreme value distribution</strong>: <code>a - ln(-ln(RNDU01ZeroOneExc())) * b</code>, where <code>b</code> is the scale and <code>a</code> is the location of the distribution&#39;s curve peak (mode).
This expresses a distribution of maximum values.</li>
<li><strong>Geometric distribution</strong>: <code>NegativeBinomialInt(1, p)</code>, where <code>p</code> has the same meaning
as in the negative binomial distribution.  As used here, this is the number of failures that have happened before a success happens. (Saucier 2000, p. 44, also mentions an alternative definition that includes the success.)</li>
<li><strong>Gumbel distribution</strong>: <code>a + ln(-ln(RNDU01ZeroOneExc())) * b</code>, where <code>b</code> is the scale and <code>a</code> is the location of the distribution&#39;s curve peak (mode).
This expresses a distribution of minimum values.</li>
<li><strong>Inverse gamma (Pearson V) distribution</strong>: <code>b / GammaDist(a)</code>, where <code>a</code> and <code>b</code> have the
same meaning as in the two-parameter gamma distribution.</li>
<li><strong>Laplace (double exponential) distribution</strong>: <code>(ln(RNDU01ZeroExc()) - ln(RNDU01ZeroExc())) * beta + mu</code>, where <code>beta</code> is the scale and <code>mu</code> is the mean.</li>
<li><strong>Logarithmic normal distribution</strong>: <code>exp(Normal(mu, sigma))</code>, where <code>mu</code> and <code>sigma</code>
have the same meaning as in the normal distribution.</li>
<li><strong>Pareto distribution</strong>: <code>pow(RNDU01ZeroOneExc(), -1.0 / alpha) * minimum</code>, where <code>alpha</code>  is the shape and <code>minimum</code> is the minimum.</li>
<li><strong>Rayleigh distribution</strong>: <code>a * sqrt(-2 * ln(RNDU01ZeroExc()))</code>, where <code>a</code> is the scale and is greater than 0.</li>
<li><strong>Student&#39;s <em>t</em>-distribution</strong>: <code>Normal(cent, 1) / sqrt(GammaDist(df * 0.5) * 2 / df)</code>, where <code>df</code> is the number of degrees of freedom, and <em>cent</em> is the mean of the normally-distributed random number.  A <code>cent</code> other than 0 indicates a <em>noncentral</em> distribution.</li>
<li><strong>Triangular distribution</strong>: <code>ContinuousWeightedChoice([startpt, midpt, endpt], [0, 1, 0])</code>. The distribution starts at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>.</li>
<li><strong>Weibull distribution</strong>: <code>b * pow(-ln(RNDU01ZeroExc()),1.0 / a)</code>, where <code>a</code> is the shape, <code>b</code> is the scale, and <code>a</code> and <code>b</code> are greater than 0.</li>
</ul>

<p>Miscellaneous:</p>

<ul>
<li><strong>Arcsine distribution</strong>: <code>min + (max - min) * BetaDist(0.5, 0.5)</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 14).</li>
<li><strong>Beta binomial distribution</strong>: <code>Binomial(trials, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>trials</code> is a parameter of the binomial distribution.</li>
<li><strong>Beta-PERT distribution</strong>: <code>startpt + size * BetaDist(1.0 + (midpt - startpt) * shape / size, 1.0 + (endpt - midpt) * shape / size)</code>. The distribution starts  at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>, <code>size</code> is <code>endpt - startpt</code>, and <code>shape</code> is a shape parameter that&#39;s 0 or greater, but usually 4.</li>
<li><strong>Beta prime distribution</strong>: <code>x / (1 - x)</code>, where <code>x</code> is <code>BetaDist(a, b)</code> and <code>a</code> and <code>b</code> are the two parameters of the beta distribution.</li>
<li><strong>Beta negative binomial distribution</strong>: <code>NegativeBinomial(successes, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>successes</code> is a parameter of the negative binomial distribution. If <em>successes</em> is 1, the result is a <em>Waring&ndash;Yule distribution</em>. (<code>NegativeBinomial</code> can be <code>NegativeBinomialInt</code> instead.)</li>
<li><strong>Binormal distribution</strong>: <code>MultivariateNormal([mu1, mu2], [[s1*s1, s1*s2*rho], [rho*s1*s2, s2*s2]])</code>, where <code>mu1</code> and <code>mu2</code> are the means of the two random variables, <code>s1</code> and <code>s2</code> are their standard deviations, and <code>rho</code> is a <em>correlation coefficient</em> greater than -1 and less than 1.</li>
<li><strong>Chi distribution</strong>: <code>sqrt(GammaDist(df * 0.5) * 2)</code>, where <code>df</code> is the number of degrees of
freedom.</li>
<li><strong>Cosine distribution</strong>: <code>min + (max - min) * asin(RNDNUMRANGE(-1, 1)) / pi</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 17).</li>
<li><strong>Double logarithmic distribution</strong>: <code>min + (max - min) * (0.5 + (RNDINT(1) * 2 - 1) * 0.5 * RNDU01OneExc() * RNDU01OneExc())</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (see also Saucier 2000, p. 15, which shows the wrong X axes).</li>
<li><strong>Erlang distribution</strong>: <code>GammaDist(shape) / rate</code>, where <code>shape</code> and <code>rate</code> are the two parameters of the Erlang distribution.</li>
<li><strong>Generalized extreme value (Fisher&ndash;Tippett) distribution</strong>: <code>a - (pow(-ln(RNDU01ZeroExc()), -c) - 1) * b / c</code> if <code>c != 0</code>, or <code>a - ln(-ln(RNDU01ZeroOneExc())) * b</code> otherwise, where <code>b</code> is the scale, <code>a</code> is the location of the distribution&#39;s curve peak (mode), and <code>c</code> is a shape parameter.
This expresses a distribution of maximum values.</li>
<li><strong>Half-normal distribution</strong>: <code>abs(Normal(0, sqrt(pi * 0.5) / invscale)))</code>, where <code>invscale</code> is a parameter of the half-normal distribution.</li>
<li><strong>Inverse chi-squared distribution</strong>: <code>df * scale / (GammaDist(df * 0.5) * 2)</code>, where <code>df</code> is the number of degrees of freedom and <code>scale</code> is the scale, usually <code>1.0 / df</code>.</li>
<li><strong>Inverse Gaussian distribution (Wald distribution)</strong>: Generate <code>n = mu + (mu*mu*y/(2*lamda)) - mu * sqrt(4 * mu * lamda * y + mu * mu * y * y) / (2 * lamda)</code>, where <code>y = pow(Normal(0, 1), 2)</code>, then return <code>n</code> if <code>RNDU01OneExc() &lt;= mu / (mu + n)</code>, or <code>mu * mu / n</code> otherwise. <code>mu</code> is the mean and <code>lamda</code> is the scale; both parameters are greater than 0. Based on method published in <a href="http://luc.devroye.org/rnbookindex.html">Devroye 1986</a>.</li>
<li><strong>Kumaraswamy distribution</strong>: <code>min + (max - min) * pow(a-pow(RNDU01ZeroExc(),1.0/b),1.0/a)</code>, where <code>a</code> and <code>b</code> are shape parameters, <code>min</code> is the minimum value, and <code>max</code> is the maximum value.</li>
<li><strong>L&eacute;vy distribution</strong>: <code>sigma * 0.5 / GammaDist(0.5) + mu</code>, where <code>mu</code> is the location and <code>sigma</code> is the dispersion.</li>
<li><strong>Logarithmic distribution</strong>: <code>min + (max - min) * RNDU01OneExc() * RNDU01OneExc()</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 26).</li>
<li><strong>Logarithmic series distribution</strong>: <code>floor(1.0 + ln(RNDU01ZeroExc()) / ln(1.0 - pow(1.0 - param, RNDU01ZeroOneExc())))</code>, where <code>param</code> is a number greater than 0 and less than 1. Based on method described in Devroye 1986.</li>
<li><strong>Logistic distribution</strong>: <code>(ln(x/(1.0 - x)) * scale + mean</code>, where <code>x</code> is <code>RNDU01ZeroOneExc()</code> and <code>mean</code> and <code>scale</code> are the two parameters of the logistic distribution.</li>
<li><strong>Maxwell distribution</strong>: <code>scale * sqrt(GammaDist(1.5) * 2)</code>, where <code>scale</code> is the scale.</li>
<li><strong>Noncentral chi-squared distribution</strong>: <code>GammaDist(df * 0.5 + Poisson(sms * 0.5)) * 2</code>, where <code>df</code> is the number of degrees of freedom and <code>sms</code> is the sum of mean squares.</li>
<li><strong>Noncentral <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5) * n / (GammaDist(n * 0.5 + Poisson(sms * 0.5)) * m)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random numbers with a chi-squared distribution, one of which has a noncentral distribution with sum of mean squares equal to <code>sms</code>.</li>
<li><strong>Parabolic distribution</strong>: <code>min + (max - min) * BetaDist(2, 2)</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 30).</li>
<li><strong>Pascal distribution</strong>: <code>NegativeBinomialInt(successes, p) + successes</code>, where <code>successes</code> and <code>p</code> have the same meaning as in the negative binomial distribution.</li>
<li><strong>Pearson VI distribution</strong>: <code>GammaDist(v) / (GammaDist(w))</code>, where <code>v</code> and <code>w</code> are shape parameters greater than 0 (Saucier 2000, p. 33; there, an additional <code>b</code> parameter is defined, but that parameter is canceled out in the source code).</li>
<li><strong>Power distribution</strong>: <code>pow(RNDU01ZeroOneExc(), 1.0 / alpha)</code>, where <code>alpha</code>  is the shape.</li>
<li><strong>Skellam distribution</strong>: <code>Poisson(mean1) - Poisson(mean2)</code>, where <code>mean1</code> and <code>mean2</code> are the means of the two Poisson variables.</li>
<li><strong>Skewed normal distribution</strong>: <code>Normal(0, x) + mu + alpha * abs(Normal(0, x))</code>, where <code>x</code> is <code>sigma / sqrt(alpha * alpha + 1.0)</code>, <code>mu</code> and <code>sigma</code> have
the same meaning as in the normal distribution, and <code>alpha</code> is a shape parameter.</li>
<li><strong>Snedecor&#39;s (Fisher&#39;s) <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5) * n / (GammaDist(n * 0.5) * m)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random numbers with a chi-squared distribution.</li>
<li><strong>Zeta distribution</strong>: Generate <code>n = floor(pow(RNDU01ZeroOneExc(), -1.0 / r))</code>, and if <code>d / pow(2, r) &lt; (d - 1) * RNDU01OneExc() * n / (pow(2, r) - 1.0)</code>, where <code>d = pow((1.0 / n) + 1, r)</code>, repeat this process. The parameter <code>r</code> is greater than 0. Based on method described in Devroye 1986. A zeta distribution <a href="#Truncation_and_Censoring">truncated</a> by rejecting random values greater than some positive integer is called a <em>Zipf distribution</em> or <em>Estoup distribution</em>. (Note that Devroye uses &quot;Zipf distribution&quot; to refer to the untruncated zeta distribution.)</li>
</ul>

<p><a id=Correlated_Random_Numbers></a></p>

<h3>Correlated Random Numbers</h3>

<p>According to (Saucier 2000), sec. 3.8, to generate two correlated (dependent) random variables&mdash;</p>

<ul>
<li>generate two independent and identically distributed random variables <code>x</code> and <code>y</code> (for example, two <code>Normal(0, 1)</code> variables or two <code>RNDU01()</code> variables), and</li>
<li>calculate <code>[x, y*sqrt(1 - rho * rho) + rho * x]</code>, where <code>rho</code> is a <em>correlation coefficient</em> in the interval <a href="if%20%60rho%60%20is%200,%20the%20variables%20are%20uncorrelated">-1, 1</a>.</li>
</ul>

<p><a id=Gaussian_Copula></a></p>

<h4>Gaussian Copula</h4>

<p>Another way to generate correlated random numbers is to use a <a href="#Multivariate_Normal_Distribution">multivariate normal distribution</a>, then convert the resulting numbers to uniformly-distributed numbers.  In the following pseudocode, which generates correlated uniformly-distributed random numbers this way:</p>

<ul>
<li>The parameter <code>covar</code> is the covariance matrix for the multivariate normal distribution.</li>
<li><code>erf(v)</code> is the <a href="https://en.wikipedia.org/wiki/Error_function">error function</a> of the variable <code>v</code>.  It&#39;s provided here because some popular programming languages, such as JavaScript at the time of this writing, don&#39;t include a built-in version of <code>erf</code>.  In the method, <code>EPSILON</code> is a very small number to end the iterative calculation.</li>
</ul>

<p>The pseudocode below is one example of a <em>copula</em> (a distribution of groups of two or more correlated uniform random numbers), namely, a <em>Gaussian copula</em>.</p>

<pre>METHOD erf(v)
    if v==0: return 0
    if v&lt;0: return erf(-v)
    if v==infinity: return 1
    // NOTE: For IEEE 64-bit IEEE 754 binary
    // floating-point (Java `double`), the following
    // line can be added:
    // if v&gt;=6: return 1
    i=1
    ret=0
    zp=-(v*v)
    zval=1.0
    den=1.0
    while i &lt; 100
        r=v*zval/den
        den=den+2
        ret=ret+r
        // NOTE: EPSILON can be 10^14,
        // for example.
        if abs(r)&lt;EPSILON: break
        if i==1: zval=zp
        else: zval = zval*zp/i
        i = i + 1
    end
    return ret*2/sqrt(pi)
END METHOD

METHOD GaussianCopula(covar)
    mvn=MultivariateNormal(nothing, covar)
    i = 0
   sqrt2=sqrt(2)
   while i &lt; size(covar)
      stdev=sqrt(covar[i][i])
      // Apply the standard normal distribution&#39;s CDF
      // function to get uniform variables
      mvn[i] = (erf(mvn[i]/(stdev*sqrt2))+1)*0.5
       i = i + 1
   end
   return mvn
END METHOD
</pre>

<p>Each of the resulting uniform variables will be in the interval [0, 1], and each one can be further transformed to any other statistical distribution (which is called a <em>marginal distribution</em> here) by one of the methods given in &quot;<a href="#Generating_Random_Numbers_from_an_Arbitrary_Distribution">Generating Random Numbers from an Arbitrary Distribution</a>&quot;.  The transformed variables will have the same correlation as the uniform variables, regardless of the marginal distributions chosen.</p>

<p><strong>Example</strong>: To generate two correlated uniform variables by this method, generate <code>GaussianCopula([[1, rho], [rho, 1]])</code>, where <code>rho</code> is the Pearson correlation coefficient, in the interval [-1, 1]. (Note that <a href="https://en.wikipedia.org/wiki/Rank_correlation"><em>rank correlation</em></a> parameters, which can be converted to <code>rho</code>, can better describe the correlation than <code>rho</code> itself. For example, for a bivariate normal distribution, the Spearman coefficient <code>srho</code> can be converted to <code>rho</code> by <code>rho = sin(srho * pi / 6) * 2</code>.  Rank correlation parameters are not further discussed in this document.)</p>

<p><a id=Generating_Random_Numbers_from_a_Distribution_of_Data_Points></a></p>

<h3>Generating Random Numbers from a Distribution of Data Points</h3>

<p>To generate a random number (or data point) based on the distribution of a list of numbers (or data points)&mdash;</p>

<ul>
<li>choose one of the numbers or points at random (see, for example, <a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List">Choosing a Random Item from a List</a>), and</li>
<li>add a randomized &quot;jitter&quot; to the chosen number or point; for example&mdash;

<ul>
<li>add <code>Normal(0, sigma)</code> to the chosen number, where <code>sigma</code> is the <em>bandwidth</em> (which should be as small as allows the estimated distribution to fit the data and remain smooth), or</li>
<li>add a separately generated <code>Normal(0, sigma)</code> to each component of the chosen point, where <code>sigma</code> is the <em>bandwidth</em><sup><a href="#Note4">(4)</a></sup>.</li>
</ul></li>
</ul>

<p>A detailed discussion on how to calculate bandwidth or on other possible ways to add randomized &quot;jitter&quot; (whose distribution is formally called a <em>kernel</em>) is outside the scope of this document.  For further information on <em>kernel density estimation</em>, which the random number generation technique here is related to, see the Wikipedia articles on <a href="https://en.wikipedia.org/wiki/Kernel_density_estimation">single-variable</a> and <a href="https://en.wikipedia.org/wiki/Multivariate_kernel_density_estimation">multiple-variable</a> estimation, or a <a href="http://mark-kay.net/2013/12/24/kernel-density-estimation/">blog post by M. Kay</a>.</p>

<p><a id=Generating_Random_Numbers_from_an_Arbitrary_Distribution></a></p>

<h3>Generating Random Numbers from an Arbitrary Distribution</h3>

<p>Many statistical distributions can be defined in terms of any of the following:</p>

<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function"><em>cumulative distribution function</em></a>, or <em>CDF</em>, returns, for each number, the probability for a randomly generated variable to be equal to or less than that number; the probability is in the interval [0, 1].</li>
<li>The <a href="https://en.wikipedia.org/wiki/Probability_density_function"><em>probability density function</em></a>, or <em>PDF</em>, is the derivative (instantaneous rate of change) of the distribution&#39;s CDF (that is, PDF(x) = CDF&prime;(x)).  The CDF is also defined as the integral of the PDF (details on integrals are outside the scope of this document).  Each value of the PDF must be 0 or greater.</li>
</ul>

<p>If a statistical distribution&#39;s <strong>PDF is known</strong>, one of the following techniques, among others, can be used to generate random numbers that follow that distribution.</p>

<ol>
<li>Use the PDF to calculate the weights for a number of sample points (usually regularly spaced). Create one list with the sampled points in ascending order (the <code>list</code>) and another list of the same size with the PDF&#39;s values at those points (the <code>weights</code>).  Finally call <code>ContinuousWeightedChoice(list, weights)</code> to generate a random number bounded by the lowest and highest sampled point. This technique can be used even if the area under the PDF isn&#39;t 1. <strong>OR</strong></li>
<li>Use <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling"><em>inverse transform sampling</em></a>. Generate <code>ICDF(RNDU01ZeroOneExc())</code>, where <code>ICDF(X)</code> is the distribution&#39;s <em>inverse cumulative distribution function</em> (<em>inverse CDF</em>, or inverse of the CDF) assuming the area under the PDF is 1. <strong>OR</strong></li>
<li><p>Use <em>rejection sampling</em>.  Choose the lowest and highest random number to generate (<code>minValue</code> and <code>maxValue</code>, respectively) and find the maximum value of the PDF at or between those points (<code>maxDensity</code>).  The rejection sampling approach is then illustrated with the following pseudocode, where <code>PDF(X)</code> is the distribution&#39;s PDF (see also Saucier 2000, p. 39).   This technique can be used even if the area under the PDF isn&#39;t 1.</p>

<pre>METHOD ArbitraryDist(minValue, maxValue, maxDensity)
     if minValue &gt;= maxValue: return error
     while True:
         x=RNDNUMEXCRANGE(minValue, maxValue)
         y=RNDNUMEXCRANGE(0, maxDensity)
         if y &lt; PDF(x): return x
     end
END METHOD
</pre></li>
</ol>

<p>If both <strong>a PDF and a uniform random variable in the interval [0, 1) (<code>randomVariable</code>)</strong> are given, then one of the following techniques can be used to generate a random number that follows that distribution:</p>

<ol>
<li>Do the same process as method 1, given earlier, except&mdash;

<ul>
<li>divide the weights in the <code>weights</code> list by the sum of all weights, and</li>
<li>use a modified version of <a href="#Continuous_Weighted_Choice"><code>ContinuousWeightedChoice</code></a> that uses <code>randomVariable</code> rather than generating a new random number. <strong>OR</strong></li>
</ul></li>
<li>Call <code>ICDF(randomVariable)</code>, where <code>ICDF(X)</code> is the distribution&#39;s inverse CDF (see method 2, given earlier).</li>
</ol>

<p>If the distribution&#39;s <strong>CDF is known</strong>, generate <code>ICDF(RNDU01ZeroOneExc())</code>, where <code>ICDF(X)</code> is the inverse of that CDF.</p>

<p><strong>Note:</strong> Further details on inverse transform sampling or on how to find integrals or inverses, as well as lists of PDFs and CDFs, are outside the scope of this page.</p>

<p><a id=Truncation_and_Censoring></a></p>

<h3>Truncation and Censoring</h3>

<p>To sample from a <em>truncated</em> statistical distribution, generate a random number from that distribution and, if that number is less than a minimum threshold and/or higher than a maximum threshold, repeat this process.</p>

<p>To sample from a <em>censored</em> statistical distribution, generate a random number from that distribution and&mdash;</p>

<ul>
<li>if that number is less than a minimum threshold, use the minimum threshold instead, and/or</li>
<li>if that number is greater than a maximum threshold, use the maximum threshold instead.</li>
</ul>

<p><a id=Random_Points_on_the_Surface_of_a_Hypersphere></a></p>

<h3>Random Points on the Surface of a Hypersphere</h3>

<p>To generate an N-dimensional point on the surface of an N-dimensional hypersphere of radius R, generate N <code>Normal(0, 1)</code> random numbers, then divide them by <code>R / X</code>, where <code>X</code> is those numbers&#39; <a href="#Notation_and_Definitions"><em>norm</em></a> (if <code>X</code> is 0, the process should repeat). A hypersphere&#39;s surface is formed by all points lying 1 unit away from a common point in N-dimensional space. Based on a technique described in <a href="http://mathworld.wolfram.com/HyperspherePointPicking.html">MathWorld</a>.</p>

<p>This problem is equivalent to generating a random unit vector (vector with length 1) in N-dimensional space.</p>

<p><a id=Random_Points_Inside_a_Ball></a></p>

<h3>Random Points Inside a Ball</h3>

<p>To generate an N-dimensional point inside an N-dimensional ball of radius R, either&mdash;</p>

<ul>
<li>generate N <code>Normal(0, 1)</code> random numbers, generate <code>X = sqrt( S - ln(RNDU01ZeroExc()))</code>, where <code>S</code> is the sum of squares of the random numbers, and multiply each random number by <code>R / X</code> (if <code>X</code> is 0, the process should repeat), or</li>
<li>generate N <code>RNDNUMRANGE(-R, R)</code> random numbers<sup><a href="#Note3">(3)</a></sup> until their <a href="#Notation_and_Definitions"><em>norm</em></a> is R or less,</li>
</ul>

<p>although the former method &quot;may ... be slower&quot; &quot;in practice&quot;, according to a <a href="http://mathworld.wolfram.com/BallPointPicking.html">MathWorld article</a>, which was the inspiration for the two methods given here.</p>

<p>If the ball is hollow, that is, only points within a range of distances from the center of the ball are allowed, then use either method given earlier to generate a random point for a ball of radius equal to the maximum allowed distance, until the <a href="#Notation_and_Definitions"><em>norm</em></a> of the numbers making up that point is within the desired range of distances.</p>

<p><a id=Random_Latitude_and_Longitude></a></p>

<h3>Random Latitude and Longitude</h3>

<p>To generate a random latitude and longitude on a sphere such that the resulting point
is (practically) uniformly distributed on the surface of a sphere&mdash;</p>

<ul>
<li>generate the longitude <code>RNDNUMEXCRANGE(-pi, pi)</code>, where the longitude ranges from -&pi; to &pi;, and</li>
<li>generate the latitude&mdash;

<ul>
<li><code>acos(RNDNUMRANGE(-1, 1)) - pi / 2</code>, where the latitude ranges from -&pi;/2 to &pi;/2 (the range includes the poles, which have many equivalent forms), or</li>
<li><code>acos(2 * RNDU01ZeroOneExc() - 1) - pi / 2</code>, where the latitude ranges from -&pi;/2 to &pi;/2 (the range excludes the poles).</li>
</ul></li>
</ul>

<p>Reference: <a href="http://mathworld.wolfram.com/SpherePointPicking.html">&quot;Sphere Point Picking&quot;</a> in MathWorld.</p>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>This page discussed many ways applications can extract random numbers
from random number generators.</p>

<p>Feel free to send comments. They may help improve this page.  In particular, corrections to any method given on this page are welcome.</p>

<p>I acknowledge the commenters to the CodeProject version of this page, including George Swan, who referred me to the reservoir sampling method.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><sup id=Note1>(1)</sup> This number format describes B-bit signed integers with minimum value -2<sup>B-1</sup> and maximum value 2<sup>B-1</sup> - 1, where B is a positive even number of bits; examples include Java&#39;s <code>short</code>, <code>int</code>, and <code>long</code>, with 16, 32, and 64 bits, respectively. A <em>signed integer</em> is an integer that can be positive, zero, or negative. In <em>two&#39; s-complement form</em>, nonnegative numbers have the highest (most significant) bit set to zero, and negative numbers have that bit (and all bits beyond) set to one, and a negative number is stored in such form by decreasing its absolute value by 1 and swapping the bits of the resulting number.</p>

<p><sup id=Note2>(2)</sup> The method that formerly appeared here is the <em>Box-Muller-transformation</em>: <code>mu + radius * cos(angle)</code> and <code>mu + radius * sin(angle)</code>, where <code>angle = 2 * pi * RNDU01OneExc()</code> and <code>radius = sqrt(-2 * ln(RNDU01ZeroExc())) * sigma</code>, are two independent normally-distributed random numbers.  A method of generating approximate standard normal random numbers, which consists of summing twelve <code>RNDU01OneExc()</code>  calls and subtracting by 6 (see also <a href="https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution">&quot;Irwin&ndash;Hall distribution&quot; on Wikipedia</a>), results in values not less than -6 or greater than 6; on the other hand, in a standard normal distribution, results less than -6 or greater than 6 will occur only with a generally negligible probability.</p>

<p><sup id=Note3>(3)</sup> The N numbers generated this way will form a point inside an N-dimensional <em>hypercube</em> with length <code>2 * R</code> in each dimension and centered at the origin of space.</p>

<p><sup id=Note4>(4)</sup> A third kind of randomized &quot;jitter&quot; (for multi-component data points) consists of a point generated from a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">multivariate normal distribution</a> with all the means equal to 0 and a <em>covariance matrix</em> that, in this context, serves as a <em>bandwidth matrix</em>. The second kind of &quot;jitter&quot; given here is an easy special case of the multivariate normal distribution, where the <em>bandwidth</em> corresponds to a bandwidth matrix with diagonal elements equal to <em>bandwidth</em>-squared and with zeros everywhere else.</p>

<p><sup id=Note5>(5)</sup> In situations where loops are not possible, such as within an SQL query, the idiom <code>min(floor(RNDU01OneExc() * maxExclusive, maxExclusive - 1))</code>, where <code>min(a,b)</code> is the smaller of <code>a</code> and <code>b</code>, returns an integer in the interval [0, <code>maxExclusive</code>); however, such an idiom can have a slight, but for most purposes negligible, bias toward <code>maxExclusive - 1</code>.</p>

<p><sup id=Note6>(6)</sup> This definition includes RNGs that&mdash;</p>

<ul>
<li>seek to generate random numbers that are at least cost-prohibitive (but not necessarily <em>impossible</em>) to predict,</li>
<li>merely seek to generate number sequences likely to pass statistical tests of randomness,</li>
<li>are initialized automatically before use,</li>
<li>are initialized with an application-specified &quot;seed&quot;,</li>
<li>use a deterministic algorithm for random number generation, and/or</li>
<li>primarily rely on one or more nondeterministic sources for random number generation.</li>
</ul>

<p>If a number generator uses a nonuniform distribution, but otherwise meets this definition, then it can be converted to one with a uniform distribution, at least in theory, by applying the nonuniform distribution&#39;s <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function"><em>cumulative distribution function</em></a> (CDF) to each generated number (see also &quot;<a href="#Generating_Random_Numbers_from_an_Arbitrary_Distribution">Generating Random Numbers from an Arbitrary Distribution</a>&quot;).  Further details on this kind of conversion, as well a list of CDFs, are outside the scope of this document.</p>

<p><sup id=Note7>(7)</sup> For an exercise solved by this method, see A. Koenig and B. E. Moo, <em>Accelerated C++</em>, 2000; see also a <a href="http://mathalope.co.uk/2014/10/26/accelerated-c-solution-to-exercise-7-9/">blog post by Johnny Chan</a>.</p>

<p><sup id=Note8>(8)</sup> <code>RNDINTEXC</code> is not given as the core random generation method because it&#39;s harder to fill integers in popular integer formats with random bits with this method.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Zero</a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
