<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generation and Sampling Methods</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generation and Sampling Methods</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>Discusses many ways applications can do random number generation and sampling from an underlying RNG and includes pseudocode for many of them.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page discusses many ways applications can generate and sample random content using an underlying random number generator (RNG), often with pseudocode. Those methods include&mdash;</p>

<ul>
<li>ways to generate uniform random numbers from an underlying RNG (such as the <a href="#Core_Random_Generation_Method"><strong>core method, <code>RNDINT(N)</code></strong></a>),</li>
<li>ways to generate randomized content and conditions, such as <a href="#Boolean_True_False_Conditions"><strong>true/false conditions</strong></a>, <a href="#Shuffling"><strong>shuffling</strong></a>, and <a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items"><strong>sampling unique items from a list</strong></a>, and</li>
<li>generating non-uniform random numbers, including <a href="#Weighted_Choice"><strong>weighted choice</strong></a>, the <a href="#Poisson_Distribution"><strong>Poisson distribution</strong></a>, and <a href="#Index_of_Non_Uniform_Distributions"><strong>other probability distributions</strong></a>.</li>
</ul>

<p><a href="https://peteroupc.github.io/randomgen.zip"><strong>Sample Python code</strong></a> that implements many of the methods in this document is available, together with <a href="https://peteroupc.github.io/randomgendoc.html"><strong>documentation for the code</strong></a>.</p>

<p>All the random number methods presented on this page are ultimately based on an underlying RNG; however, the methods make no assumptions on that RNG&#39;s implementation (e.g., whether that RNG uses only its input and its state to produce numbers) or on that RNG&#39;s statistical quality or predictability.</p>

<p><strong>In general, this document does not cover:</strong></p>

<ul>
<li>How to choose an underlying RNG for a particular application, including in terms of security, performance, and quality.  I have written more on RNG recommendations in <a href="https://peteroupc.github.io/random.html"><strong>another document</strong></a>.</li>
<li>Randomness extraction (also known as <em>unbiasing</em>, <em>deskewing</em>, or <em>whitening</em>), such as <a href="https://peteroupc.github.io/random.html#Hash_Functions"><strong>hash functions</strong></a> and von Neumann unbiasing.</li>
<li>How to generate random security parameters such as encryption keys.</li>
</ul>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/randomfunc.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomfunc.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document either on</strong> <a href="https://www.codeproject.com/Articles/1190459/Random-Number-Generation-and-Sampling-Methods"><strong>CodeProject</strong></a> <strong>or on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p><strong>Comments on any aspect of this document are welcome, but especially comments on the following:</strong></p>

<ul>
<li>Corrections to any method given on this page.</li>
<li>Should this page include additional probability distributions?  If so, which ones?</li>
<li>Ways to implement any of the randomization methods given in &quot;<a href="https://peteroupc.github.io/randomfunc.html#Randomization_with_Real_Numbers"><strong>Randomization with Real Numbers</strong></a>&quot; without rounding errors.</li>
<li>Methods to sample a random number from a distribution with arbitrary precision, in a manner that minimizes approximation error, and using only a source of random bits.</li>
</ul>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction"><strong>Introduction</strong></a>

<ul>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
</ul></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Notation_and_Definitions"><strong>Notation and Definitions</strong></a></li>
<li><a href="#Uniform_Random_Integers"><strong>Uniform Random Integers</strong></a>

<ul>
<li><a href="#RNDINT_Random_Integers_in_0_N"><code>RNDINT</code>: Random Integers in [0, N]</a></li>
<li><a href="#RNDINTRANGE_Random_Integers_in_N_M"><code>RNDINTRANGE</code>: Random Integers in [N, M]</a></li>
<li><a href="#RNDINTEXC_Random_Integers_in_0_N"><strong><code>RNDINTEXC</code>: Random Integers in [0, N)</strong></a></li>
<li><a href="#RNDINTEXCRANGE_Random_Integers_in_N_M"><strong><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</strong></a></li>
<li><a href="#Uniform_Random_Bits"><strong>Uniform Random Bits</strong></a></li>
<li><a href="#Examples_of_Using_the_RNDINT_Family"><strong>Examples of Using the <code>RNDINT</code> Family</strong></a></li>
</ul></li>
<li><a href="#Randomization_Techniques"><strong>Randomization Techniques</strong></a>

<ul>
<li><a href="#Boolean_True_False_Conditions"><strong>Boolean (True/False) Conditions</strong></a></li>
<li><a href="#Random_Sampling"><strong>Random Sampling</strong></a>

<ul>
<li><a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>Sampling With Replacement: Choosing a Random Item from a List</strong></a></li>
<li><a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items"><strong>Sampling Without Replacement: Choosing Several Unique Items</strong></a></li>
<li><a href="#Shuffling"><strong>Shuffling</strong></a></li>
<li><a href="#Random_Character_Strings"><strong>Random Character Strings</strong></a></li>
<li><a href="#Pseudocode_for_Random_Sampling"><strong>Pseudocode for Random Sampling</strong></a></li>
</ul></li>
<li><a href="#Rejection_Sampling"><strong>Rejection Sampling</strong></a></li>
<li><a href="#Random_Walks"><strong>Random Walks</strong></a></li>
<li><a href="#Random_Dates_and_Times"><strong>Random Dates and Times</strong></a></li>
<li><a href="#Randomization_in_Statistical_Testing"><strong>Randomization in Statistical Testing</strong></a></li>
<li><a href="#Markov_Chains"><strong>Markov Chains</strong></a></li>
<li><a href="#Random_Graphs"><strong>Random Graphs</strong></a></li>
<li><a href="#A_Note_on_Sorting_Random_Numbers"><strong>A Note on Sorting Random Numbers</strong></a></li>
</ul></li>
<li><a href="#General_Non_Uniform_Distributions"><strong>General Non-Uniform Distributions</strong></a>

<ul>
<li><a href="#Weighted_Choice"><strong>Weighted Choice</strong></a>

<ul>
<li><a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_Multiple_Copies"><strong>Weighted Choice Without Replacement (Multiple Copies)</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_Single_Copies"><strong>Weighted Choice Without Replacement (Single Copies)</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_List_of_Unknown_Size"><strong>Weighted Choice Without Replacement (List of Unknown Size)</strong></a></li>
<li><a href="#Priority_Sampling"><strong>Priority Sampling</strong></a></li>
</ul></li>
<li><a href="#Mixtures_of_Distributions"><strong>Mixtures of Distributions</strong></a></li>
<li><a href="#Transformations_of_Random_Numbers"><strong>Transformations of Random Numbers</strong></a></li>
</ul></li>
<li><a href="#Specific_Non_Uniform_Distributions"><strong>Specific Non-Uniform Distributions</strong></a>

<ul>
<li><a href="#Dice"><strong>Dice</strong></a></li>
<li><a href="#Binomial_Distribution"><strong>Binomial Distribution</strong></a></li>
<li><a href="#Negative_Binomial_Distribution"><strong>Negative Binomial Distribution</strong></a></li>
<li><a href="#Geometric_Distribution"><strong>Geometric Distribution</strong></a></li>
<li><a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a></li>
<li><a href="#Poisson_Distribution"><strong>Poisson Distribution</strong></a></li>
<li><a href="#Hypergeometric_Distribution"><strong>Hypergeometric Distribution</strong></a></li>
<li><a href="#Random_Integers_with_a_Given_Positive_Sum"><strong>Random Integers with a Given Positive Sum</strong></a></li>
<li><a href="#Multinomial_Distribution"><strong>Multinomial Distribution</strong></a></li>
</ul></li>
<li><a href="#Randomization_with_Real_Numbers"><strong>Randomization with Real Numbers</strong></a>

<ul>
<li><a href="#Uniform_Random_Real_Numbers"><strong>Uniform Random Real Numbers</strong></a>

<ul>
<li><a href="#For_Fixed_Point_Number_Formats"><strong>For Fixed-Point Number Formats</strong></a></li>
<li><a href="#For_Rational_Number_Formats"><strong>For Rational Number Formats</strong></a></li>
<li><a href="#For_Floating_Point_Number_Formats"><strong>For Floating-Point Number Formats</strong></a></li>
<li><a href="#Uniform_Numbers_As_Their_Digit_Expansions"><strong>Uniform Numbers As Their Digit Expansions</strong></a></li>
</ul></li>
<li><a href="#Monte_Carlo_Sampling_Expected_Values_Integration_and_Optimization"><strong>Monte Carlo Sampling: Expected Values, Integration, and Optimization</strong></a></li>
<li><a href="#Low_Discrepancy_Sequences"><strong>Low-Discrepancy Sequences</strong></a></li>
<li><a href="#Notes_on_Randomization_Involving_Real_Numbers"><strong>Notes on Randomization Involving Real Numbers</strong></a>

<ul>
<li><a href="#Probabilities_As_Their_Digit_Expansions"><strong>Probabilities As Their Digit Expansions</strong></a></li>
<li><a href="#Weighted_Choice_Involving_Real_Numbers"><strong>Weighted Choice Involving Real Numbers</strong></a></li>
<li><a href="#Random_Walks_Additional_Examples"><strong>Random Walks: Additional Examples</strong></a></li>
<li><a href="#Mixtures_Additional_Examples"><strong>Mixtures: Additional Examples</strong></a></li>
<li><a href="#Transformations_Additional_Examples"><strong>Transformations: Additional Examples</strong></a></li>
</ul></li>
<li><a href="#Random_Numbers_from_a_Distribution_of_Data_Points"><strong>Random Numbers from a Distribution of Data Points</strong></a></li>
<li><a href="#Random_Numbers_from_an_Arbitrary_Distribution"><strong>Random Numbers from an Arbitrary Distribution</strong></a>

<ul>
<li><a href="#Sampling_for_Discrete_Distributions"><strong>Sampling for Discrete Distributions</strong></a></li>
<li><a href="#Inverse_Transform_Sampling"><strong>Inverse Transform Sampling</strong></a></li>
<li><a href="#Rejection_Sampling_with_a_PDF"><strong>Rejection Sampling with a PDF</strong></a></li>
<li><a href="#Alternating_Series"><strong>Alternating Series</strong></a></li>
<li><a href="#Markov_Chain_Monte_Carlo"><strong>Markov-Chain Monte Carlo</strong></a></li>
<li><a href="#Python_Sample_Code"><strong>Python Sample Code</strong></a></li>
</ul></li>
<li><a href="#Piecewise_Linear_Distribution"><strong>Piecewise Linear Distribution</strong></a></li>
<li><a href="#Specific_Distributions"><strong>Specific Distributions</strong></a></li>
<li><a href="#Index_of_Non_Uniform_Distributions"><strong>Index of Non-Uniform Distributions</strong></a></li>
<li><a href="#Geometric_Sampling"><strong>Geometric Sampling</strong></a>

<ul>
<li><a href="#Random_Points_Inside_a_Box"><strong>Random Points Inside a Box</strong></a></li>
<li><a href="#Random_Points_Inside_a_Simplex"><strong>Random Points Inside a Simplex</strong></a></li>
<li><a href="#Random_Points_on_the_Surface_of_a_Hypersphere"><strong>Random Points on the Surface of a Hypersphere</strong></a></li>
<li><a href="#Random_Points_Inside_a_Ball_Shell_or_Cone"><strong>Random Points Inside a Ball, Shell, or Cone</strong></a></li>
<li><a href="#Random_Latitude_and_Longitude"><strong>Random Latitude and Longitude</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#Acknowledgments"><strong>Acknowledgments</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Mean_and_Variance_Calculation"><strong>Mean and Variance Calculation</strong></a></li>
<li><a href="#Norm_Calculation"><strong>Norm Calculation</strong></a></li>
<li><a href="#Multithreading_Note"><strong>Multithreading Note</strong></a></li>
<li><a href="#Implementation_Considerations"><strong>Implementation Considerations</strong></a></li>
<li><a href="#Security_Considerations"><strong>Security Considerations</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Notation_and_Definitions></a></p>

<h2>Notation and Definitions</h2>

<p>In this document, a <strong>random number generator (RNG)</strong> means software and/or hardware that seeks to generate numbers with the property that each possible outcome is as likely as any other without influence by anything else<sup><a href="#Note1"><strong>(1)</strong></a></sup>.</p>

<p>The <a href="https://peteroupc.github.io/pseudocode.html"><strong>pseudocode conventions</strong></a> apply to this document.</p>

<p>This document uses the following notation for intervals:</p>

<ul>
<li>[<code>a</code>, <code>b</code>) means &quot;<code>a</code> or greater, but less than <code>b</code>&quot;.</li>
<li>(<code>a</code>, <code>b</code>) means &quot;greater than <code>a</code>, but less than <code>b</code>&quot;.</li>
<li>(<code>a</code>, <code>b</code>] means &quot;greater than <code>a</code> and less than or equal to <code>b</code>&quot;.</li>
<li>[<code>a</code>, <code>b</code>] means &quot;<code>a</code> or greater and <code>b</code> or less&quot;.</li>
</ul>

<p>In this document:</p>

<ul>
<li><code>log1p(x)</code> is equivalent to <code>ln(1 + x)</code> and is a robust alternative where <code>x</code> is a floating-point number (Pedersen 2018)<sup><a href="#Note2"><strong>(2)</strong></a></sup>.</li>
<li><code>MakeRatio(n, d)</code> creates a rational number with the given numerator <code>n</code> and denominator <code>d</code>.</li>
<li><code>Sum(list)</code> calculates the sum of the numbers in the given list.  Note, however, that summing floating-point numbers naïvely can introduce round-off errors.  <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm"><strong>Kahan summation</strong></a> along with parallel reductions can be a more robust way than the na&iuml;ve approach to compute the sum of three or more floating-point numbers.</li>
</ul>

<p><a id=Uniform_Random_Integers></a></p>

<h2>Uniform Random Integers</h2>

<p>This section describes how an underlying RNG can be used to generate independent uniform random integers.  This section describes four methods: <code>RNDINT</code>, <code>RNDINTEXC</code>, <code>RNDINTRANGE</code>, <code>RNDINTEXCRANGE</code>.  Of these, <code>RNDINT</code>, described next, can serve as the basis for the remaining methods.</p>

<p><a id=RNDINT_Random_Integers_in_0_N></a></p>

<h3><code>RNDINT</code>: Random Integers in [0, N]</h3>

<p>In this document, <strong><code>RNDINT(maxInclusive)</code></strong> is the core method for using an underlying RNG to generate independent uniform random integers <strong>in the interval [0, <code>maxInclusive</code>]</strong>.<sup><a href="#Note3"><strong>(3)</strong></a></sup>.  The following are some ways to implement <code>RNDINT</code>:</p>

<ol>
<li><a href="#Rejection_Sampling"><strong><em>Rejection sampling</em></strong></a>, which roughly means: sample in a bigger range until a sampled number fits the smaller range.  This method is <em>unbiased</em> but has a <em>variable running time</em>.</li>
<li><p>Reduction method.  Generate <code>bignumber</code>, an N-bit random integer with many more bits than <code>maxInclusive + 1</code> has, then find&mdash;</p>

<ul>
<li><code>rem(bignumber, maxInclusive + 1)</code> (modulo reduction), or</li>
<li><code>(bignumber * (maxInclusive + 1)) &gt;&gt; N</code> (see (Lemire 2016)<sup><a href="#Note4"><strong>(4)</strong></a></sup>).</li>
</ul>

<p>Either method&#39;s running time is theoretically constant, but can introduce a so-called <em>modulo bias</em> (some numbers are slightly more likely to be chosen than others), which, however, gets smaller the more bits <code>bignumber</code> has.</p></li>
</ol>

<p>The pseudocode below implements <code>RNDINT</code> and, depending on the case, uses rejection sampling or the &quot;fast dice roller&quot; method (Lumbroso 2013)<sup><a href="#Note5"><strong>(5)</strong></a></sup>.  In the pseudocode:</p>

<table><thead>
<tr>
<th>If the underlying RNG produces:</th>
<th>Then <code>RNG()</code> is:</th>
<th>And <code>MODULUS</code> is:</th>
</tr>
</thead><tbody>
<tr>
<td>Integers in the interval [0, <em>n</em>).</td>
<td>The underlying RNG.</td>
<td><em>n</em>.</td>
</tr>
<tr>
<td>Numbers in the interval [0, 1) known to be evenly spaced by a number <em>p</em> (e.g., dSFMT).</td>
<td>The underlying RNG, except with its outputs multiplied by <em>p</em>.</td>
<td>1/<em>p</em>.</td>
</tr>
<tr>
<td>Numbers in the interval [0, 1), where numbers in [0, 0.5) and those in [0.5, 1) are known to occur with equal probability (e.g., Java&#39;s <code>Math.random()</code>).</td>
<td>An RNG that outputs 0 if the underlying RNG outputs a number less than 0.5, or 1 otherwise.</td>
<td>2.</td>
</tr>
<tr>
<td>Numbers not specified above.</td>
<td>A new RNG formed by writing the underlying RNG&#39;s outputs to a stream of memory units (such as 8-bit bytes) and using a <em>randomness extraction</em> technique to transform that stream to <em>n</em>-bit integers.</td>
<td>2<sup><em>n</em></sup>.</td>
</tr>
</tbody></table>

<pre>METHOD RndIntHelperNonPowerOfTwo(maxInclusive)
  if maxInclusive &lt;= MODULUS - 1:
    // NOTE: If the programming language implements
    // division with two integers by discarding the result&#39;s
    // fractional part, the division can be used as is without
    // using a &quot;floor&quot; function.
    nPlusOne = maxInclusive + 1
    maxexc = floor((MODULUS - 1) / nPlusOne) * nPlusOne
    while true
      ret = RNG()
      if ret &lt; nPlusOne: return ret
      if ret &lt; maxexc: return rem(ret, nPlusOne)
    end
  else
    cx = floor(maxInclusive / MODULUS) + 1
    while true
       ret = cx * RNG()
       // NOTE: The addition operation below should
       // check for integer overflow and should reject the
       // number if overflow would result.
       ret = ret + RNDINT(cx - 1)
       if ret &lt;= maxInclusive: return ret
    end
  end
END METHOD

METHOD RndIntHelperPowerOfTwo(maxInclusive)
  // NOTE: Finds the number of bits minus 1 needed
  // to represent MODULUS (in other words, the number
  // of random bits returned by RNG() ). This will
  // be a constant here, though.
  modBits = ln(MODULUS)/ln(2)
  // Fast dice roller algorithm.
  x = 1
  y = 0
  nextBit = modBits
  rngv = 0
  while true
    if nextBit &gt;= modBits
      nextBit = 0
      rngv = RNG()
    end
    x = x * 2
    y = y * 2 + rem(rngv, 2)
    rngv = floor(rngv / 2)
    nextBit = nextBit + 1
    if x &gt; maxInclusive
      if y &lt;= maxInclusive: return y
      x = x - maxInclusive - 1
      y = y - maxInclusive - 1
    end
  end
END METHOD

METHOD RNDINT(maxInclusive)
  // maxInclusive must be 0 or greater
  if maxInclusive &lt; 0: return error
  if maxInclusive == 0: return 0
  if maxInclusive == MODULUS - 1: return RNG()
  // NOTE: Finds the number of bits minus 1 needed
  // to represent MODULUS (if it&#39;s a power of 2).
  // This will be a constant here, though.  If modBits
  // is an integer, MODULUS is a power of 2, which
  // is checked below.
  modBits=ln(MODULUS)/ln(2)
  if floor(modBits) == modBits
    return RndIntHelperPowerOfTwo(maxInclusive)
  else
    return RndIntHelperNonPowerOfTwo(maxInclusive)
  end
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> Most RNG designs in common use maintain an internal state and update that state each time a random number is generated.  But for <a href="https://peteroupc.github.io/random.html#Designs_for_PRNGs"><strong><em>stateless</em> RNG designs</strong></a> (including so-called &quot;splittable&quot; RNGs), <code>RNDINT()</code>, <code>RNG()</code>, and other random sampling methods might have to be adjusted accordingly.</p>
</blockquote>

<p><a id=RNDINTRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTRANGE</code>: Random Integers in [N, M]</h3>

<p>The na&iuml;ve way of generating a <strong>random integer in the interval [<code>minInclusive</code>, <code>maxInclusive</code>]</strong>, shown below, works well for nonnegative integers and arbitrary-precision integers.</p>

<pre> METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   return minInclusive + RNDINT(maxInclusive - minInclusive)
 END METHOD
</pre>

<p>The na&iuml;ve approach won&#39;t work as well, though, if the integer format can express negative and nonnegative integers and the difference between <code>maxInclusive</code> and <code>minInclusive</code> exceeds the highest possible integer for the format.  For integer formats that can express&mdash;</p>

<ol>
<li>every integer in the interval [-1 - <code>MAXINT</code>, <code>MAXINT</code>] (e.g., Java <code>int</code>, <code>short</code>, or <code>long</code>), or</li>
<li>every integer in the interval [-<code>MAXINT</code>, <code>MAXINT</code>] (e.g., Java <code>float</code> and <code>double</code> and .NET&#39;s implementation of <code>System.Decimal</code>),</li>
</ol>

<p>where <code>MAXINT</code> is an integer greater than 0, the following pseudocode for <code>RNDINTRANGE</code> can be used.</p>

<pre>METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   if minInclusive == maxInclusive: return minInclusive
   if minInclusive==0: return RNDINT(maxInclusive)
   // Difference does not exceed maxInclusive
   if minInclusive &gt; 0 or minInclusive + MAXINT &gt;= maxInclusive
       return minInclusive + RNDINT(maxInclusive - minInclusive)
   end
   while true
     ret = RNDINT(MAXINT)
     // NOTE: For case 1, use the following line:
     if RNDINT(1) == 0: ret = -1 - ret
     // NOTE: For case 2, use the following three lines
     // instead of the preceding line; these lines
     // avoid negative zero
     // negative = RNDINT(1) == 0
     // if negative: ret = 0 - ret
     // if negative and ret == 0: continue
     if ret &gt;= minInclusive and ret &lt;= maxInclusive: return ret
   end
END METHOD
</pre>

<p><a id=RNDINTEXC_Random_Integers_in_0_N></a></p>

<h3><code>RNDINTEXC</code>: Random Integers in [0, N)</h3>

<p><code>RNDINTEXC(maxExclusive)</code>, which generates a <strong>random integer in the interval</strong> <strong>[0, <code>maxExclusive</code>)</strong>, can be implemented as follows<sup><a href="#Note6"><strong>(6)</strong></a></sup>:</p>

<pre> METHOD RNDINTEXC(maxExclusive)
    if maxExclusive &lt;= 0: return error
    return RNDINT(maxExclusive - 1)
 END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> <code>RNDINTEXC</code> is not given as the core random generation method because it&#39;s harder to fill integers in popular integer formats with random bits with this method.</p>
</blockquote>

<p><a id=RNDINTEXCRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</h3>

<p><strong><code>RNDINTEXCRANGE</code></strong> returns a <strong>random integer in the interval</strong> <strong>[<code>minInclusive</code>, <code>maxExclusive</code>)</strong>.  It can be implemented using <a href="#RNDINTRANGE_Random_Integers_in_N_M"><strong><code>RNDINTRANGE</code></strong></a>, as the following pseudocode demonstrates.</p>

<pre>METHOD RNDINTEXCRANGE(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   if minInclusive &gt;=0
     return RNDINTRANGE(minInclusive, maxExclusive - 1)
   end
   while true
     ret = RNDINTRANGE(minInclusive, maxExclusive)
     if ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<p><a id=Uniform_Random_Bits></a></p>

<h3>Uniform Random Bits</h3>

<p>The idiom <code>RNDINT((1 &lt;&lt; b) - 1)</code> is a na&iuml;ve way of generating a <strong>uniform random <code>b</code>-bit integer</strong> (with maximum 2<sup><code>b</code></sup> - 1).</p>

<p>In practice, memory is usually divided into <em>bytes</em>, or 8-bit integers in the interval [0, 255].  In this case, a block of memory can be filled with random bits&mdash;</p>

<ul>
<li>by setting each byte in the block to <code>RNDINT(255)</code>, or</li>
<li>via an RNG that outputs one or more 8-bit chunks at a time.</li>
</ul>

<p><a id=Examples_of_Using_the_RNDINT_Family></a></p>

<h3>Examples of Using the <code>RNDINT</code> Family</h3>

<ol>
<li>To generate a random number that&#39;s either -1 or 1 (a <em>Rademacher random number</em>), one of the following idioms can be used: <code>(RNDINT(1) * 2 - 1)</code> or <code>(RNDINTEXC(2) * 2 - 1)</code>.</li>
<li>To generate a random integer that&#39;s divisible by a positive integer (<code>DIV</code>), generate the integer with any method (such as <code>RNDINT</code>), let <code>X</code> be that integer, then generate <code>X - rem(X, DIV)</code> if <code>X &gt;= 0</code>, or <code>X - (DIV - rem(abs(X), DIV))</code> otherwise. (Depending on the method, the resulting integer may be out of range, in which case this procedure is to be repeated.)</li>
<li>A random 2-dimensional point on an NxM grid can be expressed as a single integer as follows:

<ul>
<li>To generate a random NxM point <code>P</code>, generate <code>P = RNDINT(N * M - 1)</code> (<code>P</code> is thus in the interval [0, <code>N * M</code>)).</li>
<li>To convert a point <code>P</code> to its 2D coordinates, generate <code>[rem(P, N), floor(P / N)]</code>. (Each coordinate starts at 0.)</li>
<li>To convert 2D coordinates <code>coord</code> to an NxM point, generate <code>P = coord[1] * N + coord[0]</code>.</li>
</ul></li>
<li>To simulate rolling an N-sided die (N greater than 1), generate a random number in the interval [1, N] by <code>RNDINTRANGE(1, N)</code>.</li>
<li>To generate a random integer with one base-10 digit, generate <code>RNDINTRANGE(0, 9)</code>.</li>
<li>To generate a random integer with N base-10 digits (where N is 2 or greater), where the first digit can&#39;t be 0, generate <code>RNDINTRANGE(pow(10, N-1), pow(10, N) - 1)</code>.</li>
<li>To generate a random number in the interval [<code>mn</code>, <code>mx</code>) in increments equal to <code>step</code>: <code>mn+step*RNDINTEXC(ceil((mx-mn)/(1.0*step)))</code>.</li>
<li>To generate a random integer in the interval [0, <code>X</code>):

<ul>
<li>And favor numbers in the middle:  <code>floor((RNDINTEXC(X) + RNDINTEXC(X)) / 2)</code>.</li>
<li>And strongly favor low numbers:  <code>floor(RNDINTEXC(X) * RNDINTEXC(X) / X)</code>.</li>
<li>And favor high numbers:  <code>max(RNDINTEXC(X), RNDINTEXC(X))</code>.</li>
<li>And strongly favor high numbers:  <code>X - 1 - floor(RNDINTEXC(X) * RNDINTEXC(X) / X)</code> or <code>max(RNDINTEXC(X), RNDINTEXC(X), RNDINTEXC(X))</code>.</li>
</ul></li>
</ol>

<p><a id=Randomization_Techniques></a></p>

<h2>Randomization Techniques</h2>

<p>This section describes commonly used randomization techniques, such as shuffling, selection of several unique items, and creating random strings of text.</p>

<p><a id=Boolean_True_False_Conditions></a></p>

<h3>Boolean (True/False) Conditions</h3>

<p>To generate a condition that is true at the specified probabilities, use
the following idioms in an <code>if</code> condition:</p>

<ul>
<li>True or false with equal probability: <code>RNDINT(1) == 0</code>.</li>
<li>True with X percent probability: <code>RNDINTEXC(100) &lt; X</code>.</li>
<li>True with probability X/Y (a <em>Bernoulli trial</em>): <code>RNDINTEXC(Y) &lt; X</code>.</li>
<li>True with odds of X to Y: <code>RNDINTEXC(X + Y) &lt; X</code>.</li>
</ul>

<blockquote>
<p><strong>Examples:</strong></p>

<ul>
<li>True with probability 3/8: <code>RNDINTEXC(8) &lt; 3</code>.</li>
<li>True with odds of 100 to 1: <code>RNDINTEXC(101) &lt; 1</code>.</li>
<li>True with 20% probability: <code>RNDINTEXC(100) &lt; 20</code>.</li>
</ul>
</blockquote>

<p>The following helper method generates 1 with probability <code>x</code>/<code>y</code> and 0 otherwise:</p>

<pre>METHOD ZeroOrOne(x,y)
  if RNDINTEXC(y)&lt;x: return 1
  return 0
END METHOD
</pre>

<p>The method can also be implemented in the following way (as pointed out by Lumbroso (2013, Appendix B)<sup><a href="#Note5"><strong>(5)</strong></a></sup>):</p>

<pre>// NOTE: Modified from Lumbroso
// Appendix B to add &#39;z==0&#39; and error checks
METHOD ZeroOrOne(x,y)
  if y &lt;= 0: return error
  if x==y: return 1
  z = x
  while true
    z = z * 2
    if z &gt;= y
      if RNDINT(1) == 0: return 1
      z = z - y
    else if z == 0 or RNDINT(1) == 0: return 0
  end
END METHOD
</pre>

<p>The following method generates 1 with probability <code>exp(-x/y)</code> and 0 otherwise (Canonne et al., 2020)<sup><a href="#Note7"><strong>(7)</strong></a></sup>:</p>

<pre>METHOD ZeroOrOneExpMinus(x, y)
  if y &lt;= 0 or x&lt;0: return error
  if x &gt; y
    xf = floor(x/y)
    x = mod(x, y)
    if x&gt;0 and ZeroOrOneExpMinus(x, y) == 0: return 0
    for i in 1..xf
      if ZeroOrOneExpMinus(1,1) == 0: return 0
    end
    return 1
  end
  r = 1
  oy = y
  while true
    if ZeroOrOne(x, y) == 0: return r
    if r==1: r=0
    else: r=1
    y = y + oy
  end
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> An algorithm that transforms &quot;coin flips&quot; biased one way into coin flips biased another way is called a <em>Bernoulli factory</em> (Keane and O&#39;Brien 1994)<sup><a href="#Note8"><strong>(8)</strong></a></sup> (Flajolet et al., 2010)<sup><a href="#Note9"><strong>(9)</strong></a></sup>.  The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> includes implementations of several Bernoulli factories.</p>

<p><strong>Example</strong>: The following pseudocode generates a random integer in [0, <code>y</code>), or -1 instead if that number would be less than <code>x</code>, using fewer random bits than the naïve approach: <code>if ZeroOrOne(x, y) == 1: return -1; else: return RNDINTEXCRANGE(x, y)</code>.</p>
</blockquote>

<p><a id=Random_Sampling></a></p>

<h3>Random Sampling</h3>

<p>This section contains ways to choose one or more items from among a collection of them, where each item in the collection has the same chance to be chosen as any other.  This is called <em>random sampling</em> and can be done <em>with replacement</em> or <em>without replacement</em>.</p>

<p><a id=Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List></a></p>

<h4>Sampling With Replacement: Choosing a Random Item from a List</h4>

<p><em>Sampling with replacement</em>  essentially means taking a random item and putting it back.  To choose a random item from a list&mdash;</p>

<ul>
<li>whose size is known in advance, use the idiom <code>list[RNDINTEXC(size(list))]</code>; or</li>
<li>whose size is not known in advance, generate <code>RandomKItemsFromFile(file, 1)</code>, in <a href="#Pseudocode_for_Random_Sampling"><strong>pseudocode given later</strong></a> (the result will be a 1-item list or be an empty list if there are no items).</li>
</ul>

<p><a id=Sampling_Without_Replacement_Choosing_Several_Unique_Items></a></p>

<h4>Sampling Without Replacement: Choosing Several Unique Items</h4>

<p><em>Sampling without replacement</em>  essentially means taking a random item <em>without</em> putting it back.   There are several approaches for doing a uniform random choice of <code>k</code> unique items or values from among <code>n</code> available items or values, depending on such things as whether <code>n</code> is known and how big <code>n</code> and <code>k</code> are.</p>

<ol>
<li><strong>If <code>n</code> is not known in advance:</strong> Use the <em>reservoir sampling</em> method; see the <code>RandomKItemsFromFile</code> method, in <a href="#Pseudocode_for_Random_Sampling"><strong>pseudocode given later</strong></a>.</li>
<li><strong>If <code>n</code> is relatively small (for example, if there are 200 available items, or there is a range of numbers from 0 through 200 to choose from):</strong>

<ul>
<li>If items have to be chosen from a list <strong>in relative order</strong>, or if <code>n</code> is 1, then use <code>RandomKItemsInOrder</code> (given later).</li>
<li>Otherwise, if the order of the sampled items is unimportant, and each item can be derived from its <em>index</em> (the item&#39;s position as an integer starting at 0) without looking it up in a list: Use the <code>RandomKItemsFromFile</code> method.</li>
<li>Otherwise, the first three cases below will choose <code>k</code> items in random order:

<ul>
<li>Store all the items in a list, <a href="#Shuffling"><strong>shuffle</strong></a> that list, then choose the first <code>k</code> items from that list.</li>
<li>If the items are already stored in a list and the list&#39;s order can be changed, then shuffle that list and choose the first <code>k</code> items from the shuffled list.</li>
<li>If the items are already stored in a list and the list&#39;s order can&#39;t be changed, then store the indices to those items in another list, shuffle the latter list, then choose the first <code>k</code> indices (or the items corresponding to those indices) from the latter list.</li>
<li>If <code>k</code> is much smaller than <code>n</code>, proceed as in item 3 instead.</li>
</ul></li>
</ul></li>
<li><strong>If <code>k</code> is much smaller than <code>n</code>:</strong>  The first three cases below will choose <code>k</code> items in random order:

<ul>
<li><strong>If the items are stored in a list whose order can be changed:</strong> Do a <em>partial shuffle</em> of that list, then choose the <em>last</em> <code>k</code> items from that list.  A <em>partial shuffle</em> proceeds as given in the section &quot;<a href="#Shuffling"><strong>Shuffling</strong></a>&quot;, except the partial shuffle stops after <code>k</code> swaps have been made (where swapping one item with itself counts as a swap).</li>
<li>Otherwise, <strong>if the items are stored in a list and <code>n</code> is not very large (for example, less than 5000):</strong> Store the indices to those items in another list, do a <em>partial shuffle</em> of the latter list, then choose the <em>last</em> <code>k</code> indices (or the items corresponding to those indices) from the latter list.</li>
<li>Otherwise, <strong>if <code>n</code> is not very large:</strong> Store all the items in a list, do a <em>partial shuffle</em> of that list, then choose the <em>last</em> <code>k</code> items from that list.</li>
<li>Otherwise, see item 5.</li>
</ul></li>
<li><strong>If <code>n - k</code> is much smaller than <code>n</code> and the order of the sampled items is unimportant:</strong>  Proceed as in item 3, except the partial shuffle involves <code>n - k</code> swaps and the <em>first</em> <code>k</code> items are chosen rather than the last <code>k</code>.</li>
<li><p><strong>Otherwise (for example, if 32-bit or larger integers will be chosen so that <code>n</code> is 2<sup>32</sup>, or if <code>n</code> is otherwise very large):</strong> Create a data structure to store the indices to items already chosen.  When a new index to an item is randomly chosen, add it to the data structure if it&#39;s not already there, or if it is, choose a new random index.  Repeat this process until <code>k</code> indices were added to the data structure this way.  Examples of suitable data structures are&mdash;</p>

<ul>
<li>a <a href="https://en.wikipedia.org/wiki/Hash_table"><strong>hash table</strong></a>,</li>
<li>a compressed bit set (e.g, &quot;roaring bitmap&quot;, EWAH), and</li>
<li>a self-sorting data structure such as a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"><strong>red&ndash;black tree</strong></a>, if the random items are to be retrieved in sorted order or in index order.</li>
</ul>

<p>Many applications require generating unique random numbers to identify database records or other shared resources, among other reasons.  For ways to generate such numbers, see my <a href="https://peteroupc.github.io/random.html#Unique_Random_Identifiers"><strong>RNG recommendation document</strong></a>.</p></li>
</ol>

<p><a id=Shuffling></a></p>

<h4>Shuffling</h4>

<p>The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle"><strong>Fisher&ndash;Yates shuffle method</strong></a> shuffles a list (puts its items in a random order) such that all permutations (arrangements) of that list are equally likely to occur, assuming the RNG it uses can choose any one of those permutations.  However, that method is also easy to write incorrectly &mdash; see also (Atwood 2007)<sup><a href="#Note10"><strong>(10)</strong></a></sup>.  The following pseudocode is designed to shuffle a list&#39;s contents.</p>

<pre>METHOD Shuffle(list)
   // NOTE: Check size of the list early to prevent
   // `i` from being less than 0 if the list&#39;s size is 0 and
   // `i` is implemented using an nonnegative integer
   // type available in certain programming languages.
   if size(list) &gt;= 2
      // Set i to the last item&#39;s index
      i = size(list) - 1
      while i &gt; 0
         // Choose an item ranging from the first item
         // up to the item given in `i`. Note that the item
         // at i+1 is excluded.
         k = RNDINTEXC(i + 1)
         // The following is wrong since it introduces biases:
         // &quot;k = RNDINTEXC(size(list))&quot;
         // The following is wrong since the algorithm won&#39;t
         // choose from among all possible permutations:
         // &quot;k = RNDINTEXC(i)&quot;
         // Swap item at index i with item at index k;
         // in this case, i and k may be the same
         tmp = list[i]
         list[i] = list[k]
         list[k] = tmp
         // Move i so it points to the previous item
         i = i - 1
      end
   end
   // NOTE: An implementation can return the
   // shuffled list, as is done here, but this is not required.
   return list
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>The choice of underlying RNG is important when it comes to shuffling; see my <a href="https://peteroupc.github.io/random.html#Shuffling"><strong>RNG recommendation document on shuffling</strong></a>.</li>
<li>A shuffling algorithm that can be carried out in parallel is described in (Bacher et al., 2015)<sup><a href="#Note11"><strong>(11)</strong></a></sup>.</li>
</ol>
</blockquote>

<p><a id=Random_Character_Strings></a></p>

<h4>Random Character Strings</h4>

<p>To generate a random string of characters:</p>

<ol>
<li>Generate a list of the letters, digits, and/or other characters the string can have.  Examples are given later in this section.</li>
<li>Build a new string whose characters are chosen at random from that character list.  The method, shown in the pseudocode below, demonstrates this. The method samples characters at random with replacement, and returns a list of the sampled characters. (How to convert this list to a text string depends on the programming language and is outside the scope of this page.) The method takes two parameters: <code>characterList</code> is the list from step 1, and <code>stringSize</code> is the number of random characters.</li>
</ol>

<p>&nbsp;</p>

<pre>METHOD RandomString(characterList, stringSize)
  i = 0
  newString = NewList()
  while i &lt; stringSize
    // Choose a character from the list
    randomChar = characterList[RNDINTEXC(size(characterList))]
    // Add the character to the string
    AddItem(newString, randomChar)
    i = i + 1
  end
  return newString
END METHOD
</pre>

<p>The following are examples of character lists:</p>

<ol>
<li>For an <em>alphanumeric string</em>, or string of letters and digits, the characters can be the basic digits &quot;0&quot; to &quot;9&quot; (U+0030-U+0039, nos. 48-57), the basic upper case letters &quot;A&quot; to &quot;Z&quot; (U+0041-U+005A, nos. 65-90), and the basic lower case letters &quot;a&quot; to &quot;z&quot; (U+0061-U+007A, nos. 96-122), as given in the Unicode Standard.</li>
<li>For a base-10 digit string, the characters can be the basic digits only.</li>
<li>For a base-16 digit (hexadecimal) string, the characters can be the basic digits as well as the basic letters &quot;A&quot; to &quot;F&quot; or &quot;a&quot; to &quot;f&quot; (not both).</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>If the list of characters is fixed, the list can be created in advance at runtime or compile time, or (if every character takes up the same number of code units) a string type as provided in the programming language can be used to store the list as a string.</li>
<li><strong>Unique random strings:</strong> Often applications need to generate a string of characters that&#39;s not only random, but also unique.  This can be done by storing a list (such as a hash table) of strings already generated and checking newly generated strings against that list.<sup><a href="#Note12"><strong>(12)</strong></a></sup></li>
<li><strong>Word generation:</strong> This technique could also be used to generate &quot;pronounceable&quot; words, but this is less flexible than other approaches; see also &quot;<a href="#Markov_Chains"><strong>Markov Chains</strong></a>&quot;.</li>
</ol>
</blockquote>

<p><a id=Pseudocode_for_Random_Sampling></a></p>

<h4>Pseudocode for Random Sampling</h4>

<p>The following pseudocode implements two methods:</p>

<ol>
<li><code>RandomKItemsFromFile</code> implements <a href="https://en.wikipedia.org/wiki/Reservoir_sampling"><strong><em>reservoir sampling</em></strong></a>; it chooses up to <code>k</code> random items from a file of indefinite size (<code>file</code>). Although the pseudocode refers to files and lines, the technique applies to any situation when items are retrieved one at a time from a data set or list whose size is not known in advance.  See the comments to find out how <code>RandomKItemsFromFile</code> can be used to choose an item at random only if it meets certain criteria (see &quot;<a href="#Rejection_Sampling"><strong>Rejection Sampling</strong></a>&quot; for example criteria).</li>
<li><code>RandomKItemsInOrder</code> returns a list of up to <code>k</code> random items from the given list (<code>list</code>), in the order in which they appeared in the list.  It is based on a technique presented in (Devroye 1986)<sup><a href="#Note13"><strong>(13)</strong></a></sup>, p. 620.</li>
</ol>

<p>&nbsp;</p>

<pre>METHOD RandomKItemsFromFile(file, k)
  list = NewList()
  j = 0
  index = 0
  while true
    // Get the next line from the file
    item = GetNextLine(file)
    thisIndex = index
    index = index + 1
    // If the end of the file was reached, break
    if item == nothing: break
    // NOTE 1: The following line is OPTIONAL
    // and can be used to choose only random lines
    // in the file that meet certain criteria,
    // expressed as MEETS_CRITERIA below.
    // ------
    // if not MEETS_CRITERIA(item): continue
    // ------
    if j &lt; k // phase 1 (fewer than k items)
      AddItem(list, item)
      // NOTE 2: To add the line number (starting at
      // 0) rather than the item, use the following
      // line instead of the previous one:
      // AddItem(list, thisIndex)
      j = j + 1
    else // phase 2
      j = RNDINT(thisIndex)
      if j &lt; k: list[j] = item
      // NOTE 3: To add the line number (starting at
      // 0) rather than the item, use the following
      // line instead of the previous one:
      // if j &lt; k: list[j] = thisIndex
    end
  end
  // NOTE 4: We shuffle at the end in case k or
  // fewer lines were in the file, since in that
  // case the items would appear in the same
  // order as they appeared in the file
  // if the list weren&#39;t shuffled.  This line
  // can be removed, however, if the order of
  // the items in the list is unimportant.
  if size(list)&gt;=2: Shuffle(list)
  return list
end

METHOD RandomKItemsInOrder(list, k)
  n = size(list)
  // Special case if k is 1
  if k==1: return [list[RNDINTEXC(n)]]
  i = 0
  kk = k
  ret = NewList()
  while i &lt; n and size(ret) &lt; k
    u = RNDINTEXC(n - i)
    if u &lt;= kk
      AddItem(ret, list[i])
      kk = kk - 1
    end
    i = i + 1
  end
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>Assume a file (<code>file</code>) has the lines <code>&quot;f&quot;</code>, <code>&quot;o&quot;</code>, <code>&quot;o&quot;</code>, <code>&quot;d&quot;</code>, in that order.  If we modify <code>RandomKItemsFromFile</code> as given in notes 2 and 3 there, and treat <code>MEETS_CRITERIA(item)</code> above as <code>item == &quot;o&quot;</code> (in note 1 of that method), then we can choose a random line number of an &quot;o&quot; line by <code>RandomKItemsFromFile(file, 1)</code>.</li>
<li>Removing <code>k</code> random items from a list of <code>n</code> items (<code>list</code>) is equivalent to generating a new
list by <code>RandomKItemsInOrder(list, n - k)</code>.</li>
<li><strong>Filtering:</strong> If an application needs to sample the same list (with or without replacement) repeatedly, but only from among a selection of that list&#39;s items, it can create a list of items it wants to sample from (or a list of indices to those items), and sample from the new list instead.<sup><a href="#Note14"><strong>(14)</strong></a></sup>  This won&#39;t work well, though, for lists of indefinite or very large size.</li>
</ol>
</blockquote>

<p><a id=Rejection_Sampling></a></p>

<h3>Rejection Sampling</h3>

<p><em>Rejection sampling</em> is a simple and flexible approach for generating random content that meets certain requirements.  To implement rejection sampling:</p>

<ol>
<li>Generate the random content (such as a random number) by any method and with any distribution and range.</li>
<li>If the content doesn&#39;t meet predetermined criteria, go to step 1.</li>
</ol>

<p>Example criteria include checking&mdash;</p>

<ul>
<li>whether a random number is not less than a minimum threshold (<em>left-truncation</em>),</li>
<li>whether a random number is not greater than a maximum threshold (<em>right-truncation</em>),</li>
<li>whether a random number is prime,</li>
<li>whether a random number is divisible or not by certain numbers,</li>
<li>whether a random number is not among recently chosen random numbers,</li>
<li>whether a random number was not already chosen (with the aid of a hash table, red-black tree, or similar structure),</li>
<li>whether a random number was not chosen more often in a row than desired,</li>
<li>whether a random point is sufficiently distant from previous random points (with the aid of a KD-tree or similar structure),</li>
<li>whether a random string matches a regular expression,</li>
<li>whether a random number is not included in a &quot;blacklist&quot; of numbers, or</li>
<li>two or more of the foregoing criteria.</li>
</ul>

<p>(KD-trees, hash tables, red-black trees, prime-number testing algorithms, and regular expressions are outside the scope of this document.)</p>

<blockquote>
<p><strong>Note:</strong> All rejection sampling strategies have a chance to reject data, so they all have a <em>variable running time</em> (in fact, they could run indefinitely).  Note that graphics processing units (GPUs) and other devices that run multiple tasks at once work better if all the tasks finish their work at the same time.  This is not possible if they all generate a random number via rejection sampling because of its variable running time.  If each iteration of the rejection sampler has a low rejection rate, one solution is to have each task run one iteration of the sampler, with its own RNG, then to take the first random number that hasn&#39;t been rejected this way by a task (which can fail at a very low rate).<sup><a href="#Note15"><strong>(15)</strong></a></sup></p>
</blockquote>

<p><a id=Random_Walks></a></p>

<h3>Random Walks</h3>

<p>A <em>random walk</em> is a process with random behavior over time.  A simple form of random walk involves generating a random number that changes the state of the walk.  The pseudocode below generates a random walk of <em>n</em> random numbers, where <code>STATEJUMP()</code> is the next number to add to the current state (see examples later in this section).</p>

<pre>METHOD RandomWalk(n)
  // Create a new list with an initial state
  list=[0]
  // Add &#39;n&#39; new numbers to the list.
  for i in 0...n: AddItem(list, list[i] + STATEJUMP())
  return list
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> A <strong>white noise process</strong> is simulated by creating a list of independent random numbers generated in the same way.  Such a process generally models behavior over time that does not depend on the time or the current state.  One example is <code>ZeroOrOne(px,py)</code> (for modeling a <em>Bernoulli process</em>, where each number is 0 or 1 depending on the probability <code>px</code>/<code>py</code>).</p>

<p><strong>Examples:</strong></p>

<ol>
<li>If <code>STATEJUMP()</code> is <code>RNDINT(1) * 2 - 1</code>, the random walk generates numbers that each differ from the last by -1 or 1, chosen at random.</li>
<li>If <code>STATEJUMP()</code> is <code>ZeroOrOne(px,py) * 2 - 1</code>, the random walk generates numbers that each differ from the last by -1 or 1 depending on the probability <code>px</code>/<code>py</code>.</li>
<li><strong>Binomial process:</strong> If <code>STATEJUMP()</code> is <code>ZeroOrOne(px,py)</code>, the random walk advances the state with probability <code>px</code>/<code>py</code>.</li>
</ol>
</blockquote>

<p><a id=Random_Dates_and_Times></a></p>

<h3>Random Dates and Times</h3>

<p>Pseudocode like the following can be used to choose a <strong>random date-and-time</strong> bounded by two dates-and-times (<code>date1</code>, <code>date2</code>).  In the following pseudocode, <code>DATETIME_TO_NUMBER</code> and <code>NUMBER_TO_DATETIME</code> convert a date-and-time to or from a number, respectively, at the required granularity, for instance, month, day, or hour granularity (the details of such conversion depend on the date-and-time format and are outside the scope of this document).</p>

<pre>     dtnum1 = DATETIME_TO_NUMBER(date1)
     dtnum2 = DATETIME_TO_NUMBER(date2)
     // Choose a random date-and-time
     // in [dtnum1, dtnum2].  Any other
     // random selection strategy can be
     // used here instead.
     num = RNDINTRANGE(date1, date2)
     result = NUMBER_TO_DATETIME(num)
</pre>

<p><a id=Randomization_in_Statistical_Testing></a></p>

<h3>Randomization in Statistical Testing</h3>

<p>Statistical testing uses shuffling and <em>bootstrapping</em> to help draw conclusions on data through randomization.</p>

<ul>
<li><a href="#Shuffling"><strong>Shuffling</strong></a> is used when each item in a data set belongs to one of several mutually exclusive groups.  Here, one or more <strong>simulated data sets</strong> are generated by shuffling the original data set and regrouping each item in the shuffled data set in order, such that the number of items in each group for the simulated data set is the same as for the original data set.</li>
<li><a href="https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29"><strong><em>Bootstrapping</em></strong></a> is a method of creating one or more random samples (simulated data sets) of an existing data set, where the items in each sample are chosen <a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>at random with replacement</strong></a>.  (Each random sample can contain duplicates this way.)  See also (Brownlee 2018)<sup><a href="#Note16"><strong>(16)</strong></a></sup>.</li>
</ul>

<p>After creating the simulated data sets, one or more statistics, such as the mean, are calculated for each simulated data set as well as the original data set, then the statistics for the simulated data sets are compared with those of the original (such comparisons are outside the scope of this document).</p>

<p><a id=Markov_Chains></a></p>

<h3>Markov Chains</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Markov_chain"><strong>Markov chain</strong></a> models one or more <em>states</em> (for example, individual letters or syllables), and stores the probabilities to transition from one state to another (e.g., &quot;b&quot; to &quot;e&quot; with a chance of 20 percent, or &quot;b&quot; to &quot;b&quot; with a chance of 1 percent).  Thus, each state can be seen as having its own list of <em>weights</em> for each relevant state transition (see &quot;<a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a>).  For example, a Markov chain for generating <strong>&quot;pronounceable&quot; words</strong>, or words similar to natural-language words, can include &quot;start&quot; and &quot;stop&quot; states for the start and end of the word, respectively.</p>

<p>An algorithm called <em>coupling from the past</em> (Propp and Wilson 1996)<sup><a href="#Note17"><strong>(17)</strong></a></sup> can sample a state from a Markov chain&#39;s <em>stationary distribution</em>, that is, the chain&#39;s steady state, by starting multiple chains at different states and running them until they all reach the same state at the same time.  The following pseudocode implements coupling from the past.  In the method, <code>StateCount</code> is the number of states in the Markov chain, <code>UPDATE(chain, state, random)</code> transitions the Markov chain to the next state given the current state and random numbers, and <code>RANDOM()</code> generates one or more random numbers needed by <code>UPDATE</code>.</p>

<pre>METHOD CFTP(chain)
   states=[]
   // Start multiple chains at different states.  NOTE:
   // If the chain is monotonic (meaning the states
   // are ordered and, whenever state A is less
   // than state B, A&#39;s next state is never higher than
   // B&#39;s next state), then just two chains can be
   // created instead, starting
   // at the first and last state, respectively.
   numstates=StateCount(chain)
   for i in 0...numstates: AddItem(states, i)
   done=false
   while not done
      // Update each chain with the same randomness
      r=RANDOM()
      for i in 0...numstates: states[i]=UPDATE(chain, states[i], r)
      // Stop when all states are the same
      fs=states[0]
      done=true
      for i in 1...numstates: done=done and states[i]==fs
   end
   return states[0] // Return the steady state
END METHOD
</pre>

<p><a id=Random_Graphs></a></p>

<h3>Random Graphs</h3>

<p>A <em>graph</em> is a listing of points and the connections between them.  The points are called <em>vertices</em> and the connections, <em>edges</em>.</p>

<p>A convenient way to represent a graph is an <em>adjacency matrix</em>.  This is an <em>n</em>&times;<em>n</em> matrix with <em>n</em> rows and <em>n</em> columns (signifying <em>n</em> vertices in the graph).  For simple graphs, an adjacency matrix contains only 1s and 0s &mdash; for the cell at row <em>r</em> and column <em>c</em>, a 1 means there is an edge pointing from vertex <em>r</em> to vertex <em>c</em>, and a 0 means there are none.</p>

<p>In this section, <code>Zeros(n)</code> creates an <code>n</code>&times;<code>n</code> zero matrix (such as a list consisting of <code>n</code> lists, each of which contains <code>n</code> zeros).</p>

<p>The following method generates a random <code>n</code>-vertex graph that follows the model G(<em>n</em>, <em>p</em>) (also known as the <em>Gilbert model</em> (Gilbert 1959)<sup><a href="#Note18"><strong>(18)</strong></a></sup>), where each edge is drawn with probability <code>px</code>/<code>py</code> (Batagelj and Brandes 2005)<sup><a href="#Note19"><strong>(19)</strong></a></sup>.</p>

<pre>METHOD GNPGraph(n, px, py)
    graph=Zeros(n)
    for i in 2...n
       j = i
       while j &gt; 0
          j = j - 1 - min(NegativeBinomialInt(1, px, py), j - 1)
          if j &gt; 0
             // Build an edge
             graph[i][j]=1
             graph[j][i]=1
          end
       end
    end
    return graph
END METHOD
</pre>

<p>Other kinds of graphs are possible, including <em>Erdős&ndash;Rényi graphs</em> (choose <em>n</em> random edges without replacement), Chung&ndash;Lu graphs, preferential attachment graphs, and more.  For example, a <em>mesh graph</em> is a graph in the form of a rectangular mesh, where vertices are the corners and edges are the sides of the mesh&#39;s rectangles.  A random <em>maze</em> is a random spanning tree of a mesh graph.  Penschuck et al. (2020)<sup><a href="#Note20"><strong>(20)</strong></a></sup> give a survey of random graph generation techniques.</p>

<p><a id=A_Note_on_Sorting_Random_Numbers></a></p>

<h3>A Note on Sorting Random Numbers</h3>

<p>In general, sorting random numbers is no different from sorting any other data. (Sorting algorithms are outside this document&#39;s scope.) <sup><a href="#Note21"><strong>(21)</strong></a></sup></p>

<p><a id=General_Non_Uniform_Distributions></a></p>

<h2>General Non-Uniform Distributions</h2>

<p>Some applications need to choose random items or numbers such that some of them are more likely to be chosen than others (a <em>non-uniform</em> distribution). Most of the techniques in this section show how to use the <a href="#Uniform_Random_Integers"><strong>uniform random number methods</strong></a> to generate such random items or numbers.</p>

<p><a id=Weighted_Choice></a></p>

<h3>Weighted Choice</h3>

<p>The weighted choice method generates a random item or number from among a collection of them with separate probabilities of each item or number being chosen.  There are several kinds of weighted choice.</p>

<p><a id=Weighted_Choice_With_Replacement></a></p>

<h4>Weighted Choice With Replacement</h4>

<p>The first kind is called weighted choice <em>with replacement</em> (which can be thought of as drawing a ball, then putting it back) or a <em>categorical distribution</em>, where the probability of choosing each item doesn&#39;t change as items are chosen.  In the following pseudocode:</p>

<ul>
<li><code>WeightedChoice</code> takes a single list <code>weights</code> of weights (integers 0 or greater) and returns the index of a weight from that list.  The greater the weight, the more likely its index will be chosen.</li>
<li><code>CumulativeWeightedChoice</code> takes a single list <code>weights</code> of N <em>cumulative weights</em>; they start at 0 and the next weight is not less than the previous.  Returns a number in the interval [0, N - 1).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD CWChoose(weights, value)
    // Choose the index according to the given value
    for i in 0...size(weights) - 1
       // Choose only if difference is positive
       if weights[i] &lt; weights[i+1] and
           weights[i]&gt;=value: return i
    end
    return 0
END METHOD

METHOD WChoose(weights, value)
    // Choose the index according to the given value
    lastItem = size(weights) - 1
    runningValue = 0
    for i in 0...size(weights) - 1
       if weights[i] &gt; 0
          newValue = runningValue + weights[i]
          lastItem = i
          // NOTE: Includes start, excludes end
          if value &lt; newValue: break
          runningValue = newValue
       end
    end
    // If we didn&#39;t break above, this is a last
    // resort (might happen because rounding
    // error happened somehow)
    return lastItem
END METHOD

METHOD WeightedChoice(weights)
    return WChoose(RNDINTEXC(Sum(weights)))
END METHOD

METHOD CumulativeWeightedChoice(weights)
    if size(weights)==0 or weights[0]!=0: return error
    // Weights is a list of cumulative weights. Chooses
    // a random number in [0, size(weights) - 1).
    sum = weights[size(weights) - 1]
    return CWChoose(RNDINTEXC(sum))
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains a variant of this method for generating multiple random points in one call, and uses Vose&#39;s <em>alias method</em> (described in &quot;<a href="https://www.keithschwarz.com/darts-dice-coins/"><strong>Darts, Dice, and Coins: Sampling from a Discrete Distribution</strong></a>&quot;) in certain cases.</p>

<p><strong>Examples:</strong></p>

<ol>
<li>Assume we have the following list: <code>[&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;grapes&quot;]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  The weight for &quot;apples&quot; is 3, and the weight for &quot;oranges&quot; is 15.  Since &quot;oranges&quot; has a higher weight than &quot;apples&quot;, the index for &quot;oranges&quot; (1) is more likely to be chosen than the index for &quot;apples&quot; (0) with the <code>WeightedChoice</code> method.  The following idiom implements how to get a randomly chosen item from the list with that method: <code>item = list[WeightedChoice(weights)]</code>.</li>
<li>Example 1 can be implemented with <code>CumulativeWeightedChoice</code> instead of <code>WeightedChoice</code> if <code>weights</code> is the following list of cumulative weights: <code>[0, 3, 18, 19, 21]</code>.</li>
<li><strong>Piecewise constant distribution.</strong> Assume the weights from example 1 are used and the list contains the following: <code>[0, 5, 10, 11, 13]</code> (one more item than the weights).  This expresses four intervals: [0, 5), [5, 10), and so on.  After a random index is chosen with <code>index = WeightedChoice(weights)</code>, an independent uniform random number in the chosen interval is chosen.  For example, code like the following chooses a random integer this way: <code>number = RNDINTEXCRANGE(list[index], list[index + 1])</code>.</li>
</ol>
</blockquote>

<p><a id=Weighted_Choice_Without_Replacement_Multiple_Copies></a></p>

<h4>Weighted Choice Without Replacement (Multiple Copies)</h4>

<p>To implement weighted choice <em>without replacement</em> (which can be thought of as drawing a ball <em>without</em> putting it back) when each weight is an integer 0 or greater, generate an index by <code>WeightedChoice</code>, and then decrease the weight for the chosen index by 1.  In this way, <strong>each weight behaves like the number of &quot;copies&quot; of each item</strong>. The pseudocode below is an example of this.</p>

<pre>// Get the sum of weights.
// NOTE: This code assumes--
// - that `weights` is a list that can be modified,
// - that all the weights are integers 0 or greater, and
// - that `list`, a list of items, was already
//   declared earlier and has at least as many
//   items as `weights`.
// If the original weights are needed for something
// else, a copy of that list should be made first,
// but the copying process is not shown here.
totalWeight = Sum(weights)
// Choose as many items as the sum of weights
i = 0
items = NewList()
while i &lt; totalWeight
    index = WeightedChoice(weights)
    // Decrease weight by 1 to implement selection
    // without replacement.
    weights[index] = weights[index] - 1
    AddItem(items, list[index])
    i = i + 1
end
</pre>

<p>Alternatively, if all the weights are integers 0 or greater and their sum is relatively small, create a list with as many copies of each item as its weight, then <a href="#Shuffling"><strong>shuffle</strong></a> that list.  The resulting list will be ordered in a way that corresponds to a weighted random choice without replacement.</p>

<blockquote>
<p><strong>Note:</strong> The weighted sampling described in this section can be useful to some applications (particularly some games) that wish to control which random numbers appear, to make the random outcomes appear fairer to users (e.g., to avoid long streaks of good outcomes or of bad outcomes).  When used for this purpose, each item represents a different outcome (e.g., &quot;good&quot; or &quot;bad&quot;), and the lists are replenished once no further items can be chosen.  However, this kind of sampling should not be used for this purpose whenever information security (ISO/IEC 27000) is involved, including when predicting future random numbers would give a player or user a significant and unfair advantage.</p>
</blockquote>

<p><a id=Weighted_Choice_Without_Replacement_Single_Copies></a></p>

<h4>Weighted Choice Without Replacement (Single Copies)</h4>

<p>The following are ways to implement weighted choice without replacement, where each item <strong>can be chosen no more than once</strong> at random (or alternatively, where higher-weighted items are more likely to appear first):</p>

<ul>
<li>Use <code>WeightedChoice</code> to choose random indices.  Each time an index is chosen, set the weight for the chosen index to 0 to keep it from being chosen again.</li>
<li>Assign each index a random exponential number (with a rate equal to that index&#39;s weight), make a list of pairs assigning each number to an index, then sort that list by those numbers.  Example: <code>v=[]; for i in 0...size(weights): AddItem(v, [ExpoRatio(100000000, weights[i], 1), i]); Sort(v)</code>.  The sorted list of indices will then correspond to a weighted choice without replacement.  See &quot;<a href="https://timvieira.github.io/blog/post/2019/09/16/algorithms-for-sampling-without-replacement/"><strong>Algorithms for sampling without replacement</strong></a>&quot;.</li>
</ul>

<p><a id=Weighted_Choice_Without_Replacement_List_of_Unknown_Size></a></p>

<h4>Weighted Choice Without Replacement (List of Unknown Size)</h4>

<p>If the number of items in a list is not known in advance, then the following pseudocode implements a <code>RandomKItemsFromFileWeighted</code> that selects up to <code>k</code> random items from a file (<code>file</code>) of indefinite size (similarly to <a href="#Pseudocode_for_Random_Sampling"><strong><code>RandomKItemsFromFile</code></strong></a>).  See (Efraimidis and Spirakis 2005)<sup><a href="#Note22"><strong>(22)</strong></a></sup>, and see also (Efraimidis 2015)<sup><a href="#Note23"><strong>(23)</strong></a></sup>, (Vieira 2014)<sup><a href="#Note24"><strong>(24)</strong></a></sup>, and (Vieira 2019)<sup><a href="#Note25"><strong>(25)</strong></a></sup>.  In the pseudocode below:</p>

<ul>
<li><code>WEIGHT_OF_ITEM(item, thisIndex)</code> is a placeholder for arbitrary code that calculates the integer weight of an individual item based on its value and its index (starting at 0); the item is ignored if its weight is 0 or less.</li>
<li><code>ITEM_OUTPUT(item, thisIndex, key)</code> is a placeholder for code that returns the item to store in the list; this can include the item&#39;s value, its index starting at 0, the item&#39;s key, or any combination of these.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD RandomKItemsFromFileWeighted(file, k)
  queue=[] // Initialize priority queue
  index = 0
  while true
    // Get the next line from the file
    item = GetNextLine(file)
    thisIndex = index
    index = index + 1
    // If the end of the file was reached, break
    if item == nothing: break
    weight = WEIGHT_OF_ITEM(item, thisIndex)
    // Ignore if item&#39;s weight is 0 or less
    if weight &lt;= 0: continue
    // NOTE: Equivalent to Expo(weight), except
    // it uses ratios
    key = ExpoRatio(100000000, weight, 1)
    itemToStore = ITEM_OUTPUT(item, thisIndex, key)
    // Begin priority queue add operation.  Instead
    // of the item (&#39;item&#39;), the line number starting at one
    // (&#39;thisIndex&#39;) can be added to the queue.
    if size(queue) &lt; k // Fewer than k items
      AddItem(queue, [key, itemToStore])
      Sort(queue)
    else // phase 2
      // Check whether this key is smaller
      // than the largest key in the queue
      if key &lt; queue[size(queue)-1][0]
          // Replace item with largest key
          queue[size(queue)-1]=[key, itemToStore]
          Sort(queue)
      end
    end
    // End priority queue add operation
  end
  list=[]
  for v in 0...size(queue): AddItem(list, queue[v][1])
  // Optional shuffling here.
  // See NOTE 4 in RandomKItemsFromFile code.
  if size(list)&gt;=2: Shuffle(list)
  return list
end
</pre>

<blockquote>
<p><strong>Note:</strong> Weighted choice <em>with replacement</em> can be implemented by doing one or more concurrent runs of <code>RandomKItemsFromFileWeighted(file, 1)</code> (making sure each run traverses <code>file</code> the same way for multiple runs as for a single run) (Efraimidis 2015)<sup><a href="#Note23"><strong>(23)</strong></a></sup>.</p>
</blockquote>

<p><a id=Priority_Sampling></a></p>

<h4>Priority Sampling</h4>

<p><em>Priority sampling</em> (Duffield et al., 2007)<sup><a href="#Note26"><strong>(26)</strong></a></sup> samples from a weighted stream of items in a way that allows the total weight of some or all the items to be estimated simply by adding their weight estimates.  The pseudocode below generates weight estimates for <code>m</code> sampled items; all other items have weight estimates of 0. See also &quot;<a href="https://timvieira.github.io/blog/post/2017/07/03/estimating-means-in-a-finite-universe/"><strong>Estimating means in a finite universe</strong></a>&quot;, which shows how priority sampling can help estimate the mean of a function over a limited but high number of data points via the weighted sum of that function&#39;s value at the sampled data points.</p>

<pre>METHOD PrioritySample(file, m)
   // Uses RandomKItemsFromFileWeighted modified
   // as follows:  Keys are generated by
   // `MakeRatio(-weight, RNDINTRANGE(1, 1000000000))`
   // and `ITEM_OUTPUT(a, b, key)` is `[a, b, -key]`.
   items=RandomKItemsFromFileWeighted(file, m+1)
   threshold=items[m][2] // Get the (m+1)th highest key
   ret=[]
   for i in 0...m: AddItem(ret,
      [max(items[i][0], threshold), items[i][1]])
   // Returns, for each item, the weight estimate and its
   // index starting at 0
   return ret
END METHOD
</pre>

<p><a id=Mixtures_of_Distributions></a></p>

<h3>Mixtures of Distributions</h3>

<p>A <em>mixture</em> consists of two or more probability distributions with separate probabilities of being sampled. To generate random content from a mixture&mdash;</p>

<ol>
<li>generate <code>index = WeightedChoice(weights)</code>, where <code>weights</code> is a list of relative probabilities that each distribution in the mixture will be sampled, then</li>
<li>based on the value of <code>index</code>, generate the random content from the corresponding distribution.</li>
</ol>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li><p>One mixture consists of the sum of three six-sided virtual die rolls and the result of one six-sided die roll, but there is an 80% chance to roll one six-sided virtual die rather than three.  The following pseudocode shows how this mixture can be sampled:</p>

<pre>index = WeightedChoice([80, 20])
number = 0
// If index 0 was chosen, roll one die
if index==0: number = RNDINTRANGE(1,6)
// Else index 1 was chosen, so roll three dice
else: number = RNDINTRANGE(1,6) +
   RNDINTRANGE(1,6) + RNDINTRANGE(1,6)
</pre></li>
<li><p>Choosing an independent uniform random point, from a complex shape (in any number of dimensions) is equivalent to doing such sampling from a mixture of simpler shapes that make up the complex shape (here, the <code>weights</code> list holds the n-dimensional &quot;volume&quot; of each simpler shape).  For example, a simple closed 2D polygon can be <a href="https://en.wikipedia.org/wiki/Polygon_triangulation"><strong><em>triangulated</em></strong></a>, or decomposed into <a href="#Random_Points_Inside_a_Simplex"><strong>triangles</strong></a>, and a mixture of those triangles can be sampled.<sup><a href="#Note27"><strong>(27)</strong></a></sup></p></li>
<li>Take a set of nonoverlapping integer ranges.  To choose an independent uniform random integer from those ranges:

<ul>
<li>Create a list (<code>weights</code>) of weights for each range.  Each range is given a weight of <code>(mx - mn) + 1</code>, where <code>mn</code> is that range&#39;s minimum and <code>mx</code> is its maximum.</li>
<li>Choose an index using <code>WeightedChoice(weights)</code>, then generate <code>RNDINTRANGE(mn, mx)</code>, where <code>mn</code> is the corresponding range&#39;s minimum and <code>mx</code> is its maximum.</li>
</ul></li>
<li>In the pseudocode <code>index = WeightedChoice([80, 20]); list = [[0, 5], [5, 10]]; number = RNDINTEXCRANGE(list[index][0], list[index][1])</code>, a random integer in [0, 5) is chosen at an 80% chance, and a random integer in [5, 10) at a 20% chance.</li>
<li><p>A <strong>hyperexponential distribution</strong> is a mixture of <a href="#Exponential_Distribution"><strong>exponential distributions</strong></a>, each one with a separate weight and separate rate parameter.  An example is below.</p>

<pre> index = WeightedChoice([0.6, 0.3, 0.1])
 // Rates of the three exponential distributions, as ratios
 rates = [[3, 10], [5, 10], [1, 100]]
 // Generate an exponential random number
 // with chosen rate, as a ratio
 number = ExpoRatio(100000, rates[i][0], rates[i][1])
</pre></li>
</ol>
</blockquote>

<p><a id=Transformations_of_Random_Numbers></a></p>

<h3>Transformations of Random Numbers</h3>

<p>Random numbers can be generated by combining and/or transforming one or more random numbers and/or discarding some of them.</p>

<p>As an example, <a href="http://www.redblobgames.com/articles/probability/damage-rolls.html"><strong>&quot;Probability and Games: Damage Rolls&quot;</strong></a> by Red Blob Games includes interactive graphics showing score distributions for lowest-of, highest-of, drop-the-lowest, and reroll game mechanics.<sup><a href="#Note28"><strong>(28)</strong></a></sup>  These and similar distributions can be generalized as follows.</p>

<p>Generate one or more random numbers, each with a separate probability distribution, then:</p>

<ol>
<li><strong>Highest-of:</strong>  Choose the highest generated number.</li>
<li><strong>Drop-the-lowest:</strong>  Add all generated numbers except the lowest.</li>
<li><strong>Reroll-the-lowest:</strong>  Add all generated numbers except the lowest, then add a number generated randomly by a separate probability distribution.</li>
<li><strong>Lowest-of:</strong>  Choose the lowest generated number.</li>
<li><strong>Drop-the-highest:</strong>  Add all generated numbers except the highest.</li>
<li><strong>Reroll-the-highest:</strong>  Add all generated numbers except the highest, then add a number generated randomly by a separate probability distribution.</li>
<li><strong>Sum:</strong> Add all generated numbers.</li>
<li><strong>Mean:</strong> Find the mean of all generated numbers.</li>
<li><strong>Geometric transformation:</strong> Treat the numbers as an <em>n</em>-dimensional point, then apply a geometric transformation, such as a rotation or other <em>affine transformation</em><sup><a href="#Note29"><strong>(29)</strong></a></sup>, to that point.</li>
</ol>

<p>If the probability distributions are the same, then strategies 1 to 3 make higher numbers more likely, and strategies 4 to 6, lower numbers.</p>

<blockquote>
<p><strong>Note:</strong> Variants of strategy 4 &mdash; e.g., choosing the second-, third-, or nth-lowest number &mdash; are formally called second-, third-, or nth-<strong>order statistics distributions</strong>, respectively.</p>

<p><strong>Examples:</strong></p>

<ol>
<li>The idiom <code>min(RNDINTRANGE(1, 6), RNDINTRANGE(1, 6))</code> takes the lowest of two six-sided die results (strategy 4).  Due to this approach, 1 is more likely to occur than 6.</li>
<li>The idiom <code>RNDINTRANGE(1, 6) + RNDINTRANGE(1, 6)</code> takes the result of two six-sided dice (see also &quot;<a href="#Dice"><strong>Dice</strong></a>&quot;) (strategy 7).</li>
<li>A <strong>binomial distribution</strong> models the sum of <code>n</code> random numbers each generated by <code>ZeroOrOne(px,py)</code> (strategy 7) (see &quot;<a href="#Binomial_Distribution"><strong>Binomial Distribution</strong></a>&quot;).</li>
<li>A <strong>hypoexponential distribution</strong> models the sum
of <em>n</em> random numbers that follow an exponential distribution and each have a separate rate parameter (see &quot;<a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a>&quot;).</li>
<li><p><strong>Clamped random numbers.</strong>  These are one example of transformed random numbers.  To generate a clamped random number, generate a random number as usual, then&mdash;</p>

<ul>
<li>if that number is less than a minimum threshold, use the minimum threshold instead (<em>left-censoring</em>), and/or</li>
<li>if that number is greater than a maximum threshold, use the maximum threshold instead (<em>right-censoring</em>).</li>
</ul>

<p>An example of a clamped random number is <code>min(200, RNDINT(255))</code>.</p></li>
<li>A <strong>compound Poisson distribution</strong> models the sum of <em>n</em> random numbers each generated the same way, where <em>n</em> follows a <a href="#Poisson_Distribution"><strong>Poisson distribution</strong></a> (e.g., <code>n = PoissonInt(10, 1)</code> for an average of 10 numbers) (strategy 7, sum).</li>
<li>A <strong>P&oacute;lya&ndash;Aeppli distribution</strong> is a compound Poisson distribution in which the random numbers are generated by <code>NegativeBinomial(1, 1-p)+1</code> for a fixed <code>p</code>.</li>
</ol>
</blockquote>

<p><a id=Specific_Non_Uniform_Distributions></a></p>

<h2>Specific Non-Uniform Distributions</h2>

<p>This section contains information on some of the most common non-uniform probability distributions.</p>

<p><a id=Dice></a></p>

<h3>Dice</h3>

<p>The following method generates a random result of rolling virtual dice. It takes three parameters: the number of dice (<code>dice</code>), the number of sides in each die (<code>sides</code>), and a number to add to the result (<code>bonus</code>) (which can be negative, but the result of the method is 0 if that result is greater).  See also Red Blob Games, <a href="http://www.redblobgames.com/articles/probability/damage-rolls.html"><strong>&quot;Probability and Games: Damage Rolls&quot;</strong></a>.</p>

<pre>METHOD DiceRoll(dice, sides, bonus)
    if dice &lt; 0 or sides &lt; 1: return error
    ret = 0
    for i in 0...dice: ret=ret+RNDINTRANGE(1, sides)
    return max(0, ret + bonus)
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong> The result of rolling&mdash;</p>

<ul>
<li>four six-sided virtual dice (&quot;4d6&quot;) is <code>DiceRoll(4,6,0)</code>,</li>
<li>three ten-sided virtual dice, with 4 added (&quot;3d10 + 4&quot;), is <code>DiceRoll(3,10,4)</code>, and</li>
<li>two six-sided virtual dice, with 2 subtracted (&quot;2d6 - 2&quot;), is <code>DiceRoll(2,6,-2)</code>.</li>
</ul>
</blockquote>

<p><a id=Binomial_Distribution></a></p>

<h3>Binomial Distribution</h3>

<p>The <em>binomial distribution</em> uses two parameters: <code>trials</code> and <code>p</code>.  This distribution models the number of successes in a fixed number of independent trials (equal to <code>trials</code>), each with the same probability of success (equal to <code>p</code>, where <code>p &lt;= 0</code> means never, <code>p &gt;= 1</code> means always, and <code>p = 1/2</code> means an equal chance of success or failure).</p>

<p>This distribution has a simple implementation: <code>count = 0; for i in 0...trials: count=count+ZeroOrOne(px, py)</code>.  But for large numbers of trials, this can be very slow.</p>

<p>The pseudocode below implements an exact sampler of this distribution, with certain optimizations based on (Farach-Colton and Tsai 2015)<sup><a href="#Note30"><strong>(30)</strong></a></sup>.  Here, the parameter <code>p</code> is expressed as a ratio <code>px</code>/<code>py</code>.</p>

<p>&nbsp;</p>

<pre>METHOD BinomialInt(trials, px, py)
  if trials &lt; 0: return error
  if trials == 0: return 0
  // Always succeeds
  if mx: return trials
  // Always fails
  if p &lt;= 0.0: return 0
  count = 0
  ret = 0
  recursed = false
  if py*2 == px // Is half
    if i &gt; 200
      // Divide and conquer
      half = floor(trials / 2)
      return BinomialInt(half, 1, 2) + BinomialInt(trials - half, 1, 2)
    else
      if mod(trials,2)==1
        count=count+RNDINT(1)
        trials=trials-1
      end
      // NOTE: This step can be made faster
      // by precalculating an alias table
      // based on a list of n + 1 binomial(0.5)
      // weights, which consist of n-choose-i
      // for all i in [0, n], and sampling based on
      // that table (see Farach-Colton and Tsai).
      for i in 0...trials: count=count+RNDINT(1)
    end
  else
    // Based on proof of Theorem 2 in Farach-Colton and Tsai.
    // Decompose px/py into its binary expansion.
    pw = MakeRatio(px, py)
    pt = MakeRatio(1, 2)
    while trials&gt;0 and pw&gt;0
      c=BinomialInt(trials, 1, 2)
      if pw&gt;=pt
        count=count+c
        trials=trials-c
        pw=pw-pt
      else
        trials=c
      end
      pt=pt/2 // NOTE: Not rounded
    end
  end
  if recursed: return count+ret
  return count
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> If <code>px</code>/<code>py</code> is <code>1</code>/<code>2</code>, the binomial distribution models the task &quot;Flip N coins, then count the number of heads&quot;, and the random sum is known as <a href="https://en.wikipedia.org/wiki/Hamming_distance"><strong><em>Hamming distance</em></strong></a> (treating each trial as a &quot;bit&quot; that&#39;s set to 1 for a success and 0 for a failure).  If <code>px</code> is <code>1</code>, then this distribution models the task &quot;Roll <code>n</code> <code>py</code>-sided dice, then count the number of dice that show the number 1.&quot;</p>
</blockquote>

<p><a id=Negative_Binomial_Distribution></a></p>

<h3>Negative Binomial Distribution</h3>

<p>The <em>negative binomial distribution</em> (<em>Pólya distribution</em>) models the number of failing trials that happen before a fixed number of successful trials (<code>successes</code>). Each trial is independent and has a success probability of <code>px/py</code> (where 0 means never and 1 means always).</p>

<pre>METHOD NegativeBinomialInt(successes, px, py)
    // Needs to be 0 or greater; px must not be 0
    if successes &lt; 0 or px == 0: return error
    if successes == 0 or px &gt;= py: return 0
    total = 0
    count = 0
    while total &lt; successes
        if ZeroOrOne(px, py) == 1: total = total + 1
        else: count = count + 1
    end
    return count
END METHOD
</pre>

<p><a id=Geometric_Distribution></a></p>

<h3>Geometric Distribution</h3>

<p>The geometric distribution is a negative binomial distribution with <code>successes = 1</code>.  Here, the sampled number is the number of failures that have happened before one success happens. (This is the definition used in <em>Mathematica</em>, for example.  Saucier 2000, p. 44, also mentions an alternative definition that includes the success, and this alternative definition is used, for example, in (Devroye 1986, p. 498)<sup><a href="#Note13"><strong>(13)</strong></a></sup>.)  For example, if <code>p</code> is 1/2, the geometric distribution models the task &quot;Flip a coin until you get tails, then count the number of heads.&quot;  As a unique property of the geometric distribution, the number of trials that have already failed in a row says nothing about the number of new trials that will fail in a row.</p>

<p><a id=Exponential_Distribution></a></p>

<h3>Exponential Distribution</h3>

<p>The <em>exponential distribution</em> uses a parameter known as &lambda;, the rate, or the inverse scale.  Usually, &lambda; is the probability that an independent event of a given kind will occur in a given span of time (such as in a given day or year), and the random result is the number of spans of time until that event happens.  Usually, &lambda; is equal to 1, or 1/1.  1/&lambda; is the scale (mean), which is usually the average waiting time between two independent events of the same kind.</p>

<p>In this document, <code>Expo(lamda)</code> is an exponentially-distributed random number with the rate <code>lamda</code>.</p>

<p>In the pseudocode below, <code>ExpoRatio</code> generates an exponential random number (in the form of a ratio) given the rate <code>rx</code>/<code>ry</code> (or scale <code>ry</code>/<code>rx</code>) and the base <code>base</code>.  <code>ExpoNumerator</code> generates the numerator of an exponential random number with rate 1 given that number&#39;s denominator.  The algorithm is due to von Neumann (1951)<sup><a href="#Note31"><strong>(31)</strong></a></sup>.</p>

<pre>METHOD ExpoRatio(base, rx, ry)
    // Generates a numerator and denominator of
    // an exponential random number with rate rx/ry.
    return MakeRatio(ExpoNumerator(base*ry), base*rx))
END METHOD

METHOD ExpoNumerator(denom)
   if denom&lt;=0: return error
   count=0
   while true
      y1=RNDINTEXC(denom)
      y=y1
      accept=true
      while true
         z=RNDINTEXC(denom)
         if y&lt;=z: break
         accept=not accept
         y=z
      end
      if accept: count=count+y1
      else: count=count+denom
      if accept: break
   end
   return count
END METHOD
</pre>

<p><a id=Poisson_Distribution></a></p>

<h3>Poisson Distribution</h3>

<p>The <em>Poisson distribution</em> uses a parameter <code>mean</code> (also known as &lambda;). &lambda; is the average number of independent events of a certain kind per fixed unit of time or space (for example, per day, hour, or square kilometer).  A Poisson-distributed number is the number of such events within one such unit.</p>

<p>In this document, <code>Poisson(mean)</code> is a Poisson-distributed number if <code>mean</code> is greater than 0, or 0 if <code>mean</code> is 0.</p>

<p>The following method generates a Poisson random number with mean <code>mx</code>/<code>my</code>, using the approach suggested by (Flajolet et al., 2010)<sup><a href="#Note9"><strong>(9)</strong></a></sup>.  In the method, <code>UniformNew()</code> creates a <em>u-rand</em>, an &quot;empty&quot; random number in [0, 1], whose bits are not yet determined (Karney 2014)<sup><a href="#Note32"><strong>(32)</strong></a></sup>, and <code>UniformLess(a, b)</code> returns whether one <em>u-rand</em> (<code>a</code>) is less than another (<code>b</code>), building up the bits of both as necessary.  For a less exact algorithm, replace <code>UniformNew()</code> with <code>RNDINT(1000)</code> and <code>UniformLess(a, b)</code> with <code>a &lt; b</code>.</p>

<pre>METHOD PoissonInt(mx, my)
    if my == 0: return error
    if mx == 0: return 0
    if (mx &lt; 0 and my &lt; 0) or (mx &gt; 0 and my &lt; 0): return 0
    if mx==my: return PoissonInt(1,2)+PoissonInt(1,2)
    if mx &gt; my
       // Mean is 1 or greater
       mm=mod(mx, my)
       if mm == 0
          mf=floor(mx/my)
          ret=0
          if mod(mf, 2)==0: ret=ret+PoissonInt(1, 1)
          if mod(mf, 2)==0: mf=mf-1
          ret=ret+PoissonInt(mf/2, 1)+PoissonInt(mf/2, 1)
          return ret
       else: return PoissonInt(mm, my)+
           PoissonInt(mx-mm, my)
    end
    while true
      // Generate n, a geometric random number
      // (NOTE: Flajolet et al. define a geometric
      // distribution as number of SUCCESSES BEFORE
      // FAILURE, not counting the failure, so we
      // have to complement the probability here)
      n = NegativeBinomialInt(1, my - mx, my)
      // If n uniform random numbers turn out
      // to be sorted, accept n
      if n&lt;=1: return n
      u = UniformNew()
      success = true
      i=1
      while i&lt;n and success
         u2 = UniformNew()
         if UniformLess(u, u2): u = u2
         else: success=false // Not sorted
         i=i+1
      end
      if success: return n
    end
    return count
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> To generate a sum of <code>n</code> independent Poisson random numbers with separate means, generate a Poisson random number whose mean is the sum of those means (see (Devroye 1986)<sup><a href="#Note13"><strong>(13)</strong></a></sup>, p. 501).  For example, to generate a sum of 1000 independent Poisson random numbers with a mean of 1/1000000, simply generate <code>PoissonInt(1, 1000)</code> (because 1/1000000 * 1000 = 1/1000).</p>
</blockquote>

<p><a id=Hypergeometric_Distribution></a></p>

<h3>Hypergeometric Distribution</h3>

<p>The following method generates a random integer that follows a <em>hypergeometric distribution</em>.  When a given number of items are drawn at random without replacement from a collection of items each labeled either <code>1</code> or <code>0</code>,  the random integer expresses the number of items drawn this way that are labeled <code>1</code>.  In the method below, <code>trials</code> is the number of items drawn at random, <code>ones</code> is the number of items labeled <code>1</code> in the set, and <code>count</code> is the number of items labeled <code>1</code> or <code>0</code> in that set.</p>

<pre>METHOD Hypergeometric(trials, ones, count)
    if ones &lt; 0 or count &lt; 0 or trials &lt; 0 or
       ones &gt; count or trials &gt; count
      return error
    end
    if ones == 0: return 0
    successes = 0
    i = 0
    currentCount = count
    currentOnes = ones
    while i &lt; trials and currentOnes &gt; 0
      if ZeroOrOne(currentOnes, currentCount) == 1
        currentOnes = currentOnes - 1
        successes = successes + 1
      end
      currentCount = currentCount - 1
      i = i + 1
    end
    return successes
END METHOD
</pre>

<blockquote>
<p><strong>Example:</strong> In a 52-card deck of Anglo-American playing cards, 12 of the cards are face cards (jacks, queens, or kings).  After the deck is shuffled and seven cards are drawn, the number of face cards drawn this way follows a hypergeometric distribution where <code>trials</code> is 7, <code>ones</code> is 12, and <code>count</code> is 52.</p>
</blockquote>

<p><a id=Random_Integers_with_a_Given_Positive_Sum></a></p>

<h3>Random Integers with a Given Positive Sum</h3>

<p>The following pseudocode shows how to generate <code>n</code> uniform random integers greater than 0 with a given positive sum, in random order. (The algorithm for this was presented in (Smith and Tromble 2004)<sup><a href="#Note33"><strong>(33)</strong></a></sup>.)  In the pseudocode below&mdash;</p>

<ul>
<li>the method <code>PositiveIntegersWithSum</code> returns <code>n</code> integers greater than 0 that sum to <code>total</code>, in random order,</li>
<li>the method <code>IntegersWithSum</code> returns <code>n</code> integers 0 or greater that sum to <code>total</code>, in random order, and</li>
<li><code>Sort(list)</code> sorts the items in <code>list</code> in ascending order (note that sort algorithms are outside the scope of this document).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD PositiveIntegersWithSum(n, total)
    if n &lt;= 0 or total &lt;=0: return error
    ls = [0]
    ret = NewList()
    while size(ls) &lt; n
      c = RNDINTEXCRANGE(1, total)
      found = false
      for j in 1...size(ls)
        if ls[j] == c
          found = true
          break
        end
      end
      if found == false: AddItem(ls, c)
    end
    Sort(ls)
    AddItem(ls, total)
    for i in 1...size(ls): AddItem(ret,
        ls[i] - ls[i - 1])
    return ret
END METHOD

METHOD IntegersWithSum(n, total)
  if n &lt;= 0 or total &lt;=0: return error
  ret = PositiveIntegersWithSum(n, total + n)
  for i in 0...size(ret): ret[i] = ret[i] - 1
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>To generate <code>N</code> uniform random numbers with a given positive average <code>avg</code>, in random order, generate <code>IntegersWithSum(N, N * avg)</code> (or its equivalent for real numbers).</li>
<li>To generate <code>N</code> uniform random numbers <code>min</code> or greater and with a given positive sum <code>sum</code>, in random order, generate <code>IntegersWithSum(N, sum - N * min)</code> (or its equivalent for real numbers), then add <code>min</code> to each number generated this way.  The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> implements an efficient way to generate such integers if each one can&#39;t exceed a given maximum; the algorithm is thanks to a <em>Stack Overflow</em> answer (<code>questions/61393463</code>) by John McClane.</li>
</ol>
</blockquote>

<p><a id=Multinomial_Distribution></a></p>

<h3>Multinomial Distribution</h3>

<p>The <em>multinomial distribution</em> uses two parameters: <code>trials</code> and <code>weights</code>.  It models the number of times each of several mutually exclusive events happens among a given number of trials (<code>trials</code>), where each event can have a separate probability of happening (given as a list of <code>weights</code>).</p>

<p>A trivial implementation is to fill a list with as many zeros as <code>weights</code>, then for each trial, choose <code>index = WeightedChoice(weights)</code> and add 1 to the item in the list at the chosen <code>index</code>.  The resulting list follows a multinomial distribution.  The pseudocode below shows an optimization suggested in (Durfee et al., 2018, Corollary 45)<sup><a href="#Note34"><strong>(34)</strong></a></sup>, but assumes all weights are integers.</p>

<pre>METHOD Multinomial(trials, weights)
    if trials &lt; 0: return error
    // create a list of successes
    list = []
    ratios = []
    sum=Sum(weights)
    for i in 0...size(weights): AddItem(ratios,
           MakeRatio(weights[i], sum))
    end
    for i in 0...size(weights)
        r=ratios[i]
        b=BinomialInt(t,r[0],r[1])
        AddItem(list, b)
        trials=trials-b
        if trials&gt;0: for j in range(i+1,
            len(weights)): ratios[j]=ratios[j]/(1-r)
    end
    return list
END METHOD
</pre>

<p><a id=Randomization_with_Real_Numbers></a></p>

<h2>Randomization with Real Numbers</h2>

<p>This section describes randomization methods that use random real numbers, not just random integers.</p>

<p>However, whenever possible, <strong>applications should work with random integers</strong>, rather than other random real numbers.  This is because:</p>

<ul>
<li>Computers can represent integers more naturally than other real numbers, making random integer generation algorithms more portable and more numerically stable than random real number generation algorithms.<sup><a href="#Note35"><strong>(35)</strong></a></sup></li>
<li>No computer can choose from among all real numbers between two others, since there are infinitely many of them.</li>
<li>For applications that may care about reproducible &quot;random&quot; numbers (unit tests, simulations, machine learning, and so on), using non-integer numbers can complicate the task of making a method reproducible from run to run or across computers.</li>
</ul>

<p>The methods in this section should not be used to generate random numbers for information security purposes, even with a secure random number generator.  See &quot;Security Considerations&quot; in the appendix.</p>

<p><a id=Uniform_Random_Real_Numbers></a></p>

<h3>Uniform Random Real Numbers</h3>

<p>This section defines the following methods that generate independent uniform random real numbers:</p>

<ul>
<li><code>RNDU01</code>: Interval [0, 1].</li>
<li><code>RNDU01OneExc</code>: Interval &#x5b;0, 1).<sup><a href="#Note36"><strong>(36)</strong></a></sup></li>
<li><code>RNDU01ZeroExc</code>: Interval (0, 1].</li>
<li><code>RNDU01ZeroOneExc</code>: Interval (0, 1).</li>
<li><code>RNDRANGE</code>: Interval [a, b].</li>
<li><code>RNDRANGEMaxExc</code>: Interval [a, b).</li>
<li><code>RNDRANGEMinExc</code>: Interval (a, b].</li>
<li><code>RNDRANGEMinMaxExc</code>: Interval (a, b).</li>
</ul>

<p><a id=For_Fixed_Point_Number_Formats></a></p>

<h4>For Fixed-Point Number Formats</h4>

<p>For fixed-point number formats representing multiples of 1/<code>n</code>, these eight methods are trivial.  The following implementations return integers that represent fixed-point numbers.</p>

<p><code>RNDU01</code> family:</p>

<ul>
<li><code>RNDU01()</code>: <code>RNDINT(n)</code>.</li>
<li><code>RNDU01ZeroExc()</code>: <code>(RNDINT(n - 1) + 1)</code> or <code>(RNDINTEXC(n) + 1)</code>.</li>
<li><code>RNDU01OneExc()</code>: <code>RNDINTEXC(n)</code> or <code>RNDINT(n - 1)</code>.</li>
<li><code>RNDU01ZeroOneExc()</code>: <code>(RNDINT(n - 2) + 1)</code> or <code>(RNDINTEXC(n - 1) + 1)</code>.</li>
</ul>

<p><code>RNDRANGE</code> family.  In each method below, <code>fpa</code> and <code>fpb</code> are the bounds of the random number generated and are integers that represent fixed-point numbers (such that <code>fpa = a * n</code> and <code>fpb = b * n</code>).  For example, if <code>n</code> is 100, to generate a number in [6.35, 9.96], generate <code>RNDRANGE(6.35, 9.96)</code> or <code>RNDINTRANGE(635, 996)</code>.</p>

<ul>
<li><code>RNDRANGE(a, b)</code>: <code>RNDINTRANGE(fpa, fpb)</code>.</li>
<li><code>RNDRANGEMinExc(a, b)</code>: <code>RNDINTRANGE(fpa + 1, fpb)</code>, or an error if <code>fpa &gt;= fpb</code>.</li>
<li><code>RNDRANGEMaxExc(a, b)</code>: <code>RNDINTEXCRANGE(fpa, fpb)</code>.</li>
<li><code>RNDRANGEMinMaxExc(a, b)</code>: <code>RNDINTRANGE(fpa + 1, fpb - 1)</code>, or an error if <code>fpa &gt;= fpb or a == fpb - 1</code>.</li>
</ul>

<p><a id=For_Rational_Number_Formats></a></p>

<h4>For Rational Number Formats</h4>

<p>For rational number formats with a fixed denominator, the eight methods can be implemented in the numerator as given in the previous section for fixed-point formats.</p>

<p><a id=For_Floating_Point_Number_Formats></a></p>

<h4>For Floating-Point Number Formats</h4>

<p>For floating-point number formats representing numbers of the form <code>FPSign</code> * <code>s</code> * <code>FPRADIX</code><sup><code>e</code></sup> <sup><a href="#Note37"><strong>(37)</strong></a></sup>, the following pseudocode implements <code>RNDRANGE(lo, hi)</code>.  In the pseudocode:</p>

<ul>
<li><code>MINEXP</code> is the lowest exponent a number can have in the floating-point format.  For the IEEE 754 binary64 format (Java <code>double</code>), <code>MINEXP = -1074</code>.  For the IEEE 754 binary32 format (Java <code>float</code>), <code>MINEXP = -149</code>.</li>
<li><code>FPPRECISION</code> is the number of significant digits in the floating-point format, whether the format stores them as such or not. Equals 53 for binary64, or 24 for binary32.</li>
<li><code>FPRADIX</code> is the digit base of the floating-point format.  Equals 2 for binary64 and binary32.</li>
<li><code>FPExponent(x)</code> returns the value of <code>e</code> for the number <code>x</code> such that the number of digits in <code>s</code> equals <code>FPPRECISION</code>.  Returns <code>MINEXP</code> if <code>x = 0</code> or if <code>e</code> would be less than <code>MINEXP</code>.</li>
<li><code>FPSignificand(x)</code> returns <code>s</code>, the significand of the number <code>x</code>.  Returns 0 if <code>x = 0</code>. Has <code>FPPRECISION</code> digits unless <code>FPExponent(x) == MINEXP</code>.</li>
<li><code>FPSign(x)</code> returns either -1 or 1 indicating whether the number is positive or negative.  Can be -1 even if <code>s</code> is 0.</li>
</ul>

<p>See also (Downey 2007)<sup><a href="#Note38"><strong>(38)</strong></a></sup> and the <a href="https://gitlab.com/christoph-conrads/rademacher-fpl"><strong>Rademacher Floating-Point Library</strong></a>.</p>

<pre>METHOD RNDRANGE(lo, hi)
  losgn = FPSign(lo)
  hisgn = FPSign(hi)
  loexp = FPExponent(lo)
  hiexp = FPExponent(hi)
  losig = FPSignificand(lo)
  hisig = FPSignificand(hi)
  if lo &gt; hi: return error
  if losgn == 1 and hisgn == -1: return error
  if losgn == -1 and hisgn == 1
    // Straddles negative and positive ranges
    // NOTE: Changes negative zero to positive
    mabs = max(abs(lo),abs(hi))
    while true
       ret=RNDRANGE(0, mabs)
       neg=rand(2)
       if neg==0: ret=-ret
       if ret&gt;=lo and ret&lt;=hi: return ret
    end
  end
  if lo == hi: return lo
  if losgn == -1
    // Negative range
    return -RNDRANGE(abs(lo), abs(hi))
  end
  // Positive range
  expdiff=hiexp-loexp
  if loexp==hiexp
    // Exponents are the same
    // NOTE: Automatically handles
    // subnormals
    s=RNDINTRANGE(losig, hisig)
    return s*1.0*pow(FPRADIX, loexp)
  end
  while true
    ex=hiexp
    while ex&gt;MINEXP
      v=RNDINTEXC(FPRADIX)
      if v==0: ex=ex-1
      else: break
    end
    s=0
    if ex==MINEXP
      // Has FPPRECISION or fewer digits
      // and so can be normal or subnormal
      s=RNDINTEXC(pow(FPRADIX,FPPRECISION))
    else if FPRADIX != 2
      // Has FPPRECISION digits
      s=RNDINTEXCRANGE(
        pow(FPRADIX,FPPRECISION-1),
        pow(FPRADIX,FPPRECISION))
    else
      // Has FPPRECISION digits (bits), the highest
      // of which is always 1 because it&#39;s the
      // only nonzero bit
      sm=pow(FPRADIX,FPPRECISION-1)
      s=RNDINTEXC(sm)+sm
    end
    ret=s*1.0*pow(FPRADIX, ex)
    if ret&gt;=lo and ret&lt;=hi: return ret
  end
END METHOD
</pre>

<p>The other seven methods can be derived from <code>RNDRANGE</code> as follows:</p>

<ul>
<li><strong><code>RNDRANGEMaxExc</code>, interval [<code>mn</code>, <code>mx</code>)</strong>:

<ul>
<li>Generate <code>RNDRANGE(mn, mx)</code> in a loop until a number other than <code>mx</code> is generated this way.  Return an error if <code>mn &gt;= mx</code> (treating positive and negative zero as different).</li>
</ul></li>
<li><strong><code>RNDRANGEMinExc</code>, interval [<code>mn</code>, <code>mx</code>)</strong>:

<ul>
<li>Generate <code>RNDRANGE(mn, mx)</code> in a loop until a number other than <code>mn</code> is generated this way.  Return an error if <code>mn &gt;= mx</code> (treating positive and negative zero as different).</li>
</ul></li>
<li><strong><code>RNDRANGEMinMaxExc</code>, interval (<code>mn</code>, <code>mx</code>)</strong>:

<ul>
<li>Generate <code>RNDRANGE(mn, mx)</code> in a loop until a number other than <code>mn</code> or <code>mx</code> is generated this way.  Return an error if <code>mn &gt;= mx</code> (treating positive and negative zero as different).</li>
</ul></li>
<li><strong><code>RNDU01()</code></strong>: <code>RNDRANGE(0, 1)</code>.</li>
<li><strong><code>RNDU01ZeroExc()</code></strong>: <code>RNDRANGEMinExc(0, 1)</code>.</li>
<li><strong><code>RNDU01OneExc()</code></strong>: <code>RNDRANGEMaxExc(0, 1)</code>.</li>
<li><strong><code>RNDU01ZeroOneExc()</code></strong>: <code>RNDRANGEMinMaxExc(0, 1)</code>.</li>
</ul>

<blockquote>
<p><strong>Note:</strong> In many software libraries, random numbers in a range are generated by dividing or multiplying a random integer by a constant.  For example, <code>RNDU01OneExc()</code> is often implemented like <code>RNDINTEXC(X) * (1.0/X)</code> or <code>RNDINTEXC(X) / X</code>, where X varies based on the software library.<sup><a href="#Note39"><strong>(39)</strong></a></sup> The disadvantage here is that not all numbers a floating-point format can represent in the range can be covered this way (Goualard 2020)<sup><a href="#Note40"><strong>(40)</strong></a></sup>.  As another example, <code>RNDRANGEMaxExc(a, b)</code> is often implemented like <code>a + RNDU01OneExc() * (b - a)</code>; however, this not only has the same disadvantage, but has many other issues where floating-point numbers are involved (Monahan 1985)<sup><a href="#Note41"><strong>(41)</strong></a></sup>.</p>
</blockquote>

<p><a id=Uniform_Numbers_As_Their_Digit_Expansions></a></p>

<h4>Uniform Numbers As Their Digit Expansions</h4>

<p>As noted by von Neumann (1951)<sup><a href="#Note31"><strong>(31)</strong></a></sup>, a uniform random number bounded by 0 and 1 can be produced by &quot;juxtapos[ing] enough random binary digits&quot;.  In this sense, the random number is <code>RNDINTEXC(2)/2 + RNDINTEXC(2)/4 + RNDINTEXC(2)/8 + ...</code>, perhaps &quot;forc[ing] the last [random bit] to be 1&quot; &quot;[t]o avoid any bias&quot;.  It is not hard to see that a uniform random number of an arbitrary base can be formed by generating a random digit expansion after the point.  For example, a random decimal number bounded by 0 and 1 can be generated as <code>RNDINTEXC(10)/10 + RNDINTEXC(10)/100 + ...</code>. (Note that the number 0 is an infinite digit expansion of zeros, and the number 1 is an infinite digit expansion of base-minus-ones.)</p>

<p><a id=Monte_Carlo_Sampling_Expected_Values_Integration_and_Optimization></a></p>

<h3>Monte Carlo Sampling: Expected Values, Integration, and Optimization</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>Randomization is the core of <strong>Monte Carlo sampling</strong>.  There are three main uses of Monte Carlo sampling: estimation, integration, and optimization.</p>

<ol>
<li><p><strong>Estimating expected values.</strong> Monte Carlo sampling can help estimate the <strong>expected value</strong> of a function given a random process or sampling distribution.  The following pseudocode estimates the expected value from a list of random numbers generated the same way.  Here, <code>EFUNC</code> is the function, and <code>MeanAndVariance</code> is given in the <a href="#Mean_and_Variance_Calculation"><strong>appendix</strong></a>.  <code>Expectation</code> returns a list of two numbers &mdash; the estimated expected value and its standard error.</p>

<pre>METHOD Expectation(numbers)
  ret=[]
  for i in 0...size(numbers)
     AddItem(ret,EFUNC(numbers[i]))
  end
  merr=MeanAndVariance(ret)
  merr[1]=merr[1]*(size(ret)-1.0)/size(ret)
  merr[1]=sqrt(merr[1]/size(ret))
  return merr
END METHOD
</pre>

<p>Examples of expected values include the following:</p>

<ul>
<li>The <strong><code>n</code>th raw moment</strong> (mean of <code>n</code>th powers) if <code>EFUNC(x)</code> is <code>pow(x, n)</code>.</li>
<li>The <strong>mean</strong>, if <code>EFUNC(x)</code> is <code>x</code>.</li>
<li>The <strong><code>n</code>th sample central moment</strong>, if <code>EFUNC(x)</code> is <code>pow(x-m, n)</code>, where <code>m</code> is the mean of the sampled numbers.</li>
<li>The (biased) <strong>sample variance</strong>, the second sample central moment.</li>
<li>The <strong>probability</strong>, if <code>EFUNC(x)</code> is <code>1</code> if some condition is met or <code>0</code> otherwise.</li>
</ul>

<p>If the sampling domain is also limited to random numbers meeting a given condition (such as <code>x &lt; 2</code> or <code>x != 10</code>), then the estimated expected value is also called the estimated <em>conditional expectation</em>.</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Monte_Carlo_integration"><strong>Monte Carlo integration</strong></a>.  This is a way to estimate a multidimensional integral; randomly sampled numbers are put into a list (<code>nums</code>) and the estimated integral and its standard error are then calculated with <code>Expectation(nums)</code> with <code>EFUNC(x) = x</code>, and multiplied by the volume of the sampling domain.</p></li>
<li><p><a href="http://mathworld.wolfram.com/StochasticOptimization.html"><strong>Stochastic optimization</strong></a>. This uses randomness to help find the minimum or maximum value of a function with one or more variables; examples include <a href="https://en.wikipedia.org/wiki/Simulated_annealing"><strong><em>simulated annealing</em></strong></a> and <a href="https://en.wikipedia.org/wiki/Simultaneous_perturbation_stochastic_approximation"><strong><em>simultaneous perturbation stochastic approximation</em></strong></a> (see also (Spall 1998)<sup><a href="#Note42"><strong>(42)</strong></a></sup>).</p></li>
</ol>

<p><a id=Low_Discrepancy_Sequences></a></p>

<h3>Low-Discrepancy Sequences</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>A <a href="https://en.wikipedia.org/wiki/Low-discrepancy_sequence"><strong><em>low-discrepancy sequence</em></strong></a> (or <em>quasirandom sequence</em>) is a sequence of numbers that behave like uniform random numbers but are <em>dependent</em> on each other, in that they are less likely to form &quot;clumps&quot; than if they were independent.  The following are examples:</p>

<ul>
<li>A base-N <em>van der Corput sequence</em> is generated as follows:  For each non-negative integer index in the sequence, take the index as a base-N number, then divide the least significant base-N digit by N, the next digit by N<sup>2</sup>, the next by N<sup>3</sup>, and so on, and add together these results of division.</li>
<li>A <em>Halton sequence</em> is a set of two or more van der Corput sequences with different prime bases; a Halton point at a given index has coordinates equal to the points for that index in the van der Corput sequences.</li>
<li>Roberts, M., in &quot;<a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/"><strong>The Unreasonable Effectiveness of Quasirandom Sequences</strong></a>&quot;, presents a low-discrepancy sequence based on a &quot;generalized&quot; version of the golden ratio.</li>
<li>Sobol sequences are explained in &quot;<a href="https://web.maths.unsw.edu.au/%7Efkuo/sobol/"><strong>Sobol sequence generator</strong></a>&quot; by S. Joe and F. Kuo.</li>
<li><em>Latin hypercube sampling</em> doesn&#39;t exactly produce low-discrepancy sequences, but serves much the same purpose.  The following pseudocode implements this sampling for an <code>n</code>-number sequence: <code>lhs = []; for i in 0...n: AddItem(RNDRANGEMinMaxExc(i*1.0/n,(i+1)*1.0/n)); lhs = Shuffle(lhs)</code>.</li>
<li>Linear congruential generators with modulus <code>m</code>, a full period, and &quot;good lattice structure&quot;; a sequence of <code>n</code>-dimensional points is then <code>[MLCG(i), MLCG(i+1), ..., MLCG(i+n-1)]</code> for each integer <code>i</code> in the interval [1, <code>m</code>] (L&#39;Ecuyer 1999)<sup><a href="#Note43"><strong>(43)</strong></a></sup> (see example pseudocode below).</li>
<li>Linear feedback shift register generators with good &quot;uniformity&quot; for Monte Carlo sampling (e.g., (Harase 2020)<sup><a href="#Note44"><strong>(44)</strong></a></sup>).</li>
<li>If the sequence outputs numbers in the interval [0, 1], the <a href="http://en.wikipedia.org/wiki/Baker&#x27;s_map"><strong>Baker&#39;s map</strong></a> of the sequence is <code>2 * (0.5-abs(x - 0.5))</code>, where <code>x</code> is each
number in the sequence.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD MLCG(seed) // m = 262139
  if seed&lt;=0: return error
  return rem(92717*seed,262139)/262139.0
END METHOD
</pre>

<p>In most cases, RNGs can be used to generate a &quot;seed&quot; to start the low-discrepancy sequence at.</p>

<p>In Monte Carlo sampling, low-discrepancy sequences are often used to achieve more efficient &quot;random&quot; sampling.</p>

<p><a id=Notes_on_Randomization_Involving_Real_Numbers></a></p>

<h3>Notes on Randomization Involving Real Numbers</h3>

<p><strong>Requires random real numbers.</strong></p>

<p><a id=Probabilities_As_Their_Digit_Expansions></a></p>

<h4>Probabilities As Their Digit Expansions</h4>

<p>Probabilities can be expressed as a digit expansion (of the form <code>0.dddddd...</code>).</p>

<p>If the probability is a rational number, express it as a rational number (<code>n</code>/<code>d</code>) and use <code>ZeroOrOne(n, d)</code> to generate 1 with probability <code>n</code>/<code>d</code> and 0 otherwise (a <em>Bernoulli trial</em>).</p>

<p>If the probability is an irrational number, such as <code>exp(-x/y)</code> or <code>ln(2)</code>, then the digit expansion is infinite and can only be approximated.  In that case, assuming the probability is in [0, 1), use the following algorithm to do a Bernoulli trial with that probability ((Brassard et al., 2015)<sup><a href="#Note45"><strong>(45)</strong></a></sup>; see also (Devroye 1986, p. 769)<sup><a href="#Note13"><strong>(13)</strong></a></sup>), where <code>BASE</code> is the digit base, such as 2 for binary or 10 for decimal:</p>

<ol>
<li>Set <code>u</code> to 0 and <code>k</code> to 1.</li>
<li>Set <code>u</code> to <code>(u * BASE) + RNDINTEXC(BASE)</code>.  Set <code>pk</code> to the <code>k</code> digits after the point in <code>p</code>&#39;s digit expansion.  Example: If <code>p</code> is &pi;/4, <code>BASE</code> is 10, and <code>k</code> is 5, then <code>pk = 78539</code>.</li>
<li>If <code>pk + 1 &lt;= u</code>, return 0.  If <code>pk - 2 &gt;= u</code>, return 1.  If neither is the case, add 1 to <code>k</code> and go to step 2.</li>
</ol>

<p><a id=Weighted_Choice_Involving_Real_Numbers></a></p>

<h4>Weighted Choice Involving Real Numbers</h4>

<p>In general, to implement weighted choice given a list of weights or cumulative weights expressed as real numbers, convert those weights to integers (see &quot;<a href="#Sampling_for_Discrete_Distributions"><strong>Sampling for Discrete Distributions</strong></a>&quot;), then use those integers in the <code>WeightedChoice</code> or <code>CumulativeWeightedChoice</code> methods, as appropriate (see &quot;<a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a>&quot;). Those two methods could instead be modified by changing <code>value = RNDINTEXC(sum)</code> to <code>value = RNDRANGEMaxExc(0, sum)</code>, but this is more likely to introduce error.</p>

<p><a id=Random_Walks_Additional_Examples></a></p>

<h4>Random Walks: Additional Examples</h4>

<ul>
<li>One example of a white noise process is a list of <code>Normal(0, 1)</code> numbers (<em>Gaussian white noise</em>).</li>
<li>If <code>STATEJUMP()</code> is <code>RNDRANGE(-1, 1)</code>, the random state is advanced by a random real number in the interval [-1, 1].</li>
<li>A <strong>continuous-time process</strong> models random behavior at every moment, not just at discrete times.  There are two popular examples:

<ul>
<li>A <em>Wiener process</em> (also known as <em>Brownian motion</em>) has random states and jumps that are normally distributed. For a random walk that follows a Wiener process, <code>STATEJUMP()</code> is <code>Normal(mu * timediff, sigma * sqrt(timediff))</code>, where  <code>mu</code> is the drift (or average value per time unit), <code>sigma</code> is the volatility, and <code>timediff</code> is the time difference between samples.  A <em>Brownian bridge</em> (Revuz and Yor 1999)<sup><a href="#Note46"><strong>(46)</strong></a></sup> modifies a Wiener process as follows: For each time X, calculate <code>W(X) - W(E) * (X - S) / (E - S)</code>, where <code>S</code> and <code>E</code> are the starting and ending times of the process, respectively, and <code>W(X)</code> and <code>W(E)</code> are the state at times X and E, respectively.</li>
<li>In a <em>Poisson process</em>, the time between each event is its own exponential random number with its own rate parameter (e.g., <code>Expo(rate)</code>) (see &quot;<a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a>&quot;), and sorting N random <code>RNDRANGE(x, y)</code> expresses N arrival times in the interval <code>[x, y]</code>. The process is <em>homogeneous</em> if all the rates are the same, and <em>inhomogeneous</em> if the rate can vary with the &quot;timestamp&quot; before each event jump; to generate arrival times here, potential arrival times are generated at the maximum possible rate (<code>maxrate</code>) and each one is accepted if <code>RNDRANGE(0, maxrate) &lt; thisrate</code>, where <code>thisrate</code> is the rate for the given arrival time (Alexoupolos 2017)<sup><a href="#Note47"><strong>(47)</strong></a></sup>.</li>
</ul></li>
</ul>

<p><a id=Mixtures_Additional_Examples></a></p>

<h4>Mixtures: Additional Examples</h4>

<p>Example 3 in &quot;<a href="#Mixtures_of_Distributions"><strong>Mixtures of Distributions</strong></a>&quot; can be adapted to nonoverlapping real number ranges by assigning weights <code>mx - mn</code> instead of <code>(mx - mn) + 1</code> and using <code>RNDRANGEMaxExc</code> instead of <code>RNDINTRANGE</code>.</p>

<p><a id=Transformations_Additional_Examples></a></p>

<h4>Transformations: Additional Examples</h4>

<ol>
<li><strong>Bates distribution</strong>: Find the mean of <em>n</em> uniform random numbers in a given range (such as by <code>RNDRANGE(minimum, maximum)</code>) (strategy 8, mean; see the <a href="#Mean_and_Variance_Calculation"><strong>appendix</strong></a>).</li>
<li>A random point (<code>x</code>, <code>y</code>) can be transformed (strategy 9, geometric transformation) to derive a point with <strong>correlated random</strong> coordinates (old <code>x</code>, new <code>x</code>) as follows (see (Saucier 2000)<sup><a href="#Note48"><strong>(48)</strong></a></sup>, sec. 3.8): <code>[x, y*sqrt(1 - rho * rho) + rho * x]</code>, where <code>x</code> and <code>y</code> are independent random numbers generated the same way, and <code>rho</code> is a <em>correlation coefficient</em> in the interval [-1, 1] (if <code>rho</code> is 0, <code>x</code> and <code>y</code> are uncorrelated).</li>
<li>It is reasonable to talk about sampling the sum or mean of N random numbers, where N has a fractional part.  In this case, <code>ceil(N)</code> random numbers are generated and the last number is multiplied by that fractional part.  For example, to sample the sum of 2.5 random numbers, generate three random numbers, multiply the last by 0.5 (the fractional part of 2.5), then sum all three numbers.</li>
</ol>

<p><a id=Random_Numbers_from_a_Distribution_of_Data_Points></a></p>

<h3>Random Numbers from a Distribution of Data Points</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>Generating random data points based on how a list of data points is distributed involves the field of <strong>machine learning</strong>: <em>fit a data model</em> to the data points, then <em>predict</em> a new data point based on that model, with randomness added to the mix.  Three kinds of data models, described below, serve this purpose. (How fitting works is outside the scope of this page.)</p>

<ol>
<li><p><strong>Density estimation models.</strong> <a href="http://scikit-learn.org/stable/modules/density.html"><strong>Density estimation</strong></a> models seek to describe the distribution of data points in a given data set, where areas with more points are more likely to be sampled.<sup><a href="#Note49"><strong>(49)</strong></a></sup> The following are examples.</p>

<ul>
<li><strong>Histograms</strong> are sets of one or more non-overlapping <em>bins</em>, which are generally of equal size.  Histograms are <a href="#Mixtures_of_Distributions"><strong><em>mixtures</em></strong></a>, where each bin&#39;s weight is the number of data points in that bin.  After a bin is randomly chosen, a random data point that could fit in that bin is generated (that point need not be an existing data point).</li>
<li><strong>Gaussian</strong> <a href="https://en.wikipedia.org/wiki/Mixture_model"><strong>mixture models</strong></a> are also mixtures, in this case, mixtures of one or more <a href="#Normal_Gaussian_Distribution"><strong>Gaussian (normal) distributions</strong></a>.</li>
<li><strong>Kernel distributions</strong> are mixtures of sampling distributions, one for each data point. Estimating a kernel distribution is called <a href="https://en.wikipedia.org/wiki/Kernel_density_estimation"><strong><em>kernel density estimation</em></strong></a>.  To sample from a kernel distribution:

<ol>
<li>Choose one of the numbers or points in the list at random <a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>with replacement</strong></a>.</li>
<li>Add a randomized &quot;jitter&quot; to the chosen number or point; for example, add a separately generated <code>Normal(0, sigma)</code> to the chosen number or each component of the chosen point, where <code>sigma</code> is the <em>bandwidth</em><sup><a href="#Note50"><strong>(50)</strong></a></sup>.</li>
</ol></li>
<li><strong>Stochastic interpolation</strong> is described in (Saucier 2000)<sup><a href="#Note48"><strong>(48)</strong></a></sup>, sec. 5.3.4.  It involves choosing a data point at random, taking the mean of that point and its <em>k</em> nearest neighbors, and shifting that mean by a random weighted sum of the differences between each of those points and that mean (here, the weight is <code>RNDRANGE((1-sqrt(k*3))/(k+1.0), (1+sqrt(k*3))/(k+1.0))</code> for each point). This approach assumes that the lowest and highest values of each dimension are 0 and 1, respectively, so that arbitrary data points have to be shifted and scaled accordingly.</li>
<li><strong>Fitting a known distribution</strong> (such as the normal distribution), with unknown parameters, to data can be done by <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation"><strong>maximum likelihood estimation</strong></a>, among other ways.  If several kinds of distributions are possible fitting choices, then the kind showing the best <em>goodness of fit</em> for the data (e.g., chi-squared goodness of fit) is chosen.</li>
</ul></li>
<li><p><strong>Regression models.</strong> A <em>regression model</em> is a model that summarizes data as a formula and an error term.  If an application has data in the form of inputs and outputs (e.g., monthly sales figures) and wants to sample a random but plausible output given a known input point (e.g., sales for a future month), then the application can fit and sample a regression model for that data.  For example, a <em>linear regression model</em>, which simulates the value of <code>y</code> given known inputs <code>a</code> and <code>b</code>, can be sampled as follows: <code>y = c1 * a + c2 * b + c3 + Normal(0, sqrt(mse))</code>, where <code>mse</code> is the mean squared error and <code>c1</code>, <code>c2</code>, and <code>c3</code> are the coefficients of the model.  (Here, <code>Normal(0, sqrt(mse))</code> is the error term.)</p></li>
<li><p><strong>Generative models.</strong> These are machine learning models that take random numbers as input and generate outputs (such as images or sounds) that are similar to examples they have already seen.  <a href="https://en.wikipedia.org/wiki/Generative_adversarial_network"><strong><em>Generative adversarial networks</em></strong></a> are one kind of generative model.</p></li>
</ol>

<blockquote>
<p><strong>Note:</strong> If the existing data points each belong in one of several <em>categories</em>:</p>

<ul>
<li>Choosing a random category could be done by choosing a random number weighted on the number of data points in each category (see &quot;<a href="#Weighted_Choice"><strong>Weighted Choice</strong></a>&quot;).</li>
<li>Choosing a random data point <em>and</em> its category could be done&mdash;

<ol>
<li>by choosing a random data point based on all the existing data points, then finding its category (e.g., via machine learning models known as <em>classification models</em>), or</li>
<li>by choosing a random category as given above, then by choosing a random data point based only on the existing data points of that category.</li>
</ol></li>
</ul>
</blockquote>

<p><a id=Random_Numbers_from_an_Arbitrary_Distribution></a></p>

<h3>Random Numbers from an Arbitrary Distribution</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>Many probability distributions can be defined in terms of any of the following:</p>

<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function"><strong><em>cumulative distribution function</em></strong></a>, or <em>CDF</em>, returns, for each number, the probability that a number equal to or greater than that number is randomly chosen; the probability is in the interval [0, 1].</li>
<li>The <a href="https://en.wikipedia.org/wiki/Probability_density_function"><strong><em>probability density function</em></strong></a>, or <em>PDF</em>, is, roughly and intuitively, a curve of weights 0 or greater, where for each number, the greater its weight, the more likely a number close to that number is randomly chosen.  In this document, the area under the PDF need not equal 1.<sup><a href="#Note51"><strong>(51)</strong></a></sup></li>
<li>The <em>quantile function</em> (also known as <em>inverse cumulative distribution function</em> or <em>inverse CDF</em>) is the inverse of the CDF and maps numbers in the interval [0, 1) to numbers in the distribution, from low to high.</li>
</ul>

<p>The following sections show different ways to generate random numbers based on a distribution, depending on what is known about that distribution.</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>Lists of PDFs, CDFs, or quantile functions are outside the scope of this page.</li>
<li>In practice, the logarithm of the PDF (log-PDF) is sometimes used instead of the PDF to improve numerical stability.</li>
</ol>
</blockquote>

<p><a id=Sampling_for_Discrete_Distributions></a></p>

<h4>Sampling for Discrete Distributions</h4>

<p>If the distribution <strong>is discrete</strong><sup><a href="#Note52"><strong>(52)</strong></a></sup>, numbers that closely follow it can be sampled by choosing points that cover all or almost all of the distribution, finding their weights or cumulative weights, and choosing a random point based on those weights.  The method will be exact as long as&mdash;</p>

<ol>
<li>the chosen points cover all of the distribution, and</li>
<li>the values of the PDF or CDF are calculated exactly, without error (if they are not, though, this method will not introduce any additional error).<sup><a href="#Note82"><strong>(82)</strong></a></sup></li>
</ol>

<p>The pseudocode below shows the following methods that work with a <strong>known PDF</strong> (<code>PDF(x)</code>, more properly called <em>probability mass function</em>) or a <strong>known CDF</strong> (<code>CDF(x)</code>) that outputs floating-point numbers of the form  <code>FPSignificand</code> * <code>FPRadix</code><sup><code>FPExponent</code></sup> (which include Java&#39;s <code>double</code> and <code>float</code>)<sup><a href="#Note53"><strong>(53)</strong></a></sup>. In the code, <code>LTDenom(x)</code> is the lowest-terms denominator of the ratio <code>x</code>.</p>

<ul>
<li><code>SampleFP(mini, maxi)</code> chooses a random number in [<code>mini</code>, <code>maxi</code>] based on a <strong>known PDF</strong>.  <code>InversionSampleFP</code> is similar, but is based on a <strong>known CDF</strong>; however, <code>SampleFP</code> should be used instead where possible.</li>
<li><code>IntegerWeightsFP(mini, maxi)</code> generates a list of integer weights for the interval [<code>mini</code>, <code>maxi</code>] based on a <strong>known PDF</strong><sup><a href="#Note54"><strong>(54)</strong></a></sup>. (Alternatively, the weights could be approximated, such as by scaling and rounding [e.g., <code>round(PDF(i) * mult)</code>] or by using a more sophisticated algorithm (Saad et al., 2020)<sup><a href="#Note55"><strong>(55)</strong></a></sup>, but doing so can introduce error.)</li>
<li><code>IntegerCDFFP</code> is similar to <code>IntegerWeightsFP</code>, but generates cumulative weights based on a <strong>known CDF</strong>.</li>
<li><code>IntegerWeightsListFP</code> generates integer weights from a list of weights or cumulative weights expressed as floating-point numbers.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD SampleFP(mini, maxi)
  return mini + WeightedChoice(IntegerWeightsFP(mini, maxi))
END METHOD

METHOD InversionSampleFP(mini, maxi)
  weights=IntegerCDFFP(mini, maxi)
  return mini + CWChoose(weights,
     weights[size(weights) - 1])
END METHOD

METHOD FPRatio(fp)
  expo=FPExponent(fp)
  sig=FPSignificand(fp)
  radix=FPRadix(fp)
  if expo&gt;=0: return MakeRatio(sig * pow(radix, expo), 1)
  return MakeRatio(sig, pow(radix, abs(expo)))
END METHOD

METHOD NormalizeRatios(ratios)
  ratioSum = Sum(ratios)
  denom = LTDenom(ratioSum)
  weights=[]
  for r in ratios: AddItem(weights, floor(r[0]*denom))
  return weights
END METHOD

METHOD IntegerWeightsFP(mini, maxi)
  ratios=[]
  for i in mini..maxi: AddItem(ratios, FPRatio(PDF(i)))
  return NormalizeRatios(ratios)
END METHOD

METHOD IntegerCDFFP(mini, maxi)
  ratios=[[0, 1]]
  for i in mini..maxi: AddItem(ratios, FPRatio(CDF(i)))
  return NormalizeRatios(ratios)
END METHOD

METHOD IntegerWeightsListFP(weights)
  ratios=[]
  for w in weights: AddItem(ratios, FPRatio(w))
  return NormalizeRatios(ratios)
END METHOD
</pre>

<p><a id=Inverse_Transform_Sampling></a></p>

<h4>Inverse Transform Sampling</h4>

<p><a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling"><strong><em>Inverse transform sampling</em></strong></a> (or simply <em>inversion</em>) is the most generic way to generate a random number that follows a distribution.</p>

<p>If the distribution <strong>has a known quantile function</strong>, generate a uniform random number in (0, 1) if that number wasn&#39;t already pregenerated, and take the quantile of that number.  However:</p>

<ul>
<li>If the distribution spans a bigger range than [0, 1], then calculating the quantile na&iuml;vely (e.g., <code>ICDF(RNDU01ZeroOneExc())</code>) can leave gaps, in the sense that some numbers with the same precision as the uniform number may not be generated even if the distribution gives them a chance of occurring; this is especially the case for uniform floating-point numbers close to 1 (Monahan 1985, sec. 4 and 6)<sup><a href="#Note41"><strong>(41)</strong></a></sup>.</li>
<li>In most cases, the quantile function is not available.  Thus, it has to be approximated.</li>
</ul>

<p>The following method generates a random number from a distribution via inversion, with an accuracy of <code>BASE</code><sup><code>-precision</code></sup> ((Devroye and Gravel 2018)<sup><a href="#Note56"><strong>(56)</strong></a></sup>, but extended for any base; see also (Bringmann and Friedrich 2013, Appendix A)<sup><a href="#Note57"><strong>(57)</strong></a></sup>).  In the method, <code>ICDF(u, ubits, prec)</code> calculates a number that is within <code>BASE</code><sup><code>-prec</code></sup> of the true quantile of <code>u</code>/<code>BASE</code><sup><code>ubits</code></sup>, and <code>BASE</code> is the digit base (e.g. 2 for binary or 10 for decimal).</p>

<pre>METHOD Inversion(precision)
   u=0
   ubits=0
   threshold=MakeRatio(1,pow(BASE, precision))*2
   incr=8
   while true
      incr=8
      if ubits==0: incr=precision
      // NOTE: If a uniform number (`n`) is already pregenerated,
      // use the following instead:
      // u = mod(floor(n*pow(BASE, ubits+incr)), pow(BASE, incr))
      u=u*pow(BASE,incr)+RNDINTEXC(pow(BASE,incr))
      ubits=ubits+incr
      lower=ICDF(u,ubits,precision)
      upper=ICDF(u+1,ubits,precision)
      // Quantile can never go down
      if lower&gt;upper: return error
      diff=upper-lower
      if diff&lt;=threshold: return upper+diff/2
   end
end
</pre>

<p>Some cases require converting a pregenerated uniform random number to a non-uniform one via quantiles (notable cases include copula methods and Monte Carlo methods involving low-discrepancy sequences).  For these cases, the following methods approximate the quantile if the application can trade accuracy for speed:</p>

<ul>
<li>Distribution is <strong>discrete, with known PDF</strong>: The most general method is sequential search (Devroye 1986, p. 85)<sup><a href="#Note13"><strong>(13)</strong></a></sup>, assuming the area under the PDF is 1 and the distribution covers only integers 0 or greater: <code>i = 0; p = PDF(i); while u01 &gt; p; u01 = u01 - p; i = i + 1; p = PDF(i); end; return p</code>, but this is not always fast.  If the interval [a, b] covers all or almost all the distribution, then the application can store the interval&#39;s PDF values in a list and call <code>WChoose</code>: <code>for i in a..b: AddItem(weights, PDF(i)); return a + WChoose(weights, u01 * Sum(weights))</code>.  Note that finding the quantile based on the <strong>CDF</strong> instead can introduce more error than with the PDF (Walter 2019)<sup><a href="#Note58"><strong>(58)</strong></a></sup>.</li>
<li>Distribution is <strong>continuous, with known PDF</strong>: See <code>ICDFFromContPDF(u01, mini, maxi, step)</code> below.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD ICDFFromContPDF(u01, mini, maxi, step)
  values=[]
  weights=[]
  areas=[]
   i = mini; while i &lt; maxi
     AddItem(values, i)
     AddItem(weights, PDF(i))
     i = i + step
   end
   AddItem(list, maxi)
   AddItem(weights, PDF(maxi))
  sum=GatherAreas(values, weights, areas)
  return PWLChoose(values, weights, areas, u01 * sum)
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>If only percentiles of data (such as the median or 50th percentile, the minimum or 0th percentile, or the maximum or 100th percentile) are available, the quantile function can be approximated via those percentiles.  The Nth percentile corresponds to the quantile for <code>N/100.0</code>.  Missing values for the quantile function can then be filled in by interpolation (such as spline fitting).  If the raw data points are available, see &quot;<a href="#Random_Numbers_from_a_Distribution_of_Data_Points"><strong>Random Numbers from a Distribution of Data Points</strong></a>&quot; instead.</li>
<li>Taking the maximum of <code>n</code> random numbers is the same as taking the quantile of <code>pow(u, 1/n)</code>, where <code>u</code> is a uniform random number (Devroye 2006)<sup><a href="#Note59"><strong>(59)</strong></a></sup>.</li>
</ol>
</blockquote>

<p><a id=Rejection_Sampling_with_a_PDF></a></p>

<h4>Rejection Sampling with a PDF</h4>

<p>If the distribution <strong>has a known PDF</strong>, and the PDF can be more easily sampled by another distribution with its own PDF (<code>PDF2</code>) that &quot;dominates&quot; <code>PDF</code> in the sense that <code>PDF2(x) &gt;= PDF(x)</code> at every valid <code>x</code>, then generate random numbers with the latter distribution until a number (<code>n</code>) that satisfies <code>r &lt;= PDF(n)</code>, where <code>r = RNDRANGEMaxExc(0, PDF2(n))</code>, is generated this way (that is, sample points in <code>PDF2</code> until a point falls within <code>PDF</code>).</p>

<p>A variant of rejection sampling is the <em>squeeze principle</em>, in which a third PDF (<code>PDF3</code>) is chosen that is &quot;dominated&quot; by the first PDF (<code>PDF</code>) and easier to sample than <code>PDF</code>.  Here, a number is accepted if <code>r &lt;= PDF3(n)</code> or <code>r &lt;= PDF(n)</code> (Devroye 1986, p. 53)<sup><a href="#Note13"><strong>(13)</strong></a></sup>.</p>

<p>See also (von Neumann 1951)<sup><a href="#Note31"><strong>(31)</strong></a></sup>; (Devroye 1986)<sup><a href="#Note13"><strong>(13)</strong></a></sup>, pp. 41-43; &quot;<a href="#Rejection_Sampling"><strong>Rejection Sampling</strong></a>&quot;; and &quot;<a href="https://mathworks.com/help/stats/generating-random-data.html"><strong>Generating Pseudorandom Numbers</strong></a>&quot;.</p>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>To sample a random number in the interval [<code>low</code>, <code>high</code>) from a PDF with a positive maximum value no greater than <code>peak</code> at that interval, generate <code>x = RNDRANGEMaxExc(low, high)</code> and <code>y = RNDRANGEMaxExc(0, peak)</code> until <code>y &lt; PDF(x)</code>, then take the last <code>x</code> generated this way. (See also Saucier 2000, pp. 6-7.)  If the distribution <strong>is discrete</strong>, generate <code>x</code> with <code>x = RNDINTEXCRANGE(low, high)</code> instead.</li>
<li>A custom distribution&#39;s PDF, <code>PDF</code>, is <code>exp(-abs(x*x*x))</code>, and the exponential distribution&#39;s PDF, <code>PDF2</code>, is <code>exp(-x)</code>.  The exponential PDF &quot;dominates&quot; the other PDF (at every <code>x</code> 0 or greater) if we multiply it by 1.5, so that <code>PDF2</code> is now <code>1.5 * exp(-x)</code>.  Now we can generate numbers from our custom distribution by sampling exponential points until a point falls within <code>PDF</code>.  This is done by generating <code>n = Expo(1)</code> until <code>PDF(n) &gt;= RNDRANGEMaxExc(0, PDF2(n))</code>.</li>
</ol>

<p><strong>Note:</strong> Rejection sampling can also be used for <a href="#Low_Discrepancy_Sequences"><strong>low-discrepancy sequences</strong></a> (especially if the target distribution has an unknown quantile function), given a distribution with an &quot;easy-to-calculate&quot; quantile function (Nguyen and Ökten 2014/2016)<sup><a href="#Note60"><strong>(60)</strong></a></sup>.  Example: (1) Generate two numbers A and B from a low-discrepancy sequence;  (2) set Q to the &quot;easy-to-calculate&quot; quantile of A, then accept Q if <code>B * PDF2(Q) &lt;= PDF(Q)</code>, or go to step 1 otherwise.</p>
</blockquote>

<p><a id=Alternating_Series></a></p>

<h4>Alternating Series</h4>

<p>If the target PDF is not known exactly, but can be approximated from above and below by two series expansions that converge to the PDF as more terms are added, the  <em>alternating series method</em> can be used.  This still requires a &quot;dominating&quot; PDF (<code>PDF2(x)</code>) to serve as the &quot;easy-to-sample&quot; distribution.  Call the series expansions <code>UPDF(x, n)</code> and <code>LPDF(x, n)</code>, respectively, where <code>n</code> is the number of terms in the series to add.  To generate a random number using this method (Devroye 2006)<sup><a href="#Note59"><strong>(59)</strong></a></sup>: (1) Generate a random number <code>x</code> that follows the &quot;dominating&quot; distribution; (2) set <code>n</code> to 0; (3) accept <code>x</code> if <code>r &lt;= LPDF(x, n)</code>, or go to step 1 if <code>r &gt;= UPDF(x, n)</code>, or repeat this step with <code>n</code> increased by 1 if neither is the case.</p>

<p><a id=Markov_Chain_Monte_Carlo></a></p>

<h4>Markov-Chain Monte Carlo</h4>

<p><a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo"><strong>Markov-chain Monte Carlo</strong></a> (MCMC) is a family of algorithms for sampling many random numbers from a probability distribution by building a <em>Markov chain</em> of random values that build on each other until they converge to the given distribution.  In general, however, these random numbers will have a statistical <em>dependence</em> on each other, and it takes an unknown time for the chain to converge (which is why techniques such as &quot;thinning&quot; -- keeping only every Nth sample -- or &quot;burn-in&quot; -- skipping iterations before sampling -- are often employed). MCMC can also estimate the distribution&#39;s sampling domain for other samplers, such as rejection sampling (above).</p>

<p>MCMC algorithms<sup><a href="#Note61"><strong>(61)</strong></a></sup> include <em>Metropolis&ndash;Hastings</em>, <em>slice sampling</em>, and <em>Gibbs sampling</em> (see also the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>).  The latter is special in that it uses not a PDF, but two or more distributions, each of which uses a random number from the previous distribution (<em>conditional distributions</em>), that converge to a <em>joint distribution</em>.</p>

<blockquote>
<p><strong>Example:</strong> In one Gibbs sampler, an initial value for <code>y</code> is chosen, then multiple <code>x</code>, <code>y</code> pairs of random numbers are generated, where <code>x = BetaDist(y, 5)</code> then <code>y = Poisson(x * 10)</code>.</p>
</blockquote>

<p><a id=Python_Sample_Code></a></p>

<h4>Python Sample Code</h4>

<p>In the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>:</p>

<ul>
<li>The <code>integers_from_pdf</code> method implements approximate sampling for discrete distributions.</li>
<li>The <code>numbers_from_cdf</code> method, the <code>from_interp</code> method, and a <code>KVectorSampler</code> class<sup><a href="#Note62"><strong>(62)</strong></a></sup> use inversion to sample a random number given a <strong>distribution&#39;s CDF</strong>.  These are all approximations. For <code>from_interp</code>, the CDF is expressed as a list of input/output pairs.</li>
<li><code>numbers_from_dist_inversion</code> generates random numbers from a distribution via inversion (Devroye and Gravel 2018)<sup><a href="#Note56"><strong>(56)</strong></a></sup>.  <code>integers_from_u01</code> computes quantiles for a discrete distribution given its PDF.</li>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/moore.py"><strong>moore.py</strong></a> and <code>numbers_from_dist</code> generate random numbers from a distribution via rejection sampling (Devroye and Gravel 2016/2018)<sup><a href="#Note63"><strong>(63)</strong></a></sup>, (Sainudiin and York 2013)<sup><a href="#Note64"><strong>(64)</strong></a></sup>.</li>
</ul>

<p><a id=Piecewise_Linear_Distribution></a></p>

<h3>Piecewise Linear Distribution</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>A <a href="http://en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution"><strong><em>piecewise linear distribution</em></strong></a> describes a continuous distribution with weights at known points and other weights determined by linear interpolation (smoothing).  The <code>PiecewiseLinear</code> method (in the pseudocode below) takes two lists as follows:</p>

<ul>
<li><code>values</code> is a list of numbers (which need not be integers). If the numbers are arranged in ascending order, which they should, the first number in this list can be returned exactly, but not the last number.</li>
<li><code>weights</code> is a list of weights for the given numbers (where each number and its weight have the same index in both lists).   The greater a number&#39;s weight, the more likely it is that a number close to that number will be chosen.  Each weight should be 0 or greater.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD PWLChoose(values, weights, areas, value)
    // Interpolate a number according to the given value
    i=0
    // Get the number corresponding to the random number
    runningValue = 0
    while i &lt; size(values) - 1
     area = areas[i]
     if area &gt; 0
      newValue = runningValue + area
      // NOTE: Includes start, excludes end
      if value &lt; newValue
       w1=weights[i]
       w2=weights[i+1]
       diff=w2-w1
       wmin=min(w1, w2)
       wmax=max(w1, w2)
       wt=(value - runningValue)/area
       interp=wt
       if diff!=0
          s=sqrt(wmax*wmax*wt+wmin*wmin-
             wmin*wmin*wt)
          interp=abs((s-wmin)/diff)
          if diff&lt;0: interp=1-interp
       end
       retValue = values[i] + (values[i + 1] - values[i]) *
          interp
       return retValue
      end
      runningValue = newValue
     end
     i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return values[size(values) - 1]
END METHOD

METHOD GatherAreas(values, weights, areas)
    // Get the sum of all areas between weights
    // NOTE: Kahan summation is more robust
    // than the naive summing given here
    msum = 0
    i = 0
    while i &lt; size(values) - 1
      weightArea = abs((weights[i] + weights[i + 1]) * 0.5 *
            (values[i + 1] - values[i]))
      AddItem(areas, weightArea)
      msum = msum + weightArea
       i = i + 1
    end
    return msum
END METHOD

METHOD PiecewiseLinear(values, weights)
    if size(values) &lt;= 0 or
       size(weights) &lt; size(values): return error
    if size(values) == 1: return values[0]
    areas = []
    msum = GatherAreas(values, weights, areas)
    // Generate random numbers
    value = RNDRANGEMaxExc(0, msum)
    return PWLChoose(values, weights, areas, value)
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains a variant to the method
above for returning more than one random number in one call.</p>

<p><strong>Example</strong>: Assume <code>values</code> is the following: <code>[0, 1, 2, 2.5, 3]</code>, and <code>weights</code> is the following: <code>[0.2, 0.8, 0.5, 0.3, 0.1]</code>.  The weight for 2 is 0.5, and that for 2.5 is 0.3.  Since 2 has a higher weight than 2.5, numbers near 2 are more likely to be chosen than numbers near 2.5 with the <code>PiecewiseLinear</code> method.</p>
</blockquote>

<p><a id=Specific_Distributions></a></p>

<h3>Specific Distributions</h3>

<p>Methods to sample additional distributions are given in a <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md"><strong>separate page</strong></a>. They cover the normal, gamma, beta, von Mises, stable, and multivariate normal distributions as well as copulas.  Note, however, that most of the methods won&#39;t sample the given distribution in a manner that minimizes approximation error), but they may still be useful if the application is willing to trade accuracy for speed.</p>

<p><a id=Index_of_Non_Uniform_Distributions></a></p>

<h3>Index of Non-Uniform Distributions</h3>

<p><strong>Many distributions here require random real numbers.</strong></p>

<p>A &dagger; symbol next to a distribution means the random number can be shifted by a location parameter (<code>mu</code>) then scaled by a scale parameter greater than 0 (<code>sigma</code>).  Example: <code>num * sigma + mu</code>.</p>

<p>A &#x2b26; symbol next to a distribution means the random number can be scaled to any range, which is given with the minimum and maximum values <code>mini</code> and <code>maxi</code>.  Example: <code>mini + (maxi - mini) * num</code>.</p>

<p>Most commonly used:
<small></p>

<ul>
<li><strong>Beta distribution</strong>&#x2b26;: See <a href="hhttps://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Beta_Distribution"><strong>Beta Distribution</strong></a>.</li>
<li><strong>Binomial distribution</strong>: See <a href="#Binomial_Distribution"><strong>Binomial Distribution</strong></a>.</li>
<li><strong>Binormal distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Cauchy (Lorentz) distribution</strong>&dagger;:  <code>Stable(1, 0)</code>.  This distribution is similar to the normal distribution, but with &quot;fatter&quot; tails. Alternative algorithm based on one mentioned in (McGrath and Irving 1975)<sup><a href="#Note65"><strong>(65)</strong></a></sup>: Generate <code>x = RNDU01ZeroExc()</code> and <code>y = RNDU01ZeroExc()</code> until <code>x * x + y * y &lt;= 1</code>, then generate <code>(RNDINT(1) * 2 - 1) * y / x</code>.</li>
<li><strong>Chi-squared distribution</strong>: <code>GammaDist(df * 0.5 + Poisson(sms * 0.5), 2)</code>, where <code>df</code> is the number of degrees of freedom and <code>sms</code> is the sum of mean squares (where <code>sms</code> other than 0 indicates a <em>noncentral</em> distribution).</li>
<li><strong>Dice</strong>: See <a href="#Dice"><strong>Dice</strong></a>.</li>
<li><strong>Exponential distribution</strong>: See <a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a>.  The na&iuml;ve implementation <code>-ln(1-RNDU01()) / lamda</code> has several problems, such as being ill-conditioned at large values because of the distribution&#39;s right-sided tail (Pedersen 2018)<sup><a href="#Note2"><strong>(2)</strong></a></sup>, as well as returning infinity if <code>RNDU01()</code> becomes 1. An application can reduce some of these problems by applying Pedersen&#39;s suggestion of using either <code>-ln(RNDRANGEMinExc(0, 0.5))</code> or <code>-log1p(-RNDRANGEMinExc(0, 0.5))</code> (rather than <code>-ln(1-RNDU01())</code>), chosen at random each time; an alternative is <code>log(1/RNDU01ZeroExc())</code> mentioned in (Devroye 2006)<sup><a href="#Note59"><strong>(59)</strong></a></sup>.</li>
<li><strong>Extreme value distribution</strong>: See generalized extreme value distribution.</li>
<li><strong>Gamma distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Gamma_Distribution"><strong>Gamma Distribution</strong></a>.  <em>3-parameter gamma distribution</em>: <code>pow(GammaDist(a, 1), 1.0 / c) * b</code>, where <code>c</code> is another shape parameter. <em>4-parameter gamma distribution</em>: <code>pow(GammaDist(a, 1), 1.0 / c) * b + d</code>, where <code>d</code> is the minimum value.</li>
<li><strong>Gaussian distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Normal_Gaussian_Distribution"><strong>Normal (Gaussian) Distribution</strong></a>.</li>
<li><strong>Geometric distribution</strong>: See <a href="#Geometric_Distribution"><strong>Geometric Distribution</strong></a>.</li>
<li><strong>Gumbel distribution</strong>: See generalized extreme value distribution.</li>
<li><strong>Inverse gamma distribution</strong>: <code>b / GammaDist(a, 1)</code>, where <code>a</code> and <code>b</code> have the
same meaning as in the gamma distribution.  Alternatively, <code>1.0 / (pow(GammaDist(a, 1), 1.0 / c) / b + d)</code>, where <code>c</code> and <code>d</code> are shape and location parameters, respectively.</li>
<li><strong>Laplace (double exponential) distribution</strong>&dagger;: <code>(Expo(1) - Expo(1))</code>.</li>
<li><strong>Logarithmic distribution</strong>&#x2b26;: <code>RNDU01OneExc() * RNDU01OneExc()</code> (Saucier 2000, p. 26).  In this distribution, lower numbers are exponentially more likely than higher numbers.</li>
<li><strong>Logarithmic normal distribution</strong>: <code>exp(Normal(mu, sigma))</code>, where <code>mu</code> and <code>sigma</code> are the underlying normal distribution&#39;s parameters.</li>
<li><strong>Multinormal distribution</strong>: See multivariate normal distribution.</li>
<li><strong>Multivariate normal distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Normal distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Normal_Gaussian_Distribution"><strong>Normal (Gaussian) Distribution</strong></a>.</li>
<li><strong>Poisson distribution</strong>: See &quot;<a href="#Poisson_Distribution"><strong>Poisson Distribution</strong></a>&quot;. If the application can trade accuracy for speed, the following can be used (Devroye 1986, p. 504)<sup><a href="#Note13"><strong>(13)</strong></a></sup>: <code>c = 0; s = 0; while true; sum = sum + Expo(1); if sum&gt;=mean: return c; else: c = c + 1; end</code>; and in addition the following optimization from (Devroye 1991)<sup><a href="#Note66"><strong>(66)</strong></a></sup> can be used: <code>while mean &gt; 20; n=ceil(mean-pow(mean,0.7)); g=GammaDist(n, 1); if g&gt;=mean: return c+(n-1-Binomial(n-1,(g-mean)/g)); mean = mean - g; c = c + n; end</code>, or the following approximation suggested in (Giammatteo and Di Mascio 2020)<sup><a href="#Note67"><strong>(67)</strong></a></sup> for <code>mean</code> greater than 50: <code>floor(1.0/3 + pow(max(0, Normal(0, 1)*pow(mean,1/6.0)*2/3 + pow(mean, 2.0/3)), 3.0/2))</code>.</li>
<li><strong>Pareto distribution</strong>: <code>pow(RNDU01ZeroOneExc(), -1.0 / alpha) * minimum</code>, where <code>alpha</code>  is the shape and <code>minimum</code> is the minimum.</li>
<li><strong>Rayleigh distribution</strong>&dagger;: <code>sqrt(Expo(0.5))</code>.  If the scale parameter (<code>sigma</code>) follows a logarithmic normal distribution, the result is a <em>Suzuki distribution</em>.</li>
<li><strong>Standard normal distribution</strong>&dagger;: <code>Normal(0, 1)</code>.  See also <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Normal_Gaussian_Distribution"><strong>Normal (Gaussian) Distribution</strong></a>.</li>
<li><strong>Student&#39;s <em>t</em>-distribution</strong>: <code>Normal(cent, 1) / sqrt(GammaDist(df * 0.5, 2 / df))</code>, where <code>df</code> is the number of degrees of freedom, and <em>cent</em> is the mean of the normally-distributed random number.  A <code>cent</code> other than 0 indicates a <em>noncentral</em> distribution.  Alternatively, <code>cos(RNDRANGE(0, pi * 2)) * sqrt((pow(RNDU01(),-2.0/df)-1) * df)</code> (Bailey 1994)<sup><a href="#Note68"><strong>(68)</strong></a></sup>.</li>
<li><strong>Triangular distribution</strong>:

<ul>
<li><strong>Generalized</strong> (Kabal 2000/2019)<sup><a href="#Note69"><strong>(69)</strong></a></sup>: <code>(1-alpha) * min(startpt, endpt) + alpha * max(startpt, endpt)</code>.  The distribution starts at <code>startpt</code> and ends at <code>endpt</code>.</li>
<li>As used in <em>Mathematica</em>: <code>x * min(startpt, endpt) + x * max(startpt, endpt)</code> where <code>x = (midpt - startpt)/(endpt - startpt)</code>.</li>
</ul></li>
<li><strong>Weibull distribution</strong>: See generalized extreme value distribution.</li>
</ul>

<p></small></p>

<p>Miscellaneous:</p>

<p><small></p>

<ul>
<li><strong>Archimedean copulas</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Arcsine distribution</strong>&#x2b26;: <code>BetaDist(0.5, 0.5)</code> (Saucier 2000, p. 14).</li>
<li><strong>Bates distribution</strong>: See <a href="#Transformations_of_Random_Numbers_Additional_Examples"><strong>Transformations of Random Numbers: Additional Examples</strong></a>.</li>
<li><strong>Beckmann distribution</strong>: See <a href="#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Beta binomial distribution</strong>: <code>Binomial(trials, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>trials</code> is a parameter of the binomial distribution.</li>
<li><strong>Beta negative binomial distribution</strong>: <code>NegativeBinomial(successes, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are the two parameters of the beta distribution, and <code>successes</code> is a parameter of the negative binomial distribution. If <em>successes</em> is 1, the result is a <em>Waring&ndash;Yule distribution</em>. A <em>Yule&ndash;Simon distribution</em> results if <em>successes</em> and <em>b</em> are both 1 (e.g., in <em>Mathematica</em>) or if <em>successes</em> and <em>a</em> are both 1 (in other works).</li>
<li><strong>Beta-PERT distribution</strong>: <code>startpt + size * BetaDist(1.0 + (midpt - startpt) * shape / size, 1.0 + (endpt - midpt) * shape / size)</code>. The distribution starts  at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>, <code>size</code> is <code>endpt - startpt</code>, and <code>shape</code> is a shape parameter that&#39;s 0 or greater, but usually 4.  If the mean (<code>mean</code>) is known rather than the peak, <code>midpt = 3 * mean / 2 - (startpt + endpt) / 4</code>.</li>
<li><strong>Beta prime distribution</strong>&dagger;: <code>pow(GammaDist(a, 1), 1.0 / alpha) / pow(GammaDist(b, 1), 1.0 / alpha)</code>, where <code>a</code>, <code>b</code>, and <code>alpha</code> are shape parameters. If <em>a</em> is 1, the result is a <em>Singh&ndash;Maddala distribution</em>; if <em>b</em> is 1, a <em>Dagum distribution</em>; if <em>a</em> and <em>b</em> are both 1, a <em>logarithmic logistic distribution</em>.</li>
<li><strong>Birnbaum&ndash;Saunders distribution</strong>: <code>pow(sqrt(4+x*x)+x,2)/(4.0*lamda)</code>, where <code>x = Normal(0,gamma)</code>, <code>gamma</code> is a shape parameter, and <code>lamda</code> is a scale parameter.</li>
<li><strong>Chi distribution</strong>: Square root of a chi-squared random number.  See chi-squared distribution.</li>
<li><strong>Compound Poisson distribution</strong>: See <a href="#Transformations_of_Random_Numbers_Additional_Examples"><strong>Transformations of Random Numbers: Additional Examples</strong></a>.</li>
<li><strong>Cosine distribution</strong>&#x2b26;: <code>atan2(x, sqrt(1 - x * x)) / pi</code>, where <code>x = RNDRANGE(-1, 1)</code> (Saucier 2000, p. 17; inverse sine replaced with <code>atan2</code> equivalent).</li>
<li><strong>Dagum distribution</strong>: See beta prime distribution.</li>
<li><strong>Dirichlet distribution</strong>: See <a href="#Random_Real_Numbers_with_a_Given_Positive_Sum"><strong>Random Real Numbers with a Given Positive Sum</strong></a>.</li>
<li><strong>Double logarithmic distribution</strong>&#x2b26;: <code>(0.5 + (RNDINT(1) * 2 - 1) * RNDRANGEMaxExc(0, 0.5) * RNDU01OneExc())</code> (see also Saucier 2000, p. 15, which shows the wrong X axes).</li>
<li><strong>Erlang distribution</strong>: <code>GammaDist(n, 1.0 / lamda)</code>.  Returns a number that simulates a sum of <code>n</code> exponential random numbers with the given <code>lamda</code> parameter.</li>
<li><strong>Estoup distribution</strong>: See zeta distribution.</li>
<li><strong>Exponential power distribution</strong> (generalized normal distribution version 1): <code>(RNDINT(1) * 2 - 1) * pow(GammaDist(1.0/a, 1), a)</code>, where <code>a</code> is a shape parameter.</li>
<li><strong>Extended xgamma distribution</strong> (Saha et al. 2019)<sup><a href="#Note70"><strong>(70)</strong></a></sup>: <code>GammaDist(alpha + x, theta)</code>, where <code>x</code> is 0 if <code>RNDU01() &lt;= theta/(theta+beta)</code> and 2 otherwise, and where <code>alpha</code>, <code>theta</code>, and <code>beta</code> are shape parameters.  If <code>alpha = 0</code>, the result is an <strong>xgamma distribution</strong> (Sen et al., 2016)<sup><a href="#Note71"><strong>(71)</strong></a></sup>.</li>
<li><strong>Fr&eacute;chet distribution</strong>: See generalized extreme value distribution.</li>
<li><strong>Fr&eacute;chet&ndash;Hoeffding lower bound copula</strong>: See <a href="#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Fr&eacute;chet&ndash;Hoeffding upper bound copula</strong>: See <a href="#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Gaussian copula</strong>: See <a href="#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Generalized extreme value (Fisher&ndash;Tippett or generalized maximum value) distribution (<code>GEV(c)</code>)</strong>&dagger;: <code>(pow(Expo(1), -c) - 1) / c</code> if <code>c != 0</code>, or <code>-ln(Expo(1))</code> otherwise, where <code>c</code> is a shape parameter. Special cases:

<ul>
<li>The negative of the result expresses a generalized minimum value.  In this case, a parameter of <code>c = 0</code> results in a <em>Gumbel distribution</em>.</li>
<li>A parameter of <code>c = 0</code> results in an <em>extreme value distribution</em>.</li>
<li><strong>Weibull distribution</strong>: <code>1 - 1.0/a * GEV(-1.0/a)</code> (or <code>pow(Expo(1), 1.0/a)</code>), where <code>a</code> is a shape parameter.</li>
<li><strong>Fr&eacute;chet distribution</strong>: <code>1 + 1.0/a * GEV(1.0/a)</code> (or <code>pow(Expo(1), -1.0/a)</code>), where <code>a</code> is a shape parameter.</li>
</ul></li>
<li><strong>Generalized Tukey lambda distribution</strong>: <code>(s1 * (pow(x, lamda1)-1.0)/lamda1 - s2 * (pow(1.0-x, lamda2)-1.0)/lamda2) + loc</code>, where <code>x</code> is <code>RNDU01()</code>, <code>lamda1</code> and <code>lamda2</code> are shape parameters, <code>s1</code> and <code>s2</code> are scale parameters, and <code>loc</code> is a location parameter.</li>
<li><strong>Half-normal distribution</strong>. Parameterizations include:

<ul>
<li><em>Mathematica</em>: <code>abs(Normal(0, sqrt(pi * 0.5) / invscale)))</code>, where <code>invscale</code> is a parameter of the half-normal distribution.</li>
<li>MATLAB: <code>abs(Normal(mu, sigma)))</code>, where <code>mu</code> and <code>sigma</code> are the underlying normal distribution&#39;s parameters.</li>
</ul></li>
<li><strong>Hyperexponential distribution</strong>: See <a href="#Mixtures_of_Distributions"><strong>Mixtures of Distributions</strong></a>.</li>
<li><strong>Hypergeometric distribution</strong>: See <a href="#Hypergeometric_Distribution"><strong>Hypergeometric Distribution</strong></a>.</li>
<li><strong>Hypoexponential distribution</strong>: See <a href="#Transformations_of_Random_Numbers"><strong>Transformations of Random Numbers</strong></a>.</li>
<li><strong>Inverse chi-squared distribution</strong>&dagger;: <code>df / (GammaDist(df * 0.5, 2))</code>, where <code>df</code> is the number of degrees of freedom.  The scale parameter (<code>sigma</code>) is usually <code>1.0 / df</code>.</li>
<li><strong>Inverse Gaussian distribution (Wald distribution)</strong>: Generate <code>n = mu + (mu*mu*y/(2*lamda)) - mu * sqrt(4 * mu * lamda * y + mu * mu * y * y) / (2 * lamda)</code>, where <code>y = pow(Normal(0, 1), 2)</code>, then return <code>n</code> if <code>RNDU01OneExc() &lt;= mu / (mu + n)</code>, or <code>mu * mu / n</code> otherwise. <code>mu</code> is the mean and <code>lamda</code> is the scale; both parameters are greater than 0. Based on method published in (Devroye 1986)<sup><a href="#Note13"><strong>(13)</strong></a></sup>.</li>
<li><strong><code>k</code>th-order statistic distribution</strong>: <code>BetaDist(k, n+1-k)</code>. Returns the <code>k</code>th smallest out of <code>n</code> uniform random numbers. See also (Devroye 1986, p. 210)<sup><a href="#Note13"><strong>(13)</strong></a></sup>.</li>
<li><strong>Kumaraswamy distribution</strong>&#x2b26;: <code>pow(1-pow(RNDU01ZeroExc(),1.0/b),1.0/a)</code>, where <code>a</code> and <code>b</code> are shape parameters.</li>
<li><strong>Landau distribution</strong>: See stable distribution.</li>
<li><strong>L&eacute;vy distribution</strong>&dagger;: <code>0.5 / GammaDist(0.5, 1)</code>.  The scale parameter (<code>sigma</code>) is also called dispersion.</li>
<li><strong>Logarithmic logistic distribution</strong>: See beta prime distribution.</li>
<li><strong>Logarithmic series distribution</strong>: Generate <code>n = NegativeBinomialInt(1, py - px, py)+1</code> (where <code>px</code>/<code>py</code> is a parameter in (0,1)), then return <code>n</code> if <code>ZeroOrOne(1, n) == 1</code>, or repeat this process otherwise (Flajolet et al., 2010)<sup><a href="#Note9"><strong>(9)</strong></a></sup>.  If the application can trade accuracy for speed, the following can be used instead: <code>floor(1.0 - Expo(log1p(-pow(1.0 - p, RNDU01ZeroOneExc()))))</code>, where <code>p</code> is the parameter in (0, 1); see (Devroye 1986)<sup><a href="#Note13"><strong>(13)</strong></a></sup>.</li>
<li><strong>Logistic distribution</strong>&dagger;: <code>(ln(x)-log1p(-x))</code> (<a href="http://timvieira.github.io/blog/post/2016/07/04/fast-sigmoid-sampling/"><strong><em>logit function</em></strong></a>), where <code>x</code> is <code>RNDU01ZeroOneExc()</code>.</li>
<li><strong>Log-multinormal distribution</strong>: See <a href="#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Max-of-uniform distribution</strong>: <code>BetaDist(n, 1)</code>.  Returns a number that simulates the largest out of <code>n</code> uniform random numbers.  See also (Devroye 1986, p. 675)<sup><a href="#Note13"><strong>(13)</strong></a></sup>.</li>
<li><strong>Maxwell distribution</strong>&dagger;: <code>sqrt(GammaDist(1.5, 2))</code>.</li>
<li><strong>Min-of-uniform distribution</strong>: <code>BetaDist(1, n)</code>.  Returns a number that simulates the smallest out of <code>n</code> uniform random numbers.  See also (Devroye 1986, p. 210)<sup><a href="#Note13"><strong>(13)</strong></a></sup>.</li>
<li><strong>Moyal distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Multinomial distribution</strong>: See <a href="#Multinomial_Distribution"><strong>Multinomial Distribution</strong></a>.</li>
<li><strong>Multivariate Poisson distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Multivariate <em>t</em>-copula</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Multivariate <em>t</em>-distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Negative binomial distribution</strong> (<code>NegativeBinomial(successes, p)</code>): See <a href="#Negative_Binomial_Distribution"><strong>Negative Binomial Distribution</strong></a>.  The negative binomial distribution can take a <code>successes</code> value other than an integer; in that case, a negative binomial (<code>successes</code>, <code>p</code>) random number is <code>Poisson(GammaDist(successes, (1 - p) / p))</code>.</li>
<li><strong>Negative multinomial distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Noncentral beta distribution</strong>&#x2b26;: <code>BetaDist(a + Poisson(nc), b)</code>, where <code>nc</code> (a noncentrality), <code>a</code>, and <code>b</code> are greater than 0.</li>
<li><strong>Parabolic distribution</strong>&#x2b26;: <code>BetaDist(2, 2)</code> (Saucier 2000, p. 30).</li>
<li><strong>Pascal distribution</strong>: <code>NegativeBinomial(successes, p) + successes</code>, where <code>successes</code> and <code>p</code> have the same meaning as in the negative binomial distribution, except <code>successes</code> is always an integer.</li>
<li><strong>Pearson VI distribution</strong>: <code>GammaDist(v, 1) / GammaDist(w, 1)</code>, where <code>v</code> and <code>w</code> are shape parameters greater than 0 (Saucier 2000, p. 33; there, an additional <code>b</code> parameter is defined, but that parameter is canceled out in the source code).</li>
<li><strong>Piecewise constant distribution</strong>: See <a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a>.</li>
<li><strong>Piecewise linear distribution</strong>: See <a href="#Continuous_Weighted_Choice"><strong>Continuous Weighted Choice</strong></a>.</li>
<li><strong>P&oacute;lya&ndash;Aeppli distribution</strong>: See <a href="#Transformations_of_Random_Numbers_Additional_Examples"><strong>Transformations of Random Numbers: Additional Examples</strong></a>.</li>
<li><strong>Power distribution</strong>: <code>BetaDist(alpha, 1) / b</code>, where <code>alpha</code>  is the shape and <code>b</code> is the domain.  Nominally in the interval (0, 1).</li>
<li><strong>Power law distribution</strong>: <code>pow(RNDRANGE(pow(mn,n+1),pow(mx,n+1)), 1.0 / (n+1))</code>, where <code>n</code>  is the exponent, <code>mn</code> is the minimum, and <code>mx</code> is the maximum.  <a href="http://mathworld.wolfram.com/RandomNumber.html"><strong>Reference</strong></a>.</li>
<li><strong>Power lognormal distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Power normal distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Product copula</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Rice distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Rice&ndash;Norton distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Singh&ndash;Maddala distribution</strong>: See beta prime distribution.</li>
<li><strong>Skellam distribution</strong>: <code>Poisson(mean1) - Poisson(mean2)</code>, where <code>mean1</code> and <code>mean2</code> are the means of the two Poisson random numbers.</li>
<li><strong>Skewed normal distribution</strong>: <code>Normal(0, x) + mu + alpha * abs(Normal(0, x))</code>, where <code>x</code> is <code>sigma / sqrt(alpha * alpha + 1.0)</code>, <code>mu</code> and <code>sigma</code> have the same meaning as in the normal distribution, and <code>alpha</code> is a shape parameter.</li>
<li><strong>Snedecor&#39;s (Fisher&#39;s) <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5, n) / (GammaDist(n * 0.5 + Poisson(sms * 0.5)) * m, 1)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random numbers with a chi-squared distribution, and if <code>sms</code> is other than 0, one of those distributions is <em>noncentral</em> with sum of mean squares equal to <code>sms</code>.</li>
<li><strong>Stable distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Stable_Distribution"><strong>Stable Distribution</strong></a>. <em>Four-parameter stable distribution</em>: <code>Stable(alpha, beta) * sigma + mu</code>, where <code>mu</code> is the mean and <code>sigma</code> is the scale; if <code>alpha</code> and <code>beta</code> are 1, the result is a <em>Landau distribution</em>.  <em>&quot;Type 0&quot; stable distribution</em>: <code>Stable(alpha, beta) * sigma + (mu - sigma * beta * x)</code>, where <code>x</code> is <code>ln(sigma)*2.0/pi</code> if <code>alpha</code> is 1, and <code>tan(pi*0.5*alpha)</code> otherwise.</li>
<li><strong>Standard complex normal distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Suzuki distribution</strong>: See Rayleigh distribution.</li>
<li><strong>Tukey lambda distribution</strong>: <code>(pow(x, lamda)-pow(1.0-x,lamda))/lamda</code>, where <code>x</code> is <code>RNDU01()</code> and <code>lamda</code> is a shape parameter.</li>
<li><strong>Twin-<em>t</em> distribution</strong> (Baker and Jackson 2018)<sup><a href="#Note72"><strong>(72)</strong></a></sup>: Generate <code>x</code>, a random Student&#39;s <em>t</em>-distributed number (not a noncentral one).  Accept <code>x</code> if <code>RNDU01OneExc() &lt; pow((1 + y) / ((1 + y * y) + y), (df + 1) * 0.5)</code>, where <code>y = x * x / df</code> and <code>df</code> is the degrees of freedom used to generate the number; repeat this process otherwise.</li>
<li><strong>von Mises distribution</strong>: See <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomnotes.md#von_Mises_Distribution"><strong>von Mises Distribution</strong></a>.</li>
<li><strong>Waring&ndash;Yule distribution</strong>: See beta negative binomial distribution.</li>
<li><strong>Wigner (semicircle) distribution</strong>&dagger;: <code>(BetaDist(1.5, 1.5)*2-1)</code>.  The scale parameter (<code>sigma</code>) is the semicircular radius.</li>
<li><strong>Yule&ndash;Simon distribution</strong>: See beta negative binomial distribution.</li>
<li><strong>Zeta distribution</strong>: Generate <code>n = floor(pow(RNDU01ZeroOneExc(), -1.0 / r))</code>, and if <code>d / pow(2, r) &lt; (d - 1) * RNDU01OneExc() * n / (pow(2, r) - 1.0)</code>, where <code>d = pow((1.0 / n) + 1, r)</code>, repeat this process. The parameter <code>r</code> is greater than 0. Based on method described in (Devroye 1986)<sup><a href="#Note13"><strong>(13)</strong></a></sup>. A zeta distribution <a href="#Rejection_Sampling"><strong>truncated</strong></a> by rejecting random values greater than some positive integer is called a <em>Zipf distribution</em> or <em>Estoup distribution</em>. (Note that Devroye uses &quot;Zipf distribution&quot; to refer to the untruncated zeta distribution.)</li>
<li><strong>Zipf distribution</strong>: See zeta distribution.</li>
</ul>

<p></small></p>

<p><a id=Geometric_Sampling></a></p>

<h3>Geometric Sampling</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>This section contains ways to choose independent uniform random points in or on geometric shapes.</p>

<p><a id=Random_Points_Inside_a_Box></a></p>

<h4>Random Points Inside a Box</h4>

<p>To generate a random point inside an N-dimensional box, generate <code>RNDRANGEMaxExc(mn, mx)</code> for each coordinate, where <code>mn</code> and <code>mx</code> are the lower and upper bounds for that coordinate.  For example&mdash;</p>

<ul>
<li>to generate a random point inside a rectangle bounded in [0, 2) along the X axis and [3, 6) along the Y axis, generate <code>[RNDRANGEMaxExc(0,2), RNDRANGEMaxExc(3,6)]</code>, and</li>
<li>to generate a <em>complex number</em> with real and imaginary parts bounded in [0, 1], generate <code>[RNDRANGE(0, 1), RNDRANGE(0, 1)]</code>.</li>
</ul>

<p><a id=Random_Points_Inside_a_Simplex></a></p>

<h4>Random Points Inside a Simplex</h4>

<p>The following pseudocode generates a random point inside an <em>n</em>-dimensional simplex (simplest convex figure, such as a line segment, triangle, or tetrahedron).  It takes one parameter, <em>points</em>, a list consisting of the <em>n</em> plus one vertices of the simplex, all of a single dimension <em>n</em> or greater. See also (Grimme 2015)<sup><a href="#Note73"><strong>(73)</strong></a></sup>, which shows MATLAB code for generating a random point uniformly inside a simplex just described, but in a different way.</p>

<pre>METHOD RandomPointInSimplex(points):
   ret=NewList()
   if size(points) &gt; size(points[0])+1: return error
   if size(points)==1 // Return a copy of the point
     for i in 0...size(points[0]): AddItem(ret,points[0][i])
     return ret
   end
   gammas=NewList()
   // Sample from a Dirichlet distribution
   for i in 0...size(points): AddItem(gammas, Expo(1))
   tsum=0
   for i in 0...size(gammas): tsum = tsum + gammas[i]
   tot = 0
   for i in 0...size(gammas) - 1
       gammas[i] = gammas[i] / tsum
       tot = tot + gammas[i]
   end
   tot = 1.0 - tot
   for i in 0...size(points[0]): AddItem(ret, points[0][i]*tot)
   for i in 1...size(points)
      for j in 0...size(points[0])
         ret[j]=ret[j]+points[i][j]*gammas[i-1]
      end
   end
   return ret
END METHOD
</pre>

<p><a id=Random_Points_on_the_Surface_of_a_Hypersphere></a></p>

<h4>Random Points on the Surface of a Hypersphere</h4>

<p>The following pseudocode shows how to generate a random N-dimensional point on the surface of an N-dimensional hypersphere, centered at the origin, of radius <code>radius</code> (if <code>radius</code> is 1, the result can also serve as a unit vector in N-dimensional space).  Here, <code>Norm</code> is given in the appendix.  See also (Weisstein)<sup><a href="#Note74"><strong>(74)</strong></a></sup>.</p>

<pre>METHOD RandomPointInHypersphere(dims, radius)
  x=0
  while x==0
    ret=[]
    for i in 0...dims: AddItem(ret, Normal(0, 1))
    x=Norm(ret)
  end
  invnorm=radius/x
  for i in 0...dims: ret[i]=ret[i]*invnorm
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains an optimized method for points on the edge of a circle.</p>

<p><strong>Example:</strong> To generate a random point on the surface of a cylinder running along the Z axis, generate random X and Y coordinates on the edge of a circle (2-dimensional hypersphere) and generate a random Z coordinate by <code>RNDRANGE(mn, mx)</code>, where <code>mn</code> and <code>mx</code> are the highest and lowest Z coordinates possible.</p>
</blockquote>

<p><a id=Random_Points_Inside_a_Ball_Shell_or_Cone></a></p>

<h4>Random Points Inside a Ball, Shell, or Cone</h4>

<p>To generate a random N-dimensional point on or inside an N-dimensional ball, centered at the origin, of radius R, either&mdash;</p>

<ul>
<li>generate a random (N+2)-dimensional point on the surface of an (N+2)-dimensional hypersphere with that radius (e.g., using <code>RandomPointInHypersphere</code>), then discard the last two coordinates (Voelker et al., 2017)<sup><a href="#Note75"><strong>(75)</strong></a></sup>, or</li>
<li>follow the pseudocode in <code>RandomPointInHypersphere</code>, except replace <code>Norm(ret)</code> with <code>sqrt(S + Expo(1))</code>, where <code>S</code> is the sum of squares of the numbers in <code>ret</code>.</li>
</ul>

<p>To generate a random point on or inside an N-dimensional spherical shell (a hollow ball), centered at the origin, with inner radius A and outer radius B (where A is less than B), either&mdash;</p>

<ul>
<li>generate a random point for a ball of radius B until the norm of that point is A or greater (see the <a href="#Appendix"><strong>appendix</strong></a>), or</li>
<li>generate a random point on the surface of an N-dimensional hypersphere with radius equal to <code>pow(RNDRANGE(pow(A, N), pow(B, N)), 1.0 / N)</code><sup><a href="#Note76"><strong>(76)</strong></a></sup>.</li>
</ul>

<p>To generate a random point on or inside a cone with height <code>H</code> and radius <code>R</code> at its base, running along the Z axis, generate a random Z coordinate by <code>Z = max(max(RNDRANGE(0, H), RNDRANGE(0, H)), RNDRANGE(0, H))</code>, then generate random X and Y coordinates inside a disc (2-dimensional ball) with radius equal to <code>max(RNDRANGE(0,R*Z/H), RNDRANGE(0,R*Z/H))</code><sup><a href="#Note77"><strong>(77)</strong></a></sup>.</p>

<blockquote>
<p><strong>Example:</strong> To generate a random point inside a cylinder running along the Z axis, generate random X and Y coordinates inside a disc (2-dimensional ball) and generate a random Z coordinate by <code>RNDRANGE(mn, mx)</code>, where <code>mn</code> and <code>mx</code> are the highest and lowest Z coordinates possible.</p>

<p><strong>Note:</strong> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains a method for generating a random point on the surface of an ellipsoid modeling the Earth.</p>
</blockquote>

<p><a id=Random_Latitude_and_Longitude></a></p>

<h4>Random Latitude and Longitude</h4>

<p>To generate a random point on the surface of a sphere in the form of a latitude and longitude (in radians with west and south coordinates negative)<sup><a href="#Note78"><strong>(78)</strong></a></sup>&mdash;</p>

<ul>
<li>generate the longitude <code>RNDRANGEMaxExc(-pi, pi)</code>, where the longitude is in the interval [-&pi;, &pi;), and</li>
<li>generate the latitude <code>atan2(sqrt(1 - x * x), x) - pi / 2</code>, where <code>x = RNDRANGE(-1, 1)</code> and the latitude is in the interval [-&pi;/2, &pi;/2] (the interval excludes the poles, which have many equivalent forms; if poles are not desired, generate <code>x</code> until neither -1 nor 1 is generated this way).</li>
</ul>

<p><a id=Acknowledgments></a></p>

<h2>Acknowledgments</h2>

<p>I acknowledge the commenters to the CodeProject version of this page, including George Swan, who referred me to the reservoir sampling method.</p>

<p>I also acknowledge Christoph Conrads, who gave suggestions in parts of this article.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> For the definition of an RNG, it is irrelevant&mdash;</p>

<ul>
<li>how hard it is to predict the numbers the item produces,</li>
<li>how well the item passes statistical randomness tests,</li>
<li>whether the item is initialized automatically or not,</li>
<li>whether the item uses only its input and its state to produce numbers, or</li>
<li>whether the item extracts random bits from one or more noise sources.</li>
</ul>

<p>If the generator produces numbers with unequal probabilities, but is otherwise an RNG as defined here, then  <em>randomness extraction</em> (which is outside the scope of this document) can make it produce numbers with closer to equal probabilities.</small></p>

<p><small><sup id=Note2>(2)</sup> Pedersen, K., &quot;<a href="https://arxiv.org/abs/1704.07949v3"><strong>Reconditioning your quantile function</strong></a>&quot;, arXiv:1704.07949v3 [stat.CO], 2018.</small></p>

<p><small><sup id=Note3>(3)</sup> For an exercise solved by the <code>RNDINT</code> pseudocode, see A. Koenig and B. E. Moo, <em>Accelerated C++</em>, 2000; see also a <a href="http://mathalope.co.uk/2014/10/26/accelerated-c-solution-to-exercise-7-9/"><strong>blog post by Johnny Chan</strong></a>.  In addition, M. O&#39;Neill discusses various methods, both biased and unbiased, for generating random integers in a range with an RNG in a <a href="http://www.pcg-random.org/posts/bounded-rands.html"><strong>blog post from July 2018</strong></a>.  Finally, a post in the Math Forum (&quot;<a href="http://mathforum.org/library/drmath/view/65653.html"><strong>Probability and Random Numbers</strong></a>&quot;, Feb. 29, 2004) and Mennucci, A.C.G., &quot;<a href="https://arxiv.org/abs/1012.4290"><strong>Bit Recycling for Scaling Random Number Generators</strong></a>&quot;, arXiv:1012.4290 [cs.IT], 2018, independently show a method for batching and recycling random bits to produce random integers in a range.</small></p>

<p><small><sup id=Note4>(4)</sup> D. Lemire, &quot;A fast alternative to the modulo reduction&quot;, Daniel Lemire&#39;s blog, 2016.</small></p>

<p><small><sup id=Note5>(5)</sup> Lumbroso, J., &quot;<a href="https://arxiv.org/abs/1304.1916"><strong>Optimal Discrete Uniform Generation from Coin Flips, and Applications</strong></a>&quot;, arXiv:1304.1916 [cs.DS].</small></p>

<p><small><sup id=Note6>(6)</sup> A na&iuml;ve <code>RNDINTEXC</code> implementation often seen in certain languages like JavaScript is the idiom <code>floor(Math.random() * maxExclusive)</code>, where <code>Math.random()</code> is any method that outputs an independent uniform random number in the interval [0, 1).  However, no implementation of <code>Math.random()</code> can choose from all real numbers in [0, 1), so this idiom can bias some results over others depending on the value of <code>maxExclusive</code>.  For example, if <code>Math.random()</code> is implemented as <code>RNDINT(X - 1)/X</code> and <code>X</code> is not divisible by <code>maxExclusive</code>, the result will be biased.  Also, an implementation might pre-round <code>Math.random() * maxExclusive</code> (before the <code>floor</code>) to the closest number it can represent; in rare cases, that might be <code>maxExclusive</code> for certain rounding modes. If an application is concerned about these issues, it should treat the <code>Math.random()</code> implementation as the underlying RNG for <code>RNDINT</code> and implement <code>RNDINTEXC</code> through <code>RNDINT</code> instead.</small></p>

<p><small><sup id=Note7>(7)</sup> Canonne, C., Kamath, G., Steinke, T., &quot;<a href="https://arxiv.org/abs/2004.00010v2"><strong>The Discrete Gaussian for Differential Privacy</strong></a>&quot;, arXiv:2004.00010v2 [cs.DS], 2020.</small></p>

<p><small><sup id=Note8>(8)</sup> Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A  Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994.</small></p>

<p><small><sup id=Note9>(9)</sup> Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560v2"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560v2  [math.PR], 2010.</small></p>

<p><small><sup id=Note10>(10)</sup> Jeff Atwood, &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/"><strong>The danger of na&iuml;vet&eacute;</strong></a>&quot;, Dec. 7, 2007.</small></p>

<p><small><sup id=Note11>(11)</sup> Bacher, A., Bodini, O., et al., &quot;<a href="https://arxiv.org/abs/1508.03167"><strong>MergeShuffle: A Very Fast, Parallel Random Permutation Algorithm</strong></a>&quot;, arXiv:1508.03167 [cs.DS], 2015.</small></p>

<p><small><sup id=Note12>(12)</sup> If the strings identify database records, file system paths, or other shared resources, special considerations apply, including the need to synchronize access to those resources.  For uniquely identifying database records, alternatives to random strings include auto-incrementing or sequentially assigned row numbers. The choice of underlying RNG is important when it comes to unique random strings; see my <a href="https://peteroupc.github.io/random.html#Unique_Random_Identifiers"><strong>RNG recommendation document</strong></a>.</small></p>

<p><small><sup id=Note13>(13)</sup> Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</small></p>

<p><small><sup id=Note14>(14)</sup> See also the <em>Stack Overflow</em> question &quot;Random index of a non zero value in a numpy array&quot;.</small></p>

<p><small><sup id=Note15>(15)</sup> S. Linderman, &quot;A Parallel Gamma Sampling Implementation&quot;, Laboratory for Independent Probabilistic Systems Blog, Feb. 21, 2013, illustrates one example, a GPU-implemented sampler of gamma-distributed random numbers.</small></p>

<p><small><sup id=Note16>(16)</sup> Brownlee, J. &quot;<a href="https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/"><strong>A Gentle Introduction to the Bootstrap Method</strong></a>&quot;, <em>Machine Learning Mastery</em>, May 25, 2018.</small></p>

<p><small><sup id=Note17>(17)</sup> Propp, J.G., Wilson, D.B., &quot;Exact sampling with coupled Markov chains and applications to statistical mechanics&quot;, 1996.</small></p>

<p><small><sup id=Note18>(18)</sup> E. N. Gilbert, &quot;Random Graphs&quot;, <em>Annals of Mathematical Statistics</em> 30(4), 1959.</small></p>

<p><small><sup id=Note19>(19)</sup> V. Batagelj and U. Brandes, &quot;Efficient generation of large random networks&quot;, Phys.Rev. E 71:036113, 2005.</small></p>

<p><small><sup id=Note20>(20)</sup> Penschuck, M., et al., &quot;<a href="https://arxiv.org/abs/2003.00736v1"><strong>Recent Advances in Scalable Network Generation</strong></a>&quot;, arXiv:2003.00736v1  [cs.DS], 2020.</small></p>

<p><small><sup id=Note21>(21)</sup> Jon Louis Bentley and James B. Saxe, &quot;Generating Sorted Lists of Random Numbers&quot;, <em>ACM Trans. Math. Softw.</em> 6 (1980), pp. 359-364, describes a way to generate random numbers in sorted order, but it&#39;s not given here because it relies on generating real numbers in the interval [0, 1], which is inherently imperfect because computers can&#39;t choose among all random numbers between 0 and 1, and there are infinitely many of them.</small></p>

<p><small><sup id=Note22>(22)</sup> Efraimidis, P. and Spirakis, P. &quot;<a href="http://utopia.duth.gr/%7Epefraimi/research/data/2007EncOfAlg.pdf"><strong>Weighted Random Sampling (2005; Efraimidis, Spirakis)</strong></a>&quot;, 2005.</small></p>

<p><small><sup id=Note23>(23)</sup> Efraimidis, P. &quot;<a href="https://arxiv.org/abs/1012.0256v2"><strong>Weighted Random Sampling over Data Streams</strong></a>&quot;, arXiv:1012.0256v2 [cs.DS], 2015.</small></p>

<p><small><sup id=Note24>(24)</sup> T. Vieira, &quot;<a href="http://timvieira.github.io/blog/post/2014/08/01/gumbel-max-trick-and-weighted-reservoir-sampling/"><strong>Gumbel-max trick and weighted reservoir sampling</strong></a>&quot;, 2014.</small></p>

<p><small><sup id=Note25>(25)</sup> T. Vieira, &quot;<a href="https://timvieira.github.io/blog/post/2019/06/11/faster-reservoir-sampling-by-waiting/"><strong>Faster reservoir sampling by waiting</strong></a>&quot;, 2019.</small></p>

<p><small><sup id=Note26>(26)</sup> Duffield, N., Lund, C., Thorup, M., &quot;Priority sampling for estimation of arbitrary subset sums&quot;, October 2007.</small></p>

<p><small><sup id=Note27>(27)</sup> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> includes a <code>ConvexPolygonSampler</code> class that implements this kind of sampling for convex polygons; unlike other polygons, convex polygons are trivial to decompose into triangles.</small></p>

<p><small><sup id=Note28>(28)</sup> That article also mentions a critical-hit distribution, which is actually a <a href="#Mixtures_of_Distributions"><strong>mixture</strong></a> of two distributions: one roll of dice and the sum of two rolls of dice.</small></p>

<p><small><sup id=Note29>(29)</sup> An <em>affine transformation</em> is one that keeps straight lines straight and parallel lines parallel.</small></p>

<p><small><sup id=Note30>(30)</sup> Farach-Colton, M. and Tsai, M.T., 2015. Exact sublinear binomial sampling. <em>Algorithmica</em> 73(4), pp. 637-651.</small></p>

<p><small><sup id=Note31>(31)</sup> von Neumann, J., &quot;Various techniques used in connection with random digits&quot;, 1951.</small></p>

<p><small><sup id=Note32>(32)</sup> Karney, C.F.F., &quot;<a href="https://arxiv.org/abs/1303.6257v2"><strong>Sampling exactly from the normal distribution</strong></a>&quot;, arXiv:1303.6257v2  [physics.comp-ph], 2014.</small></p>

<p><small><sup id=Note33>(33)</sup> Smith and Tromble, &quot;<a href="http://www.cs.cmu.edu/%7Enasmith/papers/smith+tromble.tr04.pdf"><strong>Sampling Uniformly from the Unit Simplex</strong></a>&quot;, 2004.</small></p>

<p><small><sup id=Note34>(34)</sup> Durfee, et al., &quot;l1 Regression using Lewis Weights Preconditioning and Stochastic Gradient Descent&quot;, <em>Proceedings of Machine Learning Research</em> 75(1), 2018.</small></p>

<p><small><sup id=Note35>(35)</sup> The NVIDIA white paper &quot;<a href="https://docs.nvidia.com/cuda/floating-point/"><strong>Floating Point and IEEE 754 Compliance for NVIDIA GPUs</strong></a>&quot;,
and &quot;<a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/"><strong>Floating-Point Determinism</strong></a>&quot; by Bruce Dawson, discuss issues with non-integer numbers in much more detail.</small></p>

<p><small><sup id=Note36>(36)</sup> Note that <code>RNDU01OneExc()</code> corresponds to <code>Math.random()</code> in Java and JavaScript.</small></p>

<p><small><sup id=Note37>(37)</sup> This includes integers if <code>e</code> is limited to 0, and fixed-point numbers if <code>e</code> is limited to a single exponent less than 0.</small></p>

<p><small><sup id=Note38>(38)</sup> Downey, A. B. &quot;<a href="http://allendowney.com/research/rand/"><strong>Generating Pseudo-random Floating Point Values</strong></a>&quot;, 2007.</small></p>

<p><small><sup id=Note39>(39)</sup> Ideally, <code>X</code> is the highest integer <code>p</code> such that all multiples of <code>1/p</code> in the interval [0, 1] are representable in the number format in question.  For example, <code>X</code> is 2^53 (9007199254740992) for binary64, and 2^24 (16777216) for binary32.</small></p>

<p><small><sup id=Note40>(40)</sup> Goualard, F., &quot;<a href="https://hal.archives-ouvertes.fr/hal-02427338/"><strong>Generating Random Floating-Point Numbers by Dividing Integers: a Case Study</strong></a>&quot;, 2020.</small></p>

<p><small><sup id=Note41>(41)</sup> Monahan, J.F., &quot;Accuracy in Random Number Generation&quot;, <em>Mathematics of Computation</em> 45(172), 1985.</small></p>

<p><small><sup id=Note42>(42)</sup> Spall, J.C., &quot;An Overview of the Simultaneous Perturbation Method for Efficient Optimization&quot;, <em>Johns Hopkins APL Technical Digest</em> 19(4), 1998, pp. 482-492.</small></p>

<p><small><sup id=Note43>(43)</sup> P. L&#39;Ecuyer, &quot;Tables of Linear Congruential Generators of Different Sizes and Good Lattice Structure&quot;, <em>Mathematics of Computation</em> 68(225), January 1999, with <a href="http://www.iro.umontreal.ca/%7Elecuyer/myftp/papers/latrules99Errata.pdf"><strong>errata</strong></a>.</small></p>

<p><small><sup id=Note44>(44)</sup> Harase, S., &quot;<a href="https://arxiv.org/abs/2002.09006"><strong>A table of short-period Tausworthe generators for Markov chain quasi-Monte Carlo</strong></a>&quot;, arXiv:2002.09006 [math.NA], 2020.</small></p>

<p><small><sup id=Note45>(45)</sup> Brassard, G., Devroye, L., Gravel, C., &quot;Exact Classical Simulation of the Quantum-Mechanical GHZ Distribution&quot;, <em>IEEE Transactions on Information Theory</em> 62(2), February 2016.  Note that that paper defines a Bernoulli trial as 0 for success and 1 for failure, rather than the other way around, as in this document.</small></p>

<p><small><sup id=Note46>(46)</sup> D. Revuz, M. Yor, &quot;Continuous Martingales and Brownian Motion&quot;, 1999.</small></p>

<p><small><sup id=Note47>(47)</sup> Alexopoulos, Goldsman, &quot;<a href="https://www2.isye.gatech.edu/%7Esman/courses/6644/Module07-RandomVariateGenerationSlides_171116.pdf"><strong>Random Variate Generation</strong></a>&quot;, 2017.</small></p>

<p><small><sup id=Note48>(48)</sup> Saucier, R. &quot;Computer Generation of Statistical Distributions&quot;, March 2000.</small></p>

<p><small><sup id=Note49>(49)</sup> Other references on density estimation include <a href="https://en.wikipedia.org/wiki/Multivariate_kernel_density_estimation"><strong>a Wikipedia article on multiple-variable kernel density estimation</strong></a>, and a <a href="https://web.archive.org/web/20160501200206/http://mark-kay.net/2013/12/24/kernel-density-estimation"><strong>blog post by M. Kay</strong></a>.</small></p>

<p><small><sup id=Note50>(50)</sup> &quot;Jitter&quot;, as used in this step, follows a distribution formally called a <em>kernel</em>, of which the normal distribution is one example.  <em>Bandwidth</em> should be set so that the estimated distribution fits the data and remains smooth.  A more complex kind of &quot;jitter&quot; (for multi-component data points) consists of a point generated from a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution"><strong>multinormal distribution</strong></a> with all the means equal to 0 and a <em>covariance matrix</em> that, in this context, serves as a <em>bandwidth matrix</em>.  &quot;Jitter&quot; and bandwidth are not further discussed in this document.</small></p>

<p><small><sup id=Note51>(51)</sup> More formally&mdash;</p>

<ul>
<li>the PDF is the <em>derivative</em> (instantaneous rate of change) of the distribution&#39;s CDF (that is, PDF(x) = CDF&prime;(x)), and</li>
<li>the CDF is also defined as the <em>integral</em> (&quot;area under the curve&quot;) of the PDF,</li>
</ul>

<p>provided the PDF&#39;s values are all 0 or greater and the area under the PDF&#39;s curve is 1.</small></p>

<p><small><sup id=Note52>(52)</sup> A <em>discrete distribution</em> is a distribution that associates one or more items with a separate probability. This page assumes (without loss of generality) that these items are integers.  A discrete distribution can produce non-integer values (e.g., <code>x/y</code> with probability <code>x/(1+y)</code>) as long as the values can be converted to and from integers. Two examples:</p>

<ul>
<li>A rational number in lowest terms can be converted to an integer by interleaving the bits of the numerator and denominator.</li>
<li>Integer-quantized numbers (popular in &quot;deep-learning&quot; neural networks) take a relatively small number of bits (usually 8 bits or even smaller).  An 8-bit quantized number format is effectively a &quot;look-up table&quot; that maps 256 integers to real numbers.</small></li>
</ul>

<p><small><sup id=Note53>(53)</sup> This includes integers if <code>FPExponent</code> is limited to 0, and fixed-point numbers if <code>FPExponent</code> is limited to a single exponent less than 0.</small></p>

<p><small><sup id=Note54>(54)</sup> Based on a suggestion by F. Saad in a personal communication (Mar. 26, 2020).</small></p>

<p><small><sup id=Note55>(55)</sup> Saad, F.A., et al., &quot;<a href="https://arxiv.org/abs/2001.04555"><strong>Optimal Approximate Sampling from Discrete Probability Distributions</strong></a>&quot;, arXiv:2001.04555 [cs.DS], 2020.  See also the <a href="https://github.com/probcomp/optimal-approximate-sampling"><strong>associated source code</strong></a>.</small></p>

<p><small><sup id=Note56>(56)</sup> Devroye, L., Gravel, C., &quot;<a href="https://arxiv.org/abs/1502.02539v5"><strong>Sampling with arbitrary precision</strong></a>&quot;, arXiv:1502.02539v5 [cs.IT]</small></p>

<p><small><sup id=Note57>(57)</sup> Bringmann, K., and Friedrich, T., 2013, July. Exact and efficient generation of geometric random variates and random graphs, in <em>International Colloquium on Automata, Languages, and Programming</em> (pp. 267-278).</small></p>

<p><small><sup id=Note58>(58)</sup> Walter, M., &quot;Sampling the Integers with Low Relative Error&quot;, in <em>International Conference on Cryptology in Africa</em>, Jul. 2019, pp. 157-180.</small></p>

<p><small><sup id=Note59>(59)</sup> Devroye, L., &quot;Non-Uniform Random Variate Generation&quot;.  In <em>Handbooks in Operations Research and Management Science: Simulation</em>, Henderson, S.G., Nelson, B.L. (eds.), 2006, p.83.</small></p>

<p><small><sup id=Note60>(60)</sup> Nguyen, N. and Ökten, G., &quot;<a href="https://arxiv.org/abs/1403.5599v1"><strong>The acceptance-rejection method for low-discrepancy sequences</strong></a>&quot;, arXiv:1403.5599v1  [q-fin.CP], 2014; also in <em>Monte Carlo Methods and Applications</em> 22(2), pp. 133-148, 2016.</small></p>

<p><small><sup id=Note61>(61)</sup> Tran, K.H., &quot;<a href="https://arxiv.org/abs/1607.01985v5"><strong>A Common Derivation for Markov Chain Monte Carlo Algorithms with Tractable and Intractable Targets</strong></a>&quot;, arXiv:1607.01985v5 [stat.CO], 2018, gives a common framework for describing many MCMC algorithms, including Metropolis&ndash;Hastings, slice sampling, and Gibbs sampling.</small></p>

<p><small><sup id=Note62>(62)</sup> The <code>KVectorSampler</code> class uses algorithms described in Arnas, D., Leake, C., Mortari, D., &quot;Random Sampling using k-vector&quot;, <em>Computing in Science &amp; Engineering</em> 21(1) pp. 94-107, 2019, and Mortari, D., Neta, B., &quot;k-Vector Range Searching Techniques&quot;.</small></p>

<p><small><sup id=Note63>(63)</sup> Devroye, L., Gravel, C., &quot;<a href="https://arxiv.org/abs/1511.02273v2"><strong>The expected bit complexity of the von Neumann rejection algorithm</strong></a>&quot;, arXiv:1511.02273v2  [cs.IT], 2016/2018</small></p>

<p><small><sup id=Note64>(64)</sup> Sainudiin, Raazesh, and Thomas L. York. &quot;An Auto-Validating, Trans-Dimensional, Universal Rejection Sampler for Locally Lipschitz Arithmetical Expressions,&quot; <em>Reliable Computing</em> 18 (2013): 15-54.</small></p>

<p><small><sup id=Note65>(65)</sup> McGrath, E.J., Irving, D.C., &quot;Techniques for Efficient Monte Carlo Simulation, Volume II&quot;, Oak Ridge National Laboratory, April 1975.</small></p>

<p><small><sup id=Note66>(66)</sup> Devroye, L., &quot;Expected Time Analysis of a Simple Recursive Poisson Random Variate Generator&quot;, <em>Computing</em> 46, pp. 165-173, 1991.</small></p>

<p><small><sup id=Note67>(67)</sup> Giammatteo, P., and Di Mascio, T., &quot;Wilson-Hilferty-type approximation for Poisson Random Variable&quot;, <em>Advances in Science, Technology and Engineering Systems Journal</em> 5(2), 2020.</small></p>

<p><small><sup id=Note68>(68)</sup> Bailey, R.W., &quot;Polar generation of random variates with the t distribution&quot;, <em>Mathematics of Computation</em> 62 (1984).</small></p>

<p><small><sup id=Note69>(69)</sup> Kabal, P., &quot;Generating Gaussian Pseudo-Random Variates&quot;, McGill University, 2000/2019.</small></p>

<p><small><sup id=Note70>(70)</sup> Saha, M., et al., &quot;<a href="https://arxiv.org/abs/1909.01103"><strong>The extended xgamma distribution</strong></a>&quot;, arXiv:1909.01103 [math.ST], 2019.</small></p>

<p><small><sup id=Note71>(71)</sup> Sen, S., et al., &quot;The xgamma distribution: statistical properties and application&quot;, 2016.</small></p>

<p><small><sup id=Note72>(72)</sup> Baker, R., Jackson, D., &quot;<a href="https://arxiv.org/abs/1408.3237"><strong>A new distribution for robust least squares</strong></a>&quot;, arXiv:1408.3237 [stat.ME], 2018.</small></p>

<p><small><sup id=Note73>(73)</sup> Grimme, C., &quot;Picking a Uniformly Random Point from an Arbitrary Simplex&quot;, 2015.</small></p>

<p><small><sup id=Note74>(74)</sup> Weisstein, Eric W.  &quot;<a href="http://mathworld.wolfram.com/HyperspherePointPicking.html"><strong>Hypersphere Point Picking</strong></a>&quot;.  From MathWorld&mdash;A Wolfram Web Resource.</small></p>

<p><small><sup id=Note75>(75)</sup> Voelker, A.R., Gosmann, J., Stewart, T.C., &quot;Efficiently sampling vectors and coordinates from the <em>n</em>-sphere and <em>n</em>-ball&quot;, Jan. 4, 2017.</small></p>

<p><small><sup id=Note76>(76)</sup> See the <em>Mathematics Stack Exchange</em> question titled &quot;Random multivariate in hyperannulus&quot;, <code>questions/1885630</code>.</small></p>

<p><small><sup id=Note77>(77)</sup> See the <em>Stack Overflow</em> question &quot;Uniform sampling (by volume) within a cone&quot;, <code>questions/41749411</code>. Square and cube roots replaced with maximums.</small></p>

<p><small><sup id=Note78>(78)</sup> Reference: <a href="http://mathworld.wolfram.com/SpherePointPicking.html"><strong>&quot;Sphere Point Picking&quot;</strong></a> in MathWorld (replacing inverse cosine with <code>atan2</code> equivalent).</small></p>

<p><small><sup id=Note79>(79)</sup> Describing differences between SQL dialects is outside the scope of this document, but <a href="http://flourishlib.com/docs/FlourishSQL"><strong>Flourish SQL</strong></a> describes many such differences, including those concerning RNGs.</small></p>

<p><small><sup id=Note80>(80)</sup> Mironov, I., &quot;On Significance of the Least Significant Bits For Differential Privacy&quot;, 2012.</small></p>

<p><small><sup id=Note81>(81)</sup> For example, see Balcer, V., Vadhan, S., &quot;Differential Privacy on Finite Computers&quot;, Dec. 4, 2018; as well as Micciancio, D. and Walter, M., &quot;Gaussian sampling over the integers: Efficient, generic, constant-time&quot;, in Annual International Cryptology Conference, August 2017 (pp. 455-485).</small></p>

<p><small><sup id=Note82>(82)</sup> If those values are inexact floating-point numbers, their relative error will generally be smaller the closer they are to 0 (see also Walter, 2019).</small></p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Mean_and_Variance_Calculation></a></p>

<h3>Mean and Variance Calculation</h3>

<p>The following method calculates the mean and the <a href="http://mathworld.wolfram.com/Variance.html"><strong>bias-corrected sample variance</strong></a> of a list of real numbers, using the <a href="https://www.johndcook.com/blog/standard_deviation/"><strong>Welford method</strong></a> presented by J. D. Cook.  The method returns a two-item list containing the mean and that kind of variance in that order.  (Sample variance is the estimated variance of a population or distribution assuming <code>list</code> is a random sample of that population or distribution.)  The square root of the variance calculated here is what many APIs call a standard deviation (e.g. Python&#39;s <code>statistics.stdev</code>).</p>

<pre>METHOD MeanAndVariance(list)
    if size(list)==0: return [0, 0]
    if size(list)==1: return [list[0], 0]
    xm=list[0]
    xs=0
    i=1
    while i &lt; size(list)
        c = list[i]
        i = i + 1
        cxm = (c - xm)
        xm = xm + cxm *1.0/ i
        xs = xs + cxm * (c - xm)
    end
    return [xm, xs*1.0/(size(list)-1)]
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> The population variance (or biased sample variance) is found by dividing by <code>size(list)</code> rather than <code>(size(list)-1)</code>, and the standard deviation of the population or a sample of it is the square root of that variance.</p>
</blockquote>

<p><a id=Norm_Calculation></a></p>

<h3>Norm Calculation</h3>

<p>The following method calculates the norm of a vector (list of numbers).</p>

<pre>METHOD Norm(vec)
  ret=0
  rc=0
  for i in 0...size(vec)
    rc=vec[i]*vec[i]-rc
    rt=rc+ret
    rc=(rt-ret)-rc
    ret=rt
  end
  return sqrt(ret)
END METHOD
</pre>

<p><a id=Multithreading_Note></a></p>

<h3>Multithreading Note</h3>

<p>Multithreading can serve as a fast way to generate multiple random numbers at once; it is not reflected in the pseudocode given in this page.  In general, this involves dividing a block of memory into chunks, assigning each chunk to a thread, giving each thread its own RNG instance, and letting each thread fill its assigned chunk with random numbers.  For an example, see &quot;<a href="https://docs.scipy.org/doc/numpy/reference/random/multithreading.html"><strong>Multithreaded Generation</strong></a>&quot;.</p>

<p><a id=Implementation_Considerations></a></p>

<h3>Implementation Considerations</h3>

<ol>
<li><strong>Shell scripts and Microsoft Windows batch files</strong> are designed for running other programs, rather than general-purpose programming.  However, batch files and <code>bash</code> (a shell script interpreter) might support a variable which returns a random integer in the interval [0, 32767] (called <code>%RANDOM%</code> or <code>$RANDOM</code>, respectively); neither variable is designed for information security.</li>
<li><strong>Query languages such as SQL</strong> have no procedural elements such as loops and branches.  Moreover, standard SQL does not include an RNG in its suite of functionality, but popular SQL dialects often do &mdash; with idiosyncratic behavior.<sup><a href="#Note79"><strong>(79)</strong></a></sup></li>
</ol>

<p>Whenever possible, the methods in this document should be implemented in a more general-purpose programming language than query languages, shell scripts, and batch files, especially if information security is a goal.</p>

<p><a id=Security_Considerations></a></p>

<h3>Security Considerations</h3>

<p>If an application generates random numbers for information security purposes, such as to generate random passwords or encryption keys, the following applies:</p>

<ol>
<li><strong>Cryptographic RNG.</strong> The application has to use a cryptographic RNG.  Choosing a cryptographic RNG is outside the scope of this document.</li>
<li><strong>Timing attacks.</strong>  Certain security attacks have exploited timing and other differences to recover cleartext, encryption keys, or other sensitive data.  Thus, so-called &quot;constant-time&quot; security algorithms have been developed.  (In general, &quot;constant-time&quot; algorithms are designed to have no timing differences, including memory access patterns, that reveal anything about any secret inputs, such as keys, passwords, or RNG &quot;seeds&quot;).  Examples of &quot;constant-time&quot; algorithms can include a <code>RNDINT()</code> implementation that uses Montgomery reduction.  But even if an algorithm has variable running time (e.g., <a href="#Rejection_Sampling"><strong>rejection sampling</strong></a>), it may or may not have security-relevant timing differences, especially if it does not reuse secrets.</li>
<li><strong>Security algorithms out of scope.</strong> Security algorithms that take random secrets to generate random security parameters, such as encryption keys, public/private key pairs, elliptic curves, or points on an elliptic curve, are outside this document&#39;s scope.</li>
</ol>

<p>In nearly all security-sensitive applications, random numbers generated for security purposes are integers.  In very rare cases, they&#39;re fixed-point numbers.  Even with a secure random number generator, the use of random floating-point numbers can cause security issues not present with integers or fixed-point numbers; one example is found in (Mironov 2012)<sup><a href="#Note80"><strong>(80)</strong></a></sup>.  And even in the few security applications where random floating-point numbers are used (differential privacy and lattice-based cryptography), there are ways to avoid such random numbers<sup><a href="#Note81"><strong>(81)</strong></a></sup>.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
