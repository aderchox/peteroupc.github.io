<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generation Methods</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generation Methods</h1>

<p><a href="mailto:poccil14@gmail.com">Peter Occil</a></p>

<p>Begun on June 4, 2017; last updated on July 12, 2017.</p>

<p>Discusses many ways in which applications can extract random numbers from RNGs and includes pseudocode for most of them.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page discusses many ways applications can extract random numbers
from random number generators (RNGs) and includes pseudocode for most
of them.</p>

<p>As used in this document, a random number generator&mdash;</p>

<ul>
<li>can seek to generate random numbers that are cost-prohibitive to predict (also called &quot;cryptographically strong&quot; RNGs), or merely seek to generate number sequences likely to pass statistical tests of randomness,</li>
<li>can be initialized automatically before use, or can be initialized with an application specified &quot;seed&quot;, and</li>
<li>can use a deterministic algorithm, or primarily rely on one or more nondeterministic sources for random number generation.</li>
</ul>

<p>The methods presented on this page apply to all those kinds of RNGs unless otherwise noted. Moreover, recommendations on which RNGs are suitable for which applications are generally outside the scope of this page;  I have written about this in <a href="https://peteroupc.github.io/random.html">another document</a>.</p>

<p>This methods described in this document can be categorized as follows:</p>

<ul>
<li>Methods to generate uniformly distributed random numbers from an underlying uniform RNG (such as the <a href="#Core_Random_Generation_Method">core method, <code>RNDINT(N)</code></a>).</li>
<li>Common tasks to generate randomized content and conditions, such as <a href="#Boolean_Conditions">Boolean conditions</a>, <a href="#Shuffling">shuffling</a>, and <a href="#Choosing_Several_Unique_Items">sampling unique items from a list</a>.</li>
<li>Methods to generate non-uniformly distributed random numbers, including <a href="#Weighted_Choice">weighted choice</a>, the <a href="#Normal_Gaussian_Distribution">normal distribution</a>, and <a href="#Other_Non_Uniform_Distributions">other statistical distributions</a>.</li>
</ul>

<p><a href="https://peteroupc.github.io/randomgen.py">Sample Python code</a> that implements many of the methods in this document is available.</p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Contents">Contents</a></li>
<li><a href="#Notes_and_Definitions">Notes and Definitions</a></li>
<li><a href="#Uniform_Random_Numbers">Uniform Random Numbers</a>

<ul>
<li><a href="#RNDINT_Core_Random_Integer_Method"><code>RNDINT</code>: Core Random Integer Method</a></li>
<li><a href="#RNDINTRANGE_Random_Integers_Within_a_Range_Maximum_Inclusive"><code>RNDINTRANGE</code>: Random Integers Within a Range, Maximum Inclusive</a></li>
<li><a href="#RNDBITS_Random_N_Bit_Integers"><code>RNDBITS</code>: Random N-Bit Integers</a></li>
<li><a href="#RNDU01_Random_Numbers_0_or_Greater_and_1_or_Less"><code>RNDU01</code>: Random Numbers 0 or Greater and 1 or Less</a>

<ul>
<li><a href="#RNDU01OneExc_RNDU01ZeroExc_and_RNDU01ZeroOneExc_Related_Methods"><code>RNDU01OneExc</code>, <code>RNDU01ZeroExc</code>, and <code>RNDU01ZeroOneExc</code>: Related Methods</a></li>
</ul></li>
<li><a href="#RNDNUMRANGE_Random_Numbers_Within_a_Range_Maximum_Inclusive"><code>RNDNUMRANGE</code>: Random Numbers Within a Range, Maximum Inclusive</a></li>
<li><a href="#RNDINTEXC_Modified_Core_Method_Maximum_Exclusive"><code>RNDINTEXC</code>: Modified Core Method, Maximum Exclusive</a></li>
<li><a href="#RNDINTEXCRANGE_Random_Integers_Within_a_Range_Maximum_Exclusive"><code>RNDINTEXCRANGE</code>: Random Integers Within a Range, Maximum Exclusive</a></li>
<li><a href="#RNDNUMEXCRANGE_Random_Numbers_Within_a_Range_Maximum_Exclusive"><code>RNDNUMEXCRANGE</code>: Random Numbers Within a Range, Maximum Exclusive</a></li>
</ul></li>
<li><a href="#Randomization_Techniques">Randomization Techniques</a>

<ul>
<li><a href="#Boolean_Conditions">Boolean Conditions</a></li>
<li><a href="#Shuffling">Shuffling</a></li>
<li><a href="#Choosing_a_Random_Item_from_a_List">Choosing a Random Item from a List</a></li>
<li><a href="#Creating_a_Random_Character_String">Creating a Random Character String</a></li>
<li><a href="#Choosing_Several_Unique_Items">Choosing Several Unique Items</a></li>
<li><a href="#Quasi_Random_Sampling">Quasi-Random Sampling</a></li>
</ul></li>
<li><a href="#Non_Uniform_Distributions">Non-Uniform Distributions</a>

<ul>
<li><a href="#Discrete_Weighted_Choice">Discrete Weighted Choice</a>

<ul>
<li><a href="#Example">Example</a></li>
<li><a href="#Weighted_Choice_Without_Replacement">Weighted Choice Without Replacement</a></li>
<li><a href="#Choosing_Multiple_Items">Choosing Multiple Items</a></li>
<li><a href="#Piecewise_Constant_Distribution">Piecewise Constant Distribution</a></li>
<li><a href="#Multinomial_Distribution">Multinomial Distribution</a></li>
</ul></li>
<li><a href="#Continuous_Weighted_Choice">Continuous Weighted Choice</a>

<ul>
<li><a href="#Example_2">Example</a></li>
</ul></li>
<li><a href="#Normal_Gaussian_Distribution">Normal (Gaussian) Distribution</a></li>
<li><a href="#Binomial_Distribution">Binomial Distribution</a></li>
<li><a href="#Hypergeometric_Distribution">Hypergeometric Distribution</a></li>
<li><a href="#Poisson_Distribution">Poisson Distribution</a></li>
<li><a href="#Gamma_Distribution">Gamma Distribution</a></li>
<li><a href="#Negative_Binomial_Distribution">Negative Binomial Distribution</a></li>
<li><a href="#von_Mises_distribution">von Mises distribution</a></li>
<li><a href="#Other_Non_Uniform_Distributions">Other Non-Uniform Distributions</a></li>
</ul></li>
<li><a href="#Conclusion">Conclusion</a></li>
<li><a href="#Notes">Notes</a></li>
<li><a href="#License">License</a></li>
</ul>

<p><a id=Notes_and_Definitions></a></p>

<h2>Notes and Definitions</h2>

<p>In this document:</p>

<ul>
<li>Divisions do not round to an integer.  In programming languages in which division of two integers results in an integer, the right-hand side of the division must be converted to a floating-point number first.</li>
<li>Lists are indexed starting with 0.  That means the first item in the list is 0, the second item in the list is 1, and so on, up to the last item, whose index is the list&#39;s size minus 1.</li>
<li>The pseudocode shown doesn&#39;t cover all error handling that may be necessary in a particular implementation.   Such errors may include overflow checking, bounds checking, division by zero, and checks for infinity.  Neither is the pseudocode guaranteed to yield high performance in a particular implementation, either in time or memory.</li>
<li><code>pi</code> is the constant &pi;, the ratio of a circle&#39;s circumference to its diameter.</li>
<li><code>sin(a)</code>, <code>cos(a)</code>, and <code>tan(a)</code> are the sine, cosine, and tangent of the angle <code>a</code>, respectively, where <code>a</code> is in radians.</li>
<li><code>pow(a, b)</code> is the number <code>a</code> raised to the power <code>b</code>.</li>
<li><code>abs(a)</code> is the absolute value of <code>a</code>.</li>
<li><code>acos(a)</code> is the inverse cosine of <code>a</code>.</li>
<li><code>sqrt(a)</code> is the square root of <code>a</code>.</li>
<li><code>floor(a)</code> is the highest integer that is less than or equal to <code>a</code>.</li>
<li><code>nothing</code> indicates the absence of a value.  It corresponds to <code>null</code> in Java, C#, and JavaScript, <code>nil</code> in Ruby, and <code>None</code> in Python.</li>
<li><code>true</code> and <code>false</code> are the two Boolean values.</li>
<li><code>ln(a)</code> is the natural logarithm of <code>a</code>.  It corresponds to the <code>Math.log</code> method in Java and JavaScript.</li>
<li><code>exp(a)</code> is the number <em>e</em> (base of natural logarithms) raised to the power <code>a</code>.</li>
<li><code>GetNextLine(file)</code> is a method that gets the next line from a file, or returns <code>nothing</code> if the end of the file was reached.</li>
<li><code>NewList()</code> creates a new empty list.</li>
<li><code>AddItem(list, item)</code> adds the item <code>item</code> to the list <code>list</code>.</li>
<li><code>size(list)</code> returns the size of the list <code>list</code>.</li>
<li><code>list[k]</code> refers to the item at index <code>k</code> of the list <code>list</code>.</li>
<li><code>mod(a, b)</code> is the remainder when <code>a</code> is divided by <code>b</code>.</li>
<li>The <code>&lt;&lt;</code> operator in the pseudocode is a bitwise left shift, with both sides of the operator being integers.  If both sides are positive, it is the same as multiplying the left-hand side by 2<sup><em>n</em></sup>, where <em>n</em> is the right-hand side.</li>
<li>The <code>|</code> operator in the pseudocode is a bitwise OR operator between two integers.  It combines the bits of both integers so that each bit is set in the result if the corresponding bit is set on either or both sides of the operator.</li>
<li>The <code>&amp;</code> operator in the pseudocode is a bitwise AND operator between two integers. Although the <code>&amp;</code> operator is not always equivalent to <code>mod(a, b + 1)</code>, where <code>a</code> is the left-hand side and <code>b</code> is the right-hand side, all uses of the <code>&amp;</code> operator in the pseudocode effectively have that meaning, so that the form with <code>mod</code> can be used in programming languages without a built-in AND operator.</li>
<li>The term <em>significand permutations</em>, with respect to a floating-point format, means the format&#39;s radix (number base) raised to the power of the format&#39;s precision (the maximum number of significant digits in the format). For example&mdash;

<ul>
<li>the 64-bit IEEE 754 binary floating-point format (e.g., Java <code>double</code>) has 2<sup>53</sup> (9007199254740992) significand permutations,</li>
<li>the 64-bit IEEE 754 decimal floating-point format has 10<sup>16</sup> significand permutations,</li>
<li>the 32-bit IEEE 754 binary floating-point format (e.g., Java <code>float</code>) has 2<sup>24</sup> (16777216) significand permutations, and</li>
<li>arbitrary-precision floating point numbers (e.g., Java <code>BigDecimal</code>) can have a theoretically arbitrary number of significand permutations.</li>
</ul></li>
</ul>

<p><a id=Uniform_Random_Numbers></a></p>

<h2>Uniform Random Numbers</h2>

<p>This section describes how RNGs can be used to generate uniformly-distributed random numbers.  Here is an overview of the methods described in this section.</p>

<ul>
<li>Random Integers: <code>RNDINT</code>, <code>RNDINTEXC</code>, <code>RNDINTRANGE</code>, <code>RNDINTRANGEEXC</code>.</li>
<li>Random Bits: <code>RNDBITS</code>.</li>
<li>Random Numbers in 0-1 Bounded Interval: <code>RNDU01</code>, <code>RNDU01ZeroExc</code>, <code>RNDU01OneExc</code>, <code>RNDU01ZeroOneExc</code>.</li>
<li>Other Random Numbers: <code>RNDNUMRANGE</code>, <code>RNDNUMRANGEEXC</code>.</li>
</ul>

<p>One method, <code>RNDINT</code>, described next, can serve as the basis for the remaining methods.</p>

<p><a id=RNDINT_Core_Random_Integer_Method></a></p>

<h3><code>RNDINT</code>: Core Random Integer Method</h3>

<p>The core method for generating random numbers using an RNG is called <strong><code>RNDINT(maxInclusive)</code></strong> in this document. It generates a random integer <strong>0 or greater</strong> and <strong><code>maxInclusive</code> or less</strong>, where <code>maxInclusive</code> is an integer 0 or greater, and it assumes the underlying RNG produces uniformly random numbers. This core method can serve as the basis for all other methods described in later sections that extract random numbers from RNGs.</p>

<p>The implementation of <code>RNDINT(maxInclusive)</code> depends heavily on what kind of values the underlying RNG returns.  This section explains how <code>RNDINT(maxInclusive)</code> can be implemented for four kinds of uniform RNGs.</p>

<p>In this section:</p>

<ul>
<li><code>RNG()</code> is a random number returned by the underlying random number generator.</li>
<li>The term <em>modulus</em> means an integer that is 1 higher than the highest integer that an RNG can output.</li>
</ul>

<p>If the RNG outputs <strong>integers 0 or greater and less than a positive integer</strong> (for example, less than 1,000,000 or less than 6), then <code>RNDINT(maxInclusive)</code> can be implemented as follows.  In the pseudocode below, <code>MODULUS</code> is the RNG&#39;s modulus.   Note that all the variables in this method are unsigned integers.  (For an exercise solved by this method, see A. Koenig and B. E. Moo, <em>Accelerated C++</em>, 2000; see also a <a href="http://mathalope.co.uk/2014/10/26/accelerated-c-solution-to-exercise-7-9/">blog post by Johnny Chan</a>.)</p>

<pre>METHOD RNDINT(maxInclusive)
  // maxInclusive must be 0 or greater
  if maxInclusive &lt; 0: return error
  if maxInclusive == 0: return 0
  // N equals modulus
  if maxInclusive == MODULUS - 1: return RNG()
  if maxInclusive &gt;= MODULUS:
    cx = floor(maxInclusive / MODULUS) + 1
    while true
       ret = cx * RNG
       // NOTE: If this method is implemented using a fixed-
       // precision type, the addition operation below should
       // check for overflow and should reject the number
       // if overflow would result.
       ret = ret + RNDINT(cx - 1)
       if ret &lt;= maxInclusive: return ret
    end
  else
    // NOTE: If the programming language implements
    // division with two integers by truncating to an
    // integer, the division can be used as is without
    // calling a &quot;floor&quot; function.
          nPlusOne = maxInclusive + 1
          maxexc = floor((MODULUS - 1) / nPlusOne) * nPlusOne
          while true
                    ret = RNG()
                    if ret &lt; nPlusOne: return ret
                    if ret &lt; maxexc: return mod(ret, nPlusOne)
          end
  end
END METHOD
</pre>

<p>If the RNG outputs <strong>integers 0 or greater and less than a positive integer that&#39;s a power of two</strong>, such as random bits, random bytes, or random values of a given number of bits, then <code>RNDINT(maxInclusive)</code> can be implemented as follows. In the pseudocode below, <code>MODULUS</code> is the RNG&#39;s modulus, and <code>MODBITS</code> is the number of bits, minus 1, used to represent the modulus.  For example:</p>

<ul>
<li>If the RNG outputs random 32-bit integers, <code>MODULUS</code> is 2<sup>32</sup> and <code>MODBITS</code> is 32.</li>
<li>If the RNG outputs random 8-bit bytes, <code>MODULUS</code> is 256 and <code>MODBITS</code> is 8.</li>
</ul>

<p>Note that all the variables in this method are unsigned integers.</p>

<pre>METHOD RNDINT(maxInclusive)
   // maxInclusive must be 0 or greater
    if maxInclusive &lt; 0: return error
    if maxInclusive == 0: return 0
    // maxInclusive equals maximum
    if maxInclusive == MODULUS - 1: return RNG()
    // Special cases
    if maxInclusive == 1: return RNG() &amp; 1
    if maxInclusive == 3 and MODBITS &gt;= 2: return RNG() &amp; 3
    if maxInclusive == 255 and MODBITS &gt;= 8: return RNG() &amp; 255
    if maxInclusive == 65535 and MODBITS &gt;=16: return RNG() &amp; 65535
    if maxInclusive &gt; MODULUS - 1:
        // Calculate the bit count of maxInclusive
        bitCount = 0
        tempnumber = maxInclusive
        while tempnumber &gt; 0
               // NOTE: If the programming language implements
               // division with two integers by truncating to an
               // integer, the division can be used as is without
               // calling a &quot;floor&quot; function.
               tempnumber = floor(tempnumber / 2)
               bitCount = bitCount + 1
        end
        while true
               // Build a number with `bitCount` bits
                tempnumber = 0
                while bitCount &gt; 0
                     wordBits = MODBITS
                     rngNumber = RNG()
                     if wordBits &gt; bitCount
                        wordBits = bitCount
                        // Truncate number to &#39;wordBits&#39; bits
                        rngNumber = rngNumber &amp; (
                           (1 &lt;&lt; wordBits) - 1)
                     end
                     tempnumber = tempnumber &lt;&lt; wordBits
                     // NOTE: In programming languages that
                     // support the OR operator between two
                     // integers, that operator can replace the
                     // plus operator below.
                     tempnumber = tempnumber + rngNumber
                     bitCount = bitCount - wordBits
                end
                // Accept the number if allowed
                if tempnumber &lt;= maxInclusive: return tempnumber
         end
   else
          nPlusOne = maxInclusive + 1
          maxexc = floor((MODULUS - 1) / nPlusOne) * nPlusOne
          while true
                    ret = RNG()
                    if ret &lt; nPlusOne: return ret
                    if ret &lt; maxexc: return mod(ret, nPlusOne)
          end
   end
END METHOD
</pre>

<p>Note that this implementation of <code>RNDINT(maxInclusive)</code> may result in unused bits (for example, when truncating a random number to <code>wordBits</code> bits or in the special cases at the start of the method).  It would be outside the scope of this document to describe how a more sophisticated implementation may save those bits for later reuse.</p>

<p>If the RNG outputs <strong>fixed-point numbers 0 or greater and less than a positive integer</strong>, that is, numbers with a fixed number of fractional parts, then find <code>A</code> and <code>B</code>, where <code>A</code> is the greatest integer that is less than the highest number the RNG can output, and <code>B</code> is the number of fractional parts the fixed-point number format can have, and use one of the two methods given above depending on whether <code>A * B</code> is a power of two (<code>A * B</code> is treated as the <em>modulus</em> for that purpose).  Here, though, <code>RNG()</code> in the methods above is <code>floor(RNG() * B)</code> instead.</p>

<p>If the RNG outputs <strong>floating-point numbers 0 or greater and less than 1</strong>, then find <code>s</code>, where <code>s</code> is the number of <em>significand permutations</em> for the floating-point format, and use one of the two methods given above depending on whether <code>s</code> is a power of two (<code>s</code> is treated as the <em>modulus</em> for that purpose).  Here, though, <code>RNG()</code> in the methods above is <code>floor(RNG() * s)</code> instead.  (If the RNG outputs arbitrary-precision floating-point numbers, <code>s</code> should be set to the number of different values that are possible by calling the underlying RNG.)</p>

<hr>

<p>The underlying uniform RNG can be other than already described in this section; however, a detailed <code>RNDINT(maxInclusive)</code> implementation for other kinds of RNGs is not given here, since they seem to be lesser seen in practice.  Readers who know of a uniform RNG that is in wide use and is other than already described in this section should send me a comment.</p>

<p><a id=RNDINTRANGE_Random_Integers_Within_a_Range_Maximum_Inclusive></a></p>

<h3><code>RNDINTRANGE</code>: Random Integers Within a Range, Maximum Inclusive</h3>

<p>The na&iuml;ve way of generating a <strong>random integer <code>minInclusive</code> or greater and <code>maxInclusive</code> or less</strong> is as follows. This approach works well for unsigned integers and arbitrary-precision integers.</p>

<pre> METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   return minInclusive + RNDINT(maxInclusive - minInclusive)
 END METHOD
</pre>

<p>The na&iuml;ve approach won&#39;t work as well, though, for signed integer formats if the difference between <code>maxInclusive</code> and <code>minInclusive</code> exceeds the highest possible integer for the format.  For fixed-length signed integer formats <a href="#Note1"><sup>(1)</sup></a>, such random integers can be generated using the following pseudocode.  In the pseudocode below, <code>INT_MAX</code> is the highest possible integer in the integer format.</p>

<pre>METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   if minInclusive == maxInclusive: return minInclusive
   if minInclusive==0: return RNDINT(maxInclusive)
   // Difference does not exceed maxInclusive
   if minInclusive &gt; 0 or minInclusive + INT_MAX &gt;= maxInclusive
       return minInclusive + RNDINT(maxInclusive - minInclusive)
   end
   while true
     ret = RNDINT(INT_MAX)
     // NOTE: If the signed integer format uses two&#39;s-complement
     // form, use the following line:
     if RNDINT(1) == 0: ret = -1 - ret
     // NOTE: If the signed integer format uses sign-magnitude
     // form (such as .NET&#39;s `System.Decimal`) or one&#39;s-complement
     // form,  use the following three lines instead of the preceding line;
     // here, zero will be rejected at a 50% chance because zero occurs
     // twice in both forms.
     // negative = RNDINT(1) == 0
     // if negative: ret = 0 - ret
     // if negative and ret == 0: continue
     if ret &gt;= minInclusive and ret &lt;= maxInclusive: return ret
   end
END METHOD
</pre>

<p>A common use case of <code>RNDINTRANGE</code> is to simulate die rolls.  For example, to simulate rolling a six-sided die, generate a random number from 1 through 6 by calling <code>RNDINTRANGE(1, 6)</code>.</p>

<p><a id=RNDBITS_Random_N_Bit_Integers></a></p>

<h3><code>RNDBITS</code>: Random N-Bit Integers</h3>

<p>The following na&iuml;ve way of generating a <strong>uniformly distributed random N-bit integer</strong> is as follows:</p>

<pre> METHOD RNDBITS(bits)
    // NOTE: The maximum number that could be returned
    // here is 2^bits - 1, in which all `bits` bits are set to 1.
    return RNDINT((1 &lt;&lt; bits) - 1)
 END METHOD
</pre>

<p>Although this works well for arbitrary-precision integers, it won&#39;t work well for the much more popular integer types called <em>fixed-length two&#39;s-complement signed integers</em> <a href="#Note1"><sup>(1)</sup></a>. For such signed integers as well as fixed-length unsigned integers, <code>RNDBITS(bits)</code> can be implemented using the pseudocode below.  In the pseudocode below, <code>BITCOUNT</code> is the number of bits used in the format.  Note that for such signed integers, <code>RNDBITS(bits)</code> can return a sequence of bits that resolves to a negative number.</p>

<pre>METHOD RNDBITS(bits)
     if bits&lt;0 or bits &gt; BITCOUNT: return error
     if bits==0: return 0
     if bits==1: return RNDINT(1)
     if bits==2 and BITCOUNT == 2
         return (RNDINT(1) &lt;&lt; 1) | RNDINT(1)
     end
     if bits==2: return RNDINT(3)
     bitsMinus2 = bits - 2
     // NOTE: The &quot;|&quot; below is the OR operator between
     // two integers.  The following line is implemented this
     // way to accommodate implementations that use
     // fixed-length two&#39;s-complement signed integers.
     ret = (RNDINT((1&lt;&lt;bitsMinus2) - 1) &lt;&lt; bitsMinus2) | RNDINT(3)
     // NOTE: If the implementation uses fixed-length
     // unsigned integers, the following line can replace
     // the preceding line.  Note that the implementation
     // avoids shifting an integer by BITCOUNT bits or more,
     // because such behavior is undefined in C and C++.
     // ret = RNDINT( (((1 &lt;&lt; (bits - 1)) - 1) &lt;&lt; 1) | 1 )
     // NOTE: Alternatively, a list containing powers-of-two
     // minus 1 can be generated (calculating `floor(pow(2,i)) - 1`
     // for each relevant index `i` of the list, assuming unlimited
     // precision) and the following line used instead of the
     // preceding (assuming `list` is
     // the list generated this way):
     // ret = RNDINT( list[bits] )
     return ret
END METHOD
</pre>

<p><a id=RNDU01_Random_Numbers_0_or_Greater_and_1_or_Less></a></p>

<h3><code>RNDU01</code>: Random Numbers 0 or Greater and 1 or Less</h3>

<p>The following method, <code>RNDU01()</code>, generates a <strong>random number 0 or greater and 1 or less</strong>:</p>

<pre> METHOD RNDU01()
    return RNDINT(X) / X
 END METHOD
</pre>

<p>In the method above, <code>X</code> is the number of fractional parts between 0 and 1. (For fixed-precision floating-point number formats, <code>X</code> should equal the number of <em>significand permutations</em> for that format. See &quot;Generating uniform doubles in the unit interval&quot; in the <a href="http://xoroshiro.di.unimi.it/#remarks"><code>xoroshiro+</code> remarks page</a> for further discussion.)</p>

<p>For fixed-precision binary floating-point numbers with fixed exponent range (such as Java&#39;s <code>double</code> and <code>float</code>), the following pseudocode for <code>RNDU01()</code> can be used instead, which returns a uniformly-distributed <strong>random number 0 or greater and 1 or less</strong>.  It&#39;s based on a <a href="http://allendowney.com/research/rand/">technique devised by Allen Downey</a>, who found that dividing a random number by a constant usually does not yield all representable binary floating-point numbers in the desired range.  In the pseudocode below, <code>SIGBITS</code> is the binary floating-point format&#39;s precision (for examples, see the <a href="#Notes_and_Definitions">note for &quot;significand permutations&quot;</a>).</p>

<pre>METHOD RNDU01()
    e=-SIGBITS
    while true
        if RNDINT(1)==0: e = e - 1
      else: break
    end
    sig = RNDINT((1 &lt;&lt; (SIGBITS - 1)) - 1)
    if sig==0 and RNDINT(1)==0: e = e + 1
    sig = sig + (1 &lt;&lt; (SIGBITS - 1))
    // NOTE: This multiplication should result in
    // a floating-point number; if `e` is sufficiently
    // small, the number will underflow to 0
    return sig * pow(2, e)
END METHOD
</pre>

<p><a id=RNDU01OneExc_RNDU01ZeroExc_and_RNDU01ZeroOneExc_Related_Methods></a></p>

<h4><code>RNDU01OneExc</code>, <code>RNDU01ZeroExc</code>, and <code>RNDU01ZeroOneExc</code>: Related Methods</h4>

<p>Three related methods also generate a <strong>random number in an interval bounded at 0 and 1</strong>.  They can be implemented as follows.</p>

<ul>
<li><p><strong><code>RNDU01OneExc()</code> (0 or greater, but less than 1)</strong> can be implemented in one of the following ways:</p>

<ul>
<li>Call <code>RNDU01()</code> in a loop until a number other than 1.0 is generated this way.  This is preferred.</li>
<li><code>RNDINT(X - 1) / X</code>, where X is the number of fractional parts between 0 and 1 (see previous section).</li>
</ul>

<p>Note that <code>RNDU01OneExc()</code> corresponds to <code>Math.random()</code> in Java and JavaScript.</p></li>
<li><strong><code>RNDU01ZeroExc()</code> (greater than 0, but 1 or less)</strong> can be implemented in one of the following ways:

<ul>
<li>Call <code>RNDU01()</code> in a loop until a number other than 0.0 is generated this way.  This is preferred.</li>
<li><code>(RNDINT(X - 1) + 1) / X</code>, where X is the number of fractional parts between 0 and 1 (see previous section).</li>
<li><code>1.0 - RNDU01OneExc()</code>.</li>
</ul></li>
<li><strong><code>RNDU01ZeroOneExc()</code> (greater than 0, but less than 1)</strong> can be implemented in one of the following ways:

<ul>
<li>Call <code>RNDU01()</code> in a loop until a number other than 0.0 or 1.0 is generated this way.  This is preferred.</li>
<li><code>(RNDINT(X - 2) + 1) / X</code>, where X is the number of fractional parts between 0 and 1 (see previous section).</li>
</ul></li>
</ul>

<p><a id=RNDNUMRANGE_Random_Numbers_Within_a_Range_Maximum_Inclusive></a></p>

<h3><code>RNDNUMRANGE</code>: Random Numbers Within a Range, Maximum Inclusive</h3>

<p>To generate a <strong>random number <code>minInclusive</code> or greater and <code>maxInclusive</code> or less</strong>, use the following pseudocode:</p>

<pre>METHOD RNDNUMRANGE(minInclusive, maxInclusive)
    if minInclusive &gt; maxInclusive: return error
    return minInclusive + (maxInclusive - minInclusive) * RNDU01()
END
</pre>

<p><a id=RNDINTEXC_Modified_Core_Method_Maximum_Exclusive></a></p>

<h3><code>RNDINTEXC</code>: Modified Core Method, Maximum Exclusive</h3>

<p>A method based on <code>RNDINT(maxInclusive)</code> is called <code>RNDINTEXC(maxExclusive)</code> in this document; it generates a random integer <strong>0 or greater</strong> and <strong>less than <code>maxExclusive</code></strong>, where <code>maxExclusive</code> is an integer greater than 0.  This variant is not given as the core random generation method because it&#39;s harder to fill integers in popular integer formats with random bits with this method. The method can be implemented as follows:</p>

<pre> METHOD RNDINTEXC(maxExclusive)
    if maxExclusive &lt;= 0: return error
    return RNDINT(maxExclusive - 1)
 END METHOD
</pre>

<p><strong>Note:</strong> An alternative way of generating a random integer 0 or greater and less than <code>maxExclusive</code> is the following idiom: <code>floor(RNDU01OneExc()*(maxExclusive))</code>.  This approach, though, is recommended only if the programming language supports only floating-point numbers (an example is JavaScript) or doesn&#39;t support an integer type that is big enough to fit the number <code>maxExclusive - 1</code>.</p>

<p><a id=RNDINTEXCRANGE_Random_Integers_Within_a_Range_Maximum_Exclusive></a></p>

<h3><code>RNDINTEXCRANGE</code>: Random Integers Within a Range, Maximum Exclusive</h3>

<p>A version of <code>RNDINTRANGE</code>, called <code>RNDINTEXCRANGE</code> here, returns a <strong>random integer <code>minInclusive</code> or greater and less than <code>maxExclusive</code></strong>.  It can be implemented using <a href="#Random_Integers_Within_a_Range_Maximum_Inclusive"><code>RNDINTRANGE</code></a>, as the following pseudocode demonstrates.</p>

<pre>METHOD RNDINTEXCRANGE(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   // NOTE: For signed integer formats, replace the following line
   // with &quot;if minInclusive &gt;=0 or minInclusive + INT_MAX &gt;=
   // maxExclusive&quot;, where `INT_MAX` has the same meaning
   // as the pseudocode for `RNDINTRANGE`.
   if minInclusive &gt;=0
      return minInclusive + RNDINT(maxExclusive - minInclusive - 1)
   end
   while true
     ret = RNDINTRANGE(minInclusive, maxExclusive)
     if ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<p><a id=RNDNUMEXCRANGE_Random_Numbers_Within_a_Range_Maximum_Exclusive></a></p>

<h3><code>RNDNUMEXCRANGE</code>: Random Numbers Within a Range, Maximum Exclusive</h3>

<p>To generate a <strong>random number <code>minInclusive</code> or greater and less than <code>maxExclusive</code></strong>, use the following pseudocode:</p>

<pre>METHOD RNDNUMEXCRANGE(minInclusive, maxExclusive)
    if minInclusive &gt;= maxExclusive: return error
    return minInclusive + (maxExclusive - minInclusive) * RNDU01OneExc()
END
</pre>

<p><a id=Randomization_Techniques></a></p>

<h2>Randomization Techniques</h2>

<p>This section describes commonly used randomization techniques, such as shuffling, selection of several unique items, and creating random strings of text.</p>

<p><a id=Boolean_Conditions></a></p>

<h3>Boolean Conditions</h3>

<p>To generate a condition that is true at the specified probabilities, use
the following idioms in an <code>if</code> condition:</p>

<ul>
<li>True or false with equal probability: <code>RNDINT(1) == 0</code>.</li>
<li>True with X percent probability: <code>RNDINTEXC(100) &lt; X</code>.</li>
<li>True with probability X/Y: <code>RNDINTEXC(Y) &lt; X</code>.</li>
<li>True with probability X, where X is from 0 through 1 (a <em>Bernoulli trial</em>): <code>RNDU01OneExc() &lt; X</code>.</li>
<li><strong>Example:</strong> True with probability 3/8: <code>RNDINTEXC(8) &lt; 3</code>.</li>
<li><strong>Example:</strong> True with 20% probability: <code>RNDINTEXC(100) &lt; 20</code>.</li>
</ul>

<p><a id=Shuffling></a></p>

<h3>Shuffling</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle">Fisher&ndash;Yates shuffle method</a> shuffles a list such that all permutations of that list are equally likely to occur, assuming the RNG it uses produces uniformly random numbers and can choose from among all permutations of that list.  However, that method is also easy to write incorrectly (see also Jeff Atwood, &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/">The danger of na&iuml;vet&eacute;</a>&quot;).  The following pseudocode is designed to shuffle a list&#39;s contents.</p>

<pre>METHOD Shuffle(list)
   // NOTE: Check size of the list early to prevent
   // `i` from being less than 0 if the list&#39;s size is 0 and
   // `i` is implemented using an unsigned type available
   // in certain programming languages.
   if size(list) &gt;= 2
      // Set i to the last item&#39;s index
      i = size(list) - 1
      while i &gt; 0
         // Choose an item ranging from the first item
         // up to the item given in `i`. Note that the item
         // at i+1 is excluded.
         k = RNDINTEXC(i + 1)
         // The following is wrong since it introduces biases:
         // k = RNDINTEXC(size(list))
         // The following is wrong since the algorithm won&#39;t
         // choose from among all possible permutations:
         // k = RNDINTEXC(i)
         // Swap item at index i with item at index k;
         // in this case, i and k may be the same
         tmp = list[i]
         list[i] = list[k]
         list[k] = tmp
         // Move i so it points to the previous item
         i = i - 1
      end
   end
END METHOD
</pre>

<p>An important consideration with respect to shuffling is the kind of RNG used.  Notably, in general, if a deterministic RNG&#39;s <em>period</em> (the maximum number of values in a generated sequence for that RNG before that sequence repeats) is less than the number of distinct permutations (arrangements) of a list, then there are some permutations that PRNG can&#39;t choose when it shuffles that list. RNGs that seek to generate random numbers that are cost-prohibitive to predict (so-called &quot;cryptographically strong&quot; generators) suffer less from this problem.  See also my <a href="https://peteroupc.github.io/random.html#Shuffling">RNG recommendation document on shuffling</a>.  It suffices to say here that in general, a deterministic RNG with a period 2<sup>226</sup> or greater is good enough for shuffling a 52-item list, if a deterministic RNG is otherwise called for.</p>

<p><strong>Note:</strong> In simulation testing, shuffling is used to relabel items from a dataset at random, where each item in the dataset is assigned one of several labels.  In such testing:</p>

<ul>
<li>One or more statistics that involve the specific labeling of the original dataset&#39;s groups is calculated (such as the difference, maximum, or minimum of means or variances between groups).</li>
<li>Multiple simulated datasets are generated. Each dataset is generated by merging the groups, shuffling the merged dataset, and relabeling each item in order such that the number of items in each group for the simulated dataset is the same as for the original dataset.</li>
<li>For each simulated dataset, the same statistics are calculated as for the original dataset.</li>
<li>The statistics for the simulated datasets are compared with those of the original.</li>
</ul>

<p><a id=Choosing_a_Random_Item_from_a_List></a></p>

<h3>Choosing a Random Item from a List</h3>

<p>To choose a random item from a list&mdash;</p>

<ul>
<li>whose size is known in advance, use the idiom <code>list[RNDINTEXC(size(list))]</code>.  This idiom assumes that the first item of the list is at position 0, the second is at position 1, and so on; or</li>
<li><p>whose size is not known in advance, use a method like the following.  Although the pseudocode refers to files and lines, the technique applies to any situation when items are retrieved one at a time from a dataset or list whose size is not known in advance.</p>

<pre>METHOD RandomItemFromFile(file)
   i = 1
   lastItem = nothing
   while true
      // Get the next line from the file
      item = GetNextLine(file)
      // The end of the file was reached, break
      if item == nothing: break
      if RNDINTEXC(i) == 0: lastItem = item
      i = i + 1
   end
end
</pre></li>
</ul>

<p><strong>Note:</strong> <a href="https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29"><em>Bootstrapping</em></a> is a method of creating a simulated dataset by choosing random items with replacement from an existing dataset until both datasets have the same size.  (The simulated dataset can contain duplicates this way.)  Usually, multiple simulated datasets are generated this way, one or more statistics, such as the mean, are calculated for each simulated dataset as well as the original dataset, and the statistics for the simulated datasets are compared with those of the original.</p>

<p><a id=Creating_a_Random_Character_String></a></p>

<h3>Creating a Random Character String</h3>

<p>A commonly asked question involves how to generate a random string of characters (usually a random <em>alphanumeric string</em>, or string of letters and digits).</p>

<p>The first step is to generate a list of the letters, digits, and/or other characters the string can have.  Often, those characters will be&mdash;</p>

<ul>
<li>the basic digits &quot;0&quot; to &quot;9&quot; (U+0030-U+0039, nos. 48-57),</li>
<li>the basic upper case letters &quot;A&quot; to &quot;Z&quot; (U+0041-U+005A, nos. 65-90), and</li>
<li>the basic lower case letters &quot;a&quot; to &quot;z&quot; (U+0061-U+007A, nos. 96-122),</li>
</ul>

<p>as found in the Basic Latin block of the Unicode Standard. Note that:</p>

<ul>
<li>If the list of characters is fixed, the list can be statically created at runtime or compile time, or a string type as provided in the programming language can be used to store the list as a string.</li>
<li>Instead of individual characters, the list can consist of strings of one or more characters each.  In that case, storing the list of strings as a single string is usually not a clean way to store those strings.</li>
</ul>

<p>The second step is to build a new string whose characters are chosen from that character list.  The pseudocode below demonstrates this by creating a list, rather than a string, where the random characters will be held.  It also takes the number of characters as a parameter named <code>size</code>.  (Converting this list to a text string is programming-language-dependent, and the details of the conversion are outside the scope of this page.)</p>

<pre>  METHOD RandomString(characterList, stringSize)
       i = 0
       newString = NewList()
       while i &lt; stringSize
           // Choose a character from the list
           randomChar = characterList[RNDINTEXC(size(characterList))]
           // Add the character to the string
           AddItem(newString, randomChar)
           i = i + 1
        end
        return newString
  END METHOD
</pre>

<p><em><strong>Note:</strong> Often applications need to generate a string of characters that&#39;s not only random, but also unique.  The best way to ensure uniqueness in this case is to store a list (such as a hash table) of strings already generated and to check newly generated strings against the list (or table).  Random number generators alone should not be relied on to deliver unique results.</em></p>

<p><a id=Choosing_Several_Unique_Items></a></p>

<h3>Choosing Several Unique Items</h3>

<p>Often, the need arises to choose <code>k</code> unique items or values from among <code>n</code> available items or values.  (This is also known as <em>sampling without replacement</em>.) The following assumes that each item has an equal chance of being chosen.  There are several techniques for doing this depending on whether <code>n</code> is known and how big it is:</p>

<ul>
<li><p><strong>If <code>n</code> is not known in advance:</strong> Use the <em>reservoir sampling</em> method, implemented below.  Although the pseudocode refers to files and lines, the technique applies to any situation when items are retrieved one at a time from a dataset or list whose size is not known in advance.</p>

<pre>METHOD RandomKItemsFromFile(file, k)
   list = NewList()
   j = 0
   endOfFile = false
   while j &lt; k
      // Get the next line from the file
      item = GetNextLine(file)
      // The end of the file was reached, break
      if item == nothing
         endOfFile = true
         break
      end
      AddItem(list, item)
      j = j + 1
   end
   i = 1 + k
   while endOfFile == false
      // Get the next line from the file
      item = GetNextLine(file)
      // The end of the file was reached, break
      if item == nothing: break
      j = RNDINTEXC(i)
      if j &lt; k: list[j] = item
      i = i + 1
   end
   // We shuffle at the end in case k or fewer
   // lines were in the file, since in that
   // case the items would appear in the same
   // order as they appeared in the file
   // if the list weren&#39;t shuffled.  This line
   // can be removed, however, if the items
   // in the returned list need not appear
   // in random order.
   Shuffle(list)
   return list
end
</pre></li>
<li><strong>If <code>n</code> is relatively small (for example, if there are 200 available items, or there is a range of numbers from 0 to 200 to choose from):</strong> Store all the items in a list, <a href="#Shuffling">shuffle</a> that list, then choose the first <code>k</code> items from that list.</li>
<li><strong>If <code>n</code> is relatively large (for example, if 32-bit or larger integers will be chosen so that <code>n</code> is 2<sup>32</sup> or is a greater power of 2):</strong> Create a hash table storing the indices to items already chosen.  When a new index to an item is randomly chosen, check the hash table to see if it&#39;s there already.  If it&#39;s not there already, add it to the hash table.  Otherwise, choose a new random index.  Repeat this process until <code>k</code> indices were added to the hash table this way.  Performance considerations involved in storing data in hash tables, and in retrieving data from them, are outside the scope of this document.  This technique can also be used for relatively small <code>n</code>, if some of the items have a higher probability of being chosen than others (see also <a href="#Discrete_Weighted_Choice">Discrete Weighted Choice</a>).</li>
</ul>

<p><a id=Quasi_Random_Sampling></a></p>

<h3>Quasi-Random Sampling</h3>

<p>Some applications (particularly some games) may find it important to control which random numbers appear, to make the random outcomes appear fairer to users.  Without this control, a user may experience long streaks of good outcomes or long streaks of bad outcomes, both of which are theoretically possible with a random number generator.  To implement <em>quasi-random sampling</em>, as this technique is called, an application can do one of the following:</p>

<ul>
<li>Generate a list of possible outcomes (for example, the list can contain 10 items labeled &quot;good&quot; and three labeled &quot;bad&quot;) and <a href="#Shuffling">shuffle</a> that list.  Each time an outcome must be generated, choose the next unchosen outcome from the shuffled list.  Once all those outcomes are chosen, shuffle the list again, and continue.</li>
<li>Create two lists: one list with the different possible outcomes, and another list of the same size containing an integer weight 0 or greater for each outcome (for example, one list can contain the items &quot;good&quot; and &quot;bad&quot;, and the other list can contain the weights 10 and 3, respectively).  Each time an outcome must be generated, choose one outcome using the <a href="#Weighted_Choice_Without_Replacement">weighted choice without replacement</a> technique.  Once all the weights are 0, re-fill the list of weights with the same weights the list had at the start, and continue.</li>
</ul>

<p>However, quasi-random techniques are not recommended&mdash;</p>

<ul>
<li>whenever computer or information security is involved, or</li>
<li>in cases (such as in multiplayer networked games) when predicting future random numbers would give a player or user a significant and unfair advantage.</li>
</ul>

<p><a id=Non_Uniform_Distributions></a></p>

<h2>Non-Uniform Distributions</h2>

<p>Some applications need to choose random items or numbers such that some of them are more likely to be chosen than others. This section describes how to use the <a href="#Uniform_Random_Numbers">uniform random number methods</a> to generate random numbers that follow a non-uniform statistical distribution.</p>

<p><a id=Discrete_Weighted_Choice></a></p>

<h3>Discrete Weighted Choice</h3>

<p>The discrete weighted choice method is used to choose a random item from among a set of them with different probabilities of being chosen.</p>

<p>The following pseudocode takes a single list <code>weights</code>, and returns the index of a weight from that list.  The greater the weight, the more likely its index will be chosen. (Note that there are two possible ways to generate the random number depending on whether the weights are all integers or can be fractional numbers.) Each weight should be 0 or greater.</p>

<pre>METHOD DiscreteWeightedChoice(weights)
    if size(weights) == 0: return error
    sum = 0
    // Get the sum of all weights
    i = 0
    while i &lt; size(weights)
        sum = sum + weights[i]
        i = i + 1
    end
    // Choose a random integer/number from 0 to less than
    // the sum of weights.
    value = RNDINTEXC(sum)
    // NOTE: If the weights can be fractional numbers,
    // use this instead:
    // value = RNDNUMEXCRANGE(0, sum)
    // Choose the object according to the given value
    i = 0
    lastItem = size(weights) - 1
    runningValue = 0
    while i &lt; size(weights)
       if weights[i] &gt; 0
          newValue = runningValue + weights[i]
          if value &lt; newValue: return i
          runningValue = newValue
          lastItem = i
       end
       i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return lastItem
END METHOD
</pre>

<p><a id=Example></a></p>

<h4>Example</h4>

<p>Assume we have the following list: <code>[&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;grapes&quot;]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  The weight for &quot;apples&quot; is 3, and the weight for &quot;oranges&quot; is 15.  Since &quot;oranges&quot; has a higher weight than &quot;apples&quot;, the index for &quot;oranges&quot; (1) is more likely to be chosen than the index for &quot;apples&quot; (0) with the <code>DiscreteWeightedChoice</code> method.  The following pseudocode implements how to get a randomly chosen item from the list with that method.</p>

<pre>index = DiscreteWeightedChoice(weights)
// Get the actual item
item = list[index]
</pre>

<p><a id=Weighted_Choice_Without_Replacement></a></p>

<h4>Weighted Choice Without Replacement</h4>

<p>In the example above, the weights sum to 21.  However, the weights do not mean that when 21 items are selected, the index for &quot;apples&quot; will be chosen exactly 3 times, or the index for &quot;oranges&quot; exactly 15 times, for example.  Each call to <code>DiscreteWeightedChoice</code> is independent from the others, and each weight indicates only a <em>likelihood</em> that the corresponding index will be chosen rather than the other indices.  And this likelihood doesn&#39;t change no matter how many times <code>DiscreteWeightedChoice</code> is called with the same weights.  This is called a weighted choice <em>with replacement</em>, which can be thought of as drawing a ball, then putting it back.</p>

<p>To implement weighted choice <em>without replacement</em> (which can be thought of as drawing a ball <em>without</em> putting it back), simply call <code>DiscreteWeightedChoice</code>, and then decrease the weight for the chosen index by 1.  In this way, when items are selected repeatedly, each weight behaves like the number of &quot;copies&quot; of each item. This technique, though, will only work properly if all the weights are integers 0 or greater.  The pseudocode below is an example of this.</p>

<pre>// Get the sum of weights
// (NOTE: This code assumes that `weights` is
// a list that can be modified.  If the original weights
// are needed for something else, a copy of that
// list should be made first, but the copying process
// is not shown here.  This code also assumes that `list`,
// a list of items, was already declared earlier and
// has at least as many items as `weights`.)
totalWeight = 0
i = 0
while i &lt; size(weights)
    totalWeight = totalWeight + weights[i]
    i = i + 1
end
// Choose as many items as the sum of weights
i = 0
items = NewList()
while i &lt; totalWeight
    index = DiscreteWeightedChoice(weights)
    // Decrease weight by 1 to implement selection
    // without replacement.
    weights[index] = weights[index] - 1
    AddItem(items, list[index])
    i = i + 1
end
</pre>

<p>Alternatively, if all the weights are integers 0 or greater and their sum is relatively small, create a list with as many copies of each item as its weight, then <a href="#Shuffling">shuffle</a> that list.  The resulting list will be ordered in a way that corresponds to a weighted random choice without replacement.</p>

<p><a id=Choosing_Multiple_Items></a></p>

<h4>Choosing Multiple Items</h4>

<p>The discrete weighted choice method can also be used for choosing multiple items from a list, whether or not the items have the same probability of being chosen.  In this case, after choosing a random index, set the weight for that index to 0 to keep it from being chosen again.  The pseudocode below is an example of this.</p>

<pre>// (NOTE: This code assumes that `weights` is
// a list that can be modified.  If the original weights
// are needed for something else, a copy of that
// list should be made first, but the copying process
// is not shown here.  This code also assumes that `list`,
// a list of items, was already declared earlier and
// has at least as many items as `weights`.)
chosenItems = NewList()
i = 0
// Choose k items from the list
while i &lt; k or i &lt; size(weights)
    index = DiscreteWeightedChoice(weights)
    // Set the weight for the chosen index to 0
    // so it won&#39;t be chosen again
    weights[index] = 0
    // Add the item at the chosen index
    AddItem(chosenItems, list[index])
end
// `chosenItems` now contains the items chosen
</pre>

<p><a id=Piecewise_Constant_Distribution></a></p>

<h4>Piecewise Constant Distribution</h4>

<p>The discrete weighted choice method can also be used to implement a <a href="http://en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution"><em>piecewise constant distribution</em></a>, as in the following example. Assume we have the following list: <code>[0, 5, 10, 11, 15]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  Note that the weight list has one fewer item than the number list.  The weight for &quot;0 to 5&quot; (0 or greater, less than 5) is 3, and the weight for &quot;5 to 10&quot; is 15.  Since &quot;5 to 10&quot; has a higher weight than &quot;0 to 5&quot;, this distribution will choose a number from 5 to 10 more often than a number from 0 to 5.  The following pseudocode implements the piecewise constant distribution.</p>

<pre>// Choose a random index
index = DiscreteWeightedChoice(weights)
// Choose a random number in the chosen interval on the list
number = list[index] + (list[index + 1] - list[index]) * RNDU01OneExc()
</pre>

<p>The code above implements the distribution <em>with replacement</em>.  Implementing the distribution <em>without replacement</em> is similar to implementing discrete weighted choice without replacement; the only change is
to replace <code>AddItem(items, list[index])</code> with <code>AddItem(items, list[index] + (list[index + 1] - list[index]) * RNDU01OneExc())</code> in the pseudocode.</p>

<p><a id=Multinomial_Distribution></a></p>

<h4>Multinomial Distribution</h4>

<p>The discrete weighted choice method can also be used to implement a <em>multinomial distribution</em>.  This distribution models the number of times each of several mutually exclusive events happens among a given number of trials, where each event can have a different probability of happening.  The pseudocode below is of a method that takes two parameters: <code>trials</code>, which is the number of trials, and <code>weights</code>, which are the relative probabilities of each event.  The method tallies the events as they happen and returns a list (with the same size as <code>weights</code>) containing the number of successes for each event.</p>

<pre>METHOD Multinomial(trials, weights)
    if trials &lt; 0: return error
    // create a list of successes
    list = NewList()
    i = 0
    while i &lt; size(weights)
       AddItem(list, 0)
       i = i + 1
    end
    i = 0
    while i &lt; trials
        // Choose an index
        index = DiscreteWeightedChoice(weights)
        // Tally the event at the chosen index
        list[index] = list[index] + 1
        i = i + 1
    end
    return list
END METHOD
</pre>

<p><a id=Continuous_Weighted_Choice></a></p>

<h3>Continuous Weighted Choice</h3>

<p>The continuous weighted choice method is used to choose a random number that follows a continuous statistical distribution (here, a <a href="http://en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution"><em>piecewise linear distribution</em></a>).</p>

<p>The following pseudocode takes two lists, <code>list</code> and <code>weights</code>, and returns a random number that follows the distribution.  <code>list</code> is a list of numbers (which can be fractional numbers) that should be arranged in ascending order, and <code>weights</code> is a list of <em>probability densities</em> for the given numbers (where each number and its density have the same index in both lists). (A number&#39;s <em>probability density</em> is the relative probability that a randomly chosen value will be infinitesimally close to that number, assuming no precision limits.)  Each probability density should be 0 or greater.  Both lists should be the same size.  In the pseudocode below, the first number in <code>list</code> can be returned exactly, but not the last item in <code>list</code>, assuming the numbers in <code>list</code> are arranged in ascending order.</p>

<p>In many cases, the probability densities are sampled (usually at regularly spaced points) from a so-called <a href="https://en.wikipedia.org/wiki/Probability_density_function"><em>probability density function</em></a>, a function that specifies each number&#39;s probability density.  A list of common probability density functions is outside the scope of this page.</p>

<pre>METHOD ContinuousWeightedChoice(list, weights)
    if size(list) &lt;= 0 or size(weights) &lt; size(list): return error
    if size(list) == 1: return list[0]
    // Get the sum of all areas between weights
    sum = 0
    areas = NewList()
    i = 0
    while i &lt; size(list) - 1
      weightArea = abs((weights[i] + weights[i + 1]) * 0.5 *
            (list[i + 1] - list[i]))
      AddItem(areas, weightArea)
      sum = sum + weightArea
       i = i + 1
    end
    // Choose a random number
    value = RNDNUMEXCRANGE(0, sum)
    // Interpolate a number according to the given value
    i=0
    // Get the number corresponding to the random number
    runningValue = 0
    while i &lt; size(list) - 1
     area = areas[i]
     if area &gt; 0
      newValue = runningValue + area
      if value &lt;= newValue
       // NOTE: The following line can also read
       // &quot;interp = RNDU01OneExc()&quot;, that is, a new number is generated
       // within the chosen area rather than using the point
       // already generated.
       interp = (value - runningValue) / (newValue - runningValue)
       retValue = list[i] + (list[i + 1] - list[i]) * interp
       return retValue
      end
      runningValue = newValue
     end
     i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return list[size(list) - 1]
END METHOD
</pre>

<p><a id=Example_2></a></p>

<h4>Example</h4>

<p>Assume <code>list</code> is the following: <code>[0, 1, 2, 2.5, 3]</code>, and <code>weights</code> is the following: <code>[0.2, 0.8, 0.5, 0.3, 0.1]</code>.  The probability density for 2 is 0.5, and that for 2.5 is 0.3.  Since 2 has a higher probability density than 2.5, numbers near 2 are more likely to be chosen than numbers near 2.5 with the <code>ContinuousWeightedChoice</code> method.</p>

<p><a id=Normal_Gaussian_Distribution></a></p>

<h3>Normal (Gaussian) Distribution</h3>

<p>The normal distribution (also called the Gaussian distribution) can model many kinds of measurements or scores whose values are most likely around a given average and are less likely the farther away from that average on either side.</p>

<p>The following method generates two <a href="https://en.wikipedia.org/wiki/Normal_distribution">normally-distributed</a>
random numbers with mean (average) <code>mu</code> (&mu;) and standard deviation <code>sigma</code> (&sigma;), using the so-called <a href="https://en.wikipedia.org/wiki/Box-Muller_transformation">Box-Muller transformation</a>, as further explained in the pseudocode&#39;s comments.  (In a <em>standard normal distribution</em>, &mu; = 0 and &sigma; = 1.)
The standard deviation <code>sigma</code> affects how wide the normal distribution&#39;s &quot;bell curve&quot; appears; the
probability that a normally-distributed random number will be within one standard deviation from the mean is about 68.3%;
within two standard deviations (2 times <code>sigma</code>), about 95.4%, and within three standard deviations, about 99.7%.</p>

<pre>METHOD Normal2(mu, sigma)
  // Choose a Rayleigh-distributed radius (multiplied by sigma)
  radius = sqrt(-2 * ln(RNDU01ZeroExc())) * sigma
  // Choose a random angle
  angle = 2 * pi * RNDU01OneExc()
  // Return two normally-distributed numbers.  This will
  // be the X and Y coordinates of a point on a circle.
  return [mu + radius * cos(angle), mu + radius * sin(angle)]
END METHOD
</pre>

<p>Since <code>Normal2</code> returns two numbers instead of one, but many applications require only one number at a time, a problem arises on how to return one number while storing the other for later retrieval.  Ways to solve this problem are outside the scope of this page, however.  The name <code>Normal</code> will be used in this document to represent a method that returns only one normally-distributed random number rather than two.</p>

<p>Also note that a normally-distributed random number can theoretically fall anywhere on the number line, even if it&#39;s extremely far from the mean.  Depending on the use case, an application may need to reject normally-distributed numbers lower than a minimum threshold and/or higher than a maximum threshold and generate new normally-distributed numbers, or to clamp outlying numbers to those thresholds.  But then the resulting distribution would no longer be a real normal distribution, but rather a <em>truncated</em> or <em>censored</em> normal distribution, respectively.   (Rejecting or clamping outlying numbers this way can be done for any statistical distribution, not just a normal distribution.)</p>

<p><a id=Binomial_Distribution></a></p>

<h3>Binomial Distribution</h3>

<p>The following method generates a random integer that follows a binomial distribution.  This number
expresses the number of successes that have happened after a given number of independently performed trials
(expressed as <code>trials</code> below), where the probability of a success in each trial is <code>p</code> (which ranges from 0, never, to
1, always, and which can be 0.5, meaning an equal chance of success or failure).</p>

<p><strong>Example:</strong> If <code>p</code> is 0.5, the binomial distribution models the task &quot;Flip N coins, then count the number of heads.&quot;</p>

<pre>METHOD Binomial(trials, p)
    if trials &lt; 0: return error
    if trials == 0: return 0
    // Always succeeds
    if p &gt;= 1.0: return trials
    // Always fails
    if p &lt;= 0.0: return 0
    i = 0
    count = 0
    // Suggested by Saucier, R. in &quot;Computer
    // generation of statistical distributions&quot;, 2000, p. 49
    tp = trials * p
    if tp &gt; 25 or (tp &gt; 5 and p &gt; 0.1 and p &lt; 0.9)
         countval = -1
         while countval &lt; 0: countval = Normal(tp, tp)
         return floor(countval + 0.5)
    end
    if p == 0.5
        while i &lt; trials
            if RNDINT(1) == 0
                // Success
                count = count + 1
            end
            i = i + 1
        end
    else
        while i &lt; trials
            if RNDU01OneExc() &lt; p
                // Success
                count = count + 1
            end
            i = i + 1
        end
    end
    return count
END METHOD
</pre>

<p><a id=Hypergeometric_Distribution></a></p>

<h3>Hypergeometric Distribution</h3>

<p>The following method generates a random integer that follows a hypergeometric distribution.
When a given number of items are drawn at random without replacement from a set of items
each labeled either <code>1</code> or <code>0</code>,  the random integer expresses the number of items drawn
this way that are labeled <code>1</code>.  In the method below, <code>trials</code> is the number of items
drawn at random, <code>ones</code> is the number of items labeled <code>1</code> in the set, and <code>count</code> is
the number of items labeled <code>1</code> or <code>0</code> in that set.</p>

<p><strong>Example:</strong> In a 52-card deck of Anglo-American playing cards, 12 of the cards are face
cards (jacks, queens, or kings).  After the deck is shuffled and seven cards are drawn, the number
of face cards drawn this way follows a hypergeometric distribution where <code>trials</code> is 7, <code>ones</code> is
12, and <code>count</code> is 52.</p>

<pre>METHOD Hypergeometric(trials, ones, count)
    if ones &lt; 0 or count &lt; 0 or trials &lt; 0 or ones &gt; count or trials &gt; count
            return error
    end
    if ones == 0: return 0
   successes = 0
    i = 0
    currentCount = count
    currentOnes = ones
    while i &lt; trials and currentOnes &gt; 0
            if RNDINTEXC(currentCount) &lt; currentOnes
                    currentOnes = currentOnes - 1
                    successes = successes + 1
            end
            currentCount = currentCount - 1
            i = i + 1
    end
    return successes
END METHOD
</pre>

<p><a id=Poisson_Distribution></a></p>

<h3>Poisson Distribution</h3>

<p>The following method generates a random integer that follows a Poisson distribution. In the method below, the <code>mean</code> is the average number of independent events of a certain kind per fixed unit of time or space (for example, per day, hour, or square kilometer), and the method&#39;s return value gives a random number of such events during one such unit.</p>

<p>The random integer from the method below is such that the average of the random integers approaches the given mean number when this method is called repeatedly with the same mean.  Note that the mean can be an integer or a non-integer. The method given here is based on Knuth&#39;s method from 1969.</p>

<pre>METHOD Poisson(mean)
    if mean &lt; 0: return error
    if mean == 0: return 0
    p = 1.0
    // Suggested by Saucier, R. in &quot;Computer
    // generation of statistical distributions&quot;, 2000, p. 49
    if mean &gt; 9
        p = -1.0
        while p &lt; 0: p = Normal(mean, mean)
        return floor(p + 0.5)
    end
    pn = exp(-mean)
    count = 0
    while true
        count = count + 1
        p = p * RNDU01OneExc()
        if p &lt;= pn
                return count - 1
        end
    end
END METHOD
</pre>

<p><a id=Gamma_Distribution></a></p>

<h3>Gamma Distribution</h3>

<p>The following method generates a random number that follows a gamma distribution.
The gamma distribution models expected lifetimes. The method given here is based on Marsaglia and Tsang&#39;s method from 2000.</p>

<pre>METHOD GammaDist(meanLifetime)
    // Must be greater than 0
    if meanLifetime &lt;= 0: return error
    d = meanLifetime
    v = 0
    if meanLifetime &lt; 1: d = d + 1
    d = d - (1.0 / 3) // NOTE: 1.0 / 3 must be a fractional number
    c = 1.0 / sqrt(9 * d)
    while true
        x = 0
        while true
           x = Normal(0, 1)
           v = c * x + 1;
           v = v * v * v
           if v &gt; 0: break
        end
        u = 1.0 - RNDU01OneExc()
        x2 = x * x
        if u &lt; 1 - (0.0331 * x2 * x2): break
        if ln(u) &lt; (0.5 * x2) + (d * (1 - v + ln(v))): break
    end
    ret = d * v
    if meanLifetime &lt; 1
       ret = ret * exp(ln(RNDU01ZeroExc()) / meanLifetime)
    end
    return ret
end
</pre>

<p>Extended versions of the gamma distribution:</p>

<ul>
<li>The two-parameter gamma distribution (<code>GammaDist2(a, b)</code>), where <code>b</code> is the scale, is <code>GammaDist(a) * b</code>.  Here, <code>a</code> can be seen as the mean lifetime in unspecified units of time, and <code>b</code> indicates the size of each unit of time.</li>
<li>The three-parameter gamma distribution (<code>GammaDist3(a, b, c)</code>), where <code>c</code> is another shape parameter, is <code>pow(GammaDist(a), 1.0 / c) * b</code>.</li>
<li>The four-parameter gamma distribution (<code>GammaDist4(a, b, c, d)</code>), where <code>d</code> is the minimum value, is <code>pow(GammaDist(a), 1.0 / c) * b + d</code>.</li>
</ul>

<p><a id=Negative_Binomial_Distribution></a></p>

<h3>Negative Binomial Distribution</h3>

<p>The following method generates a random integer that follows a negative binomial distribution.  This number expresses the number of failures that have happened after seeing a given number of successes (expressed as <code>successes</code> below), where the probability of a success in each case is <code>p</code> (which can be greater than 0, never, and equal to or less than 1, always, and which can be 0.5, meaning an equal chance of success or failure).</p>

<p><strong>Example:</strong> If <code>p</code> is 0.5 and <code>successes</code> is 1, the negative binomial distribution models the task &quot;Flip a coin until you get tails, then count the number of heads.&quot;</p>

<p>The following implementation of the negative binomial distribution allows <code>successes</code> to be an integer or a non-integer (and implements a distribution also known as the <em>P&oacute;lya distribution</em>).</p>

<pre>METHOD NegativeBinomial(successes, p)
    // Must be 0 or greater
    if successes &lt; 0: return error
    // No failures if no successes or if always succeeds
    if successes == 0 or p &gt;= 1.0: return 0
    // Always fails (NOTE: infinity can be the maximum possible
    // integer value if NegativeBinomial is implemented to return
    // an integer)
    if p &lt;= 0.0: return infinity
    if successes == 1.0
        // Geometric distribution special case (see Saucier 2000)
        return floor(ln(RNDU01ZeroExc()) / ln(1.0 - p))
    else
        return Poisson(GammaDist(successes) * (1 - p) / p)
    end
END METHOD
</pre>

<p>The following implementation of the negative binomial distribution allows <code>successes</code> to be an integer only.</p>

<pre>METHOD NegativeBinomialInt(successes, p)
    // Must be 0 or greater
    if successes &lt; 0: return error
    // No failures if no successes or if always succeeds
    if successes == 0 or p &gt;= 1.0: return 0
    // Always fails (NOTE: infinity can be the maximum possible
    // integer value if NegativeBinomialInt is implemented to return
    // an integer)
    if p &lt;= 0.0: return infinity
    count = 0
    total = 0
    if successes == 1
        if p == 0.5
          while RNDINT(1) == 0: count = count + 1
           return count
        end
        // Geometric distribution special case (see Saucier 2000)
        return floor(ln(RNDU01ZeroExc()) / ln(1.0 - p))
    end
    while true
        if RNDU01OneExc() &lt; p
            // Success
            total = total + 1
            if total &gt;= successes
                    return count
            end
        else
            // Failure
            count = count + 1
        end
    end
END METHOD
</pre>

<p><a id=von_Mises_distribution></a></p>

<h3>von Mises distribution</h3>

<p>The von Mises distribution describes a distribution of circular angles.  In the pseudocode below, the <code>mean</code> is the mean angle, <code>kappa</code> is a shape parameter, and the method can return a number within &pi; of that mean.  The algorithm below is the Best&ndash;Fisher algorithm from 1979 (as described in Devroye 1986 with errata incorporated).</p>

<pre>METHOD VonMises(mean, kappa)
    if kappa &lt; 0: return error
    if kappa == 0
        return RNDNUMEXCRANGE(mean-pi, mean+pi)
    end
    r = 1.0 + sqrt(4 * kappa * kappa + 1)
    rho = (r - sqrt(2 * r)) / (kappa * 2)
    s = (1 + rho * rho) / (2 * rho)
    while true
        u = RNDNUMEXCRANGE(-1, 1)
        v = RNDU01ZeroOneExc()
        z = cos(pi * u)
        w = (1 + s*z) / (s + z)
        y = kappa * (s - w)
        if y*(2 - y) - v &gt;=0 or ln(y / v) + 1 - y &gt;= 0
           if angle&lt;-1: angle=-1
           if angle&gt;1: angle=1
           angle = acos(w)
           if u &lt; 0: angle = -angle
           return mean + angle
        end
    end
END METHOD
</pre>

<p><a id=Other_Non_Uniform_Distributions></a></p>

<h3>Other Non-Uniform Distributions</h3>

<ul>
<li><strong>Beta distribution (<code>BetaDist(a, b)</code>)</strong>: <code>x / (x + GammaDist(b))</code>, where <code>x</code> is <code>GammaDist(a)</code> and <code>a</code> and <code>b</code> are
the two parameters of the beta distribution.  The range of the beta distribution is 0 or greater and less than 1.

<ul>
<li><strong>Arcsine distribution</strong>: <code>BetaDist(0.5, 0.5)</code> (Saucier 2000, p. 14).</li>
<li><strong>Beta-PERT distribution</strong>: <code>startpt + size * BetaDist(1.0 + (midpt - startpt) * shape / size, 1.0 + (endpt - midpt) * shape / size)</code>. The distribution starts  at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>, <code>size</code> is <code>endpt - startpt</code>, and <code>shape</code> is a shape parameter that&#39;s 0 or greater, but usually 4.</li>
<li><strong>Beta prime distribution</strong>: <code>x / (1 - x)</code>, where <code>x</code> is <code>BetaDist(a, b)</code> and <code>a</code> and <code>b</code> are the two parameters of the
  beta distribution.</li>
<li><strong>Parabolic distribution</strong>: <code>BetaDist(2, 2)</code> (Saucier 2000, p. 30).</li>
</ul></li>
<li><strong>Beta binomial distribution</strong>: <code>Binomial(trials, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>trials</code> is a parameter of the binomial distribution.</li>
<li><strong>Beta negative binomial distribution</strong>: <code>NegativeBinomial(successes, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>successes</code> is a parameter of the negative binomial distribution. If <em>successes</em> is 1, the result is a <em>Waring&ndash;Yule distribution</em>. (<code>NegativeBinomial</code> can be <code>NegativeBinomialInt</code> instead.)</li>
<li><strong>Cauchy (Lorentz) distribution</strong>: <code>scale * tan(pi * (RNDU01OneExc()-0.5)) + mu</code>, where <code>mu</code> and <code>scale</code>
are the two parameters of the Cauchy distribution.</li>
<li><strong>Chi distribution</strong>: <code>sqrt(GammaDist(df * 0.5) * 2)</code>, where <code>df</code> is the number of degrees of
freedom.</li>
<li><strong>Chi-squared distribution</strong>: <code>GammaDist(df * 0.5) * 2</code>, where <code>df</code> is the number of degrees of
freedom.  This expresses a sum-of-squares of <code>df</code> random variables in the standard normal distribution.</li>
<li><strong>Erlang distribution</strong>: <code>GammaDist(shape) / rate</code>, where <code>shape</code> and <code>rate</code> are the two parameters of the Erlang distribution.</li>
<li><strong>Exponential distribution</strong>: <code>-ln(RNDU01ZeroExc()) / lamda</code>, where <code>lamda</code> is the inverse scale. The <code>lamda</code> is usually the probability that an independent event of a given kind will occur in a given span of time (such as in a given day or year).  <code>1.0 / lamda</code> is the scale (mean), which is usually the average waiting time between two independent events of the same kind.</li>
<li><strong>Extreme value distribution</strong>: <code>a - ln(-ln(RNDU01ZeroOneExc())) * b</code>, where <code>b</code> is the scale and <code>a</code> is the location of the distribution&#39;s curve peak (mode).
This expresses a distribution of maximum values.</li>
<li><strong>Geometric distribution</strong>: <code>NegativeBinomialInt(1, p)</code>, where <code>p</code> has the same meaning
as in the negative binomial distribution.  As used here, this is the number of failures that have happened before a success happens. (Saucier 2000, p. 44, also mentions an alternative definition that includes the success.)</li>
<li><strong>Gumbel distribution</strong>: <code>a + ln(-ln(RNDU01ZeroOneExc())) * b</code>, where <code>b</code> is the scale and <code>a</code> is the location of the distribution&#39;s curve peak (mode).
This expresses a distribution of minimum values.</li>
<li><strong>Half-normal distribution</strong>: <code>abs(Normal(0, sqrt(pi * 0.5) / invscale)))</code>, where <code>invscale</code> is a parameter of the half-normal distribution.</li>
<li><strong>Inverse chi-squared distribution</strong>: <code>df * scale / (GammaDist(df * 0.5) * 2)</code>, where <code>df</code> is the number of degrees of freedom and <code>scale</code> is the scale, usually <code>1.0 / df</code>.</li>
<li><strong>Inverse gamma distribution</strong>: <code>b / GammaDist(a)</code>, where <code>a</code> and <code>b</code> have the
same meaning as in the two-parameter gamma distribution.</li>
<li><strong>Inverse Gaussian distribution (Wald distribution)</strong>: Generate <code>n = mu + (mu*mu*y/(2*lamda)) - mu * sqrt(4 * mu * lamda * y + mu * mu * y * y) / (2 * lamda)</code>, where <code>y = pow(Normal(0, 1), 2)</code>, then return <code>n</code> if <code>RNDU01OneExc() &lt;= mu / (mu + n)</code>, or <code>mu * mu / n</code> otherwise. <code>mu</code> is the mean and <code>lamda</code> is the scale; both parameters are greater than 0. Based on method published in <a href="http://luc.devroye.org/rnbookindex.html">Devroye 1986</a>.</li>
<li><strong>Laplace (double exponential) distribution</strong>: <code>(ln(RNDU01ZeroExc()) - ln(RNDU01ZeroExc())) * beta + mu</code>, where <code>beta</code> is the scale and <code>mu</code> is the mean.</li>
<li><strong>L&eacute;vy distribution</strong>: <code>sigma * 0.5 / GammaDist(0.5) + mu</code>, where <code>mu</code> is the location and <code>sigma</code> is the dispersion.</li>
<li><strong>Logarithmic normal distribution</strong>: <code>exp(Normal(mu, sigma))</code>, where <code>mu</code> and <code>sigma</code>
have the same meaning as in the normal distribution.</li>
<li><strong>Logarithmic series distribution</strong>: <code>floor(1.0 + ln(RNDU01ZeroExc()) / ln(1.0 - pow(1.0 - param,1.0 - RNDU01OneExc())))</code>, where <code>param</code> is a number greater than 0 and less than 1. Based on method described in Devroye 1986.</li>
<li><strong>Logistic distribution</strong>: <code>(ln(x/(1.0 - x)) * scale + mean</code>, where <code>x</code> is <code>RNDU01ZeroOneExc()</code> and <code>mean</code> and <code>scale</code> are the two parameters of the logistic distribution.</li>
<li><strong>Maxwell distribution</strong>: <code>scale * sqrt(GammaDist(1.5) * 2)</code>, where <code>scale</code> is the scale.</li>
<li><strong>Noncentral chi-squared distribution</strong>: <code>GammaDist(df * 0.5 + Poisson(sms * 0.5)) * 2</code>, where <code>df</code> is the number of degrees of freedom and <code>sms</code> is the sum of mean squares.</li>
<li><strong>Noncentral <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5) * n / (GammaDist(n * 0.5 + Poisson(sms * 0.5)) * m)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random numbers with a chi-squared distribution, one of which has a noncentral distribution with sum of mean squares equal to <code>sms</code>.</li>
<li><strong>Pareto distribution</strong>: <code>pow(RNDU01ZeroOneExc(), -1.0 / alpha) * minimum</code>, where <code>alpha</code>  is the shape and <code>minimum</code> is the minimum.</li>
<li><strong>Pascal distribution</strong>: <code>NegativeBinomialInt(successes, p) + successes</code>, where <code>successes</code> and <code>p</code> have the same meaning as in the negative binomial distribution.</li>
<li><strong>Rayleigh distribution</strong>: <code>a * sqrt(-2 * ln(RNDU01ZeroExc()))</code>, where <code>a</code> is the scale and is greater than 0.</li>
<li><strong>Skellam distribution</strong>: <code>Poisson(mean1) - Poisson(mean2)</code>, where <code>mean1</code> and <code>mean2</code> are the means of the two Poisson variables.</li>
<li><strong>Skewed normal distribution</strong>: <code>Normal(0, x) + mu + alpha * abs(Normal(0, x))</code>, where <code>x</code> is <code>sigma / sqrt(alpha * alpha + 1.0)</code>, <code>mu</code> and <code>sigma</code> have
the same meaning as in the normal distribution, and <code>alpha</code> is a shape parameter.</li>
<li><strong>Snedecor&#39;s (Fisher&#39;s) <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5) * n / (GammaDist(n * 0.5) * m)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random numbers with a chi-squared distribution.</li>
<li><strong>Student&#39;s <em>t</em>-distribution</strong>: <code>Normal(cent, 1) / sqrt(GammaDist(df * 0.5) * 2 / df)</code>, where <code>df</code> is the number of degrees of freedom, and <em>cent</em> is the mean of the normally-distributed random number.  A <code>cent</code> other than 0 indicates a <em>noncentral</em> distribution.</li>
<li><strong>Triangular distribution</strong>: <code>ContinuousWeightedChoice([startpt, midpt, endpt], [0, 1, 0])</code>. The distribution starts at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>.</li>
<li><strong>Weibull distribution</strong>: <code>b * pow(-ln(RNDU01ZeroExc()),1.0 / a)</code>, where <code>a</code> is the shape, <code>b</code> is the scale, and <code>a</code> and <code>b</code> are greater than 0.</li>
<li><strong>Zeta distribution</strong>: Generate <code>n = floor(pow(RNDU01ZeroOneExc(), -1.0 / r))</code>, and if <code>d / pow(2, r) &lt; (d - 1) * RNDU01OneExc() * n / (pow(2, r) - 1.0)</code>, where <code>d = pow((1.0 / n) + 1, r)</code>, repeat this process. The parameter <code>r</code> is greater than 0. Based on method described in Devroye 1986. A zeta distribution truncated by rejecting random values greater than some positive integer is called a <em>Zipf distribution</em> or <em>Estoup distribution</em>. (Note that Devroye uses &quot;Zipf distribution&quot; to refer to the untruncated zeta distribution.)</li>
</ul>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>This page discussed many ways applications can extract random numbers
from random number generators.</p>

<p>Feel free to send comments. They may help improve this page.  In particular, corrections to any method given on this page are welcome.</p>

<p>I acknowledge the commenters to the CodeProject version of this page, including George Swan, who referred me to the reservoir sampling method.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><sup id=Note1>(1)</sup> This number format describes B-bit signed integers with minimum value -2<sup>B-1</sup> and maximum value 2<sup>B-1</sup> - 1, where B is a positive even number of bits; examples include Java&#39;s <code>short</code>, <code>int</code>, and <code>long</code>, with 16, 32, and 64 bits, respectively. A <em>signed integer</em> is an integer that can be positive, zero, or negative. In <em>two&#39; s-complement form</em>, nonnegative numbers have the highest (most significant) bit set to zero, and negative numbers have that bit (and all bits beyond) set to one, and a negative number is stored in such form by decreasing its absolute value by 1 and swapping the bits of the resulting number.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="http://creativecommons.org/licenses/publicdomain/">A Public Domain dedication</a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
