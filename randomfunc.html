<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generation and Sampling Methods</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generation and Sampling Methods</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>Begun on June 4, 2017; last updated on Feb. 6, 2018.</p>

<p>Discusses many ways applications can do random number generation and sampling from an underlying RNG and includes pseudocode for many of them.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page discusses many ways applications can do random number generation and sampling from an underlying random number generator (RNG), often with pseudocode. Those methods include&mdash;</p>

<ul>
<li>ways to generate uniform random numbers from an underlying RNG (such as the <a href="#Core_Random_Generation_Method"><strong>core method, <code>RNDINT(N)</code></strong></a>),</li>
<li>ways to generate randomized content and conditions, such as <a href="#Boolean_True_False_Conditions"><strong>true/false conditions</strong></a>, <a href="#Shuffling"><strong>shuffling</strong></a>, and <a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items"><strong>sampling unique items from a list</strong></a>, and</li>
<li>generating non-uniform random numbers, including <a href="#Weighted_Choice"><strong>weighted choice</strong></a>, the <a href="#Normal_Gaussian_Distribution"><strong>normal distribution</strong></a>, and <a href="#Other_Non_Uniform_Distributions"><strong>other probability distributions</strong></a>.</li>
</ul>

<p><a href="https://peteroupc.github.io/randomgen.zip"><strong>Sample Python code</strong></a> that implements many of the methods in this document is available.</p>

<p>All the random number methods presented on this page are ultimately based on an underlying RNG; however, the methods make no assumptions on that RNG&#39;s implementation (e.g., whether that RNG is a deterministic RNG or some other kind) or on that RNG&#39;s statistical quality or predictability.</p>

<p>In general, this document does not cover how to choose an underlying RNG for a particular application, including in terms of security, performance, and quality.  <a href="https://peteroupc.github.io/random.html#Hash_Functions"><strong>Hash functions</strong></a> are also not specifically covered in this document.  I have written more on RNG recommendations in <a href="https://peteroupc.github.io/random.html"><strong>another document</strong></a>.</p>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/randomfunc.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomfunc.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document either on</strong> <a href="https://www.codeproject.com/Articles/1190459/Random-Number-Generation-and-Sampling-Methods"><strong>CodeProject</strong></a> <strong>or on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p><strong>Comments on any aspect of this document are welcome, but especially comments on the following:</strong></p>

<ul>
<li><strong>Corrections to any method given on this page.</strong></li>
<li><strong>Requests to provide an implementation of any method given here in other programming languages, in addition to Python.</strong></li>
<li><strong>If there is enough interest by readers, I may discuss approaches to generate random mazes, graphs, matrices, or paths.</strong></li>
<li><strong>Suggestions to trim the size of this document, such as by limiting it to the most common and most useful methods for generating random numbers.</strong></li>
</ul>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction"><strong>Introduction</strong></a>

<ul>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
</ul></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Notation_and_Definitions"><strong>Notation and Definitions</strong></a></li>
<li><a href="#Uniform_Random_Numbers"><strong>Uniform Random Numbers</strong></a>

<ul>
<li><a href="#RNDINT_Random_Integers_in_0_N"><code>RNDINT</code>: Random Integers in [0, N]</a></li>
<li><a href="#RNDINTRANGE_Random_Integers_in_N_M"><code>RNDINTRANGE</code>: Random Integers in [N, M]</a></li>
<li><a href="#RNDINTEXC_Random_Integers_in_0_N"><strong><code>RNDINTEXC</code>: Random Integers in [0, N)</strong></a></li>
<li><a href="#RNDINTEXCRANGE_Random_Integers_in_N_M"><strong><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</strong></a></li>
<li><a href="#Uniform_Random_Bits"><strong>Uniform Random Bits</strong></a></li>
<li><a href="#Uniform_Random_Real_Numbers"><strong>Uniform Random Real Numbers</strong></a>

<ul>
<li><a href="#RNDU01_RNDU01OneExc_RNDU01ZeroExc_and_RNDU01ZeroOneExc_Random_Numbers_Bounded_by_0_and_1"><strong><code>RNDU01</code>, <code>RNDU01OneExc</code>, <code>RNDU01ZeroExc</code>, and <code>RNDU01ZeroOneExc</code>: Random Numbers Bounded by 0 and 1</strong></a></li>
<li><a href="#Alternative_Implementation_for_RNDU01"><strong>Alternative Implementation for <code>RNDU01</code></strong></a></li>
<li><a href="#RNDRANGE_RNDRANGEMinExc_RNDRANGEMaxExc_and_RNDRANGEMinMaxExc_Random_Numbers_in_an_Arbitrary_Interval"><strong><code>RNDRANGE</code>, <code>RNDRANGEMinExc</code>, <code>RNDRANGEMaxExc</code>, and <code>RNDRANGEMinMaxExc</code>: Random Numbers in an Arbitrary Interval</strong></a></li>
</ul></li>
<li><a href="#Certain_Programming_Environments"><strong>Certain Programming Environments</strong></a></li>
</ul></li>
<li><a href="#Randomization_Techniques"><strong>Randomization Techniques</strong></a>

<ul>
<li><a href="#Boolean_True_False_Conditions"><strong>Boolean (True/False) Conditions</strong></a></li>
<li><a href="#Random_Sampling"><strong>Random Sampling</strong></a>

<ul>
<li><a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>Sampling With Replacement: Choosing a Random Item from a List</strong></a></li>
<li><a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items"><strong>Sampling Without Replacement: Choosing Several Unique Items</strong></a></li>
<li><a href="#Shuffling"><strong>Shuffling</strong></a></li>
<li><a href="#Random_Character_Strings"><strong>Random Character Strings</strong></a></li>
<li><a href="#Pseudocode_for_Random_Sampling"><strong>Pseudocode for Random Sampling</strong></a></li>
</ul></li>
<li><a href="#Rejection_Sampling"><strong>Rejection Sampling</strong></a></li>
<li><a href="#Generating_Random_Numbers_in_Sorted_Order"><strong>Generating Random Numbers in Sorted Order</strong></a></li>
<li><a href="#Random_Walks"><strong>Random Walks</strong></a></li>
<li><a href="#Low_Discrepancy_Sequences"><strong>Low-Discrepancy Sequences</strong></a></li>
<li><a href="#Randomization_in_Simulations"><strong>Randomization in Simulations</strong></a></li>
</ul></li>
<li><a href="#General_Non_Uniform_Distributions"><strong>General Non-Uniform Distributions</strong></a>

<ul>
<li><a href="#Weighted_Choice"><strong>Weighted Choice</strong></a>

<ul>
<li><a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_Multiple_Copies"><strong>Weighted Choice Without Replacement (Multiple Copies)</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_Single_Copies"><strong>Weighted Choice Without Replacement (Single Copies)</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_Indefinite_Size_List"><strong>Weighted Choice Without Replacement (Indefinite-Size List)</strong></a></li>
<li><a href="#Continuous_Weighted_Choice"><strong>Continuous Weighted Choice</strong></a></li>
</ul></li>
<li><a href="#Mixtures_of_Distributions"><strong>Mixtures of Distributions</strong></a></li>
<li><a href="#Transformations_of_Random_Numbers"><strong>Transformations of Random Numbers</strong></a></li>
<li><a href="#Random_Numbers_from_a_Distribution_of_Data_Points"><strong>Random Numbers from a Distribution of Data Points</strong></a></li>
<li><a href="#Random_Numbers_from_an_Arbitrary_Distribution"><strong>Random Numbers from an Arbitrary Distribution</strong></a></li>
<li><a href="#Censored_and_Truncated_Distributions"><strong>Censored and Truncated Distributions</strong></a></li>
</ul></li>
<li><a href="#Specific_Non_Uniform_Distributions"><strong>Specific Non-Uniform Distributions</strong></a>

<ul>
<li><a href="#Dice"><strong>Dice</strong></a></li>
<li><a href="#Normal_Gaussian_Distribution"><strong>Normal (Gaussian) Distribution</strong></a></li>
<li><a href="#Binomial_Distribution"><strong>Binomial Distribution</strong></a></li>
<li><a href="#Poisson_Distribution"><strong>Poisson Distribution</strong></a></li>
<li><a href="#Gamma_Distribution"><strong>Gamma Distribution</strong></a></li>
<li><a href="#Beta_Distribution"><strong>Beta Distribution</strong></a></li>
<li><a href="#Negative_Binomial_Distribution"><strong>Negative Binomial Distribution</strong></a></li>
<li><a href="#von_Mises_Distribution"><strong>von Mises Distribution</strong></a></li>
<li><a href="#Stable_Distribution"><strong>Stable Distribution</strong></a></li>
<li><a href="#Hypergeometric_Distribution"><strong>Hypergeometric Distribution</strong></a></li>
<li><a href="#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a></li>
<li><a href="#Random_Numbers_with_a_Given_Positive_Sum"><strong>Random Numbers with a Given Positive Sum</strong></a></li>
<li><a href="#Multinomial_Distribution"><strong>Multinomial Distribution</strong></a></li>
<li><a href="#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a></li>
<li><a href="#Other_Non_Uniform_Distributions"><strong>Other Non-Uniform Distributions</strong></a></li>
</ul></li>
<li><a href="#Geometric_Sampling"><strong>Geometric Sampling</strong></a>

<ul>
<li><a href="#Random_Points_Inside_a_Simplex"><strong>Random Points Inside a Simplex</strong></a></li>
<li><a href="#Random_Points_on_the_Surface_of_a_Hypersphere"><strong>Random Points on the Surface of a Hypersphere</strong></a></li>
<li><a href="#Random_Points_Inside_a_Ball_or_Shell"><strong>Random Points Inside a Ball or Shell</strong></a></li>
<li><a href="#Random_Latitude_and_Longitude"><strong>Random Latitude and Longitude</strong></a></li>
</ul></li>
<li><a href="#Conclusion"><strong>Conclusion</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Implementation_of_erf"><strong>Implementation of <code>erf</code></strong></a></li>
<li><a href="#Mean_and_Variance_Calculation"><strong>Mean and Variance Calculation</strong></a></li>
<li><a href="#Norm_Calculation"><strong>Norm Calculation</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Notation_and_Definitions></a></p>

<h2>Notation and Definitions</h2>

<ul>
<li>The <a href="https://peteroupc.github.io/pseudocode.html"><strong>pseudocode conventions</strong></a> apply to this document.</li>
<li><strong>Intervals.</strong> The following notation is used for intervals:

<ul>
<li>[<code>a</code>, <code>b</code>) means &quot;<code>a</code> or greater, but less than <code>b</code>&quot;.</li>
<li>(<code>a</code>, <code>b</code>) means &quot;greater than <code>a</code>, but less than <code>b</code>&quot;.</li>
<li>(<code>a</code>, <code>b</code>] means &quot;greater than <code>a</code> and less than or equal to <code>b</code>&quot;.</li>
<li>[<code>a</code>, <code>b</code>] means &quot;<code>a</code> or greater and <code>b</code> or less&quot;.</li>
</ul></li>
<li><strong>Random number generator (RNG).</strong> Software and/or hardware that seeks to generate independent numbers that seem to occur by chance and that are approximately uniformly distributed<sup><a href="#Note1"><strong>(1)</strong></a></sup>.</li>
</ul>

<p><a id=Uniform_Random_Numbers></a></p>

<h2>Uniform Random Numbers</h2>

<p>This section describes how an underlying RNG can be used to generate independent uniformly-distributed random numbers.  Here is an overview of the methods described in this section.</p>

<ul>
<li>Random Integers: <code>RNDINT</code>, <code>RNDINTEXC</code>, <code>RNDINTRANGE</code>, <code>RNDINTEXCRANGE</code>.</li>
<li>Random Numbers in 0-1 Bounded Interval: <code>RNDU01</code>, <code>RNDU01ZeroExc</code>, <code>RNDU01OneExc</code>, <code>RNDU01ZeroOneExc</code>.</li>
<li>Other Random Numbers: <code>RNDRANGE</code>, <code>RNDRANGEMinExc</code>, <code>RNDRANGEMaxExc</code>, <code>RNDRANGEMinMaxExc</code>.</li>
</ul>

<p>One method, <code>RNDINT</code>, described next, can serve as the basis for the remaining methods.</p>

<p><a id=RNDINT_Random_Integers_in_0_N></a></p>

<h3><code>RNDINT</code>: Random Integers in [0, N]</h3>

<p>In this document, <strong><code>RNDINT(maxInclusive)</code></strong> is the core method for generating independent uniform random integers from an underlying RNG, which is called <strong><code>RNG()</code></strong> in this section. The random integer is <strong>in the interval [0, <code>maxInclusive</code>]</strong>.  If <code>RNG()</code> outputs integers in the interval <strong>[0, positive <code>MODULUS</code>)</strong> (examples of <code>MODULUS</code> include 1,000,000 and 6), then <code>RNDINT(maxInclusive)</code> can be implemented as in the pseudocode below.<sup><a href="#Note2"><strong>(2)</strong></a></sup></p>

<pre>METHOD RndIntHelperNonPowerOfTwo(maxInclusive)
    cx = floor(maxInclusive / MODULUS) + 1
    while true
       ret = cx * RNG()
       // NOTE: If this method is implemented using a fixed-
       // precision type, the addition operation below should
       // check for overflow and should reject the number
       // if overflow would result.
       ret = ret + RNDINT(cx - 1)
       if ret &lt;= maxInclusive: return ret
    end
END METHOD

METHOD RndIntHelperPowerOfTwo(maxInclusive)
  // NOTE: Finds the number of bits minus 1 needed
  // to represent MODULUS (in other words, the number
  // of random bits returned by RNG() ). This will
  // be a constant here, though.
  modBits = ln(MODULUS)/ln(2)
  // Calculate the bit count of maxInclusive
  bitCount = 0
  tempnumber = maxInclusive
  while tempnumber &gt; 0
    // NOTE: If the programming language implements
    // division with two integers by truncating to an
    // integer, the division can be used as is without
    // using a &quot;floor&quot; function.
    tempnumber = floor(tempnumber / 2)
    bitCount = bitCount + 1
  end
  while true
    // Build a number with `bitCount` bits
    tempnumber = 0
    while bitCount &gt; 0
      wordBits = modBits
      rngNumber = RNG()
      if wordBits &gt; bitCount
        wordBits = bitCount
        // Truncate number to &#39;wordBits&#39; bits
        // NOTE: If the programming language supports a bitwise
        // AND operator, the mod operation can be implemented
        // as &quot;rndNumber AND ((1 &lt;&lt; wordBits) - 1)&quot;
        rngNumber = rem(rngNumber, (1 &lt;&lt; wordBits))
      end
      tempnumber = tempnumber &lt;&lt; wordBits
      // NOTE: In programming languages that
      // support the OR operator between two
      // integers, that operator can replace the
      // plus operator below.
      tempnumber = tempnumber + rngNumber
      bitCount = bitCount - wordBits
    end
    // Accept the number if allowed
    if tempnumber &lt;= maxInclusive: return tempnumber
  end
END METHOD

METHOD RNDINT(maxInclusive)
  // maxInclusive must be 0 or greater
  if maxInclusive &lt; 0: return error
  if maxInclusive == 0: return 0
  // N equals modulus
  if maxInclusive == MODULUS - 1: return RNG()
  // NOTE: Finds the number of bits minus 1 needed
  // to represent MODULUS (if it&#39;s a power of 2).
  // This will be a constant here, though.
  modBits=ln(MODULUS)/ln(2)
  // NOTE: The following condition checks if MODULUS
  // is a power of 2.  This will be a constant here, though.
  isPowerOfTwo=floor(modBits) == modBits
  // Special cases if MODULUS is a power of 2
  if isPowerOfTwo
       if maxInclusive == 1: return rem(RNG(), 2)
       if maxInclusive == 3 and modBits &gt;= 2: return rem(RNG(), 4)
       if maxInclusive == 255 and modBits &gt;= 8: return rem(RNG(), 256)
       if maxInclusive == 65535 and modBits &gt;=16: return rem(RNG(), 65535)
   end
  if maxInclusive &gt; MODULUS - 1:
     if isPowerOfTwo
       return RndIntHelperPowerOfTwo(maxInclusive)
     else
       return RndIntHelperNonPowerOfTwo(maxInclusive)
     end
  else
    // NOTE: If the programming language implements
    // division with two integers by truncating to an
    // integer, the division can be used as is without
    // using a &quot;floor&quot; function.
    nPlusOne = maxInclusive + 1
    maxexc = floor((MODULUS - 1) / nPlusOne) * nPlusOne
    while true
      ret = RNG()
      if ret &lt; nPlusOne: return ret
      if ret &lt; maxexc: return rem(ret, nPlusOne)
    end
  end
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>The <code>RNDINT</code> implementation given here is not necessarily performant.  For example, multithreading or vectorization (SIMD instructions) can help improve performance of generating multiple random numbers at once.  Also, if <code>MODULUS</code> is 2<sup>32</sup> or another power of 2 (indicating <code>RNG()</code> outputs <em>n</em>-bit integers), a more sophisticated implementation can save unused bits generated by <code>RNDINT</code> for later use.  These and other performance optimizations are not discussed further in this document.</li>
<li>In functional programming languages such as Haskell, <code>RNDINT()</code>, as well as <code>RNG()</code> itself and other random-number-generating methods in this document, can be implemented by taking a <em>seed</em> as an additional parameter, and returning a list of two items &mdash; the random number and a new <em>seed</em> (as in the Haskell package <code>AC-Random</code>).  This works only if the underlying RNG is deterministic.</li>
</ol>

<p><strong>Examples:</strong></p>

<ol>
<li>To generate a random number that&#39;s either -1 or 1, the following idiom can be used: <code>(RNDINT(1) * 2 - 1)</code>.</li>
<li>To generate a random integer that&#39;s divisible by a positive integer (<code>DIV</code>), generate the integer with any method (such as <code>RNDINT</code>), let <code>X</code> be that integer, then generate <code>X - rem(X, DIV)</code> if <code>X &gt;= 0</code>, or <code>X - (DIV - rem(abs(X), DIV))</code> otherwise. (Depending on the method, the resulting integer may be out of range, in which case this procedure is to be repeated.)</li>
<li>A random 2-dimensional point on an NxM grid can be expressed as a single integer as follows:

<ul>
<li>To generate a random NxM point <code>P</code>, generate <code>P = RNDINT(N * M - 1)</code> (<code>P</code> is thus in the interval [0, <code>N * M</code>)).</li>
<li>To convert a point <code>P</code> to its 2D coordinates, generate <code>[rem(P, N), floor(P / N)]</code>. (Each coordinate starts at 0.)</li>
<li>To convert 2D coordinates <code>coord</code> to an NxM point, generate <code>P = coord[1] * N + coord[0]</code>.</li>
</ul></li>
</ol>
</blockquote>

<p><a id=RNDINTRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTRANGE</code>: Random Integers in [N, M]</h3>

<p>The na&iuml;ve way of generating a <strong>random integer in the interval [<code>minInclusive</code>, <code>maxInclusive</code>]</strong>, shown below, works well for nonnegative integers and arbitrary-precision integers.</p>

<pre> METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   return minInclusive + RNDINT(maxInclusive - minInclusive)
 END METHOD
</pre>

<p>The na&iuml;ve approach won&#39;t work as well, though, for signed integer formats if the difference between <code>maxInclusive</code> and <code>minInclusive</code> exceeds the highest possible integer for the format.  For fixed-length signed integer formats <sup><a href="#Note3"><strong>(3)</strong></a></sup>, such random integers can be generated using the following pseudocode.  In the pseudocode below, <code>INT_MAX</code> is the highest possible integer in the integer format.</p>

<pre>METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   if minInclusive == maxInclusive: return minInclusive
   if minInclusive==0: return RNDINT(maxInclusive)
   // Difference does not exceed maxInclusive
   if minInclusive &gt; 0 or minInclusive + INT_MAX &gt;= maxInclusive
       return minInclusive + RNDINT(maxInclusive - minInclusive)
   end
   while true
     ret = RNDINT(INT_MAX)
     // NOTE: If the signed integer format uses two&#39;s-complement
     // form, use the following line:
     if RNDINT(1) == 0: ret = -1 - ret
     // NOTE: If the signed integer format has positive and negative
     // zero, as is the case, e.g., for Java `float` and
     // `double` and .NET&#39;s implementation of `System.Decimal`,
     // use the following three lines instead of the preceding line;
     // here, zero will be rejected at a 50% chance because zero occurs
     // twice in both forms.
     // negative = RNDINT(1) == 0
     // if negative: ret = 0 - ret
     // if negative and ret == 0: continue
     if ret &gt;= minInclusive and ret &lt;= maxInclusive: return ret
   end
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>To simulate rolling an N-sided die (N greater than 1), generate a random number in the interval [1, N] by <code>RNDINTRANGE(1, N)</code>.</li>
<li>Generating a random integer with one base-10 digit is equivalent to generating <code>RNDINTRANGE(0, 9)</code>.</li>
<li>Generating a random integer with N base-10 digits (where N is 2 or greater), where the first digit can&#39;t be 0, is equivalent to generating <code>RNDINTRANGE(pow(10, N-1), pow(10, N) - 1)</code>.</li>
<li><p>Pseudocode like the following can be used to choose a <strong>random date-and-time</strong> bounded by two others (<code>date1</code>, <code>date2</code>).  In the following pseudocode, <code>DATETIME_TO_NUMBER</code> and <code>NUMBER_TO_DATETIME</code> convert a date-and-time to or from a number, respectively, at the required granularity, for instance, month, day, or hour granularity (the details of such conversion depend on the date-and-time format and are outside the scope of this document).</p>

<pre>dtnum1 = DATETIME_TO_NUMBER(date1)
dtnum2 = DATETIME_TO_NUMBER(date2)
// Choose a random date-and-time
// in [dtnum1, dtnum2].  Any other
// random selection strategy can be
// used here.
num = RNDINTRANGE(date1, date2)
result = NUMBER_TO_DATETIME(num)
</pre></li>
</ol>
</blockquote>

<p><a id=RNDINTEXC_Random_Integers_in_0_N></a></p>

<h3><code>RNDINTEXC</code>: Random Integers in [0, N)</h3>

<p><code>RNDINTEXC(maxExclusive)</code>, which generates a <strong>random integer in the interval</strong> <strong>[0, <code>maxExclusive</code>)</strong>, can be implemented as follows<sup><a href="#Note4"><strong>(4)</strong></a></sup>:</p>

<pre> METHOD RNDINTEXC(maxExclusive)
    if maxExclusive &lt;= 0: return error
    return RNDINT(maxExclusive - 1)
 END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> <code>RNDINTEXC</code> is not given as the core random generation method because it&#39;s harder to fill integers in popular integer formats with random bits with this method.</p>

<p><strong>Example:</strong> Generating a random number in the interval [<code>mn</code>, <code>mx</code>) in increments equal to <code>step</code> is equivalent to generating <code>mn+step*RNDINTEXC(ceil((mx-mn)/(1.0*step)))</code>.</p>
</blockquote>

<p><a id=RNDINTEXCRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</h3>

<p><strong><code>RNDINTEXCRANGE</code></strong> returns a <strong>random integer in the interval</strong> <strong>[<code>minInclusive</code>, <code>maxExclusive</code>)</strong>.  It can be implemented using <a href="#RNDINTRANGE_Random_Integers_in_N_M"><strong><code>RNDINTRANGE</code></strong></a>, as the following pseudocode demonstrates.</p>

<pre>METHOD RNDINTEXCRANGE(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   // NOTE: For integer formats that can express negative
   // or nonnegative integers, replace the following line
   // with &quot;if minInclusive &gt;=0 or minInclusive + INT_MAX &gt;=
   // maxExclusive&quot;, where `INT_MAX` has the same meaning
   // as in the pseudocode for `RNDINTRANGE`.
   if minInclusive &gt;=0
     return RNDINTRANGE(minInclusive, maxExclusive - 1)
   end
   while true
     ret = RNDINTRANGE(minInclusive, maxExclusive)
     if ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<p><a id=Uniform_Random_Bits></a></p>

<h3>Uniform Random Bits</h3>

<p>The idiom <code>RNDINT((1 &lt;&lt; b) - 1)</code> is a na&iuml;ve way of generating a <strong>uniform random <code>b</code>-bit integer</strong> (with maximum 2<sup><code>b</code></sup> - 1).</p>

<p>In practice, memory is usually divided into <em>bytes</em>, or 8-bit nonnegative integers in the interval [0, 255].  In this case, a byte array or a block of memory can be filled with random bits by setting each byte to <code>RNDINT(255)</code>. (There may be faster, RNG-specific ways to fill memory with random bytes, such as with RNGs that generate random numbers in parallel.  These ways are not detailed in this document.)</p>

<p><a id=Uniform_Random_Real_Numbers></a></p>

<h3>Uniform Random Real Numbers</h3>

<p>This section defines methods that generate uniform random real numbers.</p>

<p>Note, however, that since there are infinitely many real numbers between two others, any computer implementation can randomly choose from only a subset of those numbers, since the chosen number has to be stored in a data block with finite memory space.</p>

<p><a id=RNDU01_RNDU01OneExc_RNDU01ZeroExc_and_RNDU01ZeroOneExc_Random_Numbers_Bounded_by_0_and_1></a></p>

<h4><code>RNDU01</code>, <code>RNDU01OneExc</code>, <code>RNDU01ZeroExc</code>, and <code>RNDU01ZeroOneExc</code>: Random Numbers Bounded by 0 and 1</h4>

<p>This section defines four methods that generate a <strong>random number bounded by 0 and 1</strong>.  There are several ways to implement each of those four methods; for each method, the ways are ordered from most preferred to least preferred, and <code>X</code> and <code>INVX</code> are defined later.</p>

<ul>
<li><strong><code>RNDU01()</code>, interval [0, 1]</strong>:

<ul>
<li>For Java <code>float</code> or <code>double</code>, use the alternative implementation given later.</li>
<li><code>RNDINT(X) * INVX</code>.</li>
<li><code>RNDINT(X) / X</code>, if the number format can represent <code>X</code>.</li>
</ul></li>
<li><p><strong><code>RNDU01OneExc()</code>, interval [0, 1)</strong>:</p>

<ul>
<li>Generate <code>RNDU01()</code> in a loop until a number other than 1.0 is generated this way.</li>
<li><code>RNDINT(X - 1) * INVX</code>.</li>
<li><code>RNDINTEXC(X) * INVX</code>.</li>
<li><code>RNDINT(X - 1) / X</code>, if the number format can represent <code>X</code>.</li>
<li><code>RNDINTEXC(X) / X</code>, if the number format can represent <code>X</code>.</li>
</ul>

<p>Note that <code>RNDU01OneExc()</code> corresponds to <code>Math.random()</code> in Java and JavaScript.  See also &quot;Generating uniform doubles in the unit interval&quot; in the <a href="http://xoroshiro.di.unimi.it/#remarks"><strong><code>xoroshiro+</code> remarks page</strong></a>.</p></li>
<li><strong><code>RNDU01ZeroExc()</code>, interval (0, 1]</strong>:

<ul>
<li>Generate <code>RNDU01()</code> in a loop until a number other than 0.0 is generated this way.</li>
<li><code>(RNDINT(X - 1) + 1) * INVX</code>.</li>
<li><code>(RNDINTEXC(X) + 1) * INVX</code>.</li>
<li><code>(RNDINT(X - 1) + 1) / X</code>, if the number format can represent <code>X</code>.</li>
<li><code>(RNDINTEXC(X) + 1) / X</code>, if the number format can represent <code>X</code>.</li>
<li><code>1.0 - RNDU01OneExc()</code> (but this is recommended only if the set of numbers <code>RNDU01OneExc()</code> could return &mdash; as opposed to their probability &mdash; is evenly distributed).</li>
</ul></li>
<li><strong><code>RNDU01ZeroOneExc()</code>, interval (0, 1)</strong>:

<ul>
<li>Generate <code>RNDU01()</code> in a loop until a number other than 0.0 or 1.0 is generated this way.</li>
<li><code>(RNDINT(X - 2) + 1) * INVX</code>.</li>
<li><code>(RNDINTEXC(X - 1) + 1) * INVX</code>.</li>
<li><code>(RNDINT(X - 2) + 1) / X</code>, if the number format can represent <code>X</code>.</li>
<li><code>(RNDINTEXC(X - 1) + 1) / X</code>, if the number format can represent <code>X</code>.</li>
</ul></li>
</ul>

<p>In the idioms above:</p>

<ul>
<li><code>X</code> is the highest integer <code>p</code> such that all multiples of <code>1/p</code> in the interval [0, 1] are representable in the number format in question.  For example&mdash;

<ul>
<li>for the 64-bit IEEE 754 binary floating-point format (e.g., Java <code>double</code>), <code>X</code> is 2<sup>53</sup> (9007199254740992),</li>
<li>for the 32-bit IEEE 754 binary floating-point format (e.g., Java <code>float</code>), <code>X</code> is 2<sup>24</sup> (16777216),</li>
<li>for the 64-bit IEEE 754 decimal floating-point format, <code>X</code> is 10<sup>16</sup>, and</li>
<li>for the .NET Framework decimal format (<code>System.Decimal</code>), <code>X</code> is 10<sup>28</sup>.</li>
</ul></li>
<li><code>INVX</code> is the constant 1 divided by <code>X</code>.</li>
</ul>

<p><a id=Alternative_Implementation_for_RNDU01></a></p>

<h4>Alternative Implementation for <code>RNDU01</code></h4>

<p>For Java&#39;s <code>double</code> and <code>float</code> (or generally, any fixed-precision binary floating-point format with fixed exponent range), the following pseudocode for <code>RNDU01()</code> can be used instead. See also (Downey 2007)<sup><a href="#Note5"><strong>(5)</strong></a></sup>.  In the pseudocode below, <code>SIGBITS</code> is the binary floating-point format&#39;s precision (the number of binary digits the format can represent without loss; e.g., 53 for Java&#39;s <code>double</code>).</p>

<pre>METHOD RNDU01()
    e=-SIGBITS
    while true
        if RNDINT(1)==0: e = e - 1
      else: break
    end
    sig = RNDINT((1 &lt;&lt; (SIGBITS - 1)) - 1)
    if sig==0 and RNDINT(1)==0: e = e + 1
    sig = sig + (1 &lt;&lt; (SIGBITS - 1))
    // NOTE: This multiplication should result in
    // a floating-point number; if `e` is sufficiently
    // small, the number might underflow to 0
    return sig * pow(2, e)
END METHOD
</pre>

<p><a id=RNDRANGE_RNDRANGEMinExc_RNDRANGEMaxExc_and_RNDRANGEMinMaxExc_Random_Numbers_in_an_Arbitrary_Interval></a></p>

<h4><code>RNDRANGE</code>, <code>RNDRANGEMinExc</code>, <code>RNDRANGEMaxExc</code>, and <code>RNDRANGEMinMaxExc</code>: Random Numbers in an Arbitrary Interval</h4>

<p><strong><code>RNDRANGE</code></strong> generates a <strong>random number in the interval [<code>minInclusive</code>, <code>maxInclusive</code>]</strong>.</p>

<p>For arbitrary-precision or non-negative number formats, the following pseudocode implements <code>RNDRANGE()</code>.</p>

<pre>METHOD RNDRANGE(minInclusive, maxInclusive)
    if minInclusive &gt; maxInclusive: return error
    return minInclusive + (maxInclusive - minInclusive) * RNDU01()
END METHOD
</pre>

<p>For other number formats (including Java&#39;s <code>double</code> and <code>float</code>), the pseudocode above can overflow if the difference between <code>maxInclusive</code> and <code>minInclusive</code> exceeds the maximum possible value for the format.  For such formats, the following pseudocode for <code>RNDRANGE()</code> can be used instead.  In the pseudocode below, <code>NUM_MAX</code> is the highest possible finite number for the number format.  The pseudocode assumes that the highest possible value is positive and the lowest possible value is negative.</p>

<pre>METHOD RNDRANGE(minInclusive, maxInclusive)
   if minInclusive &gt; maxInclusive: return error
   if minInclusive == maxInclusive: return minInclusive
   // usual: Difference does not exceed maxInclusive
   usual=minInclusive &gt;= 0 or
       minInclusive + NUM_MAX &gt;= maxInclusive
   rng=NUM_MAX
   if usual: rng = (maxInclusive - minInclusive)
   while true
     ret = rng * RNDU01()
     if usual: return minInclusive + ret
     // NOTE: If the number format has positive and negative
     // zero, as is the case for Java `float` and
     // `double` and .NET&#39;s implementation of `System.Decimal`,
     // for example, use the following:
     negative = RNDINT(1) == 0
     if negative: ret = 0 - ret
     if negative and ret == 0: continue
     // NOTE: For fixed-precision fixed-point numbers implemented
     // using two&#39;s complement numbers (note 3), use the following line
     // instead of the preceding three lines, where `QUANTUM` is the
     // smallest representable positive number in the fixed-point format:
     // if RNDINT(1) == 0: ret = (0 - QUANTUM) - ret
     if ret &gt;= minInclusive and ret &lt;= maxInclusive: return ret
   end
END METHOD
</pre>

<p><strong>REMARK:</strong> Multiplying by <code>RNDU01()</code> in both cases above is not ideal, since doing so merely stretches that number to fit the range if the range is greater than 1.  There may be more sophisticated ways to fill the gaps that result this way in <code>RNDRANGE</code>.<sup><a href="#Note6"><strong>(6)</strong></a></sup></p>

<p><strong><code>RNDRANGEMaxExc</code></strong> returns a  <strong>random number in the interval [<code>minInclusive</code>, <code>maxExclusive</code>)</strong>.</p>

<pre>METHOD RNDRANGEMaxExc(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   while true
     ret = RNDRANGE(minInclusive, maxExclusive)
     if ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<p><strong><code>RNDRANGEMinExc</code></strong> returns a  <strong>random number in the interval (<code>minInclusive</code>, <code>maxExclusive</code>]</strong>.</p>

<pre>METHOD RNDRANGEMinExc(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   while true
     ret = RNDRANGE(minInclusive, maxExclusive)
     if ret &gt; minExclusive: return ret
   end
END METHOD
</pre>

<p><strong><code>RNDRANGEMinMaxExc</code></strong> returns a  <strong>random number in the interval (<code>minInclusive</code>, <code>maxExclusive</code>)</strong>.</p>

<pre>METHOD RNDRANGEMinMaxExc(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   while true
     ret = RNDRANGE(minInclusive, maxExclusive)
     if ret &gt; minExclusive and
        ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<blockquote>
<p><strong>Example:</strong> To generate, uniformly at random, a point inside an N-dimensional box, generate <code>RNDRANGEMaxExc(mn, mx)</code> for each coordinate, where <code>mn</code> and <code>mx</code> are the lower and upper bounds for that coordinate.  For example, to generate, uniformly at random, a point inside a rectangle bounded in [0, 2) along the X axis and [3, 6) along the Y axis, generate <code>[RNDRANGEMaxExc(0,2), RNDRANGEMaxExc(3,6)]</code>.</p>
</blockquote>

<p><a id=Certain_Programming_Environments></a></p>

<h3>Certain Programming Environments</h3>

<p>For certain programming environments, there are special considerations:</p>

<ul>
<li>Shell scripts and Microsoft Windows batch files are designed for running other programs, rather than general-purpose programming.  However, batch files and <code>bash</code> (a shell script interpreter) might support a variable which returns a random integer in the interval [0, 32767] (called <code>%RANDOM%</code> or <code>$RANDOM</code>, respectively); neither variable is designed for information security.</li>
<li>Query languages such as SQL have no procedural elements such as loops and branches.  Moreover, standard SQL does not include an RNG in its suite of functionality, but popular SQL dialects often do &mdash; with idiosyncratic behavior.<sup><a href="#Note7"><strong>(7)</strong></a></sup></li>
</ul>

<p>Whenever possible, the methods in this document should be implemented in a more general-purpose programming language than query languages, shell scripts, and batch files, especially if information security is a goal.</p>

<p><a id=Randomization_Techniques></a></p>

<h2>Randomization Techniques</h2>

<p>This section describes commonly used randomization techniques, such as shuffling, selection of several unique items, and creating random strings of text.</p>

<p><a id=Boolean_True_False_Conditions></a></p>

<h3>Boolean (True/False) Conditions</h3>

<p>To generate a condition that is true at the specified probabilities, use
the following idioms in an <code>if</code> condition:</p>

<ul>
<li>True or false with equal probability: <code>RNDINT(1) == 0</code>.</li>
<li>True with X percent probability: <code>RNDINTEXC(100) &lt; X</code>.</li>
<li>True with probability X/Y: <code>RNDINTEXC(Y) &lt; X</code>.</li>
<li>True with odds of X to Y: <code>RNDINTEXC(X + Y) &lt; X</code>.</li>
<li>True with probability P, where P is in the interval [0, 1] (a <em>Bernoulli trial</em>): Convert P to its closest rational number X/Y, then do <code>RNDINTEXC(Y) &lt; X</code>.</li>
</ul>

<blockquote>
<p><strong>Examples:</strong></p>

<ul>
<li>True with probability 3/8: <code>RNDINTEXC(8) &lt; 3</code>.</li>
<li>True with odds of 100 to 1: <code>RNDINTEXC(101) &lt; 1</code>.</li>
<li>True with 20% probability: <code>RNDINTEXC(100) &lt; 20</code>.</li>
</ul>
</blockquote>

<p><a id=Random_Sampling></a></p>

<h3>Random Sampling</h3>

<p>This section contains ways to choose one or more items from among a collection of them, where each item has the same chance to be chosen as any other.  This is called <em>random sampling</em> and can be done <em>with replacement</em> or <em>without replacement</em>.</p>

<p><a id=Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List></a></p>

<h4>Sampling With Replacement: Choosing a Random Item from a List</h4>

<p><em>Sampling with replacement</em>  essentially means taking a random item and putting it back.  To choose a random item from a list&mdash;</p>

<ul>
<li>whose size is known in advance, use the idiom <code>list[RNDINTEXC(size(list))]</code>; or</li>
<li>whose size is not known in advance, generate <code>RandomKItemsFromFile(file, 1)</code>, in <a href="#Pseudocode_for_Random_Sampling"><strong>pseudocode given later</strong></a> (the result will be a 1-item list or be an empty list if there are no items).</li>
</ul>

<p><a id=Sampling_Without_Replacement_Choosing_Several_Unique_Items></a></p>

<h4>Sampling Without Replacement: Choosing Several Unique Items</h4>

<p><em>Sampling without replacement</em>  essentially means taking a random item <em>without</em> putting it back.   There are several approaches for choosing <code>k</code> unique items or values uniformly at random from among <code>n</code> available items or values, depending on such things as whether <code>n</code> is known and how big <code>n</code> and <code>k</code> are.</p>

<ol>
<li><strong>If <code>n</code> is not known in advance:</strong> Use the <em>reservoir sampling</em> method; see the <code>RandomKItemsFromFile</code> method, in <a href="#Pseudocode_for_Random_Sampling"><strong>pseudocode given later</strong></a>.</li>
<li><strong>If <code>n</code> is relatively small (for example, if there are 200 available items, or there is a range of numbers from 0 to 200 to choose from):</strong>  If <strong>items are to be chosen from a list in relative order</strong>, then the <code>RandomKItemsInOrder</code> method, in <a href="#Pseudocode_for_Random_Sampling"><strong>pseudocode given later</strong></a>, demonstrates a solution.  Otherwise, one of the following will choose <code>k</code> items <strong>in random order</strong>:

<ul>
<li>Store all the items in a list, <a href="#Shuffling"><strong>shuffle</strong></a> that list, then choose the first <code>k</code> items from that list.</li>
<li>If the items are already stored in a list and the list&#39;s order can be changed, then shuffle that list and choose the first <code>k</code> items from the shuffled list.</li>
<li>If the items are already stored in a list and the list&#39;s order can&#39;t be changed, then store the indices to those items in another list, shuffle the latter list, then choose the first <code>k</code> indices (or the items corresponding to those indices) from the latter list.</li>
<li>If <code>k</code> is much smaller than <code>n</code>, proceed as in item 3 instead.</li>
</ul></li>
<li><strong>If <code>k</code> is much smaller than <code>n</code>:</strong>  The first three cases below will choose <code>k</code> items in random order:

<ul>
<li><strong>If the items are stored in a list whose order can be changed:</strong> Do a <em>partial shuffle</em> of that list, then choose the <em>last</em> <code>k</code> items from that list.  A <em>partial shuffle</em> proceeds as given in the section &quot;<a href="#Shuffling"><strong>Shuffling</strong></a>&quot;, except the partial shuffle stops after <code>k</code> swaps have been made (where swapping one item with itself counts as a swap).</li>
<li>Otherwise, <strong>if the items are stored in a list and <code>n</code> is not very large (for example, less than 5000):</strong> Store the indices to those items in another list, do a <em>partial shuffle</em> of the latter list, then choose the <em>last</em> <code>k</code> indices (or the items corresponding to those indices) from the latter list.</li>
<li>Otherwise, <strong>if <code>n</code> is not very large:</strong> Store all the items in a list, do a <em>partial shuffle</em> of that list, then choose the <em>last</em> <code>k</code> items from that list.</li>
<li>Otherwise, see item 5.</li>
</ul></li>
<li><strong>If <code>n - k</code> is much smaller than <code>n</code> and the sampled items need not be in random order:</strong>  Proceed as in step 3, except the partial shuffle involves <code>n - k</code> swaps and the <em>first</em> <code>k</code> items are chosen rather than the last <code>k</code>.</li>
<li><p><strong>Otherwise (for example, if 32-bit or larger integers will be chosen so that <code>n</code> is 2<sup>32</sup>, or if <code>n</code> is otherwise very large):</strong> Create a data structure to store the indices to items already chosen.  When a new index to an item is randomly chosen, add it to the data structure if it&#39;s not already there, or if it is, choose a new random index.  Repeat this process until <code>k</code> indices were added to the data structure this way.  Examples of suitable data structures are&mdash;</p>

<ul>
<li>a <a href="https://en.wikipedia.org/wiki/Hash_table"><strong>hash table</strong></a>,</li>
<li>a compressed bit set (e.g, &quot;roaring bitmap&quot;, EWAH), and</li>
<li>a self-sorting data structure such as a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"><strong>red&ndash;black tree</strong></a>, if the random items are to be retrieved in sorted order or in index order.</li>
</ul>

<p>Although constant-memory sampling without replacement is possible with <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator"><strong><em>linear congruential generators</em></strong></a>, seeded with an RNG, this is not recommended because of the relatively small number of sequences that can be sampled this way.</p></li>
</ol>

<p><a id=Shuffling></a></p>

<h4>Shuffling</h4>

<p>The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle"><strong>Fisher&ndash;Yates shuffle method</strong></a> shuffles a list (puts its items in a random order) such that all permutations (arrangements) of that list are equally likely to occur, assuming the RNG it uses can choose any one of those permutations.  However, that method is also easy to write incorrectly &mdash; see also (Atwood 2007)<sup><a href="#Note8"><strong>(8)</strong></a></sup>.  The following pseudocode is designed to shuffle a list&#39;s contents.</p>

<pre>METHOD Shuffle(list)
   // NOTE: Check size of the list early to prevent
   // `i` from being less than 0 if the list&#39;s size is 0 and
   // `i` is implemented using an nonnegative integer
   // type available in certain programming languages.
   if size(list) &gt;= 2
      // Set i to the last item&#39;s index
      i = size(list) - 1
      while i &gt; 0
         // Choose an item ranging from the first item
         // up to the item given in `i`. Note that the item
         // at i+1 is excluded.
         k = RNDINTEXC(i + 1)
         // The following is wrong since it introduces biases:
         // &quot;k = RNDINTEXC(size(list))&quot;
         // The following is wrong since the algorithm won&#39;t
         // choose from among all possible permutations:
         // &quot;k = RNDINTEXC(i)&quot;
         // Swap item at index i with item at index k;
         // in this case, i and k may be the same
         tmp = list[i]
         list[i] = list[k]
         list[k] = tmp
         // Move i so it points to the previous item
         i = i - 1
      end
   end
   // NOTE: An implementation can return the
   // shuffled list, as is done here, but this is not required.
   return list
END METHOD
</pre>

<p>An important consideration with respect to shuffling is the nature of the underlying RNG, as I discuss in further detail in my <a href="https://peteroupc.github.io/random.html#Shuffling"><strong>RNG recommendation document on shuffling</strong></a>.<sup><a href="#Note9"><strong>(9)</strong></a></sup></p>

<p><a id=Random_Character_Strings></a></p>

<h4>Random Character Strings</h4>

<p>To generate a random string of characters:</p>

<ol>
<li>Generate a list of the letters, digits, and/or other characters the string can have.  Examples are given later in this section.</li>
<li>Build a new string whose characters are chosen from that character list.  The pseudocode below demonstrates this by creating a list, rather than a string, where the random characters will be held.  It also takes the number of characters as a parameter named <code>stringSize</code>.  (How to convert this list to a text string depends on the programming language and is outside the scope of this page.)</li>
</ol>

<p>&nbsp;</p>

<pre>METHOD RandomString(characterList, stringSize)
  i = 0
  newString = NewList()
  while i &lt; stringSize
    // Choose a character from the list
    randomChar = characterList[RNDINTEXC(size(characterList))]
    // Add the character to the string
    AddItem(newString, randomChar)
    i = i + 1
  end
  return newString
END METHOD
</pre>

<p>The following are examples of character lists:</p>

<ol>
<li>For an <em>alphanumeric string</em>, or string of letters and digits, the characters can be the basic digits &quot;0&quot; to &quot;9&quot; (U+0030-U+0039, nos. 48-57), the basic upper case letters &quot;A&quot; to &quot;Z&quot; (U+0041-U+005A, nos. 65-90), and the basic lower case letters &quot;a&quot; to &quot;z&quot; (U+0061-U+007A, nos. 96-122), as given in the Unicode Standard.</li>
<li>For a base-10 digit string, the characters can be the basic digits only.</li>
<li>For a base-16 digit (hexadecimal) string, the characters can be the basic digits as well as the basic letters &quot;A&quot; to &quot;F&quot; or &quot;a&quot; to &quot;f&quot; (not both).</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>If the list of characters is fixed, the list can be created in advance at runtime or compile time, or (if every character takes up the same number of code units) a string type as provided in the programming language can be used to store the list as a string.</li>
<li><strong>Unique random strings:</strong> Often applications need to generate a string of characters that&#39;s not only random, but also unique.  This can be done by storing a list (such as a hash table) of strings already generated and checking newly generated strings against that list.<sup><a href="#Note10"><strong>(10)</strong></a></sup></li>
<li><strong>Word generation:</strong> This technique could also be used to generate &quot;pronounceable&quot; words, but this is less flexible than other approaches; see also &quot;<a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a>&quot;.</li>
</ol>
</blockquote>

<p><a id=Pseudocode_for_Random_Sampling></a></p>

<h4>Pseudocode for Random Sampling</h4>

<p>The following pseudocode implements two methods:</p>

<ol>
<li><code>RandomKItemsFromFile</code> implements <a href="https://en.wikipedia.org/wiki/Reservoir_sampling"><strong><em>reservoir sampling</em></strong></a>; it chooses up to <code>k</code> random items from a file of indefinite size (<code>file</code>). Although the pseudocode refers to files and lines, the technique applies to any situation when items are retrieved one at a time from a data set or list whose size is not known in advance.  See the comments to find out how <code>RandomKItemsFromFile</code> can be used to choose an item at random only if it meets certain criteria (see &quot;<a href="#Rejection_Sampling"><strong>Rejection Sampling</strong></a>&quot; for example criteria).</li>
<li><code>RandomKItemsInOrder</code> returns a list of up to <code>k</code> random items from the given list (<code>list</code>), in the order in which they appeared in the list.  It is based on a technique presented in Devroye 1986, p. 620.</li>
</ol>

<p>&nbsp;</p>

<pre>METHOD RandomKItemsFromFile(file, k)
  list = NewList()
  j = 0
  index = 0
  while true
    // Get the next line from the file
    item = GetNextLine(file)
    thisIndex = index
    index = index + 1
    // If the end of the file was reached, break
    if item == nothing: break
    // NOTE 1: The following line is OPTIONAL
    // and can be used to choose only random lines
    // in the file that meet certain criteria,
    // expressed as MEETS_CRITERIA below.
    // ------
    // if not MEETS_CRITERIA(item): continue
    // ------
    if j &lt; k // phase 1 (fewer than k items)
      AddItem(list, item)
      // NOTE 2: To add the line number (starting at
      // 0) rather than the item, use the following
      // line instead of the previous one:
      // AddItem(list, thisIndex)
      j = j + 1
    else // phase 2
      j = RNDINT(thisIndex)
      if j &lt; k: list[j] = item
      // NOTE 3: To add the line number (starting at
      // 0) rather than the item, use the following
      // line instead of the previous one:
      // if j &lt; k: list[j] = thisIndex
    end
  end
  // NOTE 4: We shuffle at the end in case k or
  // fewer lines were in the file, since in that
  // case the items would appear in the same
  // order as they appeared in the file
  // if the list weren&#39;t shuffled.  This line
  // can be removed, however, if the items
  // in the returned list need not appear
  // in random order.
  if size(list)&gt;=2: Shuffle(list)
  return list
end

METHOD RandomKItemsInOrder(list, k)
  i = 0
  kk = k
  ret = NewList()
  n = size(list)
  while i &lt; n and size(ret) &lt; k
    u = RNDINTEXC(n - i)
    if u &lt;= kk
      AddItem(ret, list[i])
      kk = kk - 1
    end
    i = i + 1
  end
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>Assume a file (<code>file</code>) has the lines <code>&quot;f&quot;</code>, <code>&quot;o&quot;</code>, <code>&quot;o&quot;</code>, <code>&quot;d&quot;</code>, in that order.  If we modify <code>RandomKItemsFromFile</code> as given in notes 2 and 3 there, and treat <code>MEETS_CRITERIA(item)</code> above as <code>item == &quot;o&quot;</code> (in note 1 of that method), then we can choose a random line number of an &quot;o&quot; line by <code>RandomKItemsFromFile(file, 1)</code>.</li>
<li>Removing <code>k</code> random items from a list of <code>n</code> items (<code>list</code>) is equivalent to generating a new
list by <code>RandomKItemsInOrder(list, n - k)</code>.</li>
<li><strong>Filtering:</strong> If an application needs to sample the same list (with or without replacement) repeatedly, but only from among a selection of that list&#39;s items, it can create a list of items it wants to sample from (or a list of indices to those items), and sample from the new list instead.<sup><a href="#Note11"><strong>(11)</strong></a></sup>  This won&#39;t work well, though, for lists of indefinite or very large size.</li>
</ol>
</blockquote>

<p><a id=Rejection_Sampling></a></p>

<h3>Rejection Sampling</h3>

<p><em>Rejection sampling</em> is a simple and flexible approach for generating random content that meets certain requirements.  To implement rejection sampling:</p>

<ol>
<li>Generate the random content (such as a random number) by any method and with any distribution and range.</li>
<li>If the content doesn&#39;t meet predetermined criteria, go to step 1.</li>
</ol>

<p>Example criteria include checking&mdash;</p>

<ul>
<li>whether a random number is prime,</li>
<li>whether a random number is divisible or not by certain numbers,</li>
<li>whether a random number is not among recently chosen random numbers,</li>
<li>whether a random number was not already chosen (with the aid of a hash table, red-black tree, or similar structure),</li>
<li>whether a random number was not chosen more often in a row than desired,</li>
<li>whether a random point is sufficiently distant from previous random points (with the aid of a KD-tree or similar structure),</li>
<li>whether a random string matches a regular expression,</li>
<li>whether a random number is not included in a &quot;blacklist&quot; of numbers, or</li>
<li>two or more of the foregoing criteria.</li>
</ul>

<p>(KD-trees, hash tables, red-black trees, prime-number testing algorithms, and regular expressions are outside the scope of this document.)</p>

<p><a id=Generating_Random_Numbers_in_Sorted_Order></a></p>

<h3>Generating Random Numbers in Sorted Order</h3>

<p>To generate random numbers in sorted order&mdash;</p>

<ol>
<li>generate them using any method and where the numbers have any distribution and range, then</li>
<li>store them in a list, then</li>
<li>sort the list using a sorting algorithm (details on sorting algorithms are beyond the scope of this document).</li>
</ol>

<p>(Bentley and Saxe 1980)<sup><a href="#Note12"><strong>(12)</strong></a></sup> describes a way to generate random numbers in sorted order, but it&#39;s not given here because it relies on a method akin to <code>RNDU01()</code>, which may not be adequate for large numbers of sorted random numbers depending on how <code>RNDU01()</code> is implemented.</p>

<p><a id=Random_Walks></a></p>

<h3>Random Walks</h3>

<p>A <em>random walk</em> is a process with random behavior over time.  A simple form of random walk involves generating a random number that changes the state of the walk.  The pseudocode below generates a random walk of <em>n</em> random numbers, where <code>STATEJUMP()</code> is the next number to add to the current state (see examples later in this section).</p>

<pre>METHOD RandomWalk(n)
  // Create a new list with an initial state
  list=[0]
  // Add &#39;n&#39; new numbers to the list.
  for i in 0...n: AddItem(list, list[i] + STATEJUMP())
  return list
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>If <code>STATEJUMP()</code> is <code>RNDINT(1) * 2 - 1</code>, the random walk generates numbers that differ by -1 or 1, chosen at random.</li>
<li>If <code>STATEJUMP()</code> is <code>RNDRANGE(-1, 1)</code>, the random state is advanced by a random real number in the interval [-1, 1].</li>
<li>If <code>STATEJUMP()</code> is <code>Binomial(1, p)</code>, the random walk models a <em>binomial process</em>, where the state is advanced with probability <code>p</code>.</li>
<li>If <code>STATEJUMP()</code> is <code>Binomial(1, p) * 2 - 1</code>, the random walk generates numbers that each differ from the last by -1 or 1 depending on the probability <code>p</code>.</li>
</ol>

<p><strong>Notes:</strong></p>

<ol>
<li> A random process can also be simulated by creating a list of random numbers generated the same way.  Such a process generally models behavior over time that does not depend on the time or the current state.  Examples of this include <code>Normal(0, 1)</code> (for modeling <em>Gaussian white noise</em>) and <code>Binomial(1, p)</code> (for modeling a <em>Bernoulli process</em>, where each number is 0 or 1 depending on the probability <code>p</code>).</li>
<li> Some random walks model random behavior at every moment, not just at discrete times.  One example is a <em>Wiener process</em>, with random states and jumps that are normally distributed (a process of this kind is also known as <em>Brownian motion</em>).  (For a random walk that follows a Wiener process, <code>STATEJUMP()</code> is <code>Normal(mu * timediff, sigma * sqrt(timediff))</code>, where  <code>mu</code> is the average value per time unit, <code>sigma</code> is the volatility, and <code>timediff</code> is the time difference between samples.)</li>
<li> Some random walks model state changes happening at random times. One example is a <em>Poisson process</em>, in which the time between each event is a random exponential variable (the random time is <code>-ln(RNDU01ZeroOneExc()) / rate</code>, where <code>rate</code> is the average number of events per time unit; an <em>inhomogeneous Poisson process</em> results if <code>rate</code> can vary with the &quot;timestamp&quot; before each event jump).</li>
</ol>
</blockquote>

<p><a id=Low_Discrepancy_Sequences></a></p>

<h3>Low-Discrepancy Sequences</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Low-discrepancy_sequence"><strong><em>low-discrepancy sequence</em></strong></a> (or <em>quasirandom sequence</em>) is a sequence of numbers that follow a uniform distribution, but are less likely to form &quot;clumps&quot; than independent uniform random numbers are.  The following are examples:</p>

<ul>
<li>Sobol and Halton sequences are too complicated to show here.</li>
<li>Linear congruential generators with modulus <code>m</code>, a full period, and &quot;good lattice structure&quot;; a sequence of <code>n</code>-dimensional points is then <code>[MLCG(i), MLCG(i+1), ..., MLCG(i+n-1)]</code> for each integer <code>i</code> in the interval [1, <code>m</code>] (L&#39;Ecuyer 1999)<sup><a href="#Note13"><strong>(13)</strong></a></sup> (see example pseudocode below).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD MLCG(seed) // m = 262139
  if seed&lt;=0: return error
  return rem(92717*seed,262139)/262139.0
END METHOD
</pre>

<p>In most cases, RNGs can be used to generate a &quot;seed&quot; to start the low-discrepancy sequence at.</p>

<p><a id=Randomization_in_Simulations></a></p>

<h3>Randomization in Simulations</h3>

<p>Simulation testing uses shuffling and <em>bootstrapping</em> to help draw conclusions on data through randomization.</p>

<ul>
<li><a href="#Shuffling"><strong>Shuffling</strong></a> is used when each item in a data set belongs to one of several mutually exclusive groups.  Here, one or more <strong>simulated data sets</strong> are generated by shuffling the original data set and regrouping each item in the shuffled data set in order, such that the number of items in each group for the simulated data set is the same as for the original data set.</li>
<li><a href="https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29"><strong><em>Bootstrapping</em></strong></a> is a method of creating one or more random samples (simulated data sets) of an existing data set, where the items in each sample are chosen <a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>at random with replacement</strong></a>.  (Each random sample can contain duplicates this way.)  See also (Brownlee 2018)<sup><a href="#Note14"><strong>(14)</strong></a></sup>.</li>
</ul>

<p>After creating the simulated data sets, one or more statistics, such as the mean, are calculated for each simulated data set as well as the original data set, then the statistics for the simulated data sets are compared with those of the original (such comparisons are outside the scope of this document).</p>

<p>Randomization also occurs in numerical calculation.</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Monte_Carlo_integration"><strong>Monte Carlo integration</strong></a> uses randomization to estimate a multidimensional integral. It involves evaluating a function at N random points in the domain.  The estimated integral is the volume of the domain times the mean of those N points, and the error in the estimate is that volume times the square root of the (bias-corrected sample) variance of the N points (see the appendix). Often <a href="#Low_Discrepancy_Sequences"><strong>low-discrepancy sequences</strong></a> provide the &quot;random&quot; numbers to sample the function more efficiently.</li>
</ul>

<p><a id=General_Non_Uniform_Distributions></a></p>

<h2>General Non-Uniform Distributions</h2>

<p>Some applications need to choose random items or numbers such that some of them are more likely to be chosen than others (a <em>non-uniform</em> distribution). Most of the techniques in this section show how to use the <a href="#Uniform_Random_Numbers"><strong>uniform random number methods</strong></a> to generate such random items or numbers.</p>

<p><a id=Weighted_Choice></a></p>

<h3>Weighted Choice</h3>

<p>The weighted choice method generates a random item or number from among a collection of them with separate probabilities of each item or number being chosen.  There are several kinds of weighted choice.</p>

<p><a id=Weighted_Choice_With_Replacement></a></p>

<h4>Weighted Choice With Replacement</h4>

<p>The first kind is called weighted choice <em>with replacement</em> (which can be thought of as drawing a ball, then putting it back), where the probability of choosing each item doesn&#39;t change as items are chosen.</p>

<p>The following pseudocode implements a method <code>WeightedChoice</code> that takes a single list <code>weights</code> of weights (numbers 0 or greater), and returns the index of a weight from that list.  The greater the weight, the more likely its index will be chosen. (Note that there are two possible ways to generate the random number depending on whether the weights are all integers or can be fractional numbers.)</p>

<pre>METHOD WeightedChoice(weights)
    if size(weights) == 0: return error
    sum = 0
    // Get the sum of all weights
    i = 0
    while i &lt; size(weights)
        sum = sum + weights[i]
        i = i + 1
    end
    // Choose a random integer/number from 0 to less than
    // the sum of weights.
    value = RNDINTEXC(sum)
    // NOTE: If the weights can be fractional numbers,
    // use this instead:
    // value = RNDRANGEMaxExc(0, sum)
    // Choose the object according to the given value
    i = 0
    lastItem = size(weights) - 1
    runningValue = 0
    while i &lt; size(weights)
       if weights[i] &gt; 0
          newValue = runningValue + weights[i]
          // NOTE: Includes start, excludes end
          if value &lt; newValue: return i
          runningValue = newValue
          lastItem = i
       end
       i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return lastItem
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li><p>Assume we have the following list: <code>[&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;grapes&quot;]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  The weight for &quot;apples&quot; is 3, and the weight for &quot;oranges&quot; is 15.  Since &quot;oranges&quot; has a higher weight than &quot;apples&quot;, the index for &quot;oranges&quot; (1) is more likely to be chosen than the index for &quot;apples&quot; (0) with the <code>WeightedChoice</code> method.  The following pseudocode implements how to get a randomly chosen item from the list with that method.</p>

<pre> index = WeightedChoice(weights)
 // Get the actual item
 item = list[index]
</pre></li>
<li><p>Assume the weights from example 1 are used and the list contains ranges of numbers instead of strings: <code>[[0, 5], [5, 10], [10, 11], [11, 13]]</code>.  If a random range is chosen, a random number can be chosen from that range using code like the following: <code>number = RNDRANGEMaxExc(item[0], item[1])</code>. (See also &quot;<a href="#Mixtures_of_Distributions"><strong>Mixtures of Distributions</strong></a>&quot;.)</p></li>
<li>Assume the weights from example 1 are used and the list contains the following: <code>[0, 5, 10, 11, 13]</code> (one more item than the weights).  This expresses four ranges, the same as in example 2.  After a random index is chosen with <code>index = WeightedChoice(weights)</code>, a random number can be chosen from the corresponding range using code like the following: <code>number = RNDRANGEMaxExc(list[index], list[index + 1])</code>. (This is how the C++ library expresses a <em>piecewise constant distribution</em>.)</li>
<li>A <a href="https://en.wikipedia.org/wiki/Markov_chain"><strong>Markov chain</strong></a> models one or more <em>states</em> (for example, individual letters or syllables), and stores the probabilities to transition from one state to another (e.g., &quot;b&quot; to &quot;e&quot; with a probability of 0.2, or &quot;b&quot; to &quot;b&quot; with a probability of 0.01).  Thus, each state can be seen as having its own list of <em>weights</em> for each relevant state transition.  For example, a Markov chain for generating <strong>&quot;pronounceable&quot; words</strong>, or words similar to natural-language words, can include &quot;start&quot; and &quot;stop&quot; states for the start and end of the word, respectively.</li>
</ol>
</blockquote>

<p><a id=Weighted_Choice_Without_Replacement_Multiple_Copies></a></p>

<h4>Weighted Choice Without Replacement (Multiple Copies)</h4>

<p>To implement weighted choice <em>without replacement</em> (which can be thought of as drawing a ball <em>without</em> putting it back), generate an index by <code>WeightedChoice</code>, and then decrease the weight for the chosen index by 1.  In this way, <strong>each weight behaves like the number of &quot;copies&quot; of each item</strong>. This technique, though, will only work properly if all the weights are integers 0 or greater.  The pseudocode below is an example of this.</p>

<pre>// Get the sum of weights
// (NOTE: This code assumes that `weights` is
// a list that can be modified.  If the original weights
// are needed for something else, a copy of that
// list should be made first, but the copying process
// is not shown here.  This code also assumes that `list`,
// a list of items, was already declared earlier and
// has at least as many items as `weights`.)
totalWeight = 0
i = 0
while i &lt; size(weights)
    totalWeight = totalWeight + weights[i]
    i = i + 1
end
// Choose as many items as the sum of weights
i = 0
items = NewList()
while i &lt; totalWeight
    index = WeightedChoice(weights)
    // Decrease weight by 1 to implement selection
    // without replacement.
    weights[index] = weights[index] - 1
    AddItem(items, list[index])
    i = i + 1
end
</pre>

<p>Alternatively, if all the weights are integers 0 or greater and their sum is relatively small, create a list with as many copies of each item as its weight, then <a href="#Shuffling"><strong>shuffle</strong></a> that list.  The resulting list will be ordered in a way that corresponds to a weighted random choice without replacement.</p>

<blockquote>
<p><strong>Note:</strong> The weighted sampling described in this section can be useful to some applications (particularly some games) that wish to control which random numbers appear, to make the random outcomes appear fairer to users (e.g., to avoid long streaks of good outcomes or of bad outcomes).  When used for this purpose, each item represents a different outcome (e.g., &quot;good&quot; or &quot;bad&quot;), and the lists are replenished once no further items can be chosen.  However, this kind of sampling should not be used for this purpose whenever information security (ISO/IEC 27000) is involved, including when predicting future random numbers would give a player or user a significant and unfair advantage.</p>
</blockquote>

<p><a id=Weighted_Choice_Without_Replacement_Single_Copies></a></p>

<h4>Weighted Choice Without Replacement (Single Copies)</h4>

<p>Weighted choice can also choose items from a list, where each item has a separate probability of being chosen and <strong>can be chosen no more than once</strong>.  In this case, after choosing a random index, set the weight for that index to 0 to keep it from being chosen again.  The pseudocode below is an example of this.</p>

<pre>// (NOTE: This code assumes that `weights` is
// a list that can be modified.  If the original weights
// are needed for something else, a copy of that
// list should be made first, but the copying process
// is not shown here.  This code also assumes that `list`,
// a list of items, was already declared earlier and
// has at least as many items as `weights`.)
chosenItems = NewList()
i = 0
// Choose k items from the list
while i &lt; k or i &lt; size(weights)
    index = WeightedChoice(weights)
    // Set the weight for the chosen index to 0
    // so it won&#39;t be chosen again
    weights[index] = 0
    // Add the item at the chosen index
    AddItem(chosenItems, list[index])
end
// `chosenItems` now contains the items chosen
</pre>

<p>The technique presented here can solve the problem of sorting a list of items such that higher-weighted items are more likely to appear first.</p>

<p><a id=Weighted_Choice_Without_Replacement_Indefinite_Size_List></a></p>

<h4>Weighted Choice Without Replacement (Indefinite-Size List)</h4>

<p>If the number of items in a list is not known in advance, then the following pseudocode implements a <code>RandomKItemsFromFileWeighted</code> that selects up to <code>k</code> random items from a file (<code>file</code>) of indefinite size (similarly to <a href="#Pseudocode_for_Random_Sampling"><strong><code>RandomKItemsFromFile</code></strong></a>).  See (Efraimidis and Spirakis 2005)<sup><a href="#Note15"><strong>(15)</strong></a></sup>, and see also (Efraimidis 2015)<sup><a href="#Note16"><strong>(16)</strong></a></sup>.  In the pseudocode below, <code>WEIGHT_OF_ITEM(item, thisIndex)</code> is an arbitrary function that calculates the weight of an individual item based on its value and its index (starting at 0); the item is ignored if its weight is 0 or less.</p>

<pre>METHOD RandomKItemsFromFileWeighted(file, k)
  list = NewList()
  j = 0
  index = 0
  skIndex = 0
  smallestKey = 0
  t = 0
  while true
    // Get the next line from the file
    item = GetNextLine(file)
    thisIndex = index
    index = index + 1
    // If the end of the file was reached, break
    if item == nothing: break
    weight = WEIGHT_OF_ITEM(item, thisIndex)
    // Ignore if item&#39;s weight is 0 or less
    if weight &lt;= 0: continue
    key = pow(RNDU01(),1.0/weight)
    t = smallestKey
    if index == 0 or key &lt; smallestKey
      skIndex = index
      smallestKey = key
    end
    if j &lt; k // phase 1 (fewer than k items)
      AddItem(list, item)
      // To add the line number (starting at
      // 0) rather than the item, use the following
      // line instead of the previous one:
      // AddItem(list, thisIndex)
      j = j + 1
    else // phase 2
      if t &lt; key: list[skIndex] = item
      // To add the line number (starting at
      // 0) rather than the item, use the following
      // line instead of the previous one:
      // if t &lt; key: list[skIndex] = thisIndex
    end
  end
  // Optional shuffling here.
  // See NOTE 4 in RandomKItemsFromFile code.
  if size(list)&gt;=2: Shuffle(list)
  return list
end
</pre>

<blockquote>
<p><strong>Note:</strong> Weighted choice <em>with replacement</em> can be implemented by doing one or more concurrent runs of <code>RandomKItemsFromFileWeighted(file, 1)</code> (making sure each run traverses <code>file</code> the same way for multiple runs as for a single run) (Efraimidis 2015)<sup><a href="#Note16"><strong>(16)</strong></a></sup>.</p>
</blockquote>

<p><a id=Continuous_Weighted_Choice></a></p>

<h4>Continuous Weighted Choice</h4>

<p>The continuous weighted choice method generates a random number that follows a continuous probability distribution (here, a <a href="http://en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution"><strong><em>piecewise linear distribution</em></strong></a>).</p>

<p>The pseudocode below takes two lists as follows:</p>

<ul>
<li><code>list</code> is a list of numbers (which need not be integers). If the numbers are arranged in ascending order, which they should, the first number in this list can be returned exactly, but not the last number.</li>
<li><code>weights</code> is a list of weights for the given numbers (where each number and its weight have the same index in both lists).   The greater a number&#39;s weight, the more likely it is that a number close to that number will be chosen.  Each weight should be 0 or greater.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD ContinuousWeightedChoice(list, weights)
    if size(list) &lt;= 0 or size(weights) &lt; size(list): return error
    if size(list) == 1: return list[0]
    // Get the sum of all areas between weights
    sum = 0
    areas = NewList()
    i = 0
    while i &lt; size(list) - 1
      weightArea = abs((weights[i] + weights[i + 1]) * 0.5 *
            (list[i + 1] - list[i]))
      AddItem(areas, weightArea)
      sum = sum + weightArea
       i = i + 1
    end
    // Choose a random number
    value = RNDRANGEMaxExc(0, sum)
    // Interpolate a number according to the given value
    i=0
    // Get the number corresponding to the random number
    runningValue = 0
    while i &lt; size(list) - 1
     area = areas[i]
     if area &gt; 0
      newValue = runningValue + area
      // NOTE: Includes start, excludes end
      if value &lt; newValue
       // NOTE: The following line can also read
       // &quot;interp = RNDU01OneExc()&quot;, that is, a new number is generated
       // within the chosen area rather than using the point
       // already generated.
       interp = (value - runningValue) / (newValue - runningValue)
       retValue = list[i] + (list[i + 1] - list[i]) * interp
       return retValue
      end
      runningValue = newValue
     end
     i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return list[size(list) - 1]
END METHOD
</pre>

<blockquote>
<p><strong>Example</strong>: Assume <code>list</code> is the following: <code>[0, 1, 2, 2.5, 3]</code>, and <code>weights</code> is the following: <code>[0.2, 0.8, 0.5, 0.3, 0.1]</code>.  The weight for 2 is 0.5, and that for 2.5 is 0.3.  Since 2 has a higher weight than 2.5, numbers near 2 are more likely to be chosen than numbers near 2.5 with the <code>ContinuousWeightedChoice</code> method.</p>
</blockquote>

<p><a id=Mixtures_of_Distributions></a></p>

<h3>Mixtures of Distributions</h3>

<p>A <em>mixture</em> consists of two or more probability distributions with separate probabilities of being sampled.
To generate random content from a mixture&mdash;</p>

<ol>
<li>generate <code>index = WeightedChoice(weights)</code>, where <code>weights</code> is a list of relative probabilities that each distribution in the mixture will be sampled, then</li>
<li>based on the value of <code>index</code>, generate the random content from the corresponding distribution.</li>
</ol>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li><p>One mixture consists of two normal distributions with two different means: 1 and -1, but the mean 1 normal will be sampled 80% of the time.  The following pseudocode shows how this mixture can be sampled:</p>

<pre>index = WeightedChoice([80, 20])
number = 0
// If index 0 was chosen, sample from the mean 1 normal
if index==0: number = Normal(1, 1)
// Else index 1 was chosen, so sample from the mean -1 normal
else: number = Normal(-1, 1)
</pre></li>
<li><p>A <strong>hyperexponential distribution</strong> is a mixture of <a href="#Gamma_Distribution"><strong>exponential distributions</strong></a>, each one with a separate weight and separate rate.  An example is below.</p>

<pre>index = WeightedChoice([0.6, 0.3, 0.1])
// Rates of the three exponential distributions
rates = [0.3, 0.1, 0.05]
// Generate an exponential random number with chosen rate
number = -ln(RNDU01ZeroOneExc()) / rates[index]
</pre></li>
<li><p>Choosing a point uniformly at random from a complex shape (in any number of dimensions) is equivalent to sampling uniformly from a mixture of simpler shapes that make up the complex shape (here, the <code>weights</code> list holds the content of each simpler shape).  (Content is called area in 2D and volume in 3D.) For example, a simple closed 2D polygon can be <a href="https://en.wikipedia.org/wiki/Polygon_triangulation"><strong><em>triangulated</em></strong></a>, or decomposed into <a href="#Random_Points_Inside_a_Simplex"><strong>triangles</strong></a>, and a mixture of those triangles can be sampled.<sup><a href="#Note17"><strong>(17)</strong></a></sup></p></li>
<li><p>For generating a random integer from multiple nonoverlapping ranges of integers&mdash;</p>

<ul>
<li>each range has a weight of <code>(mx - mn) + 1</code>, where <code>mn</code> is that range&#39;s minimum and <code>mx</code> is its maximum, and</li>
<li>the chosen range is sampled by generating <code>RNDINTRANGE(mn, mx)</code>, where <code>mn</code> is the that range&#39;s minimum and <code>mx</code> is its maximum.</li>
</ul>

<p>For generating random numbers, that may or may not be integers, from nonoverlapping number ranges, each weight is <code>mx - mn</code> instead and the number is sampled by <code>RNDRANGEMaxExc(mn, mx)</code> instead.</p></li>
</ol>
</blockquote>

<p><a id=Transformations_of_Random_Numbers></a></p>

<h3>Transformations of Random Numbers</h3>

<p>Random numbers can be generated by combining and/or transforming one or more random numbers
and/or discarding some of them.</p>

<p>As an example, <a href="http://www.redblobgames.com/articles/probability/damage-rolls.html"><strong>&quot;Probability and Games: Damage Rolls&quot;</strong></a> by Red Blob Games includes interactive graphics showing score distributions for lowest-of, highest-of, drop-the-lowest, and reroll game mechanics.<sup><a href="#Note18"><strong>(18)</strong></a></sup>  These and similar distributions can be generalized as follows.</p>

<p>Generate two or more random numbers, each with a separate probability distribution, then:</p>

<ol>
<li><strong>Highest-of:</strong>  Choose the highest generated number.</li>
<li><strong>Drop-the-lowest:</strong>  Add all generated numbers except the lowest.</li>
<li><strong>Reroll-the-lowest:</strong>  Add all generated numbers except the lowest, then add a number generated randomly by a separate probability distribution.</li>
<li><strong>Lowest-of:</strong>  Choose the lowest generated number.</li>
<li><strong>Drop-the-highest:</strong>  Add all generated numbers except the highest.</li>
<li><strong>Reroll-the-highest:</strong>  Add all generated numbers except the highest, then add a number generated randomly by a separate probability distribution.</li>
<li><strong>Sum:</strong> Add all generated numbers.</li>
<li><strong>Mean:</strong> Find the mean of all generated numbers (see the appendix).</li>
<li><strong>Geometric transformation:</strong> Treat the numbers as an <em>n</em>-dimensional point, then apply a geometric transformation, such as a rotation or other <em>affine transformation</em><sup><a href="#Note19"><strong>(19)</strong></a></sup>, to that point.</li>
</ol>

<p>If the probability distributions are the same, then strategies 1 to 3 make higher numbers more likely, and strategies 4 to 6, lower numbers.</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>Variants of strategy 4 &mdash; e.g., choosing the second-, third-, or nth-lowest number &mdash; are formally called second-, third-, or nth-<strong>order statistics distributions</strong>, respectively.</li>
<li>As an extension of strategy 9 (geometric transformations), a random point (<code>x</code>, <code>y</code>) can be <strong>rotated</strong> to derive a point with <strong>correlated random</strong> coordinates (old <code>x</code>, new <code>x</code>) as follows (see (Saucier 2000)<sup><a href="#Note20"><strong>(20)</strong></a></sup>, sec. 3.8): <code>[x, y*sqrt(1 - rho * rho) + rho * x]</code>, where <code>x</code> and <code>y</code> are independent random numbers from the same distribution, and <code>rho</code> is a <em>correlation coefficient</em> in the interval [-1, 1] (if <code>rho</code> is 0, the variables are uncorrelated).</li>
</ol>

<p><strong>Examples:</strong></p>

<ol>
<li>The idiom <code>min(RNDINTRANGE(1, 6), RNDINTRANGE(1, 6))</code> takes the lowest of two six-sided die results.  Due to this approach, 1 is more likely to occur than 6.</li>
<li>The idiom <code>RNDINTRANGE(1, 6) + RNDINTRANGE(1, 6)</code> takes the result of two six-sided dice (see also &quot;<a href="#Dice"><strong>Dice</strong></a>&quot;).</li>
<li>Sampling a <strong>Bates distribution</strong> involves sampling <em>n</em> random numbers by <code>RNDRANGE(minimum, maximum)</code>, then finding the mean of those numbers (see the appendix).</li>
<li>A <strong>compound Poisson distribution</strong> models the sum of <em>n</em> random numbers each generated the same way, where <em>n</em> follows a <a href="#Poisson_Distribution"><strong>Poisson distribution</strong></a> (e.g., <code>n = Poisson(10)</code> for an average of 10 numbers).</li>
<li>A <strong>hypoexponential distribution</strong> models the sum of <em>n</em> random numbers following an exponential distribution, each with a separate <code>lamda</code> parameter (see &quot;<a href="#Gamma_Distribution"><strong>Gamma Distribution</strong></a>&quot;).</li>
</ol>
</blockquote>

<p><a id=Random_Numbers_from_a_Distribution_of_Data_Points></a></p>

<h3>Random Numbers from a Distribution of Data Points</h3>

<p>Generating random numbers (or data points) based on how a list of numbers (or data points) is distributed involves a family of techniques called <a href="http://scikit-learn.org/stable/modules/density.html"><strong><em>density estimation</em></strong></a>, which include histograms, <a href="https://en.wikipedia.org/wiki/Kernel_density_estimation"><strong>kernel density estimation</strong></a>, and Gaussian <a href="https://en.wikipedia.org/wiki/Mixture_model"><strong>mixture models</strong></a>.  These techniques seek to model the distribution of data points in a given data set, where areas with more points are more likely to be sampled.</p>

<ol>
<li><strong>Histograms</strong> are sets of one or more <em>bins</em>, which are generally of equal size.  Histograms are <a href="#Mixtures_of_Distributions"><strong><em>mixtures</em></strong></a>, where each bin&#39;s weight is the number of data points in that bin.  After a bin is randomly chosen, a random data point that could fit in that bin is generated (that point need not be an existing data point).</li>
<li><strong>Gaussian mixture models</strong> are also mixtures, in this case, mixtures of one or more <a href="#Normal_Gaussian_Distribution"><strong>Gaussian (normal) distributions</strong></a>.</li>
<li><strong>Kernel distributions</strong> are mixtures of sampling distributions, one for each data point. Estimating a kernel distribution is called <em>kernel density estimation</em>.  To sample from a kernel distribution:

<ol>
<li>Choose one of the numbers or points in the list at random <a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>with replacement</strong></a>.</li>
<li>Add a randomized &quot;jitter&quot; to the chosen number or point; for example, add a separately generated <code>Normal(0, sigma)</code> to the chosen number or each component of the chosen point, where <code>sigma</code> is the <em>bandwidth</em><sup><a href="#Note21"><strong>(21)</strong></a></sup>.</li>
</ol></li>
</ol>

<p>This document doesn&#39;t detail how to build a density estimation model.<sup><a href="#Note22"><strong>(22)</strong></a></sup></p>

<p>Another way to generate random numbers based on a distribution of data points is known as <em>stochastic interpolation</em>, described in (Saucier 2000)<sup><a href="#Note20"><strong>(20)</strong></a></sup>, sec. 5.3.4.</p>

<p><a id=Random_Numbers_from_an_Arbitrary_Distribution></a></p>

<h3>Random Numbers from an Arbitrary Distribution</h3>

<p>Many probability distributions can be defined in terms of any of the following:</p>

<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function"><strong><em>cumulative distribution function</em></strong></a>, or <em>CDF</em>, returns, for each number, the probability for a randomly generated variable to be equal to or less than that number; the probability is in the interval [0, 1].</li>
<li>The <a href="https://en.wikipedia.org/wiki/Probability_density_function"><strong><em>probability density function</em></strong></a>, or <em>PDF</em>, is, roughly and intuitively, a curve of weights 0 or greater, where for each number, the greater its weight, the more likely a number close to that number is randomly chosen.<sup><a href="#Note23"><strong>(23)</strong></a></sup></li>
</ul>

<p>If a probability distribution&#39;s <strong>PDF is known</strong>, one of the following techniques, among others, can be used to generate random numbers that follow that distribution.</p>

<ol>
<li>Use the PDF to calculate the weights for a number of sample points (usually regularly spaced). Create one list with the sampled points in ascending order (the <code>list</code>) and another list of the same size with the PDF&#39;s values at those points (the <code>weights</code>).  Finally generate <a href="#Continuous_Weighted_Choice"><strong><code>ContinuousWeightedChoice(list, weights)</code></strong></a> to generate a random number bounded by the lowest and highest sampled point. This technique can be used even if the area under the PDF isn&#39;t 1. <strong>OR</strong></li>
<li><p>Use <a href="#Rejection_Sampling"><strong><em>rejection sampling</em></strong></a>.  Choose the lowest and highest random number to generate (<code>minValue</code> and <code>maxValue</code>, respectively) and find the maximum value of the PDF at or between those points (<code>maxDensity</code>).  The rejection sampling approach is then illustrated with the following pseudocode, where <code>PDF(X)</code> is the distribution&#39;s PDF (see also Saucier 2000, p. 39).   This technique can be used even if the area under the PDF isn&#39;t 1.</p>

<pre>METHOD ArbitraryDist(minValue, maxValue, maxDensity)
     if minValue &gt;= maxValue: return error
     while True
         x=RNDRANGEMaxExc(minValue, maxValue)
         y=RNDRANGEMaxExc(0, maxDensity)
         if y &lt; PDF(x): return x
     end
END METHOD
</pre></li>
</ol>

<p>If both <strong>a PDF and a uniform random variable in the interval [0, 1) (<code>randomVariable</code>)</strong> are given, then the following technique, among other possible techniques, can be used: Create <code>list</code> and <code>weights</code> as given in method 1, then divide each item in <code>weights</code> by the sum of <code>weights</code>&#39;s items, then generate <a href="#Continuous_Weighted_Choice"><strong><code>ContinuousWeightedChoice(list, weights)</code></strong></a> (except that method is modified to use <code>value = randomVariable</code> rather than <code>value = RNDRANGEMaxExc(0, sum)</code>).</p>

<p>If the distribution&#39;s <strong>CDF is known</strong>, an approach called <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling"><strong><em>inverse transform sampling</em></strong></a> can be used: Generate <code>ICDF(RNDU01ZeroOneExc())</code>, where <code>ICDF(X)</code> is the distribution&#39;s <em>inverse CDF</em>.  The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> includes <code>from_interp</code> and <code>numbers_from_cdf</code> methods that implement this approach numerically.</p>

<blockquote>
<p><strong>Note:</strong> Further details on inverse transform sampling or on how to find inverses, as well as lists of PDFs and CDFs, are outside the scope of this page.</p>
</blockquote>

<p><a id=Censored_and_Truncated_Distributions></a></p>

<h3>Censored and Truncated Distributions</h3>

<p>To sample from a <em>censored</em> probability distribution, generate a random number from that distribution and&mdash;</p>

<ul>
<li>if that number is less than a minimum threshold, use the minimum threshold instead, and/or</li>
<li>if that number is greater than a maximum threshold, use the maximum threshold instead.</li>
</ul>

<p>To sample from a <em>truncated</em> probability distribution, generate a random number from that distribution and, if that number is less than a minimum threshold and/or higher than a maximum threshold, repeat this process.</p>

<p><a id=Specific_Non_Uniform_Distributions></a></p>

<h2>Specific Non-Uniform Distributions</h2>

<p>This section contains information on some of the most common non-uniform probability distributions.</p>

<p><a id=Dice></a></p>

<h3>Dice</h3>

<p>The following method generates a random result of rolling virtual dice.<sup><a href="#Note24"><strong>(24)</strong></a></sup>  It takes three parameters: the number of dice (<code>dice</code>), the number of sides in each die (<code>sides</code>), and a number to add to the result (<code>bonus</code>) (which can be negative, but the result of the subtraction is 0 if that result is greater).</p>

<pre>METHOD DiceRoll(dice, sides, bonus)
    if dice &lt; 0 or sides &lt; 1: return error
    if dice == 0: return 0
    if sides == 1: return dice
    ret = 0
    if dice &gt; 50
        // If there are many dice to roll,
        // use a faster approach, noting that
        // the dice-roll distribution approaches
        // a &quot;discrete&quot; normal distribution as the
        // number of dice increases.
        mean = dice * (sides + 1) * 0.5
        sigma = sqrt(dice * (sides * sides - 1) / 12)
        ret = -1
        while ret &lt; dice or ret &gt; dice * sides
            ret = round(Normal(mean, sigma))
        end
    else
         i = 0
         while i &lt; dice
              ret = ret + RNDINTRANGE(1, sides)
              i = i + 1
          end
    end
    ret = ret + bonus
    if ret &lt; 0: ret = 0
    return ret
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong> The result of rolling&mdash;</p>

<ul>
<li>four six-sided virtual dice (&quot;4d6&quot;) is <code>DiceRoll(4,6,0)</code>,</li>
<li>three ten-sided virtual dice, with 4 added (&quot;3d10 + 4&quot;), is <code>DiceRoll(3,10,4)</code>, and</li>
<li>two six-sided virtual dice, with 2 subtracted (&quot;2d6 - 2&quot;), is <code>DiceRoll(2,6,-2)</code>.</li>
</ul>
</blockquote>

<p><a id=Normal_Gaussian_Distribution></a></p>

<h3>Normal (Gaussian) Distribution</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Normal_distribution"><strong><em>normal distribution</em></strong></a> (also called the Gaussian distribution) can be implemented using the pseudocode below, which uses the polar method <sup><a href="#Note25"><strong>(25)</strong></a></sup> to generate two normally-distributed random numbers:</p>

<ul>
<li><code>mu</code> (&mu;) is the mean (average), or where the peak of the distribution&#39;s &quot;bell curve&quot; is.</li>
<li><code>sigma</code> (&sigma;), the standard deviation, affects how wide the &quot;bell curve&quot; appears. The
probability that a normally-distributed random number will be within one standard deviation from the mean is about 68.3%; within two standard deviations (2 times <code>sigma</code>), about 95.4%; and within three standard deviations, about 99.7%.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD Normal2(mu, sigma)
  while true
    a = RNDU01()
    b = RNDU01()
    if a != 0 and RNDINT(1) == 0: a = 0 - a
    if b != 0 and RNDINT(1) == 0: b = 0 - b
    c = a * a + b * b
    if c != 0 and c &lt;= 1
       c = sqrt(-2 * ln(c) / c)
       return [a * mu * c + sigma, b * mu * c + sigma]
    end
  end
END METHOD
</pre>

<p>Since <code>Normal2</code> returns two numbers instead of one, but many applications require only one number at a time, a problem arises on how to return one number while storing the other for later retrieval.  Ways to solve this problem are outside the scope of this page, however.  The name <code>Normal</code> will be used in this document to represent a method that returns only one normally-distributed random number rather than two.</p>

<p>Alternatively, or in addition, the following method (implementing a ratio-of-uniforms technique) can be used to generate normally distributed random numbers.</p>

<pre>METHOD Normal(mu, sigma)
    bmp = sqrt(2.0/exp(1.0)) // about 0.8577638849607068
    while true
        a=RNDU01ZeroExc()
        b=RNDRANGE(-bmp,bmp)
        if b*b &lt;= -a * a * 4 * ln(a)
            return (b * sigma / a) + mu
        end
    end
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>In a <em>standard normal distribution</em>, <code>mu</code> = 0 and <code>sigma</code> = 1.</li>
<li>If variance is given, rather than standard deviation, the standard deviation (<code>sigma</code>) is the variance&#39;s square root.</li>
</ul>
</blockquote>

<p><a id=Binomial_Distribution></a></p>

<h3>Binomial Distribution</h3>

<p>A random integer that follows a <em>binomial distribution</em>&mdash;</p>

<ul>
<li>expresses the number of successes that have happened after a given number of independently performed trials
(expressed as <code>trials</code> below), where the probability of a success in each trial is <code>p</code> (which ranges from 0, never, to
1, always, and which can be 0.5, meaning an equal chance of success or failure), and</li>
<li>is also known as  <a href="https://en.wikipedia.org/wiki/Hamming_distance"><strong><em>Hamming distance</em></strong></a>, if each trial is treated as a &quot;bit&quot; that&#39;s set to 1 for a success and 0 for a failure, and if <code>p</code> is 0.5.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD Binomial(trials, p)
    if trials &lt; 0: return error
    if trials == 0: return 0
    // Always succeeds
    if p &gt;= 1.0: return trials
    // Always fails
    if p &lt;= 0.0: return 0
    i = 0
    count = 0
    // Suggested by Saucier, R. in &quot;Computer
    // generation of probability distributions&quot;, 2000, p. 49
    tp = trials * p
    if tp &gt; 25 or (tp &gt; 5 and p &gt; 0.1 and p &lt; 0.9)
         countval = -1
         while countval &lt; 0 or countval &gt; trials
              countval = round(Normal(tp, tp))
         end
         return countval
    end
    if p == 0.5
        while i &lt; trials
            if RNDINT(1) == 0
                // Success
                count = count + 1
            end
            i = i + 1
        end
    else
        while i &lt; trials
            if RNDU01OneExc() &lt; p
                // Success
                count = count + 1
            end
            i = i + 1
        end
    end
    return count
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ul>
<li>If <code>p</code> is 0.5, the binomial distribution models the task &quot;Flip N coins, then count the number of heads.&quot;</li>
<li>The idiom <code>Binomial(N, 0.5) &gt;= C</code> is true if at least C coins, among N coins flipped, show the successful outcome (for example, heads if heads is the successful outcome).</li>
<li>The idiom <code>Binomial(N, 1/S)</code> models the task &quot;Roll N S-sided dice, then count the number of dice that show the number S.&quot;</li>
</ul>
</blockquote>

<p><a id=Poisson_Distribution></a></p>

<h3>Poisson Distribution</h3>

<p>The following method generates a random integer that follows a <em>Poisson distribution</em> and is based on Knuth&#39;s method from 1969.  In the method&mdash;</p>

<ul>
<li><code>mean</code> is the average number of independent events of a certain kind per fixed unit of time or space (for example, per day, hour, or square kilometer), and can be an integer or a non-integer (the method allows <code>mean</code> to be 0 mainly for convenience), and</li>
<li>the method&#39;s return value gives a random number of such events within one such unit.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD Poisson(mean)
    if mean &lt; 0: return error
    if mean == 0: return 0
    p = 1.0
    // Suggested by Saucier, R. in &quot;Computer
    // generation of probability distributions&quot;, 2000, p. 49
    if mean &gt; 9
        p = -1.0
        while p &lt; 0: p = round(Normal(mean, mean))
        return p
    end
    pn = exp(-mean)
    count = 0
    while true
        p = p * RNDU01OneExc()
        if p &lt;= pn: return count
        count = count + 1
    end
END METHOD
</pre>

<p><a id=Gamma_Distribution></a></p>

<h3>Gamma Distribution</h3>

<p>The following method generates a random number that follows a <em>gamma distribution</em> and is based on Marsaglia and Tsang&#39;s method from 2000.  Usually, the number expresses either&mdash;</p>

<ul>
<li>the lifetime (in days, hours, or other fixed units) of a random component with an average lifetime of <code>meanLifetime</code>, or</li>
<li>a random amount of time (in days, hours, or other fixed units) that passes until as many events as <code>meanLifetime</code> happen.</li>
</ul>

<p>Here, <code>meanLifetime</code> must be an integer or noninteger greater than 0, and <code>scale</code> is a scaling parameter that is greater than 0, but usually 1.</p>

<pre>METHOD GammaDist(meanLifetime, scale)
    // Needs to be greater than 0
    if meanLifetime &lt;= 0 or scale &lt;= 0: return error
    // Exponential distribution special case if
    // `meanLifetime` is 1 (see also Devroye 1986, p. 405)
    if meanLifetime == 1: return -ln(RNDU01ZeroOneExc()) * scale
    d = meanLifetime
    v = 0
    if meanLifetime &lt; 1: d = d + 1
    d = d - (1.0 / 3) // NOTE: 1.0 / 3 must be a fractional number
    c = 1.0 / sqrt(9 * d)
    while true
        x = 0
        while true
           x = Normal(0, 1)
           v = c * x + 1;
           v = v * v * v
           if v &gt; 0: break
        end
        u = RNDU01ZeroExc()
        x2 = x * x
        if u &lt; 1 - (0.0331 * x2 * x2): break
        if ln(u) &lt; (0.5 * x2) + (d * (1 - v + ln(v))): break
    end
    ret = d * v
    if meanLifetime &lt; 1
       ret = ret * exp(ln(RNDU01ZeroExc()) / meanLifetime)
    end
    return ret * scale
end
</pre>

<p>Distributions based on the gamma distribution:</p>

<ul>
<li><strong>3-parameter gamma distribution</strong>: <code>pow(GammaDist(a, 1), 1.0 / c) * b</code>, where <code>c</code> is another shape parameter.</li>
<li><strong>4-parameter gamma distribution</strong>: <code>pow(GammaDist(a, 1), 1.0 / c) * b + d</code>, where <code>d</code> is the minimum value.</li>
<li><strong>Exponential distribution</strong>: <code>GammaDist(1, 1.0 / lamda)</code> or <code>-ln(RNDU01ZeroOneExc()) / lamda</code>, where <code>lamda</code> is the inverse scale. Usually, <code>lamda</code> is the probability that an independent event of a given kind will occur in a given span of time (such as in a given day or year), and the random result is the number of spans of time until that event happens.  (This distribution is thus useful for modeling a <em>Poisson process</em>.) <code>1.0 / lamda</code> is the scale (mean), which is usually the average waiting time between two independent events of the same kind.</li>
<li><strong>Erlang distribution</strong>: <code>GammaDist(n, 1.0 / lamda)</code>.  Expresses a sum of <code>n</code> exponential random variables with the given <code>lamda</code> parameter.</li>
<li><strong>Max-of-uniform distribution</strong> (Devroye 1986, p. 675):  <code>1.0 - x/(x+GammaDist(n,1))</code>, where <code>n</code> is the number of uniform random variables, and <code>x</code> is <code>GammaDist(1,1)</code>.  Using <code>x/(x+GammaDist(n,1))</code> instead results in a <strong>min-of-uniform distribution</strong> (Devroye 1986, p. 210).</li>
</ul>

<p><a id=Beta_Distribution></a></p>

<h3>Beta Distribution</h3>

<p>In the following method, which generates a random number that follows a <em>beta distribution</em>, <code>a</code> and <code>b</code> are two parameters each greater than 0.  The range of the beta distribution is [0, 1).</p>

<pre>METHOD BetaDist(self, a, b, nc)
  if b==1 and a==1: return RNDU01()
  if a==1: return 1.0-pow(RNDU01(),1.0/b)
  if b==1: return pow(RNDU01(),1.0/a)
  x=GammaDist(a,1)
  return x/(x+GammaDist(b,1))
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> A <strong>noncentral beta distribution</strong> is sampled by generating <code>BetaDist(a + Poisson(nc), b)</code>, where <code>nc</code> is greater than 0.</p>
</blockquote>

<p><a id=Negative_Binomial_Distribution></a></p>

<h3>Negative Binomial Distribution</h3>

<p>A random integer that follows a <em>negative binomial distribution</em> expresses the number of failures that have happened after seeing a given number of successes (expressed as <code>successes</code> below), where the probability of a success in each case is <code>p</code> (where <code>p &lt;= 0</code> means never, <code>p &gt;= 1</code> means always, and <code>p = 0.5</code> means an equal chance of success or failure).</p>

<pre>METHOD NegativeBinomial(successes, p)
    // Needs to be 0 or greater
    if successes &lt; 0: return error
    // No failures if no successes or if always succeeds
    if successes == 0 or p &gt;= 1.0: return 0
    // Always fails (NOTE: infinity can be the maximum possible
    // integer value if NegativeBinomial is implemented to return
    // an integer)
    if p &lt;= 0.0: return infinity
    // NOTE: If &#39;successes&#39; can be an integer only,
    // omit the following three lines:
    if floor(successes) != successes
        return Poisson(GammaDist(successes, (1 - p) / p))
    end
    count = 0
    total = 0
    if successes == 1
        if p == 0.5
          while RNDINT(1) == 0: count = count + 1
           return count
        end
        // Geometric distribution special case (see Saucier 2000)
        return floor(ln(RNDU01ZeroExc()) / ln(1.0 - p))
    end
    while true
        if RNDU01OneExc() &lt; p
            // Success
            total = total + 1
            if total &gt;= successes
                    return count
            end
        else
            // Failure
            count = count + 1
        end
    end
END METHOD
</pre>

<blockquote>
<p><strong>Example:</strong> If <code>p</code> is 0.5 and <code>successes</code> is 1, the negative binomial distribution models the task &quot;Flip a coin until you get tails, then count the number of heads.&quot;</p>
</blockquote>

<p><a id=von_Mises_Distribution></a></p>

<h3>von Mises Distribution</h3>

<p>In the following method, which generates a random number that follows a <em>von Mises distribution</em>, which describes a distribution of circular angles&mdash;</p>

<ul>
<li><code>mean</code> is the mean angle,</li>
<li><code>kappa</code> is a shape parameter, and</li>
<li>the method can return a number within &pi; of that mean.</li>
</ul>

<p>The algorithm below is the Best&ndash;Fisher algorithm from 1979 (as described in Devroye 1986 with errata incorporated).</p>

<pre>METHOD VonMises(mean, kappa)
    if kappa &lt; 0: return error
    if kappa == 0
        return RNDRANGEMinMaxExc(mean-pi, mean+pi)
    end
    r = 1.0 + sqrt(4 * kappa * kappa + 1)
    rho = (r - sqrt(2 * r)) / (kappa * 2)
    s = (1 + rho * rho) / (2 * rho)
    while true
        u = RNDRANGEMaxExc(-1, 1)
        v = RNDU01ZeroOneExc()
        z = cos(pi * u)
        w = (1 + s*z) / (s + z)
        y = kappa * (s - w)
        if y*(2 - y) - v &gt;=0 or ln(y / v) + 1 - y &gt;= 0
           if angle&lt;-1: angle=-1
           if angle&gt;1: angle=1
           // NOTE: Inverse cosine replaced here
           // with `atan2` equivalent
           angle = atan2(sqrt(1-w*w),w)
           if u &lt; 0: angle = -angle
           return mean + angle
        end
    end
END METHOD
</pre>

<p><a id=Stable_Distribution></a></p>

<h3>Stable Distribution</h3>

<p>As more and more independent random numbers from the same distribution are added
together, their distribution tends to a <a href="https://en.wikipedia.org/wiki/Stable_distribution"><strong><em>stable distribution</em></strong></a>,
which resembles a curve with a single peak, but with generally &quot;fatter&quot; tails than the normal distribution.  The pseudocode below uses the Chambers&ndash;Mallows&ndash;Stuck algorithm.  The <code>Stable</code> method, implemented below, takes two parameters:</p>

<ul>
<li><code>alpha</code> is a stability index in the interval (0, 2].</li>
<li><code>beta</code> is a skewness in the interval [-1, 1]; if <code>beta</code> is 0, the curve is symmetric.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD Stable(alpha, beta)
    if alpha &lt;=0 or alpha &gt; 2: return error
    if beta &lt; -1 or beta &gt; 1: return error
    halfpi = pi * 0.5
    unif=RNDRANGEMinMaxExc(-halfpi, halfpi)
    // Cauchy special case
    if alpha == 1 and beta == 0: return tan(unif)
    expo=-ln(RNDU01ZeroExc())
    c=cos(unif)
    if alpha == 1
            s=sin(unif)
            return 2.0*((unif*beta+halfpi)*s/c -
                beta * ln(halfpi*expo*c/(unif*beta+halfpi)))/pi
    end
    z=-tan(alpha*halfpi)*beta
    ug=unif+atan2(-z, 1)/alpha
    cpow=pow(c, -1.0 / alpha)
    return pow(1.0+z*z, 1.0 / (2*alpha))*
        (sin(alpha*ug)*cpow)*
        pow(cos(unif-alpha*ug)/expo, (1.0 - alpha) / alpha)
END METHOD
</pre>

<p>Extended versions of the stable distribution:</p>

<ul>
<li><strong>Four-parameter stable distribution</strong>: <code>Stable(alpha, beta) * sigma + mu</code>, where <code>mu</code> is the mean and <code>sigma</code> is the scale.  If <code>alpha</code> and <code>beta</code> are 1, the result is a <strong>Landau distribution</strong>.</li>
<li><strong>&quot;Type 0&quot; stable distribution</strong>: <code>Stable(alpha, beta) * sigma + (mu - sigma * beta * x)</code>, where <code>x</code> is <code>ln(sigma)*2.0/pi</code> if <code>alpha</code> is 1, and <code>tan(pi*0.5*alpha)</code> otherwise.</li>
</ul>

<p><a id=Hypergeometric_Distribution></a></p>

<h3>Hypergeometric Distribution</h3>

<p>The following method generates a random integer that follows a <em>hypergeometric distribution</em>.
When a given number of items are drawn at random without replacement from a collection of items
each labeled either <code>1</code> or <code>0</code>,  the random integer expresses the number of items drawn
this way that are labeled <code>1</code>.  In the method below, <code>trials</code> is the number of items
drawn at random, <code>ones</code> is the number of items labeled <code>1</code> in the set, and <code>count</code> is
the number of items labeled <code>1</code> or <code>0</code> in that set.</p>

<pre>METHOD Hypergeometric(trials, ones, count)
    if ones &lt; 0 or count &lt; 0 or trials &lt; 0 or ones &gt; count or trials &gt; count
            return error
    end
    if ones == 0: return 0
   successes = 0
    i = 0
    currentCount = count
    currentOnes = ones
    while i &lt; trials and currentOnes &gt; 0
            if RNDINTEXC(currentCount) &lt; currentOnes
                    currentOnes = currentOnes - 1
                    successes = successes + 1
            end
            currentCount = currentCount - 1
            i = i + 1
    end
    return successes
END METHOD
</pre>

<blockquote>
<p><strong>Example:</strong> In a 52-card deck of Anglo-American playing cards, 12 of the cards are face
cards (jacks, queens, or kings).  After the deck is shuffled and seven cards are drawn, the number
of face cards drawn this way follows a hypergeometric distribution where <code>trials</code> is 7, <code>ones</code> is
12, and <code>count</code> is 52.</p>
</blockquote>

<p><a id=Multivariate_Normal_Multinormal_Distribution></a></p>

<h3>Multivariate Normal (Multinormal) Distribution</h3>

<p>The following pseudocode calculates a random point in space that follows a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution"><strong><em>multivariate normal (multinormal) distribution</em></strong></a>.  The method <code>MultivariateNormal</code> takes the following parameters:</p>

<ul>
<li>A list, <code>mu</code> (&mu;), which indicates the means to add to each component of the random point. <code>mu</code> can be <code>nothing</code>, in which case each component will have a mean of zero.</li>
<li>A list of lists <code>cov</code>, that specifies a <em>covariance matrix</em> (&Sigma;, a symmetric positive definite NxN matrix, where N is the number of components of the random point).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD Decompose(matrix)
  numrows = size(matrix)
  if size(matrix[0])!=numrows: return error
  // Does a Cholesky decomposition of a matrix
  // assuming it&#39;s positive definite and invertible
  ret=NewList()
  for i in 0...numrows
    submat = NewList()
    for j in 0...numrows: AddItem(submat, 0)
    AddItem(ret, submat)
  end
  s1 = sqrt(matrix[0][0])
  if s1==0: return ret // For robustness
  for i in 0...numrows
    ret[0][i]=matrix[0][i]*1.0/s1
  end
  for i in 0...numrows
    sum=0.0
    for j in 0...i: sum = sum + ret[j][i]*ret[j][i]
    sq=matrix[i][i]-sum
    if sq&lt;0: sq=0 // For robustness
    ret[i][i]=math.sqrt(sq)
  end
  for j in 0...numrows
    for i in (j + 1)...numrows
      // For robustness
      if ret[j][j]==0: ret[j][i]=0
      if ret[j][j]!=0
        sum=0
        for k in 0...j: sum = sum + ret[k][i]*ret[k][j]
        ret[j][i]=(matrix[j][i]-sum)*1.0/ret[j][j]
      end
    end
  end
  return ret
END METHOD

METHOD MultivariateNormal(mu, cov)
  mulen=size(cov)
  if mu != nothing
    mulen = size(mu)
    if mulen!=size(cov): return error
    if mulen!=size(cov[0]): return error
  end
  // NOTE: If multiple random points will
  // be generated using the same covariance
  // matrix, an implementation can consider
  // precalculating the decomposed matrix
  // in advance rather than calculating it here.
  cho=Decompose(cov)
  i=0
  ret=NewList()
  variables=NewList()
  for j in 0...mulen: AddItem(variables, Normal(0, 1))
  while i&lt;mulen
    nv=Normal(0,1)
    sum = 0
    if mu == nothing: sum=mu[i]
    for j in 0...mulen: sum=sum+variables[j]*cho[j][i]
    AddItem(ret, sum)
    i=i+1
  end
  return ret
end
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>A <strong>binormal distribution</strong> (two-variable multinormal distribution) can be sampled using the following idiom: <code>MultivariateNormal([mu1, mu2], [[s1*s1, s1*s2*rho], [rho*s1*s2, s2*s2]])</code>, where <code>mu1</code> and <code>mu2</code> are the means of the two random variables, <code>s1</code> and <code>s2</code> are their standard deviations, and <code>rho</code> is a <em>correlation coefficient</em> greater than -1 and less than 1 (0 means no correlation).</li>
<li>A <strong>log-multinormal distribution</strong> can be sampled by generating numbers from a multinormal distribution, then applying <code>exp(n)</code> to the resulting numbers, where <code>n</code> is each number generated this way.</li>
<li>A <strong>Beckmann distribution</strong> can be sampled by calculating <code>sqrt(x*x+y*y)</code>, where <code>x</code> and <code>y</code> are the two numbers in a binormal random pair (see example 1).</li>
</ol>
</blockquote>

<p><a id=Random_Numbers_with_a_Given_Positive_Sum></a></p>

<h3>Random Numbers with a Given Positive Sum</h3>

<p>Generating N <code>GammaDist(total, 1)</code> numbers and dividing them by their sum will result in N random numbers that (approximately) sum to <code>total</code> (see a <a href="https://en.wikipedia.org/wiki/Dirichlet_distribution#Gamma_distribution"><strong>Wikipedia article</strong></a>).  For example, if <code>total</code> is 1, the numbers will (approximately) sum to 1.  Note that in the exceptional case that all numbers are 0, the process should repeat.</p>

<p>The following pseudocode shows how to generate random integers with a given positive sum. (The algorithm for this was presented in (Smith and Tromble 2004)<sup><a href="#Note26"><strong>(26)</strong></a></sup>.)  In the pseudocode below&mdash;</p>

<ul>
<li>the method <code>NonzeroIntegersWithSum</code> returns <code>n</code> positive integers that sum to <code>total</code>,</li>
<li>the method <code>IntegersWithSum</code> returns <code>n</code> nonnegative integers that sum to <code>total</code>, and</li>
<li><code>Sort(list)</code> sorts the items in <code>list</code> in ascending order (note that details on sort algorithms are outside the scope of this document).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD NonzeroIntegersWithSum(n, total)
    if n &lt;= 0 or total &lt;=0: return error
    ls = NewList()
    ret = NewList()
    AddItem(ls, 0)
    while size(ls) &lt; n
            c = RNDINTEXCRANGE(1, total)
            found = false
            j = 1
            while j &lt; size(ls)
                    if ls[j] == c
                            found = true
                            break
                    end
                    j = j + 1
            end
            if found == false: AddItem(ls, c)
    end
    Sort(ls)
    AddItem(ls, total)
    for i in 1...size(ls): AddItem(ret, list[i] - list[i - 1])
    return ret
END METHOD

METHOD IntegersWithSum(n, total)
    if n &lt;= 0 or total &lt;=0: return error
    ret = NonzeroIntegersWithSum(n, total + n)
    for i in 0...size(ret): ret[i] = ret[i] - 1
    return ret
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>Generating <code>N</code> random numbers with a given positive average <code>avg</code> is equivalent to generating <code>N</code> random numbers with the sum <code>N * avg</code>.</li>
<li>Generating <code>N</code> random numbers <code>min</code> or greater and with a given positive sum <code>sum</code> is equivalent to generating <code>N</code> random numbers with the sum <code>sum - n * min</code>, then adding <code>min</code> to each number generated this way.</li>
<li>The <strong>Dirichlet distribution</strong>, as defined in some places (e.g., <em>Mathematica</em>; Devroye 1986, p. 594), models <em>n</em> random numbers, and can be sampled by generating <em>n</em>+1 random <a href="#Gamma_Distribution"><strong>gamma-distributed</strong></a> numbers, each with separate parameters, taking their sum, and dividing the first <em>n</em> numbers by that sum.</li>
</ul>
</blockquote>

<p><a id=Multinomial_Distribution></a></p>

<h3>Multinomial Distribution</h3>

<p>The <em>multinomial distribution</em> models the number of times each of several mutually exclusive events happens among a given number of trials, where each event can have a separate probability of happening.  The pseudocode below is of a method that takes two parameters: <code>trials</code>, which is the number of trials, and <code>weights</code>, which are the relative probabilities of each event.  The method tallies the events as they happen and returns a list (with the same size as <code>weights</code>) containing the number of successes for each event.</p>

<pre>METHOD Multinomial(trials, weights)
    if trials &lt; 0: return error
    // create a list of successes
    list = NewList()
    for i in 0...size(weights): AddItem(list, 0)
    for i in 0...trials
        // Choose an index
        index = WeightedChoice(weights)
        // Tally the event at the chosen index
        list[index] = list[index] + 1
    end
    return list
END METHOD
</pre>

<p><a id=Gaussian_and_Other_Copulas></a></p>

<h3>Gaussian and Other Copulas</h3>

<p>A <em>copula</em> is a distribution describing the correlation (dependence) between random numbers.</p>

<p>One example is a <em>Gaussian copula</em>; this copula is sampled by sampling from a <a href="#Multivariate_Normal_Multinormal_Distribution"><strong>multinormal distribution</strong></a>, then converting the resulting numbers to uniformly-distributed, but correlated, numbers. In the following pseudocode, which implements a Gaussian copula:</p>

<ul>
<li>The parameter <code>covar</code> is the covariance matrix for the multinormal distribution.</li>
<li><code>erf(v)</code> is the <a href="https://en.wikipedia.org/wiki/Error_function"><strong>error function</strong></a> of the variable <code>v</code> (see the appendix).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD GaussianCopula(covar)
   mvn=MultivariateNormal(nothing, covar)
   for i in 0...size(covar)
      // Apply the normal distribution&#39;s CDF
      // to get uniform variables
      mvn[i] = (erf(mvn[i]/(sqrt(2)*sqrt(covar[i][i])))+1)*0.5
   end
   return mvn
END METHOD
</pre>

<p>Each of the resulting uniform numbers will be in the interval [0, 1], and each one can be further transformed to any other probability distribution (which is called a <em>marginal distribution</em> here) by one of the methods given in &quot;<a href="#Random_Numbers_from_an_Arbitrary_Distribution"><strong>Random Numbers from an Arbitrary Distribution</strong></a>&quot;. (See also Cario and Nelson 1997.)</p>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>To generate two correlated uniform variables with a Gaussian copula, generate <code>GaussianCopula([[1, rho], [rho, 1]])</code>, where <code>rho</code> is the Pearson correlation coefficient, in the interval [-1, 1]. (Note that <a href="https://en.wikipedia.org/wiki/Rank_correlation"><strong><em>rank correlation</em></strong></a> parameters, which can be converted to <code>rho</code>, can better describe the correlation than <code>rho</code> itself. For example, for a two-variable Gaussian copula, the Spearman coefficient <code>srho</code> can be converted to <code>rho</code> by <code>rho = sin(srho * pi / 6) * 2</code>.  Rank correlation parameters are not further discussed in this document.)</li>
<li><p>The following example generates two random numbers that follow a Gaussian copula with exponential marginals (<code>rho</code> is the Pearson correlation coefficient, and <code>rate1</code> and <code>rate2</code> are the rates of the two exponential marginals).</p>

<pre>METHOD CorrelatedExpo(rho, rate1, rate2)
   copula = GaussianCopula([[1, rho], [rho, 1]])
   // Transform to exponentials using that
   // distribution&#39;s inverse CDF
   return [-ln(copula[0]) / rate1, -ln(copula[1]) / rate2]
END METHOD
</pre></li>
</ol>
</blockquote>

<p>Other kinds of copulas describe different kinds of correlation between random numbers.  Examples of other copulas are&mdash;</p>

<ul>
<li>the <strong>Fr&eacute;chet&ndash;Hoeffding upper bound copula</strong> <em>[x, x, ..., x]</em> (e.g., <code>[x, x]</code>), where <code>x = RNDU01()</code>,</li>
<li>the <strong>Fr&eacute;chet&ndash;Hoeffding lower bound copula</strong> <code>[x, 1.0 - x]</code> where <code>x = RNDU01()</code>,</li>
<li>the <strong>product copula</strong>, where each number is a separately generated <code>RNDU01()</code> (indicating no correlation between the numbers), and</li>
<li>the <strong>Archimedean copulas</strong>, described by M. Hofert and M. M&auml;chler (2011)<sup><a href="#Note27"><strong>(27)</strong></a></sup>.</li>
</ul>

<p><a id=Other_Non_Uniform_Distributions></a></p>

<h3>Other Non-Uniform Distributions</h3>

<p>Most commonly used:</p>

<ul>
<li><strong>Cauchy (Lorentz) distribution</strong>: <code>scale * tan(pi * (RNDU01OneExc()-0.5)) + mu</code>, where <code>scale</code> is the scale and <code>mu</code> is the location of the distribution&#39;s curve peak (mode).  This distribution is similar to the normal distribution, but with &quot;fatter&quot; tails.</li>
<li><strong>Chi-squared distribution</strong>: <code>GammaDist(df * 0.5 + Poisson(sms * 0.5), 2)</code>, where <code>df</code> is the number of degrees of freedom and <code>sms</code> is the sum of mean squares (where <code>sms</code> other than 0 indicates a <em>noncentral</em> distribution).</li>
<li><strong>Extreme value distribution</strong>: <code>a - ln(-ln(RNDU01ZeroOneExc())) * b</code>, where <code>b</code> is the scale and <code>a</code> is the location of the distribution&#39;s curve peak (mode).  This expresses a distribution of maximum values.</li>
<li><strong>Geometric distribution</strong>: <code>NegativeBinomial(1, p)</code>, where <code>p</code> has the same meaning
as in the negative binomial distribution.  As used here, this is the number of failures that have happened before a success happens. (Saucier 2000, p. 44, also mentions an alternative definition that includes the success.)</li>
<li><strong>Gumbel distribution</strong>: <code>a + ln(-ln(RNDU01ZeroOneExc())) * b</code>, where <code>b</code> is the scale and <code>a</code> is the location of the distribution&#39;s curve peak (mode). This expresses a distribution of minimum values.</li>
<li><strong>Inverse gamma distribution</strong>: <code>b / GammaDist(a, 1)</code>, where <code>a</code> and <code>b</code> have the
same meaning as in the gamma distribution.  Alternatively, <code>1.0 / (pow(GammaDist(a, 1), 1.0 / c) / b + d)</code>, where <code>c</code> and <code>d</code> are shape and location parameters, respectively.</li>
<li><strong>Laplace (double exponential) distribution</strong>: <code>(ln(RNDU01ZeroExc()) - ln(RNDU01ZeroExc())) * beta + mu</code>, where <code>beta</code> is the scale and <code>mu</code> is the mean.</li>
<li><strong>Logarithmic distribution</strong>: <code>min + (max - min) * RNDU01OneExc() * RNDU01OneExc()</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 26).  In this distribution, numbers closer to <code>min</code> are exponentially more likely than numbers closer to <code>max</code>.</li>
<li><strong>Logarithmic normal distribution</strong>: <code>exp(Normal(mu, sigma))</code>, where <code>mu</code> and <code>sigma</code>
have the same meaning as in the normal distribution.</li>
<li><strong>Pareto distribution</strong>: <code>pow(RNDU01ZeroOneExc(), -1.0 / alpha) * minimum</code>, where <code>alpha</code>  is the shape and <code>minimum</code> is the minimum.</li>
<li><strong>Rayleigh distribution</strong>: <code>a * sqrt(-2 * ln(RNDU01ZeroExc()))</code>, where <code>a</code> is the scale and is greater than 0.  If <code>a</code> follows a logarithmic normal distribution, the result is a <em>Suzuki distribution</em>.</li>
<li><strong>Student&#39;s <em>t</em>-distribution</strong>: <code>Normal(cent, 1) / sqrt(GammaDist(df * 0.5, 2 / df))</code>, where <code>df</code> is the number of degrees of freedom, and <em>cent</em> is the mean of the normally-distributed random number.  A <code>cent</code> other than 0 indicates a <em>noncentral</em> distribution.</li>
<li><strong>Triangular distribution</strong>: <code>ContinuousWeightedChoice([startpt, midpt, endpt], [0, 1, 0])</code>. The distribution starts at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>.</li>
<li><strong>Weibull distribution</strong>: <code>b * pow(-ln(RNDU01ZeroExc()),1.0 / a) + loc</code>, where <code>a</code> is the shape, <code>b</code> is the scale <code>loc</code> is the location, and <code>a</code> and <code>b</code> are greater than 0.</li>
</ul>

<p>Miscellaneous:</p>

<ul>
<li><strong>Arcsine distribution</strong>: <code>min + (max - min) * BetaDist(0.5, 0.5)</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 14).</li>
<li><strong>Beta binomial distribution</strong>: <code>Binomial(trials, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>trials</code> is a parameter of the binomial distribution.</li>
<li><strong>Beta-PERT distribution</strong>: <code>startpt + size * BetaDist(1.0 + (midpt - startpt) * shape / size, 1.0 + (endpt - midpt) * shape / size)</code>. The distribution starts  at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>, <code>size</code> is <code>endpt - startpt</code>, and <code>shape</code> is a shape parameter that&#39;s 0 or greater, but usually 4.  If the mean (<code>mean</code>) is known rather than the peak, <code>midpt = 3 * mean / 2 - (startpt + endpt) / 4</code>.</li>
<li><strong>Beta prime distribution</strong>: <code>pow(GammaDist(a, 1), 1.0 / alpha) * scale / pow(GammaDist(b, 1), 1.0 / alpha)</code>, where <code>a</code>, <code>b</code>, and <code>alpha</code> are shape parameters and <code>scale</code> is the scale. If <em>a</em> is 1, the result is a <em>Singh&ndash;Maddala distribution</em>; if <em>b</em> is 1, a <em>Dagum distribution</em>; if <em>a</em> and <em>b</em> are both 1, a <em>logarithmic logistic distribution</em>.</li>
<li><strong>Beta negative binomial distribution</strong>: <code>NegativeBinomial(successes, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are the two parameters of the beta distribution, and <code>successes</code> is a parameter of the negative binomial distribution. If <em>successes</em> is 1, the result is a <em>Waring&ndash;Yule distribution</em>.</li>
<li><strong>Birnbaum&ndash;Saunders distribution</strong>: <code>pow(sqrt(4+x*x)+x,2)/(4.0*lamda)</code>, where <code>x = Normal(0,gamma)</code>, <code>gamma</code> is a shape parameter, and <code>lamda</code> is a scale parameter.</li>
<li><strong>Chi distribution</strong>: <code>sqrt(GammaDist(df * 0.5, 2))</code>, where <code>df</code> is the number of degrees of freedom.</li>
<li><strong>Cosine distribution</strong>: <code>min + (max - min) * atan2(x, sqrt(1 - x * x)) / pi</code>, where <code>x = RNDRANGE(-1, 1)</code> and <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 17; inverse sine replaced with <code>atan2</code> equivalent).</li>
<li><strong>Double logarithmic distribution</strong>: <code>min + (max - min) * (0.5 + (RNDINT(1) * 2 - 1) * 0.5 * RNDU01OneExc() * RNDU01OneExc())</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (see also Saucier 2000, p. 15, which shows the wrong X axes).</li>
<li><strong>Fr&eacute;chet distribution</strong>: <code>b*pow(-ln(RNDU01ZeroExc()),-1.0/a) + loc</code>, where <code>a</code> is the shape, <code>b</code> is the scale, and <code>loc</code> is the location of the distribution&#39;s curve peak (mode). This expresses a distribution of maximum values.</li>
<li><strong>Generalized extreme value (Fisher&ndash;Tippett) distribution</strong>: <code>a - (pow(-ln(RNDU01ZeroOneExc()), -c) - 1) * b / c</code> if <code>c != 0</code>, or <code>a - ln(-ln(RNDU01ZeroOneExc())) * b</code> otherwise, where <code>b</code> is the scale, <code>a</code> is the location of the distribution&#39;s curve peak (mode), and <code>c</code> is a shape parameter. This expresses a distribution of maximum values.</li>
<li><strong>Generalized Tukey lambda distribution</strong>: <code>(s1 * (pow(x, lamda1)-1.0)/lamda1 - s2 * (pow(1.0-x, lamda2)-1.0)/lamda2) + loc</code>, where <code>x</code> is <code>RNDU01()</code>, <code>lamda1</code> and <code>lamda2</code> are shape parameters, <code>s1</code> and <code>s2</code> are scale parameters, and <code>loc</code> is a location parameter.</li>
<li><strong>Half-normal distribution</strong>. Parameterizations include:

<ul>
<li><em>Mathematica</em>: <code>abs(Normal(0, sqrt(pi * 0.5) / invscale)))</code>, where <code>invscale</code> is a parameter of the half-normal distribution.</li>
<li>MATLAB: <code>abs(Normal(mu, sigma)))</code>, where <code>mu</code> and <code>sigma</code> are the same as in the normal distribution.</li>
</ul></li>
<li><strong>Inverse chi-squared distribution</strong>: <code>df * scale / (GammaDist(df * 0.5, 2))</code>, where <code>df</code> is the number of degrees of freedom and <code>scale</code> is the scale, usually <code>1.0 / df</code>.</li>
<li><strong>Inverse Gaussian distribution (Wald distribution)</strong>: Generate <code>n = mu + (mu*mu*y/(2*lamda)) - mu * sqrt(4 * mu * lamda * y + mu * mu * y * y) / (2 * lamda)</code>, where <code>y = pow(Normal(0, 1), 2)</code>, then return <code>n</code> if <code>RNDU01OneExc() &lt;= mu / (mu + n)</code>, or <code>mu * mu / n</code> otherwise. <code>mu</code> is the mean and <code>lamda</code> is the scale; both parameters are greater than 0. Based on method published in <a href="http://luc.devroye.org/rnbookindex.html"><strong>Devroye 1986</strong></a>.</li>
<li><strong>Kumaraswamy distribution</strong>: <code>min + (max - min) * pow(1-pow(RNDU01ZeroExc(),1.0/b),1.0/a)</code>, where <code>a</code> and <code>b</code> are shape parameters, <code>min</code> is the minimum value, and <code>max</code> is the maximum value.</li>
<li><strong>L&eacute;vy distribution</strong>: <code>sigma * 0.5 / GammaDist(0.5, 1) + mu</code>, where <code>mu</code> is the location and <code>sigma</code> is the dispersion.</li>
<li><strong>Logarithmic series distribution</strong>: <code>floor(1.0 + ln(RNDU01ZeroExc()) / ln(1.0 - pow(1.0 - param, RNDU01ZeroOneExc())))</code>, where <code>param</code> is a number greater than 0 and less than 1. Based on method described in Devroye 1986.</li>
<li><strong>Logistic distribution</strong>: <code>(ln(x)-ln(1.0 - x)) * scale + mean</code>, where <code>x</code> is <code>RNDU01ZeroOneExc()</code> and <code>mean</code> and <code>scale</code> are the mean and the scale, respectively.</li>
<li><strong>Maxwell distribution</strong>: <code>scale * sqrt(GammaDist(1.5, 2))</code>, where <code>scale</code> is the scale.</li>
<li><strong>Parabolic distribution</strong>: <code>min + (max - min) * BetaDist(2, 2)</code>, where <code>min</code> is the minimum value and <code>max</code> is the maximum value (Saucier 2000, p. 30).</li>
<li><strong>Pascal distribution</strong>: <code>NegativeBinomial(successes, p) + successes</code>, where <code>successes</code> and <code>p</code> have the same meaning as in the negative binomial distribution, except <code>successes</code> is always an integer.</li>
<li><strong>Pearson VI distribution</strong>: <code>GammaDist(v, 1) / (GammaDist(w, 1))</code>, where <code>v</code> and <code>w</code> are shape parameters greater than 0 (Saucier 2000, p. 33; there, an additional <code>b</code> parameter is defined, but that parameter is canceled out in the source code).</li>
<li><strong>Power distribution</strong>: <code>pow(RNDU01ZeroOneExc(), 1.0 / alpha) / b</code>, where <code>alpha</code>  is the shape and <code>b</code> is the domain.  Nominally in the interval (0, 1).</li>
<li><strong>Power law distribution</strong>: <code>pow(RNDRANGE(pow(mn,n+1),pow(mx,n+1)), 1.0 / (n+1))</code>, where <code>n</code>  is the exponent, <code>mn</code> is the minimum, and <code>mx</code> is the maximum.  <a href="http://mathworld.wolfram.com/RandomNumber.html"><strong>Reference</strong></a>.</li>
<li><strong>Skellam distribution</strong>: <code>Poisson(mean1) - Poisson(mean2)</code>, where <code>mean1</code> and <code>mean2</code> are the means of the two Poisson variables.</li>
<li><strong>Skewed normal distribution</strong>: <code>Normal(0, x) + mu + alpha * abs(Normal(0, x))</code>, where <code>x</code> is <code>sigma / sqrt(alpha * alpha + 1.0)</code>, <code>mu</code> and <code>sigma</code> have the same meaning as in the normal distribution, and <code>alpha</code> is a shape parameter.</li>
<li><strong>Snedecor&#39;s (Fisher&#39;s) <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5, n) / (GammaDist(n * 0.5 + Poisson(sms * 0.5)) * m, 1)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random numbers with a chi-squared distribution, and if <code>sms</code> is other than 0, one of those distributions is <em>noncentral</em> with sum of mean squares equal to <code>sms</code>.</li>
<li><strong>Tukey lambda distribution</strong>: <code>(pow(x, lamda)-pow(1.0-x,lamda))/lamda</code>, where <code>x</code> is <code>RNDU01()</code> and <code>lamda</code> is a shape parameter (if 0, the result is a logistic distribution).</li>
<li><strong>Zeta distribution</strong>: Generate <code>n = floor(pow(RNDU01ZeroOneExc(), -1.0 / r))</code>, and if <code>d / pow(2, r) &lt; (d - 1) * RNDU01OneExc() * n / (pow(2, r) - 1.0)</code>, where <code>d = pow((1.0 / n) + 1, r)</code>, repeat this process. The parameter <code>r</code> is greater than 0. Based on method described in Devroye 1986. A zeta distribution <a href="#Censoring_and_Truncation"><strong>truncated</strong></a> by rejecting random values greater than some positive integer is called a <em>Zipf distribution</em> or <em>Estoup distribution</em>. (Note that Devroye uses &quot;Zipf distribution&quot; to refer to the untruncated zeta distribution.)</li>
</ul>

<p>The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> also contains implementations of the <strong>power normal distribution</strong>, the <strong>power lognormal distribution</strong>, the <strong>Moyal distribution</strong>, the <strong>negative multinomial distribution</strong>,  the <strong>multivariate <em>t</em>-distribution</strong>, the <strong>multivariate <em>t</em>-copula</strong>, and the <strong>multivariate Poisson distribution</strong>.</p>

<p><a id=Geometric_Sampling></a></p>

<h2>Geometric Sampling</h2>

<p>This section contains various geometric sampling techniques.</p>

<p><a id=Random_Points_Inside_a_Simplex></a></p>

<h3>Random Points Inside a Simplex</h3>

<p>The following pseudocode generates, uniformly at random, a point inside an <em>n</em>-dimensional simplex (simplest convex figure, such as a line segment, triangle, or tetrahedron).  It takes an array <em>points</em>, a list consisting of the <em>n</em> plus one vertices of the simplex, all of a single dimension <em>n</em> or greater.</p>

<pre>METHOD RandomPointInSimplex(points):
   ret=NewList()
   if size(points) &gt; size(points[0])+1: return error
   if size(points)==1 // Return a copy of the point
     for i in 0...size(points[0]): AddItem(ret,points[0][i])
     return ret
   end
   gammas=NewList()
   // Sample from a Dirichlet distribution
   for i in 0...size(points): AddItem(gammas,
       -ln(RNDU01ZeroOneExc()))
   tsum=0
   for i in 0...size(gammas): tsum = tsum + gammas[i]
   tot = 0
   for i in 0...size(gammas) - 1
       gammas[i] = gammas[i] / tsum
       tot = tot + gammas[i]
   end
   tot = 1.0 - tot
   for i in 0...size(points[0]): AddItem(ret, points[0][i]*tot)
   for i in 1...size(points)
      for j in 0...size(points[0])
         ret[j]=ret[j]+points[i][j]*gammas[i-1]
      end
   end
   return ret
END METHOD
</pre>

<p><a id=Random_Points_on_the_Surface_of_a_Hypersphere></a></p>

<h3>Random Points on the Surface of a Hypersphere</h3>

<p>The following pseudocode shows how to generate, uniformly at random, an N-dimensional point on the surface of an N-dimensional hypersphere, centered at the origin, of radius <code>radius</code> (if <code>radius</code> is 1, the result can also serve as a unit vector in N-dimensional space).  Here, <code>Norm</code> is given in the appendix.  See also (Weisstein)<sup><a href="#Note28"><strong>(28)</strong></a></sup>.</p>

<pre>METHOD RandomPointInHypersphere(dims, radius)
  x=0
  while x==0
    ret=[]
    for i in 0...dims: AddItem(ret, Normal(0, 1))
    x=Norm(ret)
  end
  invnorm=radius/x
  for i in 0...dims: ret[i]=ret[i]*invnorm
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Example:</strong> To generate, uniformly at random, a point on the surface of a cylinder running along the Z axis, generate, uniformly at random, X and Y coordinates on the surface of a circle (2-dimensional hypersphere) and a Z coordinate within the desired range (e.g., with <code>RNDRANGE</code>).</p>
</blockquote>

<p><a id=Random_Points_Inside_a_Ball_or_Shell></a></p>

<h3>Random Points Inside a Ball or Shell</h3>

<p>To generate, uniformly at random, an N-dimensional point inside an N-dimensional ball, centered at the origin, of radius R, follow the pseudocode in <code>RandomPointInHypersphere</code>, except replace <code>Norm(ret)</code> with <code>sqrt( S - ln(RNDU01ZeroExc()))</code>, where <code>S</code> is the sum of squares of the numbers in <code>ret</code>.  For discs and spheres (2- or 3-dimensional balls), an alternative is to generate a vector (list) of N <code>RNDRANGE(-R, R)</code> random numbers<sup><a href="#Note29"><strong>(29)</strong></a></sup> until its <em>norm</em> is R or less (see the <a href="#Appendix"><strong>appendix</strong></a>).<sup><a href="#Note30"><strong>(30)</strong></a></sup></p>

<p>To generate, uniformly at random, a point inside an N-dimensional spherical shell (a hollow ball), centered at the origin, with inner radius A and outer radius B (where A is less than B), either&mdash;</p>

<ul>
<li>generate, uniformly at random, a point for a ball of radius B until the norm of that point is A or greater (see the <a href="#Appendix"><strong>appendix</strong></a>), or</li>
<li>generate, uniformly at random, a point on the surface of an N-dimensional hypersphere with radius equal to <code>pow(RNDRANGE(pow(A, N), pow(B, N)), 1.0 / N)</code><sup><a href="#Note31"><strong>(31)</strong></a></sup>.</li>
</ul>

<blockquote>
<p><strong>Example:</strong> To generate, uniformly at random, a point inside a cylinder running along the Z axis, generate, uniformly at random, X and Y coordinates inside a disk (2-dimensional ball) and a Z coordinate within the desired range (e.g., with <code>RNDRANGE</code>).</p>
</blockquote>

<p><a id=Random_Latitude_and_Longitude></a></p>

<h3>Random Latitude and Longitude</h3>

<p>To generate, uniformly at random, a point on the surface of a sphere in the form of a latitude and longitude (in radians with west and south coordinates negative)&mdash;</p>

<ul>
<li>generate the longitude <code>RNDRANGEMaxExc(-pi, pi)</code>, where the longitude is in the interval [-&pi;, &pi;), and</li>
<li>generate the latitude <code>atan2(sqrt(1 - x * x), x) - pi / 2</code>, where <code>x = RNDRANGE(-1, 1)</code> and the latitude is in the interval [-&pi;/2, &pi;/2] (the interval excludes the poles, which have many equivalent forms; if poles are not desired, generate <code>x</code> until neither -1 nor 1 is generated this way).</li>
</ul>

<p>Reference: <a href="http://mathworld.wolfram.com/SpherePointPicking.html"><strong>&quot;Sphere Point Picking&quot;</strong></a> in MathWorld (replacing inverse cosine with <code>atan2</code> equivalent).</p>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>This page discussed many ways applications can extract random numbers
from random number generators.</p>

<p>I acknowledge the commenters to the CodeProject version of this page, including George Swan, who referred me to the reservoir sampling method.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> An RNG meeting this definition can&mdash;</p>

<ul>
<li>seek to generate random numbers that are at least cost-prohibitive (but not necessarily <em>impossible</em>) to predict,</li>
<li>merely seek to generate number sequences likely to pass statistical tests of randomness,</li>
<li>be initialized automatically before use,</li>
<li>be initialized with an application-specified &quot;seed&quot;,</li>
<li>use a deterministic algorithm for random number generation,</li>
<li>rely, at least primarily, on one or more nondeterministic sources for random number
generation (including by extracting uniformly distributed bits from two or more such sources), or</li>
<li>have two or more of the foregoing properties.</li>
</ul>

<p>If the software and/or hardware uses a nonuniform distribution, but otherwise meets this definition, it can be converted to use a uniform distribution, at least in theory, using <em>unbiasing</em>, <em>deskewing</em>, or <em>randomness extraction</em>, which are outside the scope of this document.</small></p>

<p><small><sup id=Note2>(2)</sup> There are other RNGs besides those that generate integers 0 or greater.  For example, Wichmann&ndash;Hill and dSFMT output numbers in the interval [0, 1).  For such RNGs, if the RNG is known to output numbers in the interval [0, 1) evenly spaced by a number <em>p</em>, it can be transformed into an RNG that outputs integers in the interval [0, 1/<em>p</em>) by multiplying its outputs by <em>p</em>.  Otherwise, several of its outputs can be serialized to a sequence of 8-bit bytes, then the byte sequence sent to a <a href="https://peteroupc.github.io/random.html#Hash_Functions"><strong>hash function</strong></a> with an <em>n</em>-bit output (shorter than the byte sequence), thus turning the RNG into an RNG that outputs integers in the interval [0, 2<sup><em>n</em></sup>).</p>

<p>For an exercise solved by this method, see A. Koenig and B. E. Moo, <em>Accelerated C++</em>, 2000; see also a <a href="http://mathalope.co.uk/2014/10/26/accelerated-c-solution-to-exercise-7-9/"><strong>blog post by Johnny Chan</strong></a>.  In addition, M. O&#39;Neill discusses various methods, both biased and unbiased, for generating random integers in a range with an RNG in a <a href="http://www.pcg-random.org/posts/bounded-rands.html"><strong>blog post from July 2018</strong></a>.</small></p>

<p><small><sup id=Note3>(3)</sup> This number format describes B-bit signed integers with minimum value -2<sup>B-1</sup> and maximum value 2<sup>B-1</sup> - 1, where B is a positive even number of bits; examples include Java&#39;s <code>short</code>, <code>int</code>, and <code>long</code>, with 16, 32, and 64 bits, respectively. A <em>signed integer</em> is an integer that can be positive, zero, or negative. In <em>two&#39;s-complement form</em>, nonnegative numbers have the highest (most significant) bit set to zero, and negative numbers have that bit (and all bits beyond) set to one, and a negative number is stored in such form by swapping the bits of a number equal to that number&#39;s absolute value minus 1.</small></p>

<p><small><sup id=Note4>(4)</sup> A na&iuml;ve <code>RNDINTEXC</code> implementation often seen in certain languages like JavaScript is the idiom <code>floor(RNDU01OneExc()*maxExclusive)</code>.  However, there are certain issues with this idiom:</p>

<ol>
<li>Depending on how <code>RNDU01OneExc()</code> is implemented, some integers can never occur with this idiom for large <code>maxExclusive</code> values, or this idiom can otherwise have a slight bias toward certain integers.  This bias may or may not be negligible in a given application.  For example, if <code>RNDU01OneExc()</code> is implemented as <code>RNDINT(255)/256</code>, the resulting number will have no more than 8 bits set to 1, so that not all numbers can &quot;randomly&quot; occur with <code>maxExclusive</code> greater than 256.</li>
<li>Depending on the number format, rounding error can result in <code>maxExclusive</code> being returned in rare cases.  A more robust implementation could use a loop to check whether <code>maxExclusive</code> was generated and try again if so.  Where a loop is not possible, such as within an SQL query, the idiom above can be replaced with <code>min(floor(RNDU01OneExc() * maxExclusive, maxExclusive - 1))</code>.  Both modifications could still have the issue given in item 1.</li>
</ol>

<p>If an application is concerned about these issues, it can transform the <code>RNDU01OneExc()</code> implementation (e.g., <code>Math.random()</code>) to an RNG that outputs integers 0 or greater, and use that as the underlying RNG for <code>RNDINT</code> and thus <code>RNDINTEXC</code>; see Note (2).</small></p>

<p><small><sup id=Note5>(5)</sup> Downey, A. B. &quot;<a href="http://allendowney.com/research/rand/"><strong>Generating Pseudo-random Floating Point Values</strong></a>&quot;, 2007</small></p>

<p><small><sup id=Note6>(6)</sup> See, for example, the <em>Stack Overflow</em> question &quot;How to generate a number in arbitrary range using random()={0..1} preserving uniformness and density?&quot;, <code>questions/8019589</code>.</small></p>

<p><small><sup id=Note7>(7)</sup> Describing differences between SQL dialects is outside the scope of this document, but <a href="http://flourishlib.com/docs/FlourishSQL"><strong>Flourish SQL</strong></a> describes many such differences, including those concerning RNGs.</small></p>

<p><small><sup id=Note8>(8)</sup> Jeff Atwood, &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/"><strong>The danger of na&iuml;vet&eacute;</strong></a>&quot;, Dec. 7, 2007.</small></p>

<p><small><sup id=Note9>(9)</sup> It suffices to say here that in general, whenever a deterministic RNG is otherwise called for, such an RNG is good enough for shuffling a 52-item list if its period is 2<sup>226</sup> or greater. (The <em>period</em> is the maximum number of values in a generated sequence for a deterministic RNG before that sequence repeats.)</small></p>

<p><small><sup id=Note10>(10)</sup> If the strings identify database records, file system paths, or other shared resources, special considerations apply, including the need to synchronize access to those resources.  If the string will uniquely identify database records (e.g., Web site users) and is not secret, an application should consider using an auto-incrementing row number instead, if supported by the database.</small></p>

<p><small><sup id=Note11>(11)</sup> See also the <em>Stack Overflow</em> question &quot;Random index of a non zero value in a numpy array&quot;.</small></p>

<p><small><sup id=Note12>(12)</sup> Bentley, Jon Louis and James B. Saxe.  &quot;Generating Sorted Lists of Random Numbers.&quot; <em>ACM Trans. Math. Softw.</em> 6 (1980): 359-364.</small></p>

<p><small><sup id=Note13>(13)</sup> P. L&#39;Ecuyer, &quot;Tables of Linear Congruential Generators of Different Sizes and Good Lattice Structure&quot;, January 1999.</small></p>

<p><small><sup id=Note14>(14)</sup> Brownlee, J. &quot;<a href="https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/"><strong>A Gentle Introduction to the Bootstrap Method</strong></a>&quot;, <em>Machine Learning Mastery</em>, May 25, 2018.</small></p>

<p><small><sup id=Note15>(15)</sup> Efraimidis, P. and Spirakis, P. &quot;<a href="http://utopia.duth.gr/%7Epefraimi/research/data/2007EncOfAlg.pdf"><strong>Weighted Random Sampling (2005; Efraimidis, Spirakis)</strong></a>&quot;, 2005.</small></p>

<p><small><sup id=Note16>(16)</sup> Efraimidis, P. &quot;Weighted Random Sampling over Data Streams&quot;. arXiv:1012.0256v2 [cs.DS], 2015.</small></p>

<p><small><sup id=Note17>(17)</sup> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> includes a <code>ConvexPolygonSampler</code> class that implements this kind of sampling for convex polygons; unlike other polygons, convex polygons are trivial to decompose into triangles.</small></p>

<p><small><sup id=Note18>(18)</sup> That article also mentions a critical-hit distribution, which is actually a <a href="#Mixtures_of_Distributions"><strong>mixture</strong></a> of two distributions: one roll of dice and the sum of two rolls of dice.</small></p>

<p><small><sup id=Note19>(19)</sup> An <em>affine transformation</em> is one that keeps straight lines straight and parallel lines parallel.</small></p>

<p><small><sup id=Note20>(20)</sup> Saucier, R. &quot;Computer Generation of Statistical Distributions&quot;, March 2000.</small></p>

<p><small><sup id=Note21>(21)</sup> &quot;Jitter&quot;, as used in this step, follows a distribution formally called a <em>kernel</em>, of which the normal distribution is one example.  <em>Bandwidth</em> should be as low or as high as allows the estimated distribution to fit the data and remain smooth.  A more complex kind of &quot;jitter&quot; (for multi-component data points) consists of a point generated from a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution"><strong>multinormal distribution</strong></a> with all the means equal to 0 and a <em>covariance matrix</em> that, in this context, serves as a <em>bandwidth matrix</em>.  &quot;Jitter&quot; and bandwidth are not further discussed in this document.</small></p>

<p><small><sup id=Note22>(22)</sup> Other references on density estimation include <a href="https://en.wikipedia.org/wiki/Multivariate_kernel_density_estimation"><strong>a Wikipedia article on multiple-variable kernel density estimation</strong></a>, and a <a href="http://mark-kay.net/2013/12/24/kernel-density-estimation/"><strong>blog post by M. Kay</strong></a>.</small></p>

<p><small><sup id=Note23>(23)</sup> More formally&mdash;</p>

<ul>
<li>the PDF is the <em>derivative</em> (instantaneous rate of change) of the distribution&#39;s CDF (that is, PDF(x) = CDF&prime;(x)), and</li>
<li>the CDF is also defined as the <em>integral</em> of the PDF,</li>
</ul>

<p>provided the PDF&#39;s values are all 0 or greater and the area under the PDF&#39;s curve is 1.</small></p>

<p><small><sup id=Note24>(24)</sup> The &quot;Dice&quot; section used the following sources:</p>

<ul>
<li>Red Blob Games, <a href="http://www.redblobgames.com/articles/probability/damage-rolls.html"><strong>&quot;Probability and Games: Damage Rolls&quot;</strong></a> was the main source for the dice-roll distribution.  The method <code>random(N)</code> in that document corresponds to <code>RNDINTEXC(N)</code> in this document.</li>
<li>The <a href="http://mathworld.wolfram.com/Dice.html"><strong>MathWorld article &quot;Dice&quot;</strong></a> provided the mean of the dice roll distribution.</li>
<li>S. Eger, &quot;Stirling&#39;s approximation for central extended binomial coefficients&quot;, 2014, helped suggest the variance of the dice roll distribution.</small></li>
</ul>

<p><small><sup id=Note25>(25)</sup> The method that formerly appeared here is the <em>Box&dash;Muller transformation</em>: <code>mu + radius * cos(angle)</code> and <code>mu + radius * sin(angle)</code>, where <code>angle = 2 * pi * RNDU01OneExc()</code> and <code>radius = sqrt(-2 * ln(RNDU01ZeroExc())) * sigma</code>, are two independent normally-distributed random numbers.  A method of generating approximate standard normal random numbers, which consists of summing twelve <code>RNDU01OneExc()</code>  numbers and subtracting by 6 (see also <a href="https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution"><strong>&quot;Irwin&ndash;Hall distribution&quot; on Wikipedia</strong></a>), results in values not less than -6 or greater than 6; on the other hand, in a standard normal distribution, results less than -6 or greater than 6 will occur only with a generally negligible probability.</small></p>

<p><small><sup id=Note26>(26)</sup> Smith and Tromble, &quot;<a href="http://www.cs.cmu.edu/%7Enasmith/papers/smith+tromble.tr04.pdf"><strong>Sampling Uniformly from the Unit Simplex</strong></a>&quot;, 2004.</small></p>

<p><small><sup id=Note27>(27)</sup> Hofert, M., and Maechler, M.  &quot;Nested Archimedean Copulas Meet R: The nacopula Package&quot;.  Journal of Statistical Software 39(9), 2011, pp. 1-20.</small></p>

<p><small><sup id=Note28>(28)</sup> Weisstein, Eric W.  &quot;<a href="http://mathworld.wolfram.com/HyperspherePointPicking.html"><strong>Hypersphere Point Picking</strong></a>&quot;.  From MathWorld&mdash;A Wolfram Web Resource.</small></p>

<p><small><sup id=Note29>(29)</sup> The N numbers generated this way will form a point inside an N-dimensional <em>hypercube</em> with length <code>2 * R</code> in each dimension and centered at the origin of space.</small></p>

<p><small><sup id=Note30>(30)</sup> See also a <a href="http://mathworld.wolfram.com/BallPointPicking.html"><strong>MathWorld article</strong></a>, which was the inspiration for these two methods, and the <em>Stack Overflow</em> question &quot;How to generate uniform random points in (arbitrary) N-dimension ball?&quot;, <code>questions/54544971</code>.</small></p>

<p><small><sup id=Note31>(31)</sup> See the <em>Mathematics Stack Exchange</em> question titled &quot;Random multivariate in hyperannulus&quot;, <code>questions/1885630</code>.</small></p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Implementation_of_erf></a></p>

<h3>Implementation of <code>erf</code></h3>

<p>The pseudocode below shows how the <a href="https://en.wikipedia.org/wiki/Error_function"><strong>error function</strong></a> <code>erf</code> can be implemented, in case the programming language used doesn&#39;t include a built-in version of <code>erf</code> (such as JavaScript at the time of this writing).   In the pseudocode, <code>EPSILON</code> is a very small number to end the iterative calculation.</p>

<pre>METHOD erf(v)
    if v==0: return 0
    if v&lt;0: return -erf(-v)
    if v==infinity: return 1
    // NOTE: For Java `double`, the following
    // line can be added:
    // if v&gt;=6: return 1
    i=1
    ret=0
    zp=-(v*v)
    zval=1.0
    den=1.0
    while i &lt; 100
        r=v*zval/den
        den=den+2
        ret=ret+r
        // NOTE: EPSILON can be pow(10,14),
        // for example.
        if abs(r)&lt;EPSILON: break
        if i==1: zval=zp
        else: zval = zval*zp/i
        i = i + 1
    end
    return ret*2/sqrt(pi)
END METHOD
</pre>

<p><a id=Mean_and_Variance_Calculation></a></p>

<h3>Mean and Variance Calculation</h3>

<p>The following method calculates the mean and the <a href="http://mathworld.wolfram.com/Variance.html"><strong>bias-corrected sample variance</strong></a> of a list of real numbers.   It returns a two-item list containing the mean and that kind of variance in that order. It uses the <a href="https://www.johndcook.com/blog/standard_deviation/"><strong>Welford method</strong></a> presented by J. D. Cook.  (Sample variance is the estimated variance of a population or distribution based on a random sample of that population or distribution.)</p>

<pre>METHOD MeanAndVariance(list)
    if size(list)==0: return [0, 0]
    if size(list)==1: return [list[0], 0]
    xm=list[0]
    xs=0
    i=1
    while i &lt; size(list)
        c = list[i]
        i = i + 1
        cxm = (c - xm)
        xm = xm + cxm *1.0/ i
        xs = xs + cxm * (c - xm)
    end
    return [xm, xs*1.0/(size(list)-1)]
END METHOD
</pre>

<p><a id=Norm_Calculation></a></p>

<h3>Norm Calculation</h3>

<p>The following method calculates the norm of a vector (list of numbers).</p>

<pre>METHOD Norm(vec)
  ret=0
  for i in 0...size(vec): ret=ret+vec[i]*vec[i]
  return sqrt(ret)
END METHOD
</pre>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
