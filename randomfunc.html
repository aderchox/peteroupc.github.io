<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Random Number Generation Methods</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>Random Number Generation Methods</h1>

<p><a href="mailto:poccil14@gmail.com">Peter Occil</a></p>

<p>Begun on June 4, 2017; last updated on June 13, 2017.</p>

<p>Discusses many ways in which applications can extract random numbers from RNGs and includes pseudocode for most of them.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page discusses many ways applications can extract random numbers
from random number generators (RNGs) and includes pseudocode for most
of them.</p>

<p>As used in this document--</p>

<ul>
<li>RNGs include those that seek to generate random numbers that are cost-prohibitive to predict (also called &quot;cryptographically strong&quot; RNGs) and those that merely seek to generate number sequences likely to pass statistical tests of randomness, and</li>
<li>RNGs include not only those that use a deterministic algorithm, but also those that primarily rely on one or more nondeterministic sources for random number generation.</li>
</ul>

<p>In general, though, recommendations on which RNGs are suitable for which applications are outside the scope of this page;  I have written about this in <a href="https://peteroupc.github.io/random.html">another document</a>. Moreover, the methods presented in this page can generally be used by any RNG regardless of its nature.</p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Contents">Contents</a></li>
<li><a href="#Notes_and_Definitions">Notes and Definitions</a></li>
<li><a href="#Core_Random_Generation_Method">Core Random Generation Method</a></li>
<li><a href="#Random_Numbers_Within_a_Range">Random Numbers Within a Range</a>

<ul>
<li><a href="#Random_Integers_Within_a_Range">Random Integers Within a Range</a></li>
<li><a href="#Random_Numbers_in_a_0_1_Bounded_Interval">Random Numbers in a 0-1 Bounded Interval</a></li>
<li><a href="#Uniform_Numbers_Within_a_Range">Uniform Numbers Within a Range</a></li>
</ul></li>
<li><a href="#Boolean_Conditions">Boolean Conditions</a></li>
<li><a href="#Shuffling">Shuffling</a></li>
<li><a href="#Choosing_a_Random_Item_from_a_List">Choosing a Random Item from a List</a></li>
<li><a href="#Creating_a_Random_Character_String">Creating a Random Character String</a></li>
<li><a href="#Choosing_Several_Unique_Items">Choosing Several Unique Items</a></li>
<li><a href="#Weighted_Choice">Weighted Choice</a>

<ul>
<li><a href="#Discrete_Weighted_Choice">Discrete Weighted Choice</a>

<ul>
<li><a href="#Example">Example</a></li>
<li><a href="#Weighted_Choice_Without_Replacement">Weighted Choice Without Replacement</a></li>
</ul></li>
<li><a href="#Continuous_Weighted_Choice">Continuous Weighted Choice</a>

<ul>
<li><a href="#Example">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#Normal_Distribution">Normal Distribution</a></li>
<li><a href="#Binomial_Distribution">Binomial Distribution</a></li>
<li><a href="#Hypergeometric_Distribution">Hypergeometric Distribution</a></li>
<li><a href="#Poisson_Distribution">Poisson Distribution</a></li>
<li><a href="#Gamma_Distribution">Gamma Distribution</a></li>
<li><a href="#Negative_Binomial_Distribution">Negative Binomial Distribution</a></li>
<li><a href="#Other_Non_Uniform_Distributions">Other Non-Uniform Distributions</a></li>
<li><a href="#Conclusion">Conclusion</a></li>
<li><a href="#License">License</a></li>
</ul>

<p><a id=Notes_and_Definitions></a></p>

<h2>Notes and Definitions</h2>

<p>In this document:</p>

<ul>
<li>Divisions do not round to an integer.  In programming languages in which division of two integers results in an integer, the right-hand side of the division must be converted to a floating-point number first.</li>
<li>Lists are indexed starting with 0.  That means the first item in the list is 0, the second item in the list is 1, and so on, up to the last item, whose index is the list&#39;s size minus 1.</li>
<li>The pseudocode shown doesn&#39;t cover all error handling that may be necessary in a particular implementation.   Such errors may include overflow checking, bounds checking, division by zero, and checks for infinity.  Neither is the pseudocode guaranteed to yield high performance in a particular implementation, either in time or memory.</li>
<li><code>pi</code> is the constant &pi;, the ratio of a circle&#39;s circumference to its diameter.</li>
<li><code>sin(a)</code>, <code>cos(a)</code>, and <code>tan(a)</code> are the sine, cosine, and tangent of the angle <code>a</code>, respectively, in radians.</li>
<li><code>pow(a, b)</code> is the number <code>a</code> raised to the power <code>b</code>.</li>
<li><code>abs(a)</code> is the absolute value of <code>a</code>.</li>
<li><code>sqrt(a)</code> is the square root of <code>a</code>.</li>
<li><code>ln(a)</code> is the natural logarithm of <code>a</code>.  It corresponds to the <code>Math.log</code> method in Java and JavaScript.</li>
<li><code>exp(a)</code> is the number <em>e</em> (base of natural logarithms) raised to the power <code>a</code>.</li>
<li><code>GetNextLine(file)</code> is a method that gets the next line from a file, or returns <code>nothing</code> if the end of the file was reached.</li>
<li><code>NewList()</code> creates a new empty list.</li>
<li><code>AddItem(list, item)</code> adds the item <code>item</code> to the list <code>list</code>.</li>
<li><code>size(list)</code> returns the size of the list <code>list</code>.</li>
<li><code>list[k]</code> refers to the item at index <code>k</code> of the list <code>list</code>.</li>
</ul>

<p><a id=Core_Random_Generation_Method></a></p>

<h2>Core Random Generation Method</h2>

<p>The core method for generating random numbers using an RNG is called <strong><code>RNDINT(N)</code></strong> in this document. It generates a random integer from 0 inclusive to N exclusive, where N is an integer greater than 0, and it assumes the underlying RNG produces uniformly random bits.</p>

<p><code>RNDINT(N)</code> can be implemented as follows: Use the RNG to generate as many random bits as used to represent N-minus-1, then convert those bits to a nonnegative integer. If that nonnegative integer is N or greater, repeat this process.</p>

<p>This core method can serve as the basis for all other methods described below that extract random numbers from RNGs.</p>

<p><a id=Random_Numbers_Within_a_Range></a></p>

<h2>Random Numbers Within a Range</h2>

<p>The following methods aid in generating random numbers within a range.</p>

<p><a id=Random_Integers_Within_a_Range></a></p>

<h3>Random Integers Within a Range</h3>

<ul>
<li>Random integer from MIN inclusive to MAX exclusive: <code>MIN + RNDINT(MAX - MIN)</code></li>
<li>Random integer from MIN inclusive to MAX inclusive: <code>MIN + RNDINT((MAX - MIN) + 1)</code></li>
<li><strong>Example:</strong> Random integer from 10 inclusive to 40 exclusive: <code>10 + RNDINT(30)</code></li>
</ul>

<p><a id=Random_Numbers_in_a_0_1_Bounded_Interval></a></p>

<h3>Random Numbers in a 0-1 Bounded Interval</h3>

<p>The following idioms generate a random number in an interval bounded at 0 and 1.</p>

<ul>
<li><code>RNDU()</code>, a random number 0 or greater, but less than 1 (interval <code>[0, 1)</code>): <code>RNDINT(X) / X</code></li>
<li>Random number greater than 0, but less than 1 (interval <code>(0, 1)</code>): <code>(RNDINT(X-1) + 1) / X</code></li>
<li>Random number 0 or greater, but 1 or less (interval <code>[0, 1]</code>): <code>(RNDINT(X + 1)) / X</code></li>
<li>Random number greater than 0, but 1 or less (interval <code>(0, 1]</code>): <code>(RNDINT(X) + 1) / X</code></li>
</ul>

<p>In the method definitions given above, X is an integer which is the number of fractional parts between 0 and 1.  For 64-bit IEEE 854 floating-point numbers (Java <code>double</code>), X will be 2<sup>53</sup>.  For 32-bit IEEE 854 floating-point numbers (Java <code>float</code>), X will be 2<sup>24</sup>.  (See &quot;Generating uniform doubles in the unit interval&quot; in the <a href="http://xoroshiro.di.unimi.it/#remarks"><code>xoroshiro+</code> remarks page</a>
for further discussion.)  Note that <code>RNDU()</code> corresponds to <code>Math.random()</code> in Java and JavaScript.</p>

<p><a id=Uniform_Numbers_Within_a_Range></a></p>

<h3>Uniform Numbers Within a Range</h3>

<ul>
<li>Random number from MIN inclusive to MAX exclusive: <code>MIN + RNDU()*(MAX - MIN)</code></li>
<li>Alternative way of generating a random integer from 0 inclusive to N exclusive: <code>floor(RNDU()*(N))</code>

<ul>
<li><strong>Example:</strong> In JavaScript, this can be implemented as: <code>Math.floor(Math.random()*N)</code></li>
</ul></li>
</ul>

<p><a id=Boolean_Conditions></a></p>

<h2>Boolean Conditions</h2>

<p>To generate a condition that is true at the specified probabilities, use
the following idioms in an <code>if</code> condition:</p>

<ul>
<li>True or false with equal probability: <code>RNDINT(2) == 0</code>.</li>
<li>True with X percent probability: <code>RNDINT(100) &lt; X</code>.</li>
<li>True with probability X/Y: <code>RNDINT(Y) &lt; X</code>.</li>
<li>True with probability X, where X is from 0 through 1 (a <em>Bernoulli trial</em>): <code>RNDU() &lt; X</code>.</li>
<li><strong>Example:</strong> True with probability 3/8: <code>RNDINT(8) &lt; 3</code>.</li>
<li><strong>Example:</strong> True with 20% probability: <code>RNDINT(100) &lt; 20</code>.</li>
</ul>

<p><a id=Shuffling></a></p>

<h2>Shuffling</h2>

<p>The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle">Fisher-Yates shuffle method</a> shuffles a list such that all permutations of that list are equally likely to occur, assuming the RNG it uses produces uniformly random numbers and can generate all permutations of that list.  However, that method is also easy to get wrong.  The following pseudocode is designed to shuffle a list&#39;s contents.</p>

<pre>METHOD Shuffle(list)
   // NOTE: Check size of the list early to prevent
   // `i` from being less than 0 if the list&#39;s size is 0 and
   // `i` is implemented using an unsigned type available
   // in certain programming languages.
   if size(list) &gt;= 2
      // Set i to the last item&#39;s index
      i = size(list) - 1
      while i &gt; 0
         // Choose an item ranging from the first item
         // up to the item given in i
         k = RNDINT(i + 1)
         // The following is wrong since it introduces biases:
         // k = RNDINT(size(list))
         // The following is wrong since the algorithm won&#39;t
         // choose from among all possible permutations:
         // k = RNDINT(i)
         // Swap item at index i with item at index k;
         // in this case, i and k may be the same
         tmp = list[i]
         list[i] = list[k]
         list[k] = tmp
         // Move i so it points to the previous item
         i = i - 1
      end
   end
END METHOD
</pre>

<p>An important consideration with respect to shuffling is the kind of RNG used.  Notably, a deterministic RNG can&#39;t generate all permutations of a list if the <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a> of the list&#39;s size is greater than the generator&#39;s <em>period</em> (the maximum number of values it can generate in a sequence before that sequence repeats). This means that the items in a shuffled list of that size will never appear in certain orders when that generator is used to shuffle it. For example, a deterministic RNG with period 2<sup>64</sup> can&#39;t generate all permutations of a list with more than 20 items; with period 2<sup>128</sup>, more than 34 items; with period 2<sup>226</sup>, more than 52 items; and with period 2<sup>256</sup>, more than 57 items.  RNGs that seek to generate random numbers that are cost-prohibitive to predict (so-called &quot;cryptographically strong&quot; generators) suffer less from this problem.</p>

<p><a id=Choosing_a_Random_Item_from_a_List></a></p>

<h2>Choosing a Random Item from a List</h2>

<p>To choose a random item from a list--</p>

<ul>
<li>whose size is known in advance, use the idiom <code>list[RNDINT(size(list))]</code>.  This idiom assumes that the first item of the list is at position 0, the second is at position 1, and so on.</li>
<li><p>whose size is not known in advance, use a method like the following.  Although the pseudocode refers to files and lines, the technique applies to any situation when items are retrieved one at a time from a dataset or list whose size is not known in advance.</p>

<pre>METHOD RandomItemFromFile(file)
   i = 1
   lastItem = nothing
   loop
      // Get the next line from the file
      item = GetNextLine(file)
      // The end of the file was reached, break
      if item == nothing: break
      if RNDINT(i) == 0: lastItem = item
      i = i + 1
   end
end
</pre></li>
</ul>

<p><a id=Creating_a_Random_Character_String></a></p>

<h2>Creating a Random Character String</h2>

<p>A commonly asked question involves how to generate a random string of characters (usually a random <em>alphanumeric string</em>, or string of letters and digits).</p>

<p>The first step is to generate a list of the letters, digits, and/or other characters the string can have.  Often, those characters will be--</p>

<ul>
<li>the basic digits &quot;0&quot; to &quot;9&quot; (U+0030-U+0039, nos. 48-57),</li>
<li>the basic upper case letters &quot;A&quot; to &quot;Z&quot; (U+0041-U+005A, nos. 65-90), and</li>
<li>the basic lower case letters &quot;a&quot; to &quot;z&quot; (U+0061-U+007A, nos. 96-122),</li>
</ul>

<p>as found in the Basic Latin block of the Unicode Standard. Note that:</p>

<ul>
<li>If the list of characters is fixed, the list can be statically created at runtime or compile time, or a string type as provided in the programming language can be used to store the list as a string.</li>
<li>Instead of individual characters, the list can consist of strings of characters.  In that case, storing the list of strings as a single string is usually not a clean way to store those strings.</li>
</ul>

<p>The second step is to build a new string whose characters are chosen from that character list.  The pseudocode below demonstrates this by creating a list, rather than a string, where the random characters will be held.  It also takes the number of characters as a parameter named <code>size</code>.  (Converting this list to a text string is programming-language-dependent, and the details of the conversion are outside the scope of this page.)</p>

<pre>  METHOD RandomString(characterList, stringSize)
       i = 0
       newString = NewList()
       while i &lt; stringSize
           // Choose a character from the list
           randomChar = characterList[RNDINT(size(characterList))]
           // Add the character to the string
           AddItem(newString, randomChar)
           i = i + 1
        end
        return newString
  END METHOD
</pre>

<p><em><strong>Note:</strong> Often applications need to generate a string of characters that&#39;s not only random, but also unique.  The best way to ensure uniqueness in this case is to store a list (such as a hash table) of strings already generated and to check newly generated strings against the list (or table).  Random number generators alone should not be relied on to deliver unique results.</em></p>

<p><a id=Choosing_Several_Unique_Items></a></p>

<h2>Choosing Several Unique Items</h2>

<p>Often, the need arises to choose <code>k</code> unique items or values from among <code>n</code> available items or values.  The following assumes that each item has an equal chance of being chosen.  There are several techniques for doing this depending on whether <code>n</code> is known and how big it is:</p>

<ul>
<li><p><strong>If <code>n</code> is not known in advance:</strong> Use the <em>reservoir sampling</em> method, implemented below.  Although the pseudocode refers to files and lines, the technique applies to any situation when items are retrieved one at a time from a dataset or list whose size is not known in advance.</p>

<pre>METHOD RandomKItemsFromFile(file, k)
   list = NewList()
   j = 0
   endOfFile = false
   while j &lt; k
      // Get the next line from the file
      item = GetNextLine(file)
      // The end of the file was reached, break
      if item == nothing
         endOfFile = true
         break
      end
      AddItem(list, item)
      j = j + 1
   end
   i = 1 + k
   while endOfFile == false
      // Get the next line from the file
      item = GetNextLine(file)
      // The end of the file was reached, break
      if item == nothing: break
      j = RNDINT(i)
      if j &lt; k: list[j] = item
      i = i + 1
   end
   // We shuffle at the end in case k or fewer
   // lines were in the file, since in that
   // case the items would appear in the same
   // order as they appeared in the file
   // if the list weren&#39;t shuffled.  This line
   // can be removed, however, if the items
   // in the returned list need not appear
   // in random order.
   Shuffle(list)
   return list
end
</pre></li>
<li><strong>If <code>n</code> is relatively small (for example, if there are 200 available items, or there is a range of numbers from 0 to 200 to choose from):</strong> Store all the items in a list, <a href="#Shuffling">shuffle</a> that list, and choose the first <code>k</code> items from that list.</li>
<li><strong>If <code>n</code> is relatively large (for example, if 32-bit or larger integers will be chosen so that <code>n</code> is 2<sup>32</sup> or is a greater power of 2):</strong> Create a hash table storing the items already generated.  When a new item (or index to an item) is chosen, check the hash table to see if it&#39;s there already.  If it&#39;s not there already, add it to the hash table.  Otherwise, choose a new item (or index).  Repeat this process until <code>k</code> items (or indices) were added to the hash table this way.  Performance considerations involved in storing data in hash tables, and in retrieving data from them, are outside the scope of this document.  This technique can also be used for relatively small <code>n</code>, if some of the items have a higher probability of being chosen than others (see <a href="#Discrete_Weighted_Choice">Discrete Weighted Choice</a>, below).</li>
</ul>

<p><a id=Weighted_Choice></a></p>

<h2>Weighted Choice</h2>

<p>Some applications need to choose random items or numbers such that some of them are more likely to be chosen than others.</p>

<p><a id=Discrete_Weighted_Choice></a></p>

<h3>Discrete Weighted Choice</h3>

<p>The discrete weighted choice method is used to choose a random item from among a set of them with different probabilities of being chosen.</p>

<p>The following pseudocode takes two lists, <code>list</code> and <code>weights</code>, and returns the index of one item from the list <code>list</code>.  Items with greater weights (which are given at the corresponding indices in the list <code>weights</code>) are more likely to be chosen. (Note that there are two possible ways to generate the random number depending on whether the weights are all integers or can be fractional numbers.) Each weight should be 0 or greater. Both lists should be the same size.</p>

<pre>METHOD DiscreteWeightedChoice(list, weights)
    if size(list) &lt;= 0 or size(weights) &lt; size(list): return error
    sum = 0
    // Get the sum of all weights
    i = 0
    while i &lt; size(list)
        sum = sum + weights[i]
        i = i + 1
    end
    // Choose a random integer/number from 0 to less than
    // the sum of weights.
    value = RNDINT(sum)
    // NOTE: If the weights can be fractional numbers,
    // use this instead:
    // value = RNDU() * sum
    // Choose the object according to the given value
    i = 0
    lastItem = size(list) - 1
    runningValue = 0
    while i &lt; size(list)
       if weights[i] &gt; 0
          newValue = runningValue + weights[i]
          if value &lt; newValue: return i
          runningValue = newValue
          lastItem = i
       end
       i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return lastItem
END METHOD
</pre>

<p><a id=Example></a></p>

<h4>Example</h4>

<p>Assume <code>list</code> is the following: <code>[&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;grapes&quot;]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  The weight for &quot;apples&quot; is 3, and the weight for &quot;oranges&quot; is 15.  Since &quot;oranges&quot; has a higher weight than &quot;apples&quot;, the index for &quot;oranges&quot; (1) is more likely to be chosen than the index for &quot;apples&quot; (0) with the <code>DiscreteWeightedChoice</code> method.  The following pseudocode implements how to get a randomly chosen item from the list with that method.</p>

<pre>index = DiscreteWeightedChoice(list, weights)
// Get the actual item
item = list[index]
</pre>

<p><a id=Weighted_Choice_Without_Replacement></a></p>

<h4>Weighted Choice Without Replacement</h4>

<p>In the example above, the weights sum to 21.  However, the weights do not mean that when 21 items are selected, the index for &quot;apples&quot; will be chosen exactly 3 times, or the index for &quot;oranges&quot; exactly 15 times, for example.  Each call to <code>DiscreteWeightedChoice</code> is independent from the others, and each weight indicates only a <em>likelihood</em> that the corresponding item will be chosen rather than the other items.  And this likelihood doesn&#39;t change no matter how many times <code>DiscreteWeightedChoice</code> is called with the same weights.  This is called a weighted choice <em>with replacement</em>, which can be thought of as drawing a ball, then putting it back.</p>

<p>To implement weighted choice <em>without replacement</em> (which can be thought of as drawing a ball <em>without</em> putting it back), simply call <code>DiscreteWeightedChoice</code>, and then decrease the weight for the chosen index by 1.  In this way, when items are selected repeatedly, each weight behaves like the number of &quot;copies&quot; of each item. This technique, though, will only work properly if all the weights are integers 0 or greater.  The pseudocode below is an example of this.</p>

<pre>// Get the sum of weights
// (NOTE: This assumes that `weights` is
// a list that can be modified.  If the original weights
// are needed for something else, a copy of that
// list should be made first, but the copying process
// is not shown here.)
totalWeight = 0
i = 0
while i &lt; size(list)
    totalWeight = totalWeight + weights[i]
    i = i + 1
end
// Choose as many items as the sum of weights
i = 0
items = NewList()
while i &lt; totalWeight
    index = DiscreteWeightedChoice(list, weights)
    // Decrease weight by 1 to implement selection
    // without replacement.
    weights[index] = weights[index] - 1
    AddItem(items, list[index])
    i = i + 1
end
</pre>

<p>Alternatively, if all the weights are integers 0 or greater and their sum is relatively small, create a list with as many copies of each item as its weight, then <a href="#Shuffling">shuffle</a> that list.  The resulting list will be ordered in a way that corresponds to a weighted random choice without replacement.</p>

<p><a id=Continuous_Weighted_Choice></a></p>

<h3>Continuous Weighted Choice</h3>

<p>The continuous weighted choice method is used to choose a random number that follows a continuous numerical distribution.</p>

<p>The following pseudocode takes two lists, <code>list</code> and <code>weights</code>, and returns a random number that follows the distribution.  <code>list</code> is a list of numbers (which can be fractional numbers) that should be arranged in ascending order, and <code>weights</code> is a list of <em>probability densities</em> for the given numbers (where each number and its density have the same index in both lists).  Each probability density should be 0 or greater.  Both lists should be the same size.  In the pseudocode below, the first number in <code>list</code> can be returned exactly, but not the second item in <code>list</code>, assuming the numbers in <code>list</code> are arranged in ascending order.</p>

<p>In many cases, the probability densities are sampled (usually at regularly spaced points) from a so-called <a href="https://en.wikipedia.org/wiki/Probability_density_function"><em>probability density function</em></a>, a function that specifies the <em>probability density</em> for each number (the probability that a randomly chosen value will be infinitesimally close to that number, assuming no precision limits).  A list of common probability density functions is outside the scope of this page.</p>

<pre>METHOD ContinuousWeightedChoice(list, weights)
    if size(list) &lt;= 0 or size(weights) &lt; size(list): return error
    if size(list) == 1: return list[0]
    // Get the sum of all areas between weights
    sum = 0
    areas = NewList()
    i = 0
    while i &lt; size(list) - 1
      weightArea = abs((weights[i] + weights[i + 1]) * 0.5 * (list[i + 1] - list[i]))
      AddItem(areas, weightArea)
      sum += weightArea
       i = i + 1
    end
    // Choose a random number
    value = RNDU() * sum
     // Interpolate a number according to the given value
     i=0
     // Get the number corresponding to the random number
     runningValue = 0
    while i &lt; size(list) - 1
    area = areas[i]
     if area &gt; 0
      newValue = runningValue + area
      if value &lt;= newValue
       interp = (value - runningValue) / (newValue - runningValue)
       retValue = list[i] + (list[i + 1] - list[i]) * interp
       return retValue
      end
      runningValue = newValue
     end
     i = i + 1
    end
    // Last resort (might happen because rounding
    // error happened somehow)
    return list[size(list) - 1]
END METHOD
</pre>

<p><a id=Example></a></p>

<h4>Example</h4>

<p>Assume <code>list</code> is the following: <code>[0, 1, 2, 2.5, 3]</code>, and <code>weights</code> is the following: <code>[0.2, 0.8, 0.5, 0.3, 0.1]</code>.  The probability density for 2 is 0.5, and that for 2.5 is 0.3.  Since 2 has a higher probability density than 2.5, numbers near 2 are more likely to be chosen than numbers near 2.5 with the <code>ContinuousWeightedChoice</code> method.</p>

<p><a id=Normal_Distribution></a></p>

<h2>Normal Distribution</h2>

<p>The normal distribution can model many kinds of measurements or scores whose values are most likely around a given average and are less likely the farther away from that average on either side.</p>

<p>The following method generates two <a href="https://en.wikipedia.org/wiki/Normal_distribution">normally-distributed</a>
random numbers with mean (average) <code>mu</code> (&mu;) and standard deviation <code>sigma</code> (&sigma;). (In a <em>standard normal distribution</em>, &mu; = 0 and &sigma; = 1.), using the so-called <a href="https://en.wikipedia.org/wiki/Box-Muller%20transformation">Box-Muller transformation</a>, as further explained in the pseudocode&#39;s comments.  The standard deviation <code>sigma</code> affects how wide the normal distribution&#39;s &quot;bell curve&quot; appears; the
probability that a normally-distributed random number will be one standard deviation from the mean is about 68.3%;
within two standard deviations (2 times <code>sigma</code>), about 95.4%, and within three standard deviations, about 99.7%.</p>

<pre>METHOD Normal2(mu, sigma)
  // Choose a Rayleigh-distributed radius (multiplied by sigma)
  radius = sqrt(-2 * ln(1.0 - RNDU())) * sigma
  // Choose a random angle
  angle = 2 * pi * RNDU()
  // Return two normally-distributed numbers.  This will
  // be the X and Y coordinates of a point on a circle.
  return [mu + radius * cos(angle), mu + radius * sin(angle)]
END METHOD
</pre>

<p>Since <code>Normal2</code> returns two numbers instead of one, but many applications require only one number at a time, a problem arises on how to return one number while storing the other for later retrieval.  Ways to solve this problem are outside the scope of this page, however.  The name <code>Normal</code> will be used in this document to represent a method that returns only one normally-distributed random number rather than two.</p>

<p><a id=Binomial_Distribution></a></p>

<h2>Binomial Distribution</h2>

<p>The following method generates a random integer that follows a binomial distribution.  This number
expresses the number of successes that have happened after a given number of independently performed trials
(expressed as <code>trials</code> below), where the probability of a success in each trial is <code>p</code> (which ranges from 0, never, to
1, always, and which can be 0.5, meaning an equal chance of success or failure).</p>

<p><strong>Example:</strong> If <code>p</code> is 0.5, the binomial distribution models the task &quot;Flip N coins, then count the number of heads.&quot;</p>

<pre>METHOD Binomial(trials, p)
    if trials &lt; 0: return error
    if trials == 0: return 0
    // Always succeeds
    if p &gt;= 1.0: return trials
    // Always fails
    if p &lt;= 0.0: return 0
    i = 0
    count = 0
    while i &lt; trials
        if RNDU() &lt; p
            // Success
            count = count + 1
        end
        i = i + 1
    end
    return count
END METHOD
</pre>

<p><a id=Hypergeometric_Distribution></a></p>

<h2>Hypergeometric Distribution</h2>

<p>The following method generates a random integer that follows a hypergeometric distribution.
When a given number of items are drawn at random without replacement from a set of items
each labeled either <code>1</code> or <code>0</code>,  the random integer expresses the number of items drawn
this way that are labeled <code>1</code>.  In the method below, <code>trials</code> is the number of items
drawn at random, <code>ones</code> is the number of items labeled <code>1</code> in the set, and <code>count</code> is
the number of items labeled <code>1</code> or <code>0</code> in that set.</p>

<p><strong>Example:</strong> In a 52-card deck of Anglo-American playing cards, 12 of the cards are face
cards (jacks, queens, or kings).  After the deck is shuffled and seven cards are drawn, the number
of face cards drawn this way follows a hypergeometric distribution where <code>trials</code> is 7, <code>ones</code> is
12, and <code>count</code> is 52.</p>

<pre>METHOD Hypergeometric(trials, ones, count)
    if ones &lt; 0 or count &lt; 0 or trials &lt; 0 or ones &gt; count or trials &gt; count
            return error
    end
    if ones == 0: return 0
    successes = 0
    i = 0
    currentCount = count
    currentOnes = ones
    while i &lt; trials and currentOnes &gt; 0
            if RNDINT(currentCount) &lt; currentOnes
                    currentOnes = currentOnes - 1
                    successes = successes + 1
            end
            currentCount = currentCount - 1
            i = i + 1
    end
    return successes
END METHOD
</pre>

<p><a id=Poisson_Distribution></a></p>

<h2>Poisson Distribution</h2>

<p>The following method generates a random integer that follows a Poisson distribution. The integer is such that the average of the random integers approaches the given mean number when this method is called repeatedly with the same mean.  Note that the mean can also be a non-integer number. Usually, the <code>mean</code> is the average number of independent events of a certain kind per fixed span of time or space (for example, per day, hour, or square kilometer).  The method given here is based on Knuth&#39;s method from 1969.</p>

<pre>METHOD Poisson(mean)
    if mean &lt; 0: return error
    pn = exp(-mean)
    p = 1.0
    count = 0
    loop
        count = count + 1
        p = p * RNDU()
        if p &lt;= pn
                return count - 1
        end
    end
END METHOD
</pre>

<p><a id=Gamma_Distribution></a></p>

<h2>Gamma Distribution</h2>

<p>The following method generates a random number that follows a gamma distribution.
The gamma distribution models expected lifetimes. The method given here is based on Marsaglia and Tsang&#39;s method from 2000.</p>

<pre>METHOD GammaDist(meanLifetime)
    // Must be greater than 0
    if meanLifetime &lt;= 0: return error
    d = meanLifetime
    v = 0
    if meanLifetime &lt; 1: d = d + 1
    d = d - (1/3) // NOTE: 1/3 must be a fractional number
    c = 1 / sqrt(9 * d)
    loop
        x = 0
        loop
           x = Normal(0, 1)
           v = c * x + 1;
           v = v * v * v
           if v &gt; 0: break
        end
        u = 1.0 - RNDU()
        x2 = x * x
        if u &lt; 1 - (0.0331 * x2 * x2): break
        if ln(u) &lt; (0.5 * x2) + (d * (1 - v + ln(v))): break
    end
    if meanLifetime &lt; 1
       return d * v * exp(ln(1.0 - RNDU()) / meanLifetime)
    end
    return d * v
end
</pre>

<p>The two-parameter gamma distribution (<code>GammaDist2(a, b)</code>), where <code>b</code> is the scale, is simply <code>GammaDist(a) * b</code>.  Here, <code>a</code> can be seen as the mean lifetime in unspecified units of time, and <code>b</code> indicates the size of each unit of time.</p>

<p><a id=Negative_Binomial_Distribution></a></p>

<h2>Negative Binomial Distribution</h2>

<p>The following method generates a random integer that follows a negative binomial distribution.  This number expresses the number of failures that have happened after seeing a given number of successes (expressed as <code>successes</code> below), where the probability of a success in each case is <code>p</code> (which can be greater than 0, never, and equal to or less than 1, always, and which can be 0.5, meaning an equal chance of success or failure).</p>

<p><strong>Example:</strong> If <code>p</code> is 0.5 and <code>successes</code> is 1, the negative binomial distribution models the task &quot;Flip a coin until you get tails, then count the number of heads.&quot;</p>

<p>The following implementation of the negative binomial distribution allows <code>successes</code> to be an integer or a non-integer.</p>

<pre>METHOD NegativeBinomial(successes, p)
    // Must be 0 or greater
    if successes &lt; 0: return error
// No failures if no successes or if always succeeds
    if successes == 0 or p &gt;= 1.0: return 0
    // Always fails (NOTE: infinity can be the maximum possible
    // integer value if NegativeBinomial is implemented to return
    // an integer)
    if p &lt;= 0.0: return infinity
    // NOTE: `successes` must be greater than 0,
    // but can be a non-integer
    return Poisson(GammaDist(successes) * (1 - p) / p)
END METHOD
</pre>

<p>The following implementation of the negative binomial distribution allows <code>successes</code> to be an integer only.</p>

<pre>METHOD NegativeBinomialInt(successes, p)
    // Must be 0 or greater
    if successes &lt; 0: return error
// No failures if no successes or if always succeeds
    if successes == 0 or p &gt;= 1.0: return 0
    // Always fails (NOTE: infinity can be the maximum possible
    // integer value if NegativeBinomialInt is implemented to return
    // an integer)
    if p &lt;= 0.0: return infinity
    count = 0
    total = 0
    loop
        if RNDU() &lt; p
            // Success
            total = total + 1
            if total &gt;= successes
                    return count
            end
        else
            // Failure
            count = count + 1
        end
    end
END METHOD
</pre>

<p><a id=Other_Non_Uniform_Distributions></a></p>

<h2>Other Non-Uniform Distributions</h2>

<ul>
<li><strong>Beta distribution</strong>: <code>x / (x + GammaDist(b))</code>, where <code>x</code> is <code>GammaDist(a)</code> and <code>a</code> and <code>b</code> are
the two parameters of the beta distribution.</li>
<li><strong>Beta binomial distribution</strong>: <code>Binomial(trials, x / (x + GammaDist(b)))</code>, where <code>x</code> is <code>GammaDist(a)</code>, <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>trials</code> is a parameter of the binomial distribution.</li>
<li><strong>Cauchy distribution</strong>: <code>scale * tan(pi * (RNDU()-0.5)) + mu</code>, where <code>mu</code> and <code>scale</code>
are the two parameters of the Cauchy distribution.</li>
<li><strong>Chi-squared distribution</strong>: <code>GammaDist(df * 0.5) * 2</code>, where <code>df</code> is the number of degrees of
freedom.</li>
<li><strong>Exponential distribution</strong>: <code>-ln(1.0 - RNDU()) / lambda</code>, where <code>lambda</code> is the inverse scale. The <code>lambda</code> is usually the probability that an independent event of a given kind will occur in a given span of time (such as in a given day or year).  <code>1/lambda</code> is the scale (mean), which is usually the average waiting time between two independent events of the same kind.</li>
<li><strong>Geometric distribution</strong>: <code>NegativeBinomialInt(1, p)</code>, where <code>p</code> has the same meaning
as in the negative binomial distribution.</li>
<li><strong>Inverse gamma distribution</strong>: <code>b / GammaDist(a)</code>, where <code>a</code> and <code>b</code> have the
same meaning as in the two-parameter gamma distribution.</li>
<li><strong>Laplace (double exponential) distribution</strong>: <code>(ln(1.0 - RNDU())-ln(1.0 - RNDU()))*beta+mu</code>, where <code>beta</code> is the scale and <code>mu</code> is the mean.</li>
<li><strong>Logarithmic normal distribution</strong>: <code>exp(Normal(mu, sigma))</code>, where <code>mu</code> and <code>sigma</code>
have the same meaning as in the normal distribution.</li>
<li><strong>Pascal distribution:</strong> <code>NegativeBinomialInt(successes, p) + successes</code>, where <code>successes</code> and <code>p</code> have the same meaning as in the negative binomial distribution.</li>
<li><strong>Rayleigh distribution</strong>: <code>sqrt(-ln(1.0 - RNDU())*2*a*a)</code>, where <code>a</code> is the scale and is greater than 0.</li>
<li><strong>Snedecor&#39;s <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5) * n / (GammaDist(n * 0.5) * m)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random numbers with a chi-squared distribution.</li>
<li><strong>Student&#39;s <em>t</em>-distribution</strong>: <code>Normal(0, 1) / sqrt(GammaDist(df * 0.5) * 2 / df)</code>, where <code>df</code> is the number of degrees of freedom.</li>
<li><strong>Triangular distribution</strong>: <code>ContinuousWeightedChoice([startpt, midpt, endpt], [0, 1, 0])</code>. The distribution starts at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>.</li>
<li><strong>Weibull distribution</strong>: <code>b * pow(-ln(1.0 - RNDU()),1/a)</code>, where <code>a</code> is the shape, <code>b</code> is the scale, and <code>a</code> and <code>b</code> are greater than 0.</li>
</ul>

<p><a id=Conclusion></a></p>

<h2>Conclusion</h2>

<p>This page discussed many ways applications can extract random numbers
from random number generators.</p>

<p>Feel free to send comments. They may help improve this page.  In particular, corrections to any method given on this page are welcome.</p>

<p>I acknowledge the commenters to the CodeProject version of this page, including George Swan, who referred me to the reservoir sampling method.</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>This page is licensed under <a href="http://creativecommons.org/licenses/publicdomain/">A Public Domain dedication</a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
