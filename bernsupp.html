<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Supplemental Notes for Bernoulli Factory Algorithms</title><meta name="citation_title" content="Supplemental Notes for Bernoulli Factory Algorithms"><meta name="citation_pdf_url" content="https://peteroupc.github.io/bernsupp.pdf"><meta name="citation_url" content="https://peteroupc.github.io/bernsupp.html"><meta name="citation_date" content="2021/12/16"><meta name="citation_online_date" content="2021/12/16"><meta name="og:title" content="Supplemental Notes for Bernoulli Factory Algorithms"><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/bernsupp.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Supplemental Notes for Bernoulli Factory Algorithms"><meta name="author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Supplemental Notes for Bernoulli Factory Algorithms</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#General_Factory_Functions"><strong>General Factory Functions</strong></a>

<ul>
<li><a href="#Approximation_Schemes"><strong>Approximation Schemes</strong></a></li>
<li><a href="#Schemes_That_Don_t_Work"><strong>Schemes That Don&#39;t Work</strong></a></li>
</ul></li>
<li><a href="#Approximate_Bernoulli_Factories"><strong>Approximate Bernoulli Factories</strong></a></li>
<li><a href="#Achievable_Simulation_Rates"><strong>Achievable Simulation Rates</strong></a></li>
<li><a href="#Complexity"><strong>Complexity</strong></a></li>
<li><a href="#Examples_of_Bernoulli_Factory_Approximation_Schemes"><strong>Examples of Bernoulli Factory Approximation Schemes</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Which_functions_admit_a_Bernoulli_factory"><strong>Which functions admit a Bernoulli factory?</strong></a></li>
<li><a href="#Which_functions_don_t_require_outside_randomness_to_simulate"><strong>Which functions don&#39;t require outside randomness to simulate?</strong></a></li>
<li><a href="#Multiple_Output_Bernoulli_Factory"><strong>Multiple-Output Bernoulli Factory</strong></a></li>
<li><a href="#Proofs_for_Function_Approximation_Schemes"><strong>Proofs for Function Approximation Schemes</strong></a></li>
<li><a href="#Example_of_Approximation_Scheme"><strong>Example of Approximation Scheme</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=General_Factory_Functions></a></p>

<h2>General Factory Functions</h2>

<p>As a reminder, the <em>Bernoulli factory problem</em> is: We&#39;re given a coin that shows heads with an unknown probability, <em>&lambda;</em>, and the goal is to use that coin (and possibly also a fair coin) to build a &quot;new&quot; coin that shows heads with a probability that depends on <em>&lambda;</em>, call it <em>f</em>(<em>&lambda;</em>).</p>

<p>The algorithms for <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory functions</strong></a>, described in my main article on Bernoulli factory algorithms, work by building randomized upper and lower bounds for a function <em>f</em>(<em>&lambda;</em>), based on flips of the input coin.  Roughly speaking, the algorithms work as follows:</p>

<ol>
<li>Generate a uniform(0, 1) random variate, <em>U</em>.</li>
<li>Flip the input coin, then build an upper and lower bound for <em>f</em>(<em>&lambda;</em>), based on the outcomes of the flips so far.</li>
<li>If <em>U</em> is less than or equal to the lower bound, return 1. If <em>U</em> is greater than the upper bound, return 0.  Otherwise, go to step 2.</li>
</ol>

<p>These randomized upper and lower bounds come from two sequences of polynomials as follows:</p>

<ol>
<li>One sequence approaches the function <em>f</em>(<em>&lambda;</em>) from above, the other from below, and both sequences must converge to <em>f</em>.</li>
<li>For each sequence, the first polynomial has degree 1 (so is a linear function), and each other polynomial&#39;s degree is 1 higher than the previous.</li>
<li><p>The <em>consistency requirement</em> must be met: The difference&mdash;</p>

<ul>
<li>between the degree-(<em>n</em>&minus;1) upper polynomial and the degree-<em>n</em> upper polynomial, and</li>
<li>between the degree-<em>n</em> lower polynomial and the degree-(<em>n</em>&minus;1) lower polynomial,</li>
</ul>

<p>must have non-negative coefficients, once the polynomials are rewritten in Bernstein form and elevated to degree <em>n</em>.</p></li>
</ol>

<p>The consistency requirement ensures that the upper polynomials &quot;decrease&quot; and the lower polynomials &quot;increase&quot;.  Unfortunately, the reverse is not true in general; even if the upper polynomials &quot;decrease&quot; and the lower polynomials &quot;increase&quot; to <em>f</em>, this does not mean that the scheme will ensure consistency.  Examples of this fact are shown in the section &quot;<a href="#Schemes_That_Don_t_Work"><strong>Schemes That Don&#39;t Work</strong></a>&quot; later in this document.</p>

<p>In this document, <strong>fbelow</strong>(<em>n</em>, <em>k</em>) and <strong>fabove</strong>(<em>n</em>, <em>k</em>) mean the <em>k</em><sup>th</sup> coefficient for the lower or upper degree-<em>n</em> polynomial in Bernstein form, respectively, where <em>k</em> is an integer in the interval [0, <em>n</em>].</p>

<p><a id=Approximation_Schemes></a></p>

<h3>Approximation Schemes</h3>

<p>A <em>factory function</em> <em>f</em>(<em>&lambda;</em>) is a function for which the Bernoulli factory problem can be solved (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#About_Bernoulli_Factories"><strong>About Bernoulli Factories</strong></a>&quot;). The following are approximation schemes for <em>f</em> if it belongs to one of certain classes of factory functions.  It would be helpful to plot the desired function <em>f</em> using a computer algebra system to see if it belongs to any of the classes of functions described below.</p>

<p><strong>Concave functions.</strong> If <em>f</em> is known to be <em>concave</em> in the interval [0, 1] (which roughly means that its rate of growth there never goes up), then <strong>fbelow</strong>(<em>n</em>, <em>k</em>) can equal <em>f</em>(<em>k</em>/<em>n</em>), thanks to Jensen&#39;s inequality.</p>

<p><strong>Convex functions.</strong> If <em>f</em> is known to be <em>convex</em> in the interval [0, 1] (which roughly means that its rate of growth there never goes down), then <strong>fabove</strong>(<em>n</em>, <em>k</em>) can equal <em>f</em>(<em>k</em>/<em>n</em>), thanks to Jensen&#39;s inequality.  One example is <em>f</em>(<em>&lambda;</em>) = exp(&minus;<em>&lambda;</em>/4).</p>

<p><strong>Twice differentiable functions.</strong> The following method, proved in the appendix, implements <strong>fabove</strong> and <strong>fbelow</strong> if <em>f</em>(<em>&lambda;</em>)&mdash;</p>

<ul>
<li>has a defined &quot;slope-of-slope&quot; everywhere in [0, 1] (that is, the function is <em>twice differentiable</em> there), and</li>
<li>in the interval [0, 1]&mdash;

<ul>
<li>has a minimum of greater than 0 and a maximum of less than 1, or</li>
<li>is convex and has a minimum of greater than 0, or</li>
<li>is concave and has a maximum of less than 1.</li>
</ul></li>
</ul>

<p>Let <em>m</em> be an upper bound of the highest value of abs(<em>f&prime;&prime;</em>(<em>x</em>)) for any <em>x</em> in [0, 1], where <em>f&prime;&prime;</em> is the &quot;slope-of-slope&quot; function of <em>f</em>.  Then for every integer <em>n</em> that&#39;s a power of 2:</p>

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is concave; otherwise, min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), ..., <strong>fbelow</strong>(4,4)) if <em>n</em> &lt; 4; otherwise,  <em>f</em>(<em>k</em>/<em>n</em>) &minus; <em>m</em>/(7*<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is convex; otherwise, max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), ..., <strong>fabove</strong>(4,4)) if <em>n</em> &lt; 4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + <em>m</em>/(7*<em>n</em>).</li>
</ul>

<p>My <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/approxscheme.py"><strong>GitHub repository</strong></a> includes SymPy code for a method, <code>c2params</code>, to calculate the necessary values for <em>m</em> and the bounds of these polynomials, given <em>f</em>.</p>

<blockquote>
<p><strong>Note:</strong> For this method, the &quot;slope-of-slope&quot; function need not be continuous (Y. Peres, pers. comm., 2021).</p>

<p><strong>Example:</strong> Take <em>f</em>(<em>&lambda;</em>) = exp(&minus;<em>&lambda;</em>).  This is a convex and twice differentiable function, and bounded below by 3321/10000.  Then it can be shown that the following scheme for <em>f</em> is valid:</p>

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 3321/10000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1/(7*n). (Observe that <em>f</em>(<em>k</em>/4) &minus; 1/(7*4) &ge; 3321/10000.)</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) (because <em>f</em> is convex).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul>
</blockquote>

<p><strong>Hölder and Lipschitz continuous functions.</strong> I have found a way to extend the results of Nacu and Peres (2005)[^1] to certain functions with a slope that tends to a vertical slope.  The following scheme, proved in the appendix, implements <strong>fabove</strong> and <strong>fbelow</strong> if <em>f</em>(<em>&lambda;</em>)&mdash;</p>

<ul>
<li>is <em>&alpha;</em>-<a href="https://en.wikipedia.org/wiki/H%C3%B6lder_condition"><strong><em>Hölder continuous</em></strong></a> on [0, 1], meaning its vertical slopes there, if any, are no &quot;steeper&quot; than that of <em>m</em>*<em>&lambda;</em><sup><em>&alpha;</em></sup>, for some number <em>m</em> greater than 0 (the Hölder constant) and for some <em>&alpha;</em> in the interval (0, 1], and</li>
<li>in the interval [0, 1]&mdash;

<ul>
<li>has a minimum of greater than 0 and a maximum of less than 1, or</li>
<li>is convex and has a minimum of greater than 0, or</li>
<li>is concave and has a maximum of less than 1.</li>
</ul></li>
</ul>

<p>If <em>f</em> in [0, 1] has a defined slope at all points or &quot;almost everywhere&quot;[^2], and does not tend to a vertical slope anywhere, then <em>f</em> is <a href="https://en.wikipedia.org/wiki/Lipschitz_continuity"><strong><em>Lipschitz continuous</em></strong></a>, <em>&alpha;</em> is 1, and <em>m</em> is the highest absolute value of the function&#39;s &quot;slope&quot;.  Otherwise, finding <em>m</em> for a given <em>&alpha;</em> is non-trivial and it requires knowing where <em>f</em>&#39;s vertical slopes are, among other things.[^3]  But assuming <em>m</em> and <em>&alpha;</em> are known, then for every integer <em>n</em> that&#39;s a power of 2:</p>

<ul>
<li><em>D</em>(<em>n</em>) = <em>m</em>*(2/7)<sup><em>&alpha;</em>/2</sup>/((2<sup><em>&alpha;</em>/2</sup>&minus;1)*<em>n</em><sup><em>&alpha;</em>/2</sup>).</li>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is concave; otherwise, min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), ..., <strong>fbelow</strong>(4,4)) if <em>n</em> &lt; 4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; <em>D</em>(<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is convex; otherwise, max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), ..., <strong>fabove</strong>(4,4)) if <em>n</em> &lt; 4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + <em>D</em>(<em>n</em>).</li>
</ul>

<blockquote>
<p><strong>Note:</strong></p>

<ol>
<li>Some functions <em>f</em> are not <em>&alpha;</em>-Hölder continuous for any <em>&alpha;</em> greater than 0.  These functions have a slope that&#39;s steeper than every &quot;nth&quot; root, and can&#39;t be handled by this method.  One example is <em>f</em>(<em>&lambda;</em>) = 1/10 if <em>&lambda;</em> is 0 and &minus;1/(2*ln(<em>&lambda;</em>/2)) + 1/10 otherwise, which has a slope near 0 that&#39;s steeper than every &quot;nth&quot; root.</li>
<li>In the Lipschitz case (<em>&alpha;</em> = 1), <em>D</em>(<em>n</em>) can be <em>m</em>*322613/(250000*sqrt(<em>n</em>)), which is an upper bound.</li>
<li>In the case <em>&alpha;</em> = 1/2, <em>D</em>(<em>n</em>) can be <em>m</em>*154563/(40000*<em>n</em><sup>1/4</sup>), which is an upper bound.</li>
</ol>
</blockquote>

<p><strong>Certain functions that equal 0 at 0.</strong> This approach involves transforming the function <em>f</em> so that it no longer equals 0 at the point 0.  This can be done by dividing <em>f</em> by a function (<em>h</em>(<em>&lambda;</em>)) that &quot;dominates&quot; <em>f</em> at every point in the interval [0, 1].  Unlike for the original function, there might be an approximation scheme described earlier in this section for the transformed function.</p>

<p>More specifically, <em>h</em>(<em>&lambda;</em>) must meet the following requirements:</p>

<ul>
<li><em>h</em>(<em>&lambda;</em>) is continuous on the closed interval [0, 1].</li>
<li><em>h</em>(0) = 0. (This is required to ensure correctness in case <em>&lambda;</em> is 0.)</li>
<li>1 &ge; <em>h</em>(1) &ge; <em>f</em>(1) &ge; 0.</li>
<li>1 &gt; <em>h</em>(<em>&lambda;</em>) &gt; <em>f</em>(<em>&lambda;</em>) &gt; 0 for every <em>&lambda;</em> in the open interval (0, 1).</li>
<li>If <em>f</em>(1) = 0, then <em>h</em>(1) = 0. (This is required to ensure correctness in case <em>&lambda;</em> is 1.)</li>
</ul>

<p>Also, <em>h</em> should be a function with a simple Bernoulli factory algorithm.  For example, <em>h</em> can be a polynomial in Bernstein form of degree <em>n</em> whose <em>n</em> plus one coefficients are [0, 1, 1, ..., 1].  This polynomial is easy to simulate using the algorithms from the section &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Polynomials"><strong>Certain Polynomials</strong></a>&quot;.</p>

<p>The algorithm is now described.</p>

<p>Let <em>g</em>(<em>&lambda;</em>) = lim<sub><em>&nu;</em>&rarr;<em>&lambda;</em></sub> <em>f</em>(<em>&nu;</em>)/<em>h</em>(<em>&nu;</em>) (in other words, the value that <em>f</em>(<em>&nu;</em>)/<em>h</em>(<em>&nu;</em>) approaches as <em>&nu;</em> approaches <em>&lambda;</em>.) If&mdash;</p>

<ul>
<li><em>f</em>(0) = 0 and <em>f</em>(1) &lt; 1, and</li>
<li><em>g</em>(<em>&lambda;</em>) is continuous on [0, 1] and belongs in one of the classes of functions given earlier,</li>
</ul>

<p>then <em>f</em> can be simulated using the following algorithm:</p>

<ol>
<li>Run a Bernoulli factory algorithm for <em>h</em>.  If the call returns 0, return 0. (For example, if <em>h</em>(<em>&lambda;</em>) = <em>&lambda;</em>, then this step amounts to the following: &quot;Flip the input coin.  If it returns 0, return 0.&quot;)</li>
<li>Run a Bernoulli factory algorithm for <em>g</em>(.) and return the result of that algorithm.  This can be one of the <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory function algorithms</strong></a> if there is a way to calculate polynomials that converge to <em>g</em>(.) in a manner needed for that algorithm (for example, if <em>g</em> is described earlier in this section).</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>It may happen that <em>g</em>(0) = 0.  In this case, step 2 of this algorithm can involve running this algorithm again, but with new <em>g</em> and <em>h</em> functions that are found based on the current <em>g</em> function.  See the second example below.</li>
<li><p>If&mdash;</p>

<ul>
<li><em>f</em> is monotonically increasing,</li>
<li><em>h</em>(<em>&lambda;</em>) = <em>&lambda;</em>, and</li>
<li><em>f&prime;</em>(<em>&lambda;</em>), the &quot;slope&quot; function of <em>f</em>, is continuous on [0, 1], maps (0, 1) to (0, 1), and belongs in one of the classes of functions given earlier,</li>
</ul>

<p>then step 2 can be implemented by taking <em>g</em> as <em>f&prime;</em>, except: (A) a uniform(0, 1) random variate <em>u</em> is generated at the start of the step; (B) instead of flipping the input coin as normal during that step, a different coin is flipped that does the following: &quot;Flip the input coin, then <a href="https://peteroupc.github.io/bernoulli.html#Algorithms"><strong>sample from the number <em>u</em></strong></a>. Return 1 if both the call and the flip return 1, and return 0 otherwise.&quot;<br/>This is the &quot;<strong>integral method</strong>&quot; of Flajolet et al. (2010)[^4] (the modified step 2 simulates 1/<em>&lambda;</em> times the <em>integral</em> of <em>f</em>.).</p></li>
</ol>

<p><strong>Examples:</strong></p>

<ol>
<li>If <em>f</em>(<em>&lambda;</em>) = (sinh(<em>&lambda;</em>)+cosh(<em>&lambda;</em>)&minus;1)/4, then <em>f</em> is bounded from above by <em>h</em>(<em>&lambda;</em>) = <em>&lambda;</em>, so <em>g</em>(<em>&lambda;</em>) is 1/4 if <em>&lambda;</em> = 0, and (exp(<em>&lambda;</em>) &minus; 1)/(4*<em>&lambda;</em>) otherwise.  The following SymPy code computes this example: <code>fx = (sinh(x)+cosh(x)-1)/4; h = x; pprint(Piecewise((limit(fx/h,x,0), Eq(x,0)), ((fx/h).simplify(), True)))</code>.</li>
<li><p>If <em>f</em>(<em>&lambda;</em>) = cosh(<em>&lambda;</em>) &minus; 1, then <em>f</em> is bounded from above by <em>h</em>(<em>&lambda;</em>) = <em>&lambda;</em>, so <em>g</em>(<em>&lambda;</em>) is 0 if <em>&lambda;</em> = 0, and (cosh(<em>&lambda;</em>)&minus;1)/<em>&lambda;</em> otherwise.  Since <em>g</em>(0) = 0, we find new functions <em>g</em> and <em>h</em> based on the current <em>g</em>.  The current <em>g</em> is bounded from above by <em>H</em>(<em>&lambda;</em>) = <em>&lambda;</em>*3*(2&minus;<em>&lambda;</em>)/5 (a degree-2 polynomial that in Bernstein form has coefficients [0, 6/10, 6/10]), so <em>G</em>(<em>&lambda;</em>) = 5/12 if <em>&lambda;</em> = 0, and &minus;(5*cosh(<em>&lambda;</em>) &minus; 5)/(3*<em>&lambda;</em><sup>2</sup>*(<em>&lambda;</em>&minus;2)) otherwise. <em>G</em> is bounded away from 0 and 1, so we have the following algorithm:</p>

<ol>
<li>(Simulate <em>h</em>.) Flip the input coin.  If it returns 0, return 0.</li>
<li>(Simulate <em>H</em>.) Flip the input coin twice.  If both flips return 0, return 0.  Otherwise, with probability 4/10 (that is, 1 minus 6/10), return 0.</li>
<li>Run a Bernoulli factory algorithm for <em>G</em> (which might involve building polynomials that converge to <em>G</em>, noticing that <em>G</em> is twice differentiable) and return the result of that algorithm.</li>
</ol></li>
</ol>
</blockquote>

<p><strong>Certain functions that equal 0 at 0 and 1 at 1.</strong>  Let <em>f</em>, <em>g</em>, and <em>h</em> be functions as defined earlier, except that <em>f</em>(0) = 0 and <em>f</em>(1) = 1.  Define the following additional functions:</p>

<ul>
<li><em>&omega;</em>(<em>&lambda;</em>) is a function that meets the following requirements:

<ul>
<li><em>&omega;</em>(<em>&lambda;</em>) is continuous on the closed interval [0, 1].</li>
<li><em>&omega;</em>(0) = 0 and <em>&omega;</em>(1) = 1.</li>
<li>1 &gt; <em>f</em>(<em>&lambda;</em>) &gt; <em>&omega;</em>(<em>&lambda;</em>) &gt; 0 for every <em>&lambda;</em> in the open interval (0, 1).</li>
</ul></li>
<li><em>q</em>(<em>&lambda;</em>) = lim<sub><em>&nu;</em>&rarr;<em>&lambda;</em></sub> <em>&omega;</em>(<em>&nu;</em>)/<em>h</em>(<em>&nu;</em>).</li>
<li><em>r</em>(<em>&lambda;</em>) = lim<sub><em>&nu;</em>&rarr;<em>&lambda;</em></sub> (1&minus;<em>g</em>(<em>&nu;</em>))/(1&minus;<em>q</em>(<em>&nu;</em>)).</li>
</ul>

<p>Roughly speaking, <em>&omega;</em> is a function that bounds <em>f</em> from below, just as <em>h</em> bounds <em>f</em> from above. <em>&omega;</em> should be a function with a simple Bernoulli factory algorithm, such as a polynomial in Bernstein form.  If both <em>&omega;</em> and <em>h</em> are polynomials of the same degree, <em>q</em> will be a rational function with a relatively simple Bernoulli factory algorithm (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Rational_Functions"><strong>Certain Rational Functions</strong></a>&quot;).</p>

<p>Now, if <em>r</em>(<em>&lambda;</em>) is continuous on [0, 1], then <em>f</em> can be simulated using the following algorithm:</p>

<ol>
<li>Run a Bernoulli factory algorithm for <em>h</em>.  If the call returns 0, return 0. (For example, if <em>h</em>(<em>&lambda;</em>) = <em>&lambda;</em>, then this step amounts to the following: &quot;Flip the input coin.  If it returns 0, return 0.&quot;)</li>
<li>Run a Bernoulli factory algorithm for <em>q</em>(.).  If the call returns 1, return 1.</li>
<li>Run a Bernoulli factory algorithm for <em>r</em>(.), and return 1 minus the result of that call.  The Bernoulli factory algorithm can be one of the <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory function algorithms</strong></a> if there is a way to calculate polynomials that converge to <em>r</em>(.) in a manner needed for that algorithm (for example, if <em>r</em> is described earlier in this section).</li>
</ol>

<blockquote>
<p><strong>Note:</strong> Quick proof: Rewrite $f=h\dot{}(q\dot{}1+(1-q)\dot{}(1-r))+(1-h)\dot{}0$.</p>

<p><strong>Example:</strong> If <em>f</em>(<em>&lambda;</em>) = (1&minus;exp(<em>&lambda;</em>))/(1&minus;exp(1)), then <em>f</em> is bounded from above by <em>h</em>(<em>&lambda;</em>) = <em>&lambda;</em>, and from below by <em>&omega;</em>(<em>&lambda;</em>) = <em>&lambda;</em><sup>2</sup>.  As a result, <em>q</em>(<em>&lambda;</em>) = <em>&lambda;</em>, and <em>r</em>(<em>&lambda;</em>) = (2 &minus; exp(1))/(1 &minus; exp(1)) if <em>&lambda;</em> = 0; 1/(exp(1)&minus;1) if <em>&lambda;</em> = 1; and (&minus;<em>&lambda;</em>*(1 &minus; exp(1)) &minus; exp(<em>&lambda;</em>) + 1)/(<em>&lambda;</em>*(1 &minus; exp(1))*(<em>&lambda;</em> &minus; 1)) otherwise.  This can be computed using the following SymPy code: <code>fx=(1-exp(x))/(1-exp(1)); h=x; omega=x**2; q=(omega/h); r=(1-fx/h)/(1-q); r=Piecewise((limit(r, x, 0), Eq(x,0)), (limit(r,x,1),Eq(x,1)), (r,True)).simplify(); pprint(r)</code>.</p>
</blockquote>

<p><strong>Other functions that equal 0 or 1 at the endpoints 0 and/or 1.</strong> If <em>f</em> does not fully admit an approximation scheme under the convex, concave, twice differentiable, and Hölder classes:</p>

<table><thead>
<tr>
<th>If <em>f</em>(0) =</th>
<th>And <em>f</em>(1) =</th>
<th>Method</th>
</tr>
</thead><tbody>
<tr>
<td>&gt; 0 and &lt; 1</td>
<td>1</td>
<td>Use the algorithm for <strong>certain functions that equal 0 at 0</strong>, but with <em>f</em>(<em>&lambda;</em>) = 1 &minus; <em>f</em>(1&minus;<em>&lambda;</em>).<br/><em>Inverted coin</em>: Instead of the usual input coin, use a coin that does the following: &quot;Flip the input coin and return 1 minus the result.&quot;<br/><em>Inverted result:</em> If the overall algorithm would return 0, it returns 1 instead, and vice versa.</td>
</tr>
<tr>
<td>&gt; 0 and &lt; 1</td>
<td>0</td>
<td>Algorithm for <strong>certain functions that equal 0 at 0</strong>, but with <em>f</em>(<em>&lambda;</em>) = <em>f</em>(1&minus;<em>&lambda;</em>).  (For example, cosh(<em>&lambda;</em>)&minus;1 becomes cosh(1&minus;<em>&lambda;</em>)&minus;1.)<br/>Inverted coin.</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Algorithm for <strong>certain functions that equal 0 at 0 and 1 at 1</strong>, but with <em>f</em>(<em>&lambda;</em>) = 1&minus;<em>f</em>(<em>&lambda;</em>).<br/>Inverted result.</td>
</tr>
<tr>
<td>1</td>
<td>&gt; 0 and &le; 1</td>
<td>Algorithm for <strong>certain functions that equal 0 at 0</strong>, but with <em>f</em>(<em>&lambda;</em>) = 1&minus;<em>f</em>(<em>&lambda;</em>).<br/>Inverted result.</td>
</tr>
</tbody></table>

<p><strong>Specific functions.</strong> My <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/approxscheme.py"><strong>GitHub repository</strong></a> includes SymPy code for a method, <code>approxscheme2</code>, to build a polynomial approximation scheme for certain factory functions.</p>

<p><a id=Schemes_That_Don_t_Work></a></p>

<h3>Schemes That Don&#39;t Work</h3>

<p>In the academic literature (papers and books), there are many approximation methods that involve polynomials that converge from above and below to a function.  Unfortunately, most of them cannot be used as is to simulate a function <em>f</em> in the Bernoulli Factory setting, because they don&#39;t ensure the consistency requirement described earlier.</p>

<p>The following are approximation schemes with counterexamples to consistency.</p>

<p><strong>First scheme.</strong> In this scheme (Powell 1981)[^5], let <em>f</em> be a C<sup>2</sup> continuous function (a function with continuous &quot;slope&quot; and &quot;slope-of-slope&quot; functions) in [0, 1].  Then for every <em>n</em>&ge;1:</p>

<ul>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + <em>M</em> / (8*<em>n</em>).</li>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; <em>M</em> / (8*<em>n</em>).</li>
</ul>

<p>Where <em>M</em> is not less than the maximum absolute value of <em>f</em>&#39;s slope-of-slope function (second derivative), and where <em>k</em> is an integer in the interval [0, <em>n</em>].</p>

<p>The counterexample involves the C<sup>2</sup> continuous function <em>g</em>(<em>&lambda;</em>) = sin(<em>&pi;</em>*<em>&lambda;</em>)/4 + 1/2.</p>

<p>For <em>g</em>, the coefficients for&mdash;</p>

<ul>
<li>the degree-2 upper polynomial in Bernstein form (<strong>fabove</strong>(5, <em>k</em>)) are [0.6542..., 0.9042..., 0.6542...], and</li>
<li>the degree-4 upper polynomial in Bernstein form (<strong>fabove</strong>(6, <em>k</em>)) are [0.5771..., 0.7538..., 0.8271..., 0.7538..., 0.5771...].</li>
</ul>

<p>The degree-2 polynomial lies above the degree-4 polynomial everywhere in [0, 1].  However, to ensure consistency, the degree-2 polynomial, once elevated to degree 4 and rewritten in Bernstein form, must have coefficients that are greater than or equal to those of the degree-4 polynomial.</p>

<ul>
<li>Once elevated to degree 4, the degree-2 polynomial&#39;s coefficients are [0.6542..., 0.7792..., 0.8208..., 0.7792..., 0.6542...].</li>
</ul>

<p>As we can see, the elevated polynomial&#39;s coefficient 0.8208... is less than the corresponding coefficient 0.8271... for the degree-4 polynomial.</p>

<p><em>The rest of this section will note counterexamples involving other functions and schemes, without demonstrating them in detail.</em></p>

<p><strong>Second scheme.</strong> In this scheme, let <em>f</em> be a Lipschitz continuous function in [0, 1] (that is, a continuous function in [0, 1] that has a defined slope at all points or &quot;almost everywhere&quot;, and does not tend to a vertical slope anywhere).  Then for every <em>n</em>&ge;2:</p>

<ul>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + <em>L</em>*(5/4) / sqrt(<em>n</em>).</li>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus;  <em>L</em>*(5/4) / sqrt(<em>n</em>).</li>
</ul>

<p>Where L is the maximum absolute &quot;slope&quot;, also known as the Lipschitz constant, and (5/4) is the so-called Popoviciu constant, and where <em>k</em> is an integer in the interval [0, <em>n</em>] (Lorentz 1986)[^6], (Popoviciu 1935)[^7].</p>

<p>There are two counterexamples here; together they show that this scheme can fail to ensure consistency, even if the set of functions is restricted to &quot;smooth&quot; functions (not just Lipschitz continuous functions):</p>

<ol>
<li>The function <em>f</em>(<em>&lambda;</em>) = min(<em>&lambda;</em>, 1&minus;<em>&lambda;</em>)/2 is Lipschitz continuous with Lipschitz constant 1/2.  (In addition, <em>f</em> has a kink at 1/2, so that it&#39;s not differentiable, but this is not essential for the counterexample.)  The counterexample involves the degree-5 and degree-6 upper polynomials (<strong>fabove</strong>(5, <em>k</em>) and <strong>fabove</strong>(6, <em>k</em>)).</li>
<li>The function <em>f</em> = sin(4*<em>&pi;</em>*<em>&lambda;</em>)/4 + 1/2, a &quot;smooth&quot; function with Lipschitz constant <em>&pi;</em>.  The counterexample involves the degree-3 and degree-4 lower polynomials (<strong>fbelow</strong>(3, <em>k</em>) and <strong>fbelow</strong>(4, <em>k</em>)).</li>
</ol>

<p>It is yet to be seen whether a counterexample exists for this scheme when <em>n</em> is restricted to powers of 2.</p>

<p><strong>Third scheme.</strong> Same as the second scheme, but replacing (5/4) with the Sikkema constant, <em>S</em> = (4306+837*sqrt(6))/5832 (Lorentz 1986)[^6], (Sikkema 1961)[^8], which is slightly less than 1.09.   In fact, the same counterexamples for the second scheme apply to this one, since this scheme merely multiplies the offset to bring the approximating polynomials closer to <em>f</em>.</p>

<p><strong>Note on &quot;clamping&quot;.</strong> For any approximation scheme, &quot;clamping&quot; the values of <strong>fbelow</strong> and <strong>fabove</strong> to fit the interval [0, 1] won&#39;t necessarily preserve the consistency requirement, even if the original scheme met that requirement.</p>

<p>Here is a counterexample that applies to any approximation scheme.</p>

<p>Let <em>g</em> and <em>h</em> be two polynomials in Bernstein form as follows:</p>

<ul>
<li><em>g</em> has degree 5 and coefficients [10179/10000, 2653/2500, 9387/10000, 5049/5000, 499/500, 9339/10000].</li>
<li><em>h</em> has degree 6 and coefficients [10083/10000, 593/625, 9633/10000, 4513/5000, 4947/5000, 9473/10000, 4519/5000].</li>
</ul>

<p>After elevating <em>g</em>&#39;s degree, <em>g</em>&#39;s coefficients are no less than <em>h</em>&#39;s, as required by the consistency property.</p>

<p>However, if we clamp coefficients above 1 to equal 1, so that <em>g</em> is now <em>g&prime;</em> with [1, 1, 9387/10000, 1, 499/500, 9339/10000] and <em>h</em> is now <em>h&prime;</em> with [1, 593/625, 9633/10000, 4513/5000, 4947/5000, 9473/10000, 4519/5000], and elevate <em>g&prime;</em> for coefficients [1, 1, 14387/15000, 19387/20000, 1499/1500, 59239/60000, 9339/10000], some of the coefficients of <em>g&prime;</em> are less than those of <em>h&prime;</em>.  Thus, for this pair of polynomials, clamping the coefficients will destroy the consistent approximation property.</p>

<p><a id=Approximate_Bernoulli_Factories></a></p>

<h2>Approximate Bernoulli Factories</h2>

<p>Although the schemes in the previous section don&#39;t work when building a <em>family</em> of polynomials that converge to a function <em>f</em>(<em>&lambda;</em>), they are still useful for building an <em>approximation</em> to that function, in the form of a <em>single</em> polynomial, so that we get an <strong>approximate Bernoulli factory</strong> for <em>f</em>.</p>

<p>Here, <em>f</em>(<em>&lambda;</em>) can be any function that maps the closed interval [0, 1] to [0, 1], even if it isn&#39;t continuous or a factory function (examples include the &quot;step function&quot; 0 if <em>&lambda;</em> &lt; 1/2 and 1 otherwise, or the function 2*min(<em>&lambda;</em>, 1 &minus; <em>&lambda;</em>)).  Continuous functions can be approximated arbitrarily well by an approximate Bernoulli factory (as a result of the so-called &quot;Weierstrass approximation theorem&quot;), but this is not the case in general for discontinuous functions.</p>

<p>To build an approximate Bernoulli factory:</p>

<ol>
<li><p>We first find a polynomial in Bernstein form of degree <em>n</em> that is close to the desired function <em>f</em>.</p>

<p>The simplest choice for this polynomial has <em>n</em>+1 coefficients and its <em>j</em><sup>th</sup> coefficient (starting at 0) is found as <em>f</em>(<em>j</em>/<em>n</em>), and this is used in the examples below.  For this choice, if <em>f</em> is continuous, the polynomial can be brought arbitrarily close to <em>f</em> by choosing <em>n</em> high enough.</p>

<p>Whatever polynomial is used, the polynomial&#39;s coefficients must all lie in [0, 1].</p></li>
<li><p>Then, we use one of the algorithms in the section &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Certain Polynomials</strong></a>&quot; to toss heads with probability equal to that polynomial, given its coefficients.</p></li>
</ol>

<p><strong>Examples of approximate Bernoulli factories.</strong> The schemes in the previous section give an upper bound on the error on approximating <em>f</em> with a degree-<em>n</em> polynomial in Bernstein form.  For example, the third scheme does this when <em>f</em> is a Lipschitz continuous function (with Lipschitz constant <em>L</em>).  To find a degree <em>n</em> such that <em>f</em> is approximated with a maximum error of <em>&epsilon;</em>, we need to solve the following equation for <em>n</em>:</p>

<ul>
<li><em>&epsilon;</em> = <em>L</em>*((4306+837*sqrt(6))/5832) / sqrt(<em>n</em>).</li>
</ul>

<p>This has the following solution:</p>

<ul>
<li><em>n</em> = <em>L</em><sup>2</sup>*(3604122*sqrt(6) + 11372525)/(17006112*<em>&epsilon;</em><sup>2</sup>).</li>
</ul>

<p>This is generally not an integer, so we use <em>n</em> = ceil(<em>n</em>) to get the solution if it&#39;s an integer, or the nearest integer that&#39;s bigger than the solution.  This solution can be simplified further to <em>n</em> = ceil(59393*<em>L</em><sup>2</sup>/(50000*<em>&epsilon;</em><sup>2</sup>)), which bounds the previous solution from above.</p>

<p>Now, if <em>f</em> is a Lipschitz continuous factory function with Lipschitz constant <em>L</em>, the following algorithm (adapted from &quot;Certain Polynomials&quot;) simulates a polynomial that approximates <em>f</em> with a maximum error of <em>&epsilon;</em>:</p>

<ol>
<li>Calculate <em>n</em> as ceil(59393*<em>L</em><sup>2</sup>/(50000*<em>&epsilon;</em><sup>2</sup>)).</li>
<li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</li>
<li>With probability <em>f</em>(<em>j</em>/<em>n</em>), return 1.  Otherwise, return 0. (If <em>f</em>(<em>j</em>/<em>n</em>) can be an irrational number, see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Algorithms_for_General_Irrational_Constants"><strong>Algorithms for General Irrational Constants</strong></a>&quot; for ways to sample this irrational probability exactly.)</li>
</ol>

<p>As another example, we use the first scheme in the previous section to get the following approximate algorithm for C<sup>2</sup> continuous functions with maximum &quot;slope-of-slope&quot; of <em>M</em>:</p>

<ol>
<li>Calculate <em>n</em> as ceil(<em>M</em>/(8*<em>&epsilon;</em>)) (upper bound of the solution to the equation <em>&epsilon;</em> = <em>M</em>/(8*<em>n</em>)).</li>
<li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</li>
<li>With probability <em>f</em>(<em>j</em>/<em>n</em>), return 1.  Otherwise, return 0.</li>
</ol>

<p>We can proceed similarly with other methods that give an upper bound on the Bernstein-form polynomial approximation error, if they apply to the function <em>f</em> that we seek to approximate.</p>

<p><strong>Approximate methods for linear functions.</strong> There are a number of approximate methods to simulate <em>&lambda;</em>*<em>c</em>, where <em>c</em> &gt; 1 and <em>&lambda;</em> lies in [0, 1/<em>c</em>).  (&quot;Approximate&quot; because this function touches 1 at 1/<em>c</em>, so it can&#39;t be a factory function.) Since the methods use only up to <em>n</em> flips, where <em>n</em> is an integer greater than 0, the approximation will be a polynomial of degree <em>n</em>.</p>

<ul>
<li><p>Henderson and Glynn (2003, Remark 4)[^9] approximates the function <em>&lambda;</em>*2 using a polynomial where the <em>j</em><sup>th</sup> coefficient (starting at 0) is min((<em>j</em>/<em>n</em>)*2, 1&minus;1/<em>n</em>).  If <em>g</em>(<em>&lambda;</em>) is that polynomial, then the error in approximating <em>f</em> is no greater than 1&minus;<em>g</em>(1/2).  <em>g</em> can be computed with the SymPy computer algebra library as follows: <code>from sympy.stats import *; g=2*E( Min(sum(Bernoulli((&quot;B%d&quot; % (i)),z) for i in range(n))/n,(S(1)-S(1)/n)/2))</code>.</p></li>
<li><p>I found the following approximation for <em>&lambda;</em>*<em>c</em>[^10]: &quot;(1.) Set <em>j</em> to 0 and <em>i</em> to 0; (2.) If <em>i</em> &ge; <em>n</em>, return 0; (3.) Flip the input coin, and if it returns 1, add 1 to <em>j</em>; (4.) (Estimate the probability and return 1 if it &#39;went over&#39;.) If (<em>j</em>/(<em>i</em>+1)) &ge; 1/<em>c</em>, return 1; (5.) Add 1 to <em>i</em> and go to step 2.&quot;  Here, <em>&lambda;</em>*<em>c</em> is approximated by a polynomial where the <em>j</em><sup>th</sup> coefficient (starting at 0) is min((<em>j</em>/<em>n</em>)*<em>c</em>, 1).  If <em>g</em>(<em>&lambda;</em>) is that polynomial, then the error in approximating <em>f</em> is no greater than 1&minus;<em>g</em>(1/<em>c</em>).</p></li>
<li><p>The previous approximation generalizes the one given in section 6 of Nacu and Peres (2005)[^1], which approximates <em>&lambda;</em>*2.</p></li>
</ul>

<blockquote>
<p><strong>Note:</strong> Bias and variance are the two sources of error in a randomized estimation algorithm.  Let <em>g</em>(<em>&lambda;</em>) be an approximation of <em>f</em>(<em>&lambda;</em>). The original Bernoulli factory for <em>f</em>, if it exists, has bias 0 and variance <em>f</em>(<em>&lambda;</em>)*(1&minus;<em>f</em>(<em>&lambda;</em>)), but the approximate Bernoulli factory has bias <em>g</em>(<em>&lambda;</em>) &minus; <em>f</em>(<em>&lambda;</em>) and variance <em>g</em>(<em>&lambda;</em>)*(1&minus;<em>g</em>(<em>&lambda;</em>)).  Unlike with bias, there are ways to reduce variance, which are outside the scope of this document.  An estimation algorithm&#39;s <em>mean squared error</em> equals variance plus square of bias.</p>
</blockquote>

<p><a id=Achievable_Simulation_Rates></a></p>

<h2>Achievable Simulation Rates</h2>

<p>In general, the number of input coin flips needed by any Bernoulli factory algorithm for a factory function <em>f</em>(<em>&lambda;</em>) depends on how &quot;smooth&quot; the function <em>f</em> is.</p>

<p>The following table summarizes the rate of simulation (in terms of the number of input coin flips needed) that can be achieved <em>in theory</em> depending on <em>f</em>(<em>&lambda;</em>), assuming the unknown probability of heads.  In the table below:</p>

<ul>
<li><em>&lambda;</em>, lies in the interval [<em>&epsilon;</em>, 1&minus;<em>&epsilon;</em>] for some <em>&epsilon;</em> &gt; 0.</li>
<li><em>&Delta;</em>(<em>n</em>, <em>r</em>, <em>&lambda;</em>) = <em>O</em>(max(sqrt(<em>&lambda;</em>*(1&minus;<em>&lambda;</em>)/<em>n</em>),1/<em>n</em>)<sup><em>r</em></sup>), that is, <em>O</em>((1/<em>n</em>)<sup><em>r</em></sup>) near <em>&lambda;</em> = 0 or 1, and <em>O</em>((1/<em>n</em>)<sup><em>r</em>/2</sup>) elsewhere. (<em>O</em>(<em>h</em>(<em>n</em>)) roughly means &quot;bounded from above by <em>h</em>(<em>n</em>) times a constant, for large enough <em>n</em>&quot;.)</li>
</ul>

<table><thead>
<tr>
<th>Property of simulation</th>
<th>Property of <em>f</em></th>
</tr>
</thead><tbody>
<tr>
<td>Requires no more than <em>n</em> input coin flips.</td>
<td>If and only if <em>f</em> can be written as a polynomial in Bernstein form of degree <em>n</em> with coefficients in [0, 1] (Goyal and Sigman 2012)[^11].</td>
</tr>
<tr>
<td>Requires a finite number of flips on average. Also known as &quot;realizable&quot; by Flajolet et al. (2010)[^4].</td>
<td>Only if <em>f</em> is Lipschitz continuous (Nacu and Peres 2005)[^1].<br/>Whenever <em>f</em> admits a fast simulation (Mendo 2019)[^12].</td>
</tr>
<tr>
<td>Number of flips required, raised to power of <em>r</em>, is finite on average and has a tail that drops off uniformly for every <em>&lambda;</em>.</td>
<td>Only if <em>f</em> is <em>C</em><sup><em>r</em></sup> continuous (has <em>r</em> or more continuous derivatives, or &quot;slope&quot; functions) (Nacu and Peres 2005)[^1].</td>
</tr>
<tr>
<td>Requires more than <em>n</em> flips with probability <em>&Delta;</em>(<em>n</em>, <em>r</em> + 1, <em>&lambda;</em>), for integer <em>r</em> &ge; 0 and every <em>&lambda;</em>. (The greater <em>r</em> is, the faster the simulation.)</td>
<td>Only if <em>f</em> is <em>C</em><sup><em>r</em></sup> continuous and the <em>r</em><sup>th</sup> derivative is in the Zygmund class (has no vertical slope) (Holtz et al. 2011)[^13].</td>
</tr>
<tr>
<td>Requires more than <em>n</em> flips with probability <em>&Delta;</em>(<em>n</em>, <em>&alpha;</em>, <em>&lambda;</em>), for non-integer <em>&alpha;</em> &gt; 0 and every <em>&lambda;</em>. (The greater <em>&alpha;</em> is, the faster the simulation.)</td>
<td>If and only if <em>f</em> is <em>C</em><sup><em>r</em></sup> continuous and the <em>r</em><sup>th</sup> derivative is (<em>&alpha;</em> &minus; <em>r</em>)-Hölder continuous, where <em>r</em> = floor(<em>&alpha;</em>) (Holtz et al. 2011)[^13]. Assumes <em>f</em> is bounded away from 0 and 1.</td>
</tr>
<tr>
<td>&quot;Fast simulation&quot; (requires more than <em>n</em> flips with a probability that decays exponentially as <em>n</em> gets large).  Also known as &quot;strongly realizable&quot; by Flajolet et al. (2010)[^4].</td>
<td>If and only if <em>f</em> is real analytic (is <em>C</em><sup>&infin;</sup> continuous, or has continuous <em>k</em><sup>th</sup> derivative for every <em>k</em>, and agrees with its Taylor series at every point) (Nacu and Peres 2005)[^1].</td>
</tr>
<tr>
<td>Average number of flips bounded from below by (<em>f&prime;</em>(<em>&lambda;</em>))<sup>2</sup>*<em>&lambda;</em>*(1&minus;<em>&lambda;</em>)/(<em>f</em>(<em>&lambda;</em>)*(1&minus;<em>f</em>(<em>&lambda;</em>))), where <em>f&prime;</em> is the first derivative of <em>f</em>.</td>
<td>Whenever <em>f</em> admits a fast simulation (Mendo 2019)[^12].</td>
</tr>
</tbody></table>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>By the results of Holtz et al., it is suspected that the target function <em>f</em> can&#39;t be simulated using a finite number of flips on average unless <em>f</em> is <em>C</em><sup>2</sup> continuous.</li>
<li>If a function is constant on some non-empty open interval in its domain, but is not constant on the whole domain, then it can&#39;t be real analytic.</li>
</ol>
</blockquote>

<p><a id=Complexity></a></p>

<h2>Complexity</h2>

<p>The following note shows the complexity of the algorithm for 1/<em>&phi;</em> in the main article, where <em>&phi;</em> is the golden ratio.</p>

<p>Let <strong>E</strong>[<em>N</em>] be the expected (&quot;long-run average&quot;) number of unbiased random bits (fair coin flips) generated by the algorithm.</p>

<p>Then, since each bit is independent, <strong>E</strong>[<em>N</em>] = 2*<em>&phi;</em> as shown below.</p>

<ul>
<li>Each iteration stops the algorithm with probability <em>p</em> = (1/2) + (1&minus;(1/2)) * (1/<em>&phi;</em>) (1/2 for the initial bit and 1/<em>&phi;</em> for the recursive run; (1&minus;(1/2)) because we&#39;re subtracting the (1/2) earlier on the right-hand side from 1).</li>
<li>Thus, the expected number of iterations is <strong>E</strong>[<em>T</em>] = 1/<em>p</em> by a well-known rejection sampling argument, since the algorithm doesn&#39;t depend on iteration counts.</li>
<li>Each iteration uses 1 * (1/2) + (1 + <strong>E</strong>[<em>N</em>]) * (1/2) bits on average, so the whole algorithm uses <strong>E</strong>[<em>N</em>] = (1 * (1/2) + (1 + <strong>E</strong>[<em>N</em>]) * (1/2)) * <strong>E</strong>[<em>T</em>] bits on average (each iteration consumes either 1 bit with probability 1/2, or (1 + <strong>E</strong>[<em>N</em>]) bits with probability 1/2). This equation has the solution <strong>E</strong>[<em>N</em>] = 1 + sqrt(5) = 2*<em>&phi;</em>.</li>
</ul>

<p>Also, on average, half of these flips (<em>&phi;</em>) show 1 and half show 0, since the bits are unbiased (the coin is fair).</p>

<p>A similar analysis to the one above can be used to find the expected (&quot;long-run average&quot;) time complexity of many Bernoulli factory algorithms.</p>

<p><a id=Examples_of_Bernoulli_Factory_Approximation_Schemes></a></p>

<h2>Examples of Bernoulli Factory Approximation Schemes</h2>

<p>The following are approximation schemes and hints to simulate a coin of probability <em>f</em>(<em>&lambda;</em>) given an input coin with probability of heads of <em>&lambda;</em>.  The schemes were generated automatically using <code>approxscheme2</code> and have not been rigorously verified for correctness.</p>

<ul>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>min(1/2, <em>&lambda;</em>)</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 9563/10000 if <em>n</em>&lt;8; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 322613/(250000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 371/500 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 967839/(2000000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>cosh(<em>&lambda;</em>) &minus; 3/4</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>The function was detected to be convex and twice differentiable, leading to:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 487/2500 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 154309/(700000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 1043/5000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 462927/(2800000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>3/4 &minus; sqrt(&minus;<em>&lambda;</em>*(<em>&lambda;</em> &minus; 1))</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be convex and (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1545784563/(400000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 26278337571/(25600000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>3*sin(sqrt(3)*sqrt(sin(2*<em>&lambda;</em>)))/4 + 1/50</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 709907859/(100000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 709907859/(100000000*n<sup>1/4</sup>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 6389170731/(3200000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 6389170731/(3200000000*n<sup>1/4</sup>).</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>3/4 &minus; sqrt(&minus;<em>&lambda;</em>*(<em>&lambda;</em> &minus; 1))</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be convex and (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1545784563/(400000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 26278337571/(25600000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>sqrt(1 &minus; <em>&lambda;</em><sup>2</sup>)</strong>.  Then simulate <em>f</em> by first flipping the input coin.  If it returns 0, return 1.  Otherwise, flip the input coin.  If it returns 0, return 1.  Otherwise, simulate <em>g</em>(<em>&lambda;</em>) (a function described below) and return 1 minus the result.<br>
Let <em>g</em>(<em>&lambda;</em>) = 1/2 if <em>&lambda;</em> = 0; (1 &minus; sqrt(1 &minus; <em>&lambda;</em><sup>2</sup>))/<em>&lambda;</em><sup>2</sup> otherwise. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be convex and (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>g</em>(<em>k</em>/<em>n</em>) &minus; 405238440128399386484736/(1953125*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>g</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>g</em>(<em>k</em>/<em>n</em>) &minus; 6331850627006240413824/(1953125*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>g</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong><em>&lambda;</em>*sin(7*&pi;*<em>&lambda;</em>)/4 + 1/2</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be twice differentiable using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 523/10000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 11346621/(700000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 1229/1250 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 11346621/(700000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 681/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 34039863/(4480000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 4837/5000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 34039863/(4480000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>sin(4*&pi;*<em>&lambda;</em>)/4 + 1/2</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>The function was detected to be twice differentiable, leading to:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 737/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1973921/(350000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 9263/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 1973921/(350000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 1123/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1973921/(448000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 8877/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 1973921/(448000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>sin(6*&pi;*<em>&lambda;</em>)/4 + 1/2</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>The function was detected to be twice differentiable, leading to:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 517/10000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 2220661/(175000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 9483/10000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 2220661/(175000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 1043/10000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 104371067/(11200000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 8957/10000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 104371067/(11200000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>sin(4*&pi;*<em>&lambda;</em>)/4 + 1/2</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>The function was detected to be twice differentiable, leading to:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 737/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1973921/(350000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 9263/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 1973921/(350000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 1123/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1973921/(448000*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 8877/10000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 1973921/(448000*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong><em>&lambda;</em><sup>2</sup>/2 + 1/10 if <em>&lambda;</em> &le; 1/2; <em>&lambda;</em>/2 &minus; 1/40 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be convex and twice differentiable using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 321/5000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1/(7*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 693/10000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 55/(448*n).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong><em>&lambda;</em>/2 if <em>&lambda;</em> &le; 1/2; (4*<em>&lambda;</em> &minus; 1)/(8*<em>&lambda;</em>) otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and twice differentiable using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 893/2000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 2/(7*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 4197/10000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 5/(28*n).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>1/2 &minus; sqrt(1 &minus; 2*<em>&lambda;</em>)/2 if <em>&lambda;</em> &lt; 1/2; sqrt(2*<em>&lambda;</em> &minus; 1)/2 + 1/2 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 1545784563/(400000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 1545784563/(400000000*n<sup>1/4</sup>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 10820491941/(12800000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 10820491941/(12800000000*n<sup>1/4</sup>).</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>1/2 &minus; sqrt(1 &minus; 2*<em>&lambda;</em>)/4 if <em>&lambda;</em> &lt; 1/2; sqrt(2*<em>&lambda;</em> &minus; 1)/4 + 1/2 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 772969563/(400000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 772969563/(400000000*n<sup>1/4</sup>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 193/5000 if <em>n</em>&lt;16; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 5410786941/(12800000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 4807/5000 if <em>n</em>&lt;16; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 5410786941/(12800000000*n<sup>1/4</sup>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong><em>&lambda;</em>/2 + (1 &minus; 2*<em>&lambda;</em>)<sup>3/2</sup>/12 &minus; 1/12 if <em>&lambda;</em> &lt; 0; <em>&lambda;</em>/2 + (2*<em>&lambda;</em> &minus; 1)<sup>3/2</sup>/12 &minus; 1/12 if <em>&lambda;</em> &ge; 1/2; <em>&lambda;</em>/2 + (1 &minus; 2*<em>&lambda;</em>)<sup>3/2</sup>/12 &minus; 1/12 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be convex and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 322613/(500000*sqrt(n)).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 3548743/(32000000*sqrt(n)).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>1/2 &minus; sqrt(1 &minus; 2*<em>&lambda;</em>)/4 if <em>&lambda;</em> &lt; 1/2; sqrt(2*<em>&lambda;</em> &minus; 1)/4 + 1/2 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) &minus; 772969563/(400000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 772969563/(400000000*n<sup>1/4</sup>).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 193/5000 if <em>n</em>&lt;16; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 5410786941/(12800000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 4807/5000 if <em>n</em>&lt;16; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 5410786941/(12800000000*n<sup>1/4</sup>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>1/2 &minus; sqrt(1 &minus; 2*<em>&lambda;</em>)/8 if <em>&lambda;</em> &lt; 1/2; sqrt(2*<em>&lambda;</em> &minus; 1)/8 + 1/2 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be (1/2)-Hölder continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 333/10000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 386562063/(400000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 9667/10000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 386562063/(400000000*n<sup>1/4</sup>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 451/2000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 2705934441/(12800000000*n<sup>1/4</sup>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 1549/2000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 2705934441/(12800000000*n<sup>1/4</sup>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong><em>&lambda;</em>/4 + (1 &minus; 2*<em>&lambda;</em>)<sup>3/2</sup>/24 + 5/24 if <em>&lambda;</em> &lt; 0; <em>&lambda;</em>/4 + (2*<em>&lambda;</em> &minus; 1)<sup>3/2</sup>/24 + 5/24 if <em>&lambda;</em> &ge; 1/2; <em>&lambda;</em>/4 + (1 &minus; 2*<em>&lambda;</em>)<sup>3/2</sup>/24 + 5/24 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be convex and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 443/5000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 322613/(1000000*sqrt(n)).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = 1111/5000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) &minus; 3548743/(64000000*sqrt(n)).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>3*<em>&lambda;</em>/2 if <em>&lambda;</em> &le; 1 &minus; <em>&lambda;</em>; 3/2 &minus; 3*<em>&lambda;</em>/2 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 124/125 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 967839/(500000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 1863/2000 if <em>n</em>&lt;64; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 2903517/(2000000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>9*<em>&lambda;</em>/5 if <em>&lambda;</em> &le; 1 &minus; <em>&lambda;</em>; 9/5 &minus; 9*<em>&lambda;</em>/5 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 2903517/(1250000*sqrt(n)).</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + 8710551/(5000000*sqrt(n)).</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>min(<em>&lambda;</em>, 1 &minus; <em>&lambda;</em>)</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 9563/10000 if <em>n</em>&lt;8; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 322613/(250000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 123/125 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 967839/(1000000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong><em>&lambda;</em>/2 if <em>&lambda;</em> &le; 1 &minus; <em>&lambda;</em>; 1/2 &minus; <em>&lambda;</em>/2 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 5727/10000 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 322613/(500000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 123/250 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 967839/(2000000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>19*<em>&lambda;</em>/20 if <em>&lambda;</em> &le; 1 &minus; <em>&lambda;</em>; 19/20 &minus; 19*<em>&lambda;</em>/20 otherwise</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 1817/2000 if <em>n</em>&lt;8; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 6129647/(5000000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 2337/2500 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 18388941/(20000000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
<li>Let <em>f</em>(<em>&lambda;</em>) = <strong>min(1/8, 3*<em>&lambda;</em>)</strong>. Then, for every integer <em>n</em> that&#39;s a power of 2, starting from 1:

<ul>
<li>Detected to be concave and Lipschitz continuous using numerical methods, which may be inaccurate:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 4047/5000 if <em>n</em>&lt;32; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 967839/(250000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
<li>Generated using tighter bounds than necessarily proven:

<ul>
<li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = 171/400 if <em>n</em>&lt;4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + 967839/(1600000*sqrt(n)).</li>
<li><strong>fbound</strong>(<em>n</em>) = [0, 1].</li>
</ul></li>
</ul></li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p>[^1]: Nacu, Şerban, and Yuval Peres. &quot;<a href="https://projecteuclid.org/euclid.aoap/1106922322"><strong>Fast simulation of new coins from old</strong></a>&quot;, The Annals of Applied Probability 15, no. 1A (2005): 93-115.</p>

<p>[^2]: This means the exceptions make up a zero-volume (Lebesgue measure zero) set of points.</p>

<p>[^3]: Specifically, the constant <em>m</em> is a number equal to or greater than abs(<em>f</em>(<em>x</em>)&minus;<em>f</em>(<em>y</em>))/(abs(<em>x</em>&minus;<em>y</em>)<sup><em>&alpha;</em></sup>) for every <em>x</em> in [0, 1] and every <em>y</em> in [0, 1] such that <em>x</em> != <em>y</em>.  However, <em>m</em> can&#39;t directly be calculated as it would involve checking an infinite number of <em>x</em>, <em>y</em> pairs.</p>

<p>[^4]: Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560 [math.PR], 2010.</p>

<p>[^5]: Powell, M.J.D., <em>Approximation Theory and Methods</em>, 1981</p>

<p>[^6]: G. G. Lorentz. Bernstein polynomials. 1986.</p>

<p>[^7]: Popoviciu, T., &quot;Sur l&#39;approximation des fonctions convexes d&#39;ordre supérieur&quot;, Mathematica (Cluj), 1935.</p>

<p>[^8]: Sikkema, P.C., &quot;Der Wert einiger Konstanten in der Theorie der Approximation mit Bernstein-Polynomen&quot;, Numer. Math. 3 (1961).</p>

<p>[^9]: Henderson, S.G., Glynn, P.W., &quot;Nonexistence of a class of variate generation schemes&quot;, <em>Operations Research Letters</em> 31 (2003).</p>

<p>[^10]: For this approximation, if <em>n</em> were infinity, the method would return 1 with probability 1 and so would not approximate <em>&lambda;</em>*<em>c</em>, of course.</p>

<p>[^11]: Goyal, V. and Sigman, K., 2012. On simulating a class of Bernstein polynomials. ACM Transactions on Modeling and Computer Simulation (TOMACS), 22(2), pp.1-5.</p>

<p>[^12]: Mendo, Luis. &quot;An asymptotically optimal Bernoulli factory for certain functions that can be expressed as power series.&quot; Stochastic Processes and their Applications 129, no. 11 (2019): 4366-4384.</p>

<p>[^13]: Holtz, O., Nazarov, F., Peres, Y., &quot;New Coins from Old, Smoothly&quot;, <em>Constructive Approximation</em> 33 (2011).</p>

<p>[^14]: Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994.</p>

<p>[^15]: von Neumann, J., &quot;Various techniques used in connection with random digits&quot;, 1951.</p>

<p>[^16]: Peres, Y., &quot;<a href="https://projecteuclid.org/euclid.aos/1176348543"><strong>Iterating von Neumann&#39;s procedure for extracting random bits</strong></a>&quot;, Annals of Statistics 1992,20,1, p. 590-597.</p>

<p>[^17]: Knuth, Donald E. and Andrew Chi-Chih Yao. &quot;The complexity of nonuniform random variate generation&quot;, in <em>Algorithms and Complexity: New Directions and Recent Results</em>, 1976.</p>

<p>[^18]: Mossel, Elchanan, and Yuval Peres. New coins from old: computing with unknown bias. Combinatorica, 25(6), pp.707-724.</p>

<p>[^19]: S. Pae, &quot;<a href="https://arxiv.org/abs/1602.06058v2"><strong>Binarization Trees and Random Number Generation</strong></a>&quot;, arXiv:1602.06058v2 [cs.DS], 2018.</p>

<p>[^20]: Levy, H., <em>Stochastic dominance</em>, 1998.</p>

<p>[^21]: Henry (<a href="https://math.stackexchange.com/users/6460/henry">https://math.stackexchange.com/users/6460/henry</a>), Proving stochastic dominance for hypergeometric random variables, URL (version: 2021-02-20): <a href="https://math.stackexchange.com/q/4033573"><strong>https://math.stackexchange.com/q/4033573</strong></a> .</p>

<p>[^22]: Gal, S.G., &quot;Calculus of the modulus of continuity for nonconcave functions and applications&quot;, <em>Calcolo</em> 27 (1990)</p>

<p>[^23]: Gal, S.G., 1995. Properties of the modulus of continuity for monotonous convex functions and applications. <em>International Journal of Mathematics and Mathematical Sciences</em> 18(3), pp.443-446.</p>

<p>[^24]: Anastassiou, G.A., Gal, S.G., <em>Approximation Theory: Moduli of Continuity and Global Smoothness Preservation</em>, Birkhäuser, 2012.</p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Which_functions_admit_a_Bernoulli_factory></a></p>

<h3>Which functions admit a Bernoulli factory?</h3>

<p>Let <em>f</em>(<em>&lambda;</em>) be a function whose domain is the <em>closed</em> interval [0, 1] or a subset of it, and that maps its domain to [0, 1].  The domain of <em>f</em> gives the allowable values of <em>&lambda;</em>, which is the input coin&#39;s probability of heads.</p>

<p><em>f</em> admits a Bernoulli factory if and only if <em>f</em> is constant on its domain, or is continuous and <em>polynomially bounded</em> on its domain, as defined in the section &quot;Proofs for Function Approximation Schemes&quot; (Keane and O&#39;Brien 1994)[^14].</p>

<p>If <em>f</em>(<em>&lambda;</em>) meets these sufficient conditions, it admits a Bernoulli factory:</p>

<ul>
<li><em>f</em>(<em>&lambda;</em>) is continuous on the closed interval [0, 1].</li>
<li><em>f</em>(<em>&lambda;</em>) has a minimum of greater than 0 and a maximum of less than 1.</li>
</ul>

<p>If <em>f</em>(<em>&lambda;</em>) meets these sufficient conditions, it admits a Bernoulli factory and is Hölder continuous (has no slope steeper than an <em>n</em><sup>th</sup> root&#39;s):</p>

<ul>
<li><em>f</em>(<em>&lambda;</em>) is continuous.</li>
<li><em>f</em>(<em>&lambda;</em>) maps the closed interval [0, 1] to [0, 1].</li>
<li><em>f</em>(<em>&lambda;</em>) equals neither 0 nor 1 on the open interval (0, 1).</li>
<li><em>f</em>(<em>&lambda;</em>) is algebraic over rational numbers (that is, there is a nonzero polynomial <em>P</em>(<em>x</em>, <em>y</em>) in two variables and whose coefficients are rational numbers, such that <em>P</em>(<em>x</em>, <em>f</em>(<em>x</em>)) = 0 for every <em>x</em> in the domain of <em>f</em>).</li>
</ul>

<p>A <a href="https://mathoverflow.net/a/395018/171320"><strong>proof by Reid Barton</strong></a> begins by showing that <em>f</em> is a <em>semialgebraic function</em>, so that by a known inequality and the other conditions, it meets the definitions of being Hölder continuous and polynomially bounded.</p>

<p><a id=Which_functions_don_t_require_outside_randomness_to_simulate></a></p>

<h3>Which functions don&#39;t require outside randomness to simulate?</h3>

<p>The function <em>f</em>(<em>&lambda;</em>) is <em>strongly simulable</em> if it admits a Bernoulli factory algorithm that uses nothing but the input coin as a source of randomness (Keane and O&#39;Brien 1994)[^14].  See &quot;<a href="https://peteroupc.github.io/bernoulli.html#Randomized_vs_Non_Randomized_Algorithms"><strong>Randomized vs. Non-Randomized Algorithms</strong></a>&quot;.</p>

<p><strong>Strong Simulability Statement.</strong> A function <em>f</em>(<em>&lambda;</em>) is strongly simulable only if&mdash;</p>

<ol>
<li><em>f</em> is constant on its domain, or is continuous and polynomially bounded on its domain, and</li>
<li><em>f</em> maps the closed interval [0, 1] or a subset of it to [0, 1], and</li>
<li><em>f</em>(0) equals 0 or 1 whenever 0 is in the domain of <em>f</em>, and</li>
<li><em>f</em>(1) equals 0 or 1 whenever 1 is in the domain of <em>f</em>.</li>
</ol>

<p>Keane and O&#39;Brien already showed that <em>f</em> is strongly simulable if conditions 1 and 2 are true and neither 0 nor 1 are included in the domain of <em>f</em>.  Conditions 3 and 4 are required because <em>&lambda;</em> (the probability of heads) can be 0 or 1 so that the input coin returns 0 or 1, respectively, every time.  This is called a &quot;degenerate&quot; coin.  When given just a degenerate coin, no algorithm can produce one value with probability greater than 0, and another value with the opposite probability.  Rather, the algorithm can only produce a constant value with probability 1.  In the Bernoulli factory problem, that constant is either 0 or 1, so a Bernoulli factory algorithm for <em>f</em> must return 1 with probability 1, or 0 with probability 1, when given just a degenerate coin and no outside randomness, resulting in conditions 3 and 4.</p>

<p>We can show that <em>f</em> is strongly simulable by showing that there is a Bernoulli factory for <em>f</em> that must flip the input coin and get 0 and 1 before it uses any outside randomness.</p>

<p><strong>Proposition 1.</strong> <em>If f(&lambda;) is described in the strong simulability statement and is a polynomial with computable coefficients, it is strongly simulable.</em></p>

<p><em>Proof:</em> If <em>f</em> is the constant 0 or 1, the proof is trivial: simply return 0 or 1, respectively.</p>

<p>Otherwise: Let <em>a</em>[<em>j</em>] be the <em>j</em><sup>th</sup> coefficient of the polynomial in Bernstein form.  Consider the following algorithm, modified from (Goyal and Sigman 2012)[^11].</p>

<ol>
<li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</li>
<li>If 0 is in the domain of <em>f</em> and if <em>j</em> is 0, return <em>f</em>(0). (By condition 3, <em>f</em>(0) must be either 0 or 1.)</li>
<li>If 1 is in the domain of <em>f</em> and if <em>j</em> is <em>n</em>, return <em>f</em>(1). (By condition 4, <em>f</em>(1) must be either 0 or 1.)</li>
<li>Generate a uniform(0, 1) random variate, then return 1 if that variate is less than <em>a</em>[<em>j</em>] (<em>a</em>[<em>j</em>] is the coefficient <em>j</em> of the polynomial written in Bernstein form), or 0 otherwise.</li>
</ol>

<p>(By the properties of the Bernstein form, <em>a</em>[0] will equal <em>f</em>(0) and <em>a</em>[<em>n</em>] will equal <em>f</em>(1) whenever 0 or 1 is in the domain of <em>f</em>, respectively.)</p>

<p>Step 4 is done by first generating unbiased bits (such as with the von Neumann trick of flipping the input coin twice until the flip returns 0 then 1 or 1 then 0 this way, then taking the result as 0 or 1, respectively (von Neumann 1951)[^15]), then using the algorithm in &quot;<a href="https://peteroupc.github.io/bernoulli.html#Digit_Expansion"><strong>Digit Expansions</strong></a>&quot; to produce the probability <em>a</em>[<em>j</em>].  The algorithm computes <em>a</em>[<em>j</em>] bit by bit and compares the computed value with the generated bits.  Since the coin returned both 0 and 1 in step 1 earlier in the algorithm, we know the coin isn&#39;t degenerate, so that step 4 will finish with probability 1.  Now, since the Bernoulli factory used only the input coin for randomness, this shows that <em>f</em> is strongly simulable. &#x25a1;</p>

<p><strong>Proposition 2.</strong> <em>If f(&lambda;) is described in the strong simulability statement, and if either f is constant on its domain or f meets the additional conditions below, then f is strongly simulable.</em></p>

<ol>
<li><em>If f(0) = 0 or f(1) = 0 or both, then there is a polynomial g(&lambda;) in Bernstein form whose coefficients are computable and in the interval [0, 1], such that g(0) = f(0) and g(1) = f(1) whenever 0 or 1, respectively, is in the domain of f, and such that g(&lambda;) &gt; f(&lambda;) for every &lambda; in the domain of f, except at 0 and 1.</em></li>
<li><em>If f(0) = 1 or f(1) = 1 or both, then there is a polynomial h(&lambda;) in Bernstein form whose coefficients are computable and in the interval [0, 1], such that h(0) = f(0) and h(1) = f(1) whenever 0 or 1, respectively, is in the domain of f, and such that h(&lambda;) &lt; f(&lambda;) for every &lambda; in the domain of f, except at 0 and 1.</em></li>
</ol>

<p><strong>Lemma 1.</strong> <em>If f(&lambda;) is described in the strong simulability statement and meets the additional condition below, then f is strongly simulable.</em></p>

<ul>
<li><em>There is a polynomial g(&lambda;) in Bernstein form whose coefficients are computable and in the interval [0, 1], such that g(0) = f(0) and g(1) = f(1) whenever 0 or 1, respectively, is in the domain of f, and such that g(&lambda;) &gt; f(&lambda;) for every &lambda; in the domain of f, except at 0 and 1.</em></li>
</ul>

<p><em>Proof:</em>  Consider the following algorithm.</p>

<ol>
<li>If <em>f</em> is 0 everywhere in its domain or 1 everywhere in its domain, return 0 or 1, respectively.</li>
<li><p>Otherwise, use the algorithm given in Proposition 1 to simulate <em>g</em>(<em>&lambda;</em>).  If the algorithm returns 0, return 0. By the additional condition in the lemma, 0 will be returned if <em>&lambda;</em> is either 0 or 1.</p>

<p>Now, we know that the input coin&#39;s probability of heads is neither 0 nor 1.</p>

<p>By the conditions in the lemma, both <em>f</em> and <em>g</em> will be positive on the open interval (0, 1) (wherever <em>f</em> is defined).</p>

<p>Now let <em>h</em>(<em>&lambda;</em>) = <em>f</em>(<em>&lambda;</em>)/<em>g</em>(<em>&lambda;</em>).  By the conditions in the lemma, <em>h</em> will be positive everywhere in that interval.</p></li>
<li><p>If <em>h</em> equals 1 everywhere in the interval (0, 1) (wherever <em>f</em> is defined), return 1.</p></li>
<li>Otherwise, we run a Bernoulli factory algorithm for <em>h</em>(<em>&lambda;</em>) that uses the input coin (and possibly outside randomness).  Since <em>h</em> is continuous and polynomially bounded and the input coin&#39;s probability of heads is neither 0 nor 1, <em>h</em> is strongly simulable; we can replace the outside randomness in the algorithm with unbiased random bits via the von Neumann trick.</li>
</ol>

<p>Thus, <em>f</em> admits an algorithm that uses nothing but the input coin as a source of randomness, and so is strongly simulable. &#x25a1;</p>

<p><strong>Lemma 2.</strong> <em>If f(&lambda;) is described in the strong simulability statement and meets the additional conditions below, then f is strongly simulable.</em></p>

<ol>
<li><em>There are two polynomials g(&lambda;) and &omega;(&lambda;) in Bernstein form, such that both polynomials&#39; coefficients are computable and all in the interval [0, 1].</em></li>
<li><em>g(0) = &omega;(0) = f(0) = 0 (so that 0 is in the domain of f).</em></li>
<li><em>g(1) = &omega;(1) = f(1) = 1 (so that 1 is in the domain of f).</em></li>
<li><em>For every &lambda; in the domain of f, except at 0 and 1, g(&lambda;) &gt; f(&lambda;).</em></li>
<li><em>For every &lambda; in the domain of f, except at 0 and 1, &omega;(&lambda;) &lt; f(&lambda;).</em></li>
</ol>

<p><em>Proof:</em> First, assume <em>g</em> and <em>&omega;</em> have the same degree.  If not, elevate the degree of the polynomial with lesser degree to have the same degree as the other.</p>

<p>Now, let <em>g</em>[<em>j</em>] and <em>&omega;</em>[<em>j</em>] be the <em>j</em><sup>th</sup> coefficient of the polynomial <em>g</em> or <em>&omega;</em>, respectively, in Bernstein form.  Consider the following algorithm, which is similar to the algorithm in Proposition 1.</p>

<ol>
<li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</li>
<li>If 0 is in the domain of <em>f</em> and if <em>j</em> is 0, return <em>g</em>(0) = <em>&omega;</em>(0) = 0.</li>
<li>If 1 is in the domain of <em>f</em> and if <em>j</em> is <em>n</em>, return <em>g</em>(1) = <em>&omega;</em>(1) = 0.</li>
<li>Generate a uniform(0, 1) random variate, then return 1 if that variate is less than <em>&omega;</em>[<em>j</em>], or return 0 if that variate is greater than <em>g</em>[<em>j</em>].  This step is carried out via the von Neumann method, as in Proposition 1.</li>
</ol>

<p>If the algorithm didn&#39;t return a value, then by now we know that the input coin&#39;s probability of heads is neither 0 nor 1, since step 2 returned a value (either 0 or 1), which can only happen if the input coin didn&#39;t return all zeros or all ones.</p>

<p>Now let <em>r</em>(<em>&lambda;</em>) = (<em>f</em>(<em>&lambda;</em>) &minus; <em>&omega;</em>(<em>&lambda;</em>)) / (<em>g</em>(<em>&lambda;</em>) &minus; <em>&omega;</em>(<em>&lambda;</em>)).  By the conditions in the lemma, <em>h</em> will be positive everywhere in the interval (0, 1), wherever <em>f</em> is defined.</p>

<p>Now, run a Bernoulli factory algorithm for <em>r</em>(<em>&lambda;</em>) that uses the input coin (and possibly outside randomness).  Since <em>r</em> is continuous and polynomially bounded and the input coin&#39;s probability of heads is neither 0 nor 1, <em>r</em> is strongly simulable; we can replace the outside randomness in the algorithm with unbiased random bits via the von Neumann trick.</p>

<p>Thus, <em>f</em> admits an algorithm that uses nothing but the input coin as a source of randomness, and so is strongly simulable. &#x25a1;</p>

<p><em>Proof of Proposition 2:</em>  The following cases can occur:</p>

<ol>
<li>If neither 0 nor 1 are in the domain of <em>f</em>, then <em>f</em> is strongly simulable by the discussion above.</li>
<li>If <em>f</em> is 0 everywhere in its domain or 1 everywhere in its domain: Return 0 or 1, respectively.</li>
<li>If 0 but not 1 is in the domain of <em>f</em>: If <em>f</em>(0) = 0, apply Lemma 1.  If <em>f</em>(0) = 1, apply Lemma 1, but take <em>f</em> = 1 &minus; <em>f</em> and return 1 minus the output of the lemma&#39;s algorithm (this will bring <em>f</em>(0) = 0 and satisfy the lemma.)</li>
<li>If 1 but not 0 is in the domain of <em>f</em>: If <em>f</em>(1) = 0, apply Lemma 1.  If <em>f</em>(1) = 1, apply Lemma 1, but take <em>f</em> = 1 &minus; <em>f</em> and return 1 minus the output of the lemma&#39;s algorithm (this will bring <em>f</em>(1) = 0 and satisfy the lemma.)</li>
<li><em>f</em>(0) = <em>f</em>(1) = 0: Apply Lemma 1.</li>
<li><em>f</em>(0) = <em>f</em>(1) = 1: Apply Lemma 1, but take <em>f</em> = 1 &minus; <em>f</em> and return 1 minus the output of the lemma&#39;s algorithm.</li>
<li><em>f</em>(0) = 0 and <em>f</em>(1) = 1: Apply Lemma 2.</li>
<li><em>f</em>(0) = 1 and <em>f</em>(1) = 0: Apply Lemma 2, but take <em>f</em> = 1 &minus; <em>f</em> and return 1 minus the output of the lemma&#39;s algorithm.</li>
</ol>

<p>&#x25a1;</p>

<p><strong>Proposition 3.</strong> <em>If f(&lambda;) is described in the strong simulability statement and is Lipschitz continuous, then f is strongly simulable.</em></p>

<p><strong>Lemma 3.</strong> <em>If f(&lambda;) is described in the strong simulability statement, is Lipschitz continuous, and is such that f(0) = 0 and f(1) = 0 whenever 0 or 1, respectively, is in the domain of f, then f is strongly simulable.</em></p>

<p><em>Proof:</em> If <em>f</em> is 0 everywhere in its domain or 1 everywhere in its domain: Return 0 or 1, respectively.  Otherwise, let&mdash;</p>

<ul>
<li><em>M</em> be the Lipschitz constant of <em>f</em> (for example, its &quot;slope&quot; function&#39;s maximum absolute value), or a computable number greater than this.</li>
<li><em>l</em> be either 0 if 0 is in the domain of <em>f</em>, or 1 otherwise, and</li>
<li><em>u</em> be either 0 if 1 is in the domain of <em>f</em>, or 1 otherwise.</li>
</ul>

<p>To build <em>g</em>, take its degree as ceil(<em>M</em>)+1 or greater (so that <em>g</em>&#39;s Lipschitz constant is greater than <em>M</em> and <em>g</em> has ceil(<em>M</em>) + 2 coefficients), then set the first coefficient as <em>l</em>, the last coefficient as <em>u</em>, and the remaining coefficients as 1. (As a result, the polynomial <em>g</em> will have computable coefficients.) Then <em>g</em> will meet the additional condition for Lemma 1 and the result follows from that lemma. &#x25a1;</p>

<p><strong>Lemma 4.</strong> <em>If f(&lambda;) is described in the strong simulability statement, is Lipschitz continuous, and is such that f(0) = 0 and f(1) = 1 (so that 0 and 1 are in the domain of f), then f is strongly simulable.</em></p>

<p><em>Proof:</em> Let <em>M</em> and <em>l</em> be as in Lemma 3.</p>

<p>To build <em>g</em> and <em>&omega;</em>, take their degree as ceil(<em>M</em>)+1 or greater (so that their Lipschitz constant is greater than <em>M</em> and each polynomial has ceil(<em>M</em>) + 2 coefficients), then for each polynomial, set its first coefficient as <em>l</em> and the last coefficient as 1. The remaining coefficients of <em>g</em> are set as 1 and the remaining coefficients of <em>&omega;</em> are set as 0.  (As a result, the polynomial <em>g</em> will have computable coefficients.)  Then <em>g</em> and <em>&omega;</em> will meet the additional conditions for Lemma 2 and the result follows from that lemma. &#x25a1;</p>

<p><em>Proof of Proposition 3:</em> In the proof of proposition 2, replace Lemma 1 and Lemma 2 with Lemma 3 and Lemma 4, respectively. &#x25a1;</p>

<p>It is suspected that the conditions in Proposition 2 are necessary and sufficient for <em>f</em>(<em>&lambda;</em>) to be strongly simulable.</p>

<p><a id=Multiple_Output_Bernoulli_Factory></a></p>

<h3>Multiple-Output Bernoulli Factory</h3>

<p>A related topic is a Bernoulli factory that takes a coin with unknown probability of heads <em>&lambda;</em> and produces one or more samples of the probability <em>f</em>(<em>&lambda;</em>).  This section calls it a <em>multiple-output Bernoulli factory</em>.</p>

<p>Obviously, any single-output Bernoulli factory can produce multiple outputs by running itself multiple times.  But for some functions <em>f</em>, there may be a more efficient algorithm in terms of input coin flips.</p>

<p>Let <em>J</em> be a closed interval on (0, 1), such as [1/100, 99/100].  Define the <em>entropy bound</em> as <em>h</em>(<em>f</em>(<em>&lambda;</em>))/<em>h</em>(<em>&lambda;</em>) where <em>h</em>(<em>x</em>) = &minus;<em>x</em>*ln(<em>x</em>)&minus;(1&minus;<em>x</em>)*ln(1&minus;<em>x</em>) is related to the Shannon entropy function.  The question is:</p>

<p><em>When the probability &lambda; can be any value in J, is there a multiple-output Bernoulli factory for f(&lambda;) with an expected (&quot;long-run average&quot;) number of input coin flips per sample that is arbitrarily close to the entropy bound?  Call such a Bernoulli factory an <strong>optimal factory</strong>.</em></p>

<p>(See Nacu and Peres (2005, Question 2)[^1].)</p>

<p>So far, the following functions do admit an <em>optimal factory</em>:</p>

<ul>
<li>The functions <em>&lambda;</em> and 1 &minus; <em>&lambda;</em>.</li>
<li>Constants in [0, 1].  As Nacu and Peres (2005)[^1] already showed, any such constant <em>c</em> admits an optimal factory: generate unbiased random bits using Peres&#39;s iterated von Neumann extractor (Peres 1992)[^16], then build a binary tree that generates 1 with probability <em>c</em> and 0 otherwise (Knuth and Yao 1976)[^17].</li>
</ul>

<p>It is easy to see that if an <em>optimal factory</em> exists for <em>f</em>(<em>&lambda;</em>), then one also exists for 1 &minus; <em>f</em>(<em>&lambda;</em>): simply change all ones returned by the <em>f</em>(<em>&lambda;</em>) factory into zeros and vice versa.</p>

<p>Also, as Yuval Peres (Jun. 24, 2021) told me, there is an efficient multiple-output Bernoulli factory for <em>f</em>(<em>&lambda;</em>) = <em>&lambda;</em>/2: the key is to flip the input coin enough times to produce unbiased random bits using his extractor (Peres 1992)[^12], then multiply each unbiased bit with another input coin flip to get a sample from <em>&lambda;</em>/2.  Given that the sample is equal to 0, there are three possibilities that can &quot;be extracted to produce more fair bits&quot;: either the unbiased bit is 0, or the coin flip is 0, or both are 0.</p>

<p>This algorithm, though, doesn&#39;t count as an <em>optimal factory</em>, and Peres described this algorithm only incompletely.  By simulation and trial and error I found an improved version of the algorithm.  It uses two randomness extractors (extractor 1 and extractor 2) that produce unbiased random bits from biased data (which is done using a method given later in this section).  The extractors must be asymptotically optimal (they must approach the entropy limit as closely as desired); one example is the iterated von Neumann construction in Peres (1992)[^16].  The algorithm consists of doing the following in a loop until the desired number of outputs is generated.</p>

<ol>
<li>If the number of outputs generated so far is divisible by 20, do the following:

<ul>
<li>Generate an unbiased random bit (see below).  If that bit is zero, output 0, then repeat this step unless the desired number of outputs has been generated.  If the bit is 1, flip the input coin and output the result.</li>
</ul></li>
<li>Otherwise, do the following:

<ol>
<li>Generate an unbiased random bit (see below), call it <em>fc</em>.  Then flip the input coin and call the result <em>bc</em>.</li>
<li>Output <em>fc</em>*<em>bc</em>.</li>
<li>(The following steps pass &quot;unused&quot; randomness to the extractor in a specific way to ensure correctness.) If <em>fc</em> is 0, and <em>bc</em> is 1, append 0 to extractor 2&#39;s input bits.</li>
<li>If <em>fc</em> and <em>bc</em> are both 0, append 1 then 1 to extractor 2&#39;s input bits.</li>
<li>If <em>fc</em> is 1 and <em>bc</em> is 0, append 1 then 0 to extractor 2&#39;s input bits.</li>
</ol></li>
</ol>

<p>Inspired by Peres&#39;s result with <em>&lambda;</em>/2, the following algorithm is proposed.  It works for any rational function of the form <em>D</em>(<em>&lambda;</em>)/<em>E</em>(<em>&lambda;</em>), where&mdash;</p>

<ul>
<li><em>D</em>(<em>&lambda;</em>) = &sum;<sub><em>i</em> = 0, ..., <em>k</em></sub> <em>&lambda;</em><sup><em>i</em></sup> * (1 &minus; <em>&lambda;</em>)<sup><em>k</em> &minus; <em>i</em></sup> * <em>d</em>[<em>i</em>],</li>
<li><em>E</em>(<em>&lambda;</em>) = &sum;<sub><em>i</em> = 0, ..., <em>k</em></sub> <em>&lambda;</em><sup><em>i</em></sup> * (1 &minus; <em>&lambda;</em>)<sup><em>k</em> &minus; <em>i</em></sup> * <em>e</em>[<em>i</em>],</li>
<li>every <em>d</em>[<em>i</em>] is less than or equal to the corresponding <em>e</em>[<em>i</em>], and</li>
<li>each <em>d</em>[<em>i</em>] and each <em>e</em>[<em>i</em>] is a non-negative integer.</li>
</ul>

<p>The algorithm is a modified version of the &quot;block simulation&quot; in Mossel and Peres (2005, Proposition 2.5)[^18], which also &quot;extracts&quot; residual randomness with the help of six asymptotically optimal randomness extractors.  In the algorithm, let <em>r</em> be an integer such that, for every integer <em>i</em> in [0, <em>k</em>], <em>e</em>[<em>i</em>] &lt; choose(<em>k</em>, <em>i</em>)*choose(2*<em>r</em>, <em>r</em>).</p>

<ol>
<li>Set <em>iter</em> to 0.</li>
<li>Flip the input coin <em>k</em> times.  Then build a bitstring <em>B1</em> consisting of the coin flip results in the order they occurred.  Let <em>i</em> be the number of ones in <em>B1</em>.</li>
<li>Generate 2*<em>r</em> unbiased random bits (see below).  (Rather than flipping the input coin 2*<em>r</em> times, as in the algorithm of Proposition 2.5.)  Then build a bitstring <em>B2</em> consisting of the coin flip results in the order they occurred.</li>
<li>If the number of ones in <em>B2</em> is other than <em>r</em>: Translate <em>B1</em> + <em>B2</em> to an integer under mapping 1, then pass that number to extractor 2<sup>&dagger;</sup>, then add 1 to <em>iter</em>, then go to step 2.</li>
<li>Translate <em>B1</em> + <em>B2</em> to an integer under mapping 2, call the integer <em>&beta;</em>.  If <em>&beta;</em> &lt; <em>d</em>[<em>i</em>], pass <em>&beta;</em> to extractor 3, then pass <em>iter</em> to extractor 6, then output a 1.  Otherwise, if <em>&beta;</em> &lt; <em>e</em>[<em>i</em>], pass <em>&beta;</em> &minus; <em>d</em>[<em>i</em>] to extractor 4, then pass <em>iter</em> to extractor 6, then output a 0.  Otherwise, pass <em>&beta;</em> &minus; <em>e</em>[<em>i</em>] to extractor 5, then add 1 to <em>iter</em>, then go to step 2.</li>
</ol>

<p>The mappings used in this algorithm are as follows:</p>

<ol>
<li>A one-to-one mapping between&mdash;

<ul>
<li>bitstrings of length <em>k</em> + 2*<em>r</em> with fewer or greater than <em>r</em> ones among the last 2*<em>r</em> bits, and</li>
<li>the integers in [0, 2<sup><em>k</em></sup> * (2<sup>2*<em>r</em></sup> &minus; choose(2*<em>r</em>, <em>r</em>))).</li>
</ul></li>
<li>A one-to-one mapping between&mdash;

<ul>
<li>bitstrings of length <em>k</em> + 2*<em>r</em> with exactly <em>i</em> ones among the first <em>k</em> bits and exactly <em>r</em> ones among the remaining bits, and</li>
<li>the integers in [0, choose(<em>k</em>, <em>i</em>)*choose(2*<em>r</em>, <em>r</em>)).</li>
</ul></li>
</ol>

<p>In this algorithm, an unbiased random bit is generated as follows.  Let <em>m</em> be an even integer that is 32 or greater (in general, the greater <em>m</em> is, the more efficient the overall algorithm is in terms of coin flips).</p>

<ol>
<li>Use extractor 1 to extract outputs from floor(<em>n</em>/<em>m</em>)*<em>m</em> inputs, where <em>n</em> is the number of input bits available to that extractor.  Do the same for the remaining extractors.</li>
<li>If extractor 2 has at least one unused output bit, take an output and stop.  Otherwise, repeat this step for the remaining extractors.</li>
<li>Flip the input coin at least <em>m</em> times, append the coin results to extractor 1&#39;s inputs, and go to step 1.</li>
</ol>

<p>Now consider the last paragraph of Proposition 2.5.  If the input coin were flipped in step 2, the probability of&mdash;</p>

<ul>
<li>outputting 1 in the algorithm&#39;s last step would be <em>P1</em> = <em>&lambda;</em><sup><em>r</em></sup>*(1&minus;<em>&lambda;</em>)<sup><em>r</em></sup>*<em>D</em>(<em>&lambda;</em>).</li>
<li>outputting either 0 or 1 in that step would be <em>P01</em> = <em>&lambda;</em><sup><em>r</em></sup>*(1&minus;<em>&lambda;</em>)<sup><em>r</em></sup>*<em>E</em>(<em>&lambda;</em>),</li>
</ul>

<p>so that the algorithm would simulate <em>f</em>(<em>&lambda;</em>) = <em>P1</em> / <em>P01</em>.  Observe that the <em>&lambda;</em><sup><em>r</em></sup>*(1&minus;<em>&lambda;</em>)<sup><em>r</em></sup> cancels out in the division.  Thus, we could replace the input coin with unbiased random bits and still simulate <em>f</em>(<em>&lambda;</em>); the <em>&lambda;</em><sup><em>r</em></sup>*(1&minus;<em>&lambda;</em>)<sup><em>r</em></sup> above would then be (1/2)<sup>2*<em>r</em></sup>.</p>

<p>While this algorithm is coin-flip-efficient, it is not believed to be an optimal factory, at least not without more work.  In particular, a bigger savings of input coin flips could occur if <em>f</em>(<em>&lambda;</em>) maps the interval <em>J</em> to a small range of values, so that the algorithm could, for example, generate a uniform random variate in [0, 1] using unbiased random bits and see whether it lies outside that range of values &mdash; and thus produce a sample from <em>f</em>(<em>&lambda;</em>) without flipping the input coin again.</p>

<p><small><sup>&dagger;</sup> For example, by translating the number to input bits via Pae&#39;s entropy-preserving binarization (Pae 2018)[^19].  But correctness might depend on how this is done; after all, the number of coin flips per sample must equal or exceed the entropy bound for every <em>&lambda;</em>.</small></p>

<p><a id=Proofs_for_Function_Approximation_Schemes></a></p>

<h3>Proofs for Function Approximation Schemes</h3>

<p>This section shows mathematical proofs for some of the approximation schemes of this page.</p>

<p>In the following results:</p>

<ul>
<li>A <em>strictly bounded factory function</em> means a continuous function on the closed interval [0, 1], with a minimum of greater than 0 and a maximum of less than 1.</li>
<li>A function <em>f</em>(<em>&lambda;</em>) is <em>polynomially bounded</em> if both <em>f</em>(<em>&lambda;</em>) and 1&minus;<em>f</em>(<em>&lambda;</em>) are bounded from below by min(<em>&lambda;</em><sup><em>n</em></sup>, (1&minus;<em>&lambda;</em>)<sup><em>n</em></sup>) for some integer <em>n</em> (Keane and O&#39;Brien 1994)[^14].</li>
<li>A <em>modulus of continuity</em> of a function <em>f</em> means a non-negative and nondecreasing function <em>&omega;</em> on the interval [0, 1], for which <em>&omega;</em>(0) = 0, and for which abs(f(<em>x</em>) &minus; f(<em>y</em>)) &le; <em>&omega;</em>(abs(<em>x</em>&minus;<em>y</em>)) for every <em>x</em> in [0, 1] and every <em>y</em> in [0, 1].  Loosely speaking, a modulus of continuity <em>&omega;</em>(<em>&delta;</em>) is bounded below by <em>f</em>&#39;s maximum range in a window of size <em>&delta;</em>.</li>
</ul>

<p><strong>Lemma 1.</strong> <em>Let f(&lambda;) be a continuous and nondecreasing function, and let X<sub>k</sub> be a hypergeometric(2*n, k, n) random variable, where n&ge;1 is a constant integer and k is an integer in [0, 2*n] .  Then the expected value of f(X<sub>k</sub>/n) is nondecreasing as k increases.</em></p>

<p><em>Proof.</em> This is equivalent to verifying whether <em>X</em><sub><em>m</em>+1</sub>/<em>n</em> &quot;dominates&quot; <em>X</em><sub><em>m</em></sub>/<em>n</em> (and, obviously by extension, <em>X</em><sub><em>m</em>+1</sub> &quot;dominates&quot; <em>X</em><sub><em>m</em></sub>) in terms of first-degree stochastic dominance (Levy 1998)[^20].   This means that the probability that (<em>X</em><sub><em>m</em>+1</sub> &le; <em>j</em>) is less than or equal to that for <em>X</em><sub><em>m</em></sub> for each <em>j</em> in the interval [0, <em>n</em>].  A proof of this was given by the user &quot;Henry&quot; of the <em>Mathematics Stack Exchange</em> community[^21]. &#x25a1;</p>

<p>Lemma 6(i) of Nacu and Peres (2005)[^1] can be applied to continuous functions beyond just Lipschitz continuous functions.  This includes <em>Hölder continuous</em> functions, namely continuous functions with no slope that&#39;s &quot;steeper&quot; than every &quot;nth&quot; root.</p>

<p><strong>Lemma 2.</strong> <em>Let f(&lambda;) be a continuous function that maps [0, 1] to [0, 1], and let X be a hypergeometric(2*n, k, n) random variable.</em></p>

<ol>
<li><em>Let &omega;(x) be a modulus of continuity of f.  If &omega; is continuous and concave on [0, 1], then the expression&mdash;<br>abs(<strong>E</strong>[f(X/n)] &minus; f(k/(2*n))),&nbsp;&nbsp;&nbsp;(1)<br>is bounded from above by&mdash;</em>

<ul>
<li><em>&omega;(sqrt(1/(8*n&minus;4))), for every integer n&ge;1 that&#39;s a power of 2,</em></li>
<li><em>&omega;(sqrt(1/(7*n))), for every integer n&ge;4 that&#39;s a power of 2,</em></li>
<li><em>&omega;(sqrt(1/(2*n))), for every integer n&ge;1 that&#39;s a power of 2, and</em></li>
<li><em>&omega;(sqrt( (k/(2*n)) * (1&minus;k/(2*n)) / (2*n&minus;1) )), for every n&ge;1 that&#39;s a power of 2.</em></li>
</ul></li>
<li><em>If f is &alpha;-Hölder continuous with Hölder constant M and with &alpha; in the interval (0, 1], then the expression (1) is bounded from above by&mdash;</em>

<ul>
<li><em>M*(1/(2*n))<sup>&alpha;/2</sup>, for every integer n&ge;1 that&#39;s a power of 2,</em></li>
<li><em>M*(1/(7*n))<sup>&alpha;/2</sup>, for every integer n&ge;4 that&#39;s a power of 2, and</em></li>
<li><em>M*(1/(8*n&minus;4))<sup>&alpha;/2</sup>, for every integer n&ge;1 that&#39;s a power of 2.</em></li>
</ul></li>
<li><em>If f has a second derivative whose absolute value is defined in all of [0, 1] and bounded from above by M, then the expression (1) is bounded from above by&mdash;</em>

<ul>
<li><em>(M/2)*(1/(7*n)), for every integer n&ge;4 that&#39;s a power of 2, and</em></li>
<li><em>(M/2)*(1/(8*n&minus;4)), for every integer n&ge;1 that&#39;s a power of 2.</em></li>
</ul></li>
<li><em>If f is convex, nondecreasing, and bounded from below by 0, then the expression (1) is bounded from above by <strong>E</strong>[f(Y/n)] for every integer n&ge;1 that&#39;s a power of 2, where Y is a hypergeometric(2*n, n, n) random variable.</em></li>
</ol>

<p><em>Proof.</em></p>

<ol>
<li><em>&omega;</em> is assumed to be non-negative because absolute values are non-negative.  To prove the first and second bounds: abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<em>k</em>/(2 * <em>n</em>))) &le; <strong>E</strong>[abs(<em>f</em>(<em>X</em>/<em>n</em>) &minus; <em>f</em>(<em>k</em>/(2 * <em>n</em>))] &le; <strong>E</strong>[<em>&omega;</em>(abs(<em>X</em>/<em>n</em> &minus; <em>k</em>/(2 * <em>n</em>))] &le; <em>&omega;</em>(<strong>E</strong>[abs(<em>X</em>/<em>n</em> &minus; <em>k</em>/(2 * <em>n</em>))]) (by Jensen&#39;s inequality and because <em>&omega;</em> is concave) &le; <em>&omega;</em>(sqrt(<strong>E</strong>[abs(<em>X</em>/<em>n</em> &minus; <em>k</em>/(2 * <em>n</em>))]<sup>2</sup>)) = <em>&omega;</em>(sqrt(<strong>Var</strong>[<em>X</em>/<em>n</em>])) = <em>&omega;</em>(sqrt((<em>k</em>*(2 * <em>n</em>&minus;<em>k</em>)/(4*(2 * <em>n</em>&minus;1)*<em>n</em><sup>2</sup>)))) &le; <em>&omega;</em>(sqrt((<em>n</em><sup>2</sup>/(4*(2 * <em>n</em>&minus;1)*<em>n</em><sup>2</sup>)))) = <em>&omega;</em>(sqrt((1/(8*<em>n</em>&minus;4)))) = <em>&rho;</em>, and for every <em>n</em>&ge;4 that&#39;s an integer power of 2, <em>&rho;</em> &le; <em>&omega;</em>(sqrt(1/(7*<em>n</em>))).  To prove the third bound: abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<em>k</em>/(2 * <em>n</em>))) &le; <em>&omega;</em>(sqrt(<strong>Var</strong>[<em>X</em>/<em>n</em>])) &le; <em>&omega;</em>(sqrt(1/(2*n))).  To prove the fourth bound: abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<em>k</em>/(2 * <em>n</em>))) &le; <em>&omega;</em>(sqrt((<em>n</em><sup>2</sup>/(4*(2 * <em>n</em>&minus;1)*<em>n</em><sup>2</sup>)))) = <em>&omega;</em>(sqrt( (<em>k</em>/(2*<em>n</em>)) * (1&minus;<em>k</em>/(2*<em>n</em>)) / (2*<em>n</em>&minus;1) )).</li>
<li>By the definition of Hölder continuous functions, take <em>&omega;</em>(<em>x</em>) = <em>M</em>*<em>x</em><sup><em>&alpha;</em></sup>.  Because <em>&omega;</em> is a concave modulus of continuity on [0,1], the result follows from part 1.</li>
<li>abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<em>k</em>/(2 * <em>n</em>))) &le; (<em>M</em>/2)*<strong>Var</strong>[<em>X</em>/<em>n</em>] = (<em>M</em>/2)*(<em>k</em>*(2 * <em>n</em>&minus;<em>k</em>)/(4*(2 * <em>n</em>&minus;1)*<em>n</em><sup>2</sup>)) &le; (<em>M</em>/2)*(<em>n</em><sup>2</sup>/(4*(2 * <em>n</em>&minus;1)*<em>n</em><sup>2</sup>)) = (<em>M</em>/2)*(1/(8*<em>n</em>&minus;4)) = <em>&rho;</em>.  For every integer <em>n</em>&ge;4 that&#39;s a power of 2, <em>&rho;</em> &le;  (<em>M</em>/2)*(1/(7*<em>n</em>)).</li>
<li>Let <em>X</em><sub><em>m</em></sub> be a hypergeometric(2 * <em>n</em>, <em>m</em>, <em>n</em>) random variable.  By Lemma 1 and the assumption that <em>f</em> is nondecreasing, <strong>E</strong>[<em>f</em>(<em>X</em><sub><em>k</em></sub>/<em>n</em>)] is nondecreasing as <em>k</em> increases, so take <strong>E</strong>[<em>f</em>(<em>X</em><sub><em>n</em></sub>/<em>n</em>)] = <strong>E</strong>[<em>f</em>(<em>Y</em></sub>/<em>n</em>)] as the upper bound.  Then, abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<em>k</em>/(2 * <em>n</em>))) = abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<strong>E</strong>[<em>X</em>/<em>n</em>])) = <strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<strong>E</strong>[<em>X</em>/<em>n</em>]) (by Jensen&#39;s inequality, because <em>f</em> is convex and bounded by 0) = <strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] &minus; <em>f</em>(<em>k</em>/(2 * <em>n</em>)) &le; <strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] (because <em>f</em> is bounded by 0) &le; <strong>E</strong>[<em>f</em>(<em>Y</em>/<em>n</em>)]. &#x25a1;</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li><strong>E</strong>[.] means expected value (&quot;long-run average&quot;), and <strong>Var</strong>[.] means variance.  A hypergeometric(2 * <em>n</em>, <em>k</em>, <em>n</em>) random variable is the number of &quot;good&quot; balls out of <em>n</em> balls taken uniformly at random, all at once, from a bag containing 2 * <em>n</em> balls, <em>k</em> of which are &quot;good&quot;.</li>
<li><em>f</em> is <em>&alpha;</em>-Hölder continuous if its vertical slopes, if any, are no &quot;steeper&quot; than that of <em>M</em>*<em>&lambda;</em><sup><em>&alpha;</em></sup>, where <em>&alpha;</em> is in the interval (0, 1] and <em>M</em> is greater than 0.  An <em>&alpha;</em>-Hölder continuous function on the closed interval [0, 1] is also <em>&beta;</em>-Hölder continuous for any <em>&beta;</em> less than <em>&alpha;</em>.</li>
<li>Parts 1 and 2 exploit a tighter bound on <strong>Var</strong>[<em>X</em>/<em>n</em>] than the bound given in Nacu and Peres (2005, Lemma 6(i) and 6(ii), respectively)[^1].  However, for technical reasons, different bounds are proved for different ranges of integers <em>n</em>.</li>
<li>For part 3, as in Lemma 6(ii) of Nacu and Peres 2005, the second derivative need not be continuous (Y. Peres, pers. comm., 2021).</li>
<li>All continuous functions that map the closed interval [0, 1] to [0, 1], including all of them that admit a Bernoulli factory, have a modulus of continuity.  The proof of part 1 remains valid even if <em>&omega;</em>(0) &gt; 0, because the bounds proved remain correct even if <em>&omega;</em> is overestimated.  The following functions have a simple <em>&omega;</em> that satisfies the lemma:

<ol>
<li>If <em>f</em> is monotone increasing and convex, <em>&omega;</em>(<em>x</em>) can equal <em>f</em>(1) &minus; <em>f</em>(1&minus;<em>x</em>) (Gal 1990)[^22]; (Gal 1995)[^23].</li>
<li>If <em>f</em> is monotone decreasing and convex, <em>&omega;</em>(<em>x</em>) can equal <em>f</em>(0) &minus; <em>f</em>(<em>x</em>) (Gal 1990)[^22]; (Gal 1995)[^23].</li>
<li>If <em>f</em> is monotone increasing and concave, <em>&omega;</em>(<em>x</em>) can equal <em>f</em>(<em>x</em>) &minus; <em>f</em>(0) (by symmetry with 2).</li>
<li>If <em>f</em> is monotone decreasing and concave, <em>&omega;</em>(<em>x</em>) can equal <em>f</em>(1&minus;<em>x</em>) &minus; <em>f</em>(1) (by symmetry with 1).</li>
<li>If <em>f</em> is concave and is monotone increasing then monotone decreasing, then <em>&omega;</em>(<em>h</em>) can equal (<em>f</em>(min(<em>h</em>, <em>&sigma;</em>))+(<em>f</em>(1&minus;min(<em>h</em>, 1&minus;<em>&sigma;</em>))&minus;<em>f</em>(1)), where <em>&sigma;</em> is the point where <em>f</em> stops increasing and starts decreasing (Anastassiou and Gal 2012)[^24].</li>
</ol></li>
</ol>
</blockquote>

<p><strong>Theorem 1.</strong> <em>Let &omega;(x) be as described in part 1 of Lemma 2, and let f(&lambda;) be a strictly bounded factory function. Let&mdash;</em></p>

<p><em>&eta;(n) = &eta;(2<sup>m</sup>) = &sum;<sub>k=m, m+1,...</sub> &phi;(2<sup>k</sup>),</em></p>

<p><em>for every integer n&ge;1 that&#39;s a power of 2 (with n=2<sup>m</sup>), where &phi;(n) is either&mdash;</em></p>

<ul>
<li><em>&omega;(sqrt(1/(8*n&minus;4))), or</em></li>
<li><em>&omega;(sqrt(1/(2*n))).</em></li>
</ul>

<p><em>If the infinite series &eta;(n) converges, then the following approximation scheme for f(&lambda;) is valid in the following sense: By forming two sequences of polynomials in Bernstein form with coefficients <strong>fabove</strong>(n, k) for the upper polynomials, and <strong>fbelow</strong>(n, k) for the lower polynomials, then those polynomials meet conditions (i), (iii), and (iv) of Proposition 3 of Nacu and Peres (2005)[^1], for every integer n&ge;1 that&#39;s a power of 2, by defining <strong>fabove</strong> and <strong>fbelow</strong> as follows:</em></p>

<ul>
<li><em><strong>fbelow</strong>(n, k) = f(k/n) &minus; &eta;(n).</em></li>
<li><em><strong>fabove</strong>(n, k) = f(k/n) + &eta;(n).</em></li>
</ul>

<p><em>Except that the following bounding note applies: If <strong>fabove</strong>(n, k) &gt; 1 for a given n and some k, <strong>fabove</strong>(n, k) = 1 instead for that n, and if <strong>fbelow</strong>(n, k) &lt; 0 for a given n and some k, <strong>fbelow</strong>(n, k) = 0 instead for that n.</em></p>

<p><em>Proof.</em> Follows from part 1 of Lemma 2 above as well as Remark B and the proof of Proposition 10 of Nacu and Peres (2005)[^1].</p>

<p>For the series <em>&eta;</em>(<em>n</em>) in the theorem, each term of the series is nonnegative making the series nonnegative and, by the assumption that the series converges, <em>&eta;</em>(<em>n</em>) is nonincreasing with increasing <em>n</em>.</p>

<p>Condition (i) says that the coefficients <strong>fbelow</strong> and <strong>fabove</strong> must be bounded by 0 and 1.  This is ensured starting with a large enough value of <em>n</em> greater than 0, call it <em>n</em><sub>0</sub>, as shown next.</p>

<p>Let <em>&epsilon;</em> be a positive distance between 0 and the minimum or between 1 and the maximum of <em>f</em>, whichever is smaller.  This <em>&epsilon;</em> exists by the assumption that <em>f</em> is bounded away from 0 and 1. Because the series <em>&eta;</em> converges, <em>&eta;</em>(<em>n</em>) will eventually stay less than <em>&epsilon;</em>.  And the <code>f(k/n)</code> term is bounded by the minimum and maximum of <em>f</em> by construction.  This combined means that the coefficients <strong>fbelow</strong> and <strong>fabove</strong> will eventually be bounded by 0 and 1 for every integer <em>n</em> starting with <em>n</em><sub>0</sub>.</p>

<p>For <em>n</em> less than <em>n</em><sub>0</sub>, condition (i) is ensured by setting <strong>fbelow</strong> and <strong>fabove</strong> to 0 or 1, respectively, whenever a coefficient of the degree-<em>n</em> polynomial would otherwise be outside the bounds.</p>

<p>Condition (iii) says that the upper polynomials must converge to <em>f</em> and so must the lower polynomials.  This is ensured in a similar way as in Proposition 10, as well as by the assumption that the series converges: as <em>n</em> goes to infinity, <em>&eta;</em>(<em>n</em>) goes to 0 so that the coefficients, and thus the polynomials, converge to <em>f</em>.  For <em>n</em> less than <em>n</em><sub>0</sub>, the values of <strong>fbelow</strong> and <strong>fabove</strong> can be 0 or 1 without affecting convergence.</p>

<p>Condition (iv) is the <em>consistency requirement</em> described earlier in this page. This is ensured as in Proposition 10 by bounding, from below, the offset by which to shift the approximating polynomials.  This lower bound is <em>&eta;</em>(<em>n</em>), a solution to the equation 0 = <em>&eta;</em>(<em>n</em>) &minus; <em>&eta;</em>(2 * <em>n</em>) &minus; <em>&phi;</em>(<em>n</em>) (see note below), where <em>&phi;</em> can take on either form given in the theorem. The solution given in the theorem is easy to prove by noting that this is a recursive process: we start by calculating the series for <em>n</em> = 2*<em>n</em>, then adding <em>&phi;</em>(<em>n</em>) to it, in effect working backwards and recursively, and we can easily see that we can calculate the series for <em>n</em> = 2*<em>n</em> only if the series converges, hence the assumption of a converging series. For <em>n</em><sub>0</sub>, the consistency requirement is maintained by noting that the degree-<em>n</em><sub>0</sub> polynomial&#39;s coefficients must be bounded by 0 and 1 by condition (i) so they will likewise be bounded by those of the lower and upper polynomials of degree less than <em>n</em><sub>0</sub>, and those polynomials are the constant 0 and the constant 1, respectively, as are their coefficients. &#x25a1;</p>

<blockquote>
<p><strong>Note:</strong> There is only one solution <em>&eta;</em>(<em>n</em>) in the case at hand.  Unlike so-called <a href="https://math.stackexchange.com/questions/3993739"><strong><em>functional equations</em></strong></a> and linear recurrences, with a solution that varies depending on the starting value, there is only one solution in the case at hand, namely the solution that makes the series converge, if it exists at all.  Alternatively, the equation can be expanded to 0 = <em>&eta;</em>(<em>n</em>) &minus; <em>&eta;</em>(4 * <em>n</em>) &minus; <em>&phi;</em>(2*<em>n</em>) &minus; <em>&phi;</em>(<em>n</em>) = <em>&eta;</em>(<em>n</em>) &minus; <em>&eta;</em>(8 * <em>n</em>) &minus; <em>&phi;</em>(4*<em>n</em>) &minus; <em>&phi;</em>(2*<em>n</em>) &minus; <em>&phi;</em>(<em>n</em>) = ...</p>
</blockquote>

<p><strong>Corollary 1.</strong> <em>Let f(&lambda;) be a strictly bounded factory function. If f is &alpha;-Hölder continuous with Hölder constant M and with &alpha; in the interval (0, 1], then the following approximation scheme determined by <strong>fbelow</strong> and <strong>fabove</strong> is valid in the sense of Theorem 1, subject to the bounding note:</em></p>

<ul>
<li><em><strong>fbelow</strong>(n, k) = f(k/n) &minus; &delta;(n).</em></li>
<li><em><strong>fabove</strong>(n, k) = f(k/n) + &delta;(n).</em></li>
</ul>

<p><em>Where D(n) = M/((2<sup>&alpha;/2</sup>&minus;1)*n<sup>&alpha;/2</sup>).</em></p>

<p><em>Proof.</em> Follows from Theorem 1 by using the <em>&omega;</em> given in part 2 of Lemma 2, and by using <em>&phi;</em>(<em>n</em>) = <em>&omega;</em>(sqrt(1/(2*<em>n</em>))). &#x25a1;</p>

<blockquote>
<p><strong>Note:</strong> For specific values of <em>&alpha;</em>, the equation <em>D</em>(<em>n</em>) = <em>D</em>(2 * <em>n</em>) + <em>&phi;</em>(<em>n</em>) can be solved via linear recurrences; an example for <em>&alpha;</em> = 1/2 is the following SymPy code: <code>rsolve(Eq(f(n),f(n+1)+z*(1/(2*2**n))**((S(1)/2)/2)),f(n)).subs(n,ln(n,2)).simplify()</code>.  Trying different values of <em>&alpha;</em> suggested the following formula for Hölder continuous functions with <em>&alpha;</em> of 1/<em>j</em> or greater: (<em>M</em>* &sum;<sub><em>i</em> = 0,...,(<em>j</em>*2)&minus;1</sub> 2<sup><em>i</em>/(2*<em>j</em>)</sup>)/<em>n</em><sup>1/(2*<em>j</em>)</sup> = <em>M</em> / ((2<sup>1/(2*<em>j</em>)</sup>&minus;1)*<em>n</em><sup>1/(2*<em>j</em>)</sup>); and generalizing the latter expression led to the term in the theorem.</p>
</blockquote>

<p><strong>Corollary 2.</strong> <em>Let f(&lambda;) be a strictly bounded factory function.  If f is Lipschitz continuous with Lipschitz constant M, then the following approximation scheme determined by <strong>fbelow</strong> and <strong>fabove</strong> is valid in the sense of Theorem 1, subject to the bounding note:</em></p>

<ul>
<li><em><strong>fbelow</strong>(n, k) = f(k/n) &minus; M/((sqrt(2)&minus;1)*sqrt(n)).</em></li>
<li><em><strong>fabove</strong>(n, k) = f(k/n) + M/((sqrt(2)&minus;1)*sqrt(n)).</em></li>
</ul>

<p><em>Proof.</em> Because Lipschitz continuous functions are 1-Hölder continuous with Hölder constant <em>M</em>, the result follows from Corollary 1. &#x25a1;</p>

<blockquote>
<p><strong>Note:</strong> This special case of Theorem 1 was already found by Nacu and Peres (2005)[^1].</p>
</blockquote>

<p><strong>Theorem 2.</strong> <em>Let f(&lambda;) be a strictly bounded factory function, and let &omega;(x) be as described in Theorem 1. Theorem 1 remains valid with the following versions of &phi;(n), <strong>fbelow</strong>, and <strong>fabove</strong>, rather than as given in that theorem, subject to the bounding note:</em></p>

<ul>
<li><em>&phi;(n) = &omega;(sqrt(1/(7*n))).</em></li>
<li><em><strong>fbelow</strong>(n, k) = min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), ..., <strong>fbelow</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) &minus; &eta;(n).</em></li>
<li><em><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), ..., <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) + &eta;(n).</em></li>
</ul>

<p><em>Proof.</em>  Follows from Theorem 1 and part 1 of Lemma 2 above, as well as Remark B and the proof of Proposition 10 of Nacu and Peres, including the observation in Remark B of the paper that we can start the algorithm from <em>n</em> = 4; in that case, the upper and lower polynomials of degree 1 through 3 above would be constant functions, so that as polynomials in Bernstein form, the coefficients of each one would be equal.  With the <em>&phi;</em> given in this theorem, the series <em>&eta;</em>(<em>n</em>) in Theorem 1 remains nonnegative; also, this theorem adopts Theorem 1&#39;s assumption that the series converges, so that <em>&eta;</em>(<em>n</em>) still decreases with increasing <em>n</em>. &#x25a1;</p>

<p><strong>Corollary 3.</strong> <em>Let f(&lambda;) be a strictly bounded factory function. If f is &alpha;-Hölder continuous with Hölder constant M and with &alpha; in the interval (0, 1], then the following approximation scheme is valid in the sense of Theorem 1, subject to the bounding note:</em></p>

<ul>
<li><em><strong>fbelow</strong>(n, k) = min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), ..., <strong>fbelow</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) &minus; &eta;(n).</em></li>
<li><em><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), ..., <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) + &eta;(n).</em></li>
</ul>

<p><em>Where &eta;(n) = M*(2/7)<sup>&alpha;/2</sup>/((2<sup>&alpha;/2</sup>&minus;1)*n<sup>&alpha;/2</sup>).</em></p>

<p><em>Proof.</em> Follows from Theorem 2 by using the <em>&omega;</em> given in part 2 of Lemma 2. &#x25a1;</p>

<p><strong>Theorem 3.</strong> <em>Let f(&lambda;) be a strictly bounded factory function.  If f has a second derivative whose absolute value is defined in all of [0, 1] and bounded from above by M, then the following approximation scheme is valid in the sense of Theorem 1, subject to the bounding note:</em></p>

<ul>
<li><em><strong>fbelow</strong>(n, k) = min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), ..., <strong>fbelow</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) &minus; M/(7*n).</em></li>
<li><em><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), ..., <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) + M/(7*n).</em></li>
</ul>

<p><em>Proof.</em>  Because (<em>M</em>/2)*(1/(7*<em>n</em>)) in part 3 of Lemma 2 is bounded the same way as the statement <em>&omega;</em>(sqrt(1/(7*n))) in Theorem 2 and part 1 of Lemma 2, take <em>&omega;</em>(<em>n</em>) as (<em>M</em>/2)*(1/(7*<em>n</em>)).  Then the result follows from Theorem 2.  &#x25a1;</p>

<p><strong>Theorem 4.</strong> <em>Let f(&lambda;) be a strictly bounded factory function.  If f is convex and nondecreasing, then Theorem 1 remains valid with &phi;(n) = <strong>E</strong>[f(Y/n)] (where Y is a hypergeometric(2*n, n, n) random variable), rather than as given in that theorem.</em></p>

<p><em>Proof.</em>  Follows from Theorem 1 and part 4 of Lemma 2 above. With the <em>&phi;</em> given in this theorem, the series <em>&eta;</em>(<em>n</em>) in Theorem 1 remains nonnegative; also, this theorem adopts Theorem 1&#39;s assumption that the series converges, so that <em>&eta;</em>(<em>n</em>) still decreases with increasing <em>n</em>. &#x25a1;</p>

<p><strong>Proposition 1.</strong></p>

<ol>
<li><em>Let f be as given in any of Theorems 1 through 4, except that f must be concave and polynomially bounded and may have a minimum of 0. Then the approximation scheme of that theorem remains valid if <strong>fbelow</strong>(n, k) = f(k/n), rather than as given in that theorem.</em></li>
<li><em>Let f be as given in any of Theorems 1 through 4, except that f must be convex and polynomially bounded and may have a maximum of 1.  Then the approximation scheme of that theorem remains valid if <strong>fabove</strong>(n, k) = f(k/n), rather than as given in that theorem.</em></li>
<li><p><em>Theorems 1 through 4 can be extended to all integers n&ge;1, not just those that are powers of 2, by defining&mdash;</em></p>

<ul>
<li><em><strong>fbelow</strong>(n, k) = (k/n)*<strong>fbelow</strong>(n&minus;1, max(0, k&minus;1)) + ((n&minus;k)/n)*<strong>fbelow</strong>(n&minus;1, min(n&minus;1, k)), and</em></li>
<li><em><strong>fabove</strong>(n, k) = (k/n)*<strong>fabove</strong>(n&minus;1, max(0, k&minus;1)) + ((n&minus;k)/n)*<strong>fabove</strong>(n&minus;1, min(n&minus;1, k)),</em></li>
</ul>

<p><em>for every integer n&ge;1 other than a power of 2. Parts 1 and 2 of this proposition still apply to the modified scheme.</em></p></li>
</ol>

<p><em>Proof.</em> Parts 1 and 2 follow from Theorems 1 through 4, as the case may be.  For part 1, the lower polynomials are replaced by the degree-<em>n</em> Bernstein approximations of <em>f</em>, and they meet the conditions in those theorems by Jensen&#39;s inequality.  For part 2, the upper polynomials are involved instead of the lower polynomials.  Part 3 also follows from Remark B of Nacu and Peres (2005)[^1]. &#x25a1;</p>

<p><a id=Example_of_Approximation_Scheme></a></p>

<h3>Example of Approximation Scheme</h3>

<p>The following example uses the results above to build an approximation scheme for a factory function.</p>

<p>Let <em>f</em>(<em>&lambda;</em>) = 0 if <em>&lambda;</em> is 0, and (ln(<em>&lambda;</em>/exp(3)))<sup>&minus;2</sup> otherwise.  Then the following approximation scheme is valid in the sense of Theorem 1:</p>

<ul>
<li><em>&eta;</em>(<em>k</em>) = &Phi;(1, 2, (ln(<em>k</em>)+ln(7)+6)/ln(2))*4/ln(2)<sup>2</sup>.</li>
<li><strong>fbelow</strong>(n, k) = f(<em>k</em>/<em>n</em>).</li>
<li><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), ..., <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(<em>k</em>/<em>n</em>) +  <em>&eta;</em>(<em>n</em>).</li>
</ul>

<p>Where &Phi;(.) is a function called the <em>Lerch transcendent</em>, and <strong>fabove</strong> is subject to Theorem 1&#39;s bounding note.</p>

<p>Notice that the function <em>f</em> is not Hölder continuous; its slope is exponentially steep at the point 0.</p>

<p>The first step is to find a concave modulus of continuity of <em>f</em> (called <em>&omega;</em>(<em>h</em>)).  Because <em>f</em> is monotone increasing and concave, and because <em>f</em>(0) = 0, we can take <em>&omega;</em>(<em>h</em>) = <em>f</em>(<em>h</em>).</p>

<p>Now, by plugging sqrt(1/(7*<em>n</em>)) into <em>&omega;</em>, we get the following for Theorem 2 (assuming <em>n</em>&ge;0):</p>

<ul>
<li><em>&phi;</em>(<em>n</em>) = 1/(ln(sqrt(7/<em>n</em>)/7)&minus;3)<sup>2</sup>.</li>
</ul>

<p>Now, by applying Theorem 1, we compute <em>&eta;</em>(<em>k</em>) by substituting <em>n</em> with 2<sup><em>n</em></sup>, summing over [<em>k</em>, &infin;), and substituting <em>k</em> with log2(<em>k</em>).  <em>&eta;</em> converges, resulting in:</p>

<ul>
<li><em>&eta;</em>(<em>k</em>) = &Phi;(1, 2, (ln(<em>k</em>)+ln(7)+6)/ln(2))*4/ln(2)<sup>2</sup>,</li>
</ul>

<p>where &Phi;(.) is the Lerch transcendent.  This <em>&eta;</em> matches the <em>&eta;</em> given in the scheme above.  That scheme then follows from Theorems 1 and 2, as well as from part 1 of Proposition 1 because <em>f</em> is concave.</p>

<p>The following SymPy code is an example of finding the parameters for this approximation scheme.</p>

<pre>px=Piecewise((0,Eq(x,0)),((ln(x/exp(3))**-2),True))
# omega is modulus of continuity.  Since
# px is monotone increasing, concave, and px(0)=0,
# we can take omega as px
omega=px
omega=piecewise_fold(omega.rewrite(Piecewise)).simplify()
# compute omega
phi=omega.subs(x,sqrt(1/(7*n)))
pprint(phi)
# compute eta
eta=summation(phi.subs(n,2**n),(n,k,oo)).simplify()
pprint(eta)
for i in range(20):
  # Calculate upper bounds for eta at certain points.
  try:
    print(&quot;eta(2^%d) ~= %s&quot; % (i,ceiling(eta.subs(k,i)*10000000).n()/10000000))
  except:
    print(&quot;eta(2^%d) ~= [FAILED]&quot; % (i))
</pre>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
