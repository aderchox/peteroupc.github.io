<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Supplemental Notes for Bernoulli Factory Algorithms</title><meta name="citation_title" content="Supplemental Notes for Bernoulli Factory Algorithms"><meta name="og:title" content="Supplemental Notes for Bernoulli Factory Algorithms"><meta name="og:type" content="article"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Supplemental Notes for Bernoulli Factory Algorithms"><meta name="author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Supplemental Notes for Bernoulli Factory Algorithms</h1>

<p><a id=General_Factory_Functions></a></p>

<h2>General Factory Functions</h2>

<p>The algorithms for <a href="https://peteroupc.github.io/bernoulli.html"><strong>general factory functions</strong></a> work with two sequences of polynomials: one approaches the function <em>f</em>(<em>&lambda;</em>) from above, the other from below, where <em>f</em> is a continuous function that maps the interval (0, 1) to (0, 1).  (These two sequences form a so-called <em>approximation scheme</em> for <em>f</em>.) One requirement for these algorithms to work correctly is called the <em>consistency requirement</em>:</p>

<ul>
<li>For each sequence, the difference between one polynomial and the previous one must have non-negative Bernstein coefficients (once the latter polynomial is elevated to the same degree as the other).</li>
</ul>

<p>The consistency requirement ensures that the polynomials approach the target function without crossing each other.  Unfortunately, the reverse is generally not true; even if the upper polynomials &quot;decrease&quot; and the lower polynomials &quot;increase&quot; to <em>f</em>, this does not mean that the scheme will ensure consistency.  And indeed this is the case for many approximation schemes given in the literature.  The following are schemes with counterexamples to the consistency requirement.</p>

<p><a id=Schemes_That_Don_t_Work></a></p>

<h3>Schemes That Don&#39;t Work</h3>

<p><strong>First scheme.</strong> In this scheme (Powell 1981)<sup><a href="#Note1"><strong>(1)</strong></a></sup>, let <em>f</em> be a twice differentiable function (that is, a C2 continuous function, or a function with continuous &quot;slope&quot; and &quot;slope-of-slope&quot; functions).  Then the upper polynomial of degree <em>n</em> has Bernstein coefficients as follows, for all <em>n</em>&ge;1:</p>

<ul>
<li><em>b</em>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) + M / (8*<em>n</em>),</li>
</ul>

<p>where M is an upper bound of the maximum absolute value of <em>f</em>&#39;s slope-of-slope function (second derivative), and where <em>k</em> is an integer in the interval [0, <em>n</em>].</p>

<p>And the lower polynomial of degree <em>n</em> has Bernstein coefficients as follows:</p>

<ul>
<li>a(n, k) = f(k/n) + M / (8*n).</li>
</ul>

<p>The counterexample is given at: <a href="https://math.stackexchange.com/a/3945261/721857"><strong>https://math.stackexchange.com/a/3945261/721857</strong></a></p>

<p><strong>Second scheme.</strong> In this scheme, let <em>f</em> be a Lipschitz continuous function in [0, 1] (that is, a function whose slope does not tend to a vertical slope anywhere in [0, 1]).  Then the upper polynomial of degree <em>n</em> has Bernstein coefficients as follows, for all n&ge;2:</p>

<ul>
<li>b(n, k) = f(k/n) + (5/4) / sqrt(n),</li>
</ul>

<p>where L is the maximum absolute &quot;slope&quot;, also known as the Lipschitz constant, and (5/4) is the so-called Popoviciu constant, and where <em>k</em> is an integer in the interval [0, <em>n</em>] (Lorentz 1986)<sup><a href="#Note2"><strong>(2)</strong></a></sup>, (Popoviciu 1935)<sup><a href="#Note3"><strong>(3)</strong></a></sup>.</p>

<p>And the lower polynomial of degree <em>n</em> has Bernstein coefficients as follows, for all n&ge;1:</p>

<ul>
<li>a(n, k) = f(k/n) + (5/4) / sqrt(n).</li>
</ul>

<p>The following counterexamples show that this scheme can fail to ensure consistency, even if the set of functions is restricted to &quot;smooth&quot; functions (not just Lipschitz continuous functions).</p>

<p>For the first counterexample, the function <em>g</em>(<em>&lambda;</em>) = min(<em>&lambda;</em>, 1&minus;<em>&lambda;</em>)/2 is Lipschitz continuous with Lipschitz constant 1.  (In addition, <em>g</em> has a kink at 1/2, so that it&#39;s not differentiable, but this is not essential for the counterexample.)</p>

<p>For <em>g</em>, the Bernstein coefficients for&mdash;</p>

<ul>
<li>the degree-5 upper polynomial (b(5, k)) are [0.4874..., 0.5874..., 0.6874..., 0.6874..., 0.5874..., 0.4874...], and</li>
<li>the degree-6 upper polynomial (b(6, k)) are [0.4449..., 0.5283..., 0.6116..., 0.6949..., 0.6116..., 0.5283..., 0.4449...].</li>
</ul>

<p>The degree-5 polynomial lies above the degree-6 polynomial everywhere in [0, 1].  However, to ensure consistency, the degree-5 polynomial, once elevated to degree 6, must have Bernstein coefficients that are greater than or equal to those of the degree-6 polynomial.</p>

<ul>
<li>Once elevated to degree 6, the degree-5 polynomial&#39;s coefficients are [0.4874..., 0.5707..., 0.6541..., 0.6874..., 0.6541..., 0.5707..., 0.4874...].</li>
</ul>

<p>As we can see, the elevated polynomial&#39;s coefficient 0.6874... is less than the corresponding coefficient 0.6949... for the degree-6 polynomial.</p>

<p>There is a similar counterexample that can be built:</p>

<ul>
<li>When <em>g</em> = sin(4*<em>&pi;</em>*<em>&lambda;</em>)/4 + 1/2, a &quot;smooth&quot; function with Lipschitz constant <em>&pi;</em>, the counterexample is present between the degree-3 and degree-4 lower polynomials.</li>
</ul>

<p>Thus, we have shown that this approximation scheme is not guaranteed to meet the consistency requirement for all Lipschitz continuous functions.</p>

<p>It is yet to be seen whether a counterexample exists for this scheme when <em>n</em> is restricted to powers of 2.</p>

<p><strong>Third scheme.</strong> Same as the second scheme, but replacing (5/4) with the Sikkema constant, <em>S</em> = (4306+837*sqrt(6))/5832 (Lorentz 1986)<sup><a href="#Note2"><strong>(2)</strong></a></sup>, (Sikkema 1961)<sup><a href="#Note4"><strong>(4)</strong></a></sup>.   In fact, the same counterexamples for the second scheme apply to this one, since this scheme merely multiplies the offset to bring the approximating polynomials closer to <em>f</em>.</p>

<p>For example, the first counterexample for this scheme is almost the same as the first one for the second scheme, except the coefficients for&mdash;</p>

<ul>
<li>the degree-5 upper polynomial are [0.5590..., 0.6590..., 0.7590..., 0.7590..., 0.6590..., 0.5590...], and</li>
<li>the degree-6 upper polynomial are [0.5103..., 0.5936..., 0.6770..., 0.7603..., 0.6770..., 0.5936..., 0.5103...].</li>
</ul>

<p>And once elevated to degree 6, the degree-5 polynomial&#39;s coefficients are [0.5590..., 0.6423..., 0.7257..., 0.7590..., 0.7257..., 0.6423..., 0.5590...].</p>

<p>As we can see, the elevated polynomial&#39;s coefficient 0.7590... is less than the corresponding coefficient 0.7603... for the degree-6 polynomial.</p>

<p><a id=Other_Schemes></a></p>

<h3>Other Schemes</h3>

<p>There is an easy extension to lemma 6(i) of Nacu and Peres (2005)<sup><a href="#Note4"><strong>(4)</strong></a></sup> to certain functions with a slope that tends to a vertical slope.  Specifically, it applies to any <em>Hölder continuous</em> function, which means a continuous function whose slope doesn&#39;t go exponentially fast to a vertical slope (the parameters <em>&alpha;</em> and <em>M</em> mean that the function is no &quot;steeper&quot; than <em>M</em>*<em>x</em><sup><em>&alpha;</em></sup>; <em>&alpha;</em> is in the interval (0, 1] and <em>M</em> is greater than 0). As a special case, Lipschitz continuous functions have <em>&alpha;</em> = 1 and <em>M</em> equal to their Lipschitz constant.</p>

<p><strong>Lemma 1.</strong> <em>Let f(&lambda;) be an &alpha;-Hölder continuous function with Hölder constant M that maps [0, 1] to [&minus;1, 1], and let X be a hypergeometric(2*n, k, n) random variable.  Then abs(<strong>E</strong>[f(X/n)] &minus; f(k/(2*n))) is bounded from above by M*(1/(2*n))<sup>&alpha;/2</sup>. (<strong>E</strong>[.] means expected or average value, and <strong>Var</strong>[.] means variance.)</em></p>

<p><em>Proof.</em> abs(<strong>E</strong>[f(X/n)] &minus; f(k/(2*n))) &le; <strong>E</strong>[abs(f(X/n) &minus; f(k/(2*n))] &le; <em>M</em>*<strong>E</strong>[abs(<em>X</em>/<em>n</em> &minus; <em>k</em>/(2*<em>n</em>))]<sup><em>&alpha;</em></sup> (by the definition of Hölder continuous functions) &le; <em>M</em>*(<strong>E</strong>[abs(<em>X</em>/<em>n</em> &minus; <em>k</em>/(2*<em>n</em>))]<sup>2</sup>)<sup><em>&alpha;</em>/2</sup> = &le; <em>M</em>*<strong>Var</strong>[<em>X</em>/<em>n</em>]<sup><em>&alpha;</em>/2</sup> &le; <em>M</em>*(1/(2*<em>n</em>))<sup><em>&alpha;</em>/2</sup>.  &#x25a1;</p>

<p><strong>Theorem 1.</strong> <em>Let f(&lambda;) be an &alpha;-Hölder continuous function with Hölder constant M that maps (0, 1) to (0, 1). The following Bernstein coefficients (a(n, k) for the upper polynomials, and b(n, k) for the lower polynomials, for all n&ge;1 that are powers of 2) form an approximation scheme that meets conditions (i), (iii), and (iv) of Proposition 3 of Nacu and Peres (2005)<sup><a href="#Note4"><strong>(4)</strong></a></sup>, for all n&ge;1, and thus can be used to simulate f via the algorithms for general factory functions described at the top of this article:</em></p>

<ul>
<li><em>a(n, k) = f(k/n) &minus; &delta;(n) (kth Bernstein coefficient of lower nth degree polynomial).</em></li>
<li><em>b(n, k) = f(k/n) + &delta;(n); (kth Bernstein coefficient of upper nth degree polynomial).</em></li>
</ul>

<p><em>Where &delta;(n) is a solution to the functional equation &delta;(n) = &delta;(2*n) + M*(1/(2*n))<sup>&alpha;/2</sup>.</em></p>

<p><em>Proof.</em> Follows from Lemma 1 above as well as Proposition 10 of Nacu and Peres (2005)<sup><a href="#Note4"><strong>(4)</strong></a></sup>.  &#x25a1;</p>

<p>Unfortunately, there is no easy way to solve the functional equation above in a way that works for all <em>&alpha;</em>.  However, the following examples show solutions that lead to approximation schemes that work for any <em>&alpha;</em>-Hölder continuous function with certain values of <em>&alpha;</em>.</p>

<ul>
<li>If <em>&alpha;</em> is 1/2 or greater: <em>&delta;</em>(<em>n</em>) = (<em>M</em>*(2<sup>1/4</sup> + 2<sup>2/4</sup> + 2<sup>3/4</sup> + 1))/<em>n</em><sup>1/4</sup>. (Solved via SymPy: <code>rsolve(Eq(f(n),f(n+1)+z*(1/(2*2**n))**((S(1)/2)/2)),f(n)).subs(n,log(n,2)).simplify()</code>.)</li>
<li>If <em>&alpha;</em> is 2/3 or greater: <em>&delta;</em>(<em>n</em>) = 2<sup>2/3</sup>*<em>M</em>*(2<sup>1/3</sup> + 2<sup>2/3</sup> + 2)/(2*<em>n</em><sup>1/3</sup>).</li>
</ul>

<p><a id=SymPy_Code_for_Building_Approximation_Schemes></a></p>

<h2>SymPy Code for Building Approximation Schemes</h2>

<p>The following Python code uses the SymPy computer algebra library. It contains a method, named <code>approxscheme2</code>, that builds a scheme for approximating a continuous function <em>f</em>(<em>&lambda;</em>) whose domain is [0, 1], with the help of polynomials that converge from above and below to that function.  Not all functions that admit a Bernoulli factory are supported yet.  One example of the output follows.</p>

<p>Note that because numerical methods may be used in some cases, and because only a finite number of polynomials are generated and checked by the code, the approximation scheme is not guaranteed to be correct in all cases.</p>

<p>The <code>approxscheme2</code> method takes these parameters:</p>

<ul>
<li><code>func</code>: SymPy expression of the desired function.</li>
<li><code>x</code>: Variable used by <code>func</code>.</li>
<li><code>double</code>: Whether to double the degree with each additional level (<code>True</code>, the default) or to increase that degree by 1 with each level (<code>False</code>).</li>
<li><code>kind</code>: a string specifying the approximation scheme, such as &quot;c2&quot; (see code for <code>buildParam</code>).</li>
<li><code>lip</code>: A manually determined parameter that depends on the &#39;kind&#39;, in case the parameter can&#39;t be found automatically.</li>
<li><code>levels</code>: Number of polynomial levels to generate.  The first level will be the polynomial of degree 2 for the kinds &quot;c1&quot;, &quot;c0&quot;, or &quot;sikkema&quot;, and degree 1 otherwise.  Default is 9.</li>
</ul>

<p>The method prints out text describing the approximation scheme, which can then be used in either of the <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory function algorithms</strong></a> to simulate <em>f</em>(<em>&lambda;</em>) given a black-box way to sample the probability <em>&lambda;</em>.  It refers to the functions <strong>fbelow</strong>, <strong>fabove</strong>, and <strong>fbound</strong>, which have the meanings given in those algorithms.</p>

<pre>def upperbound(x, boundmult=1000000000000000):
    # Calculates a limited-precision upper bound of x.
    boundmult = S(boundmult)
    return ceiling(x * boundmult) / boundmult

def lowerbound(x, boundmult=1000000000000000):
    # Calculates a limited-precision lower bound of x.
    boundmult = S(boundmult)
    return floor(x * boundmult) / boundmult

def degelev(poly, degs):
    # Degree elevation of Bernstein polynomials.
    # See also Tsai and Farouki 2001.
    n = len(poly) - 1
    ret = []
    nchoose = [math.comb(n, j) for j in range(n // 2 + 1)]
    degschoose = (
        nchoose if degs == n else [math.comb(degs, j) for j in range(degs // 2 + 1)]
    )
    for k in range(0, n + degs + 1):
        ndk = math.comb(n + degs, k)
        c = 0
        for j in range(max(0, k - degs), min(n, k) + 1):
            degs_choose_kj = (
                degschoose[k - j]
                if k - j &lt; len(degschoose)
                else degschoose[degs - (k - j)]
            )
            n_choose_j = nchoose[j] if j &lt; len(nchoose) else nchoose[n - j]
            c += poly[j] * degs_choose_kj * n_choose_j / ndk
        ret.append(c)
    return ret

def buildOffset(kind, dd, n):
    if kind == &quot;c2&quot;:
        # Use the theoretical offset for twice
        # differentiable functions. dd=max. abs. second derivative
        return dd / (n * 2)
    elif kind == &quot;lipschitz&quot;:
        # Use the theoretical offset for Lipschitz
        # continuous functions. dd=max. abs. &quot;slope&quot;
        return dd * (1 + sqrt(2)) / sqrt(n)
    elif kind == &quot;sikkema&quot;:
        # Use the theoretical offset for C0
        # Lipschitz continuous functions involving Sikkema&#39;s constant.
        # (If the function is not Lipschitz continuous the formula
        # is sikkema*W(1/sqrt(n)), where W(h) is the function&#39;s
        # modulus of continuity.)
        sikkema = S(4306 + 837 * sqrt(6)) / 5832
        return sikkema * dd / sqrt(n)
    elif kind == &quot;c1&quot;:
        # Use the theoretical offset for C1
        # functions with a Lipschitz continuous slope.
        # dd=max. abs. &quot;slope-of-slope&quot; (Lipschitz constant
        # of first derivative). (G. G. Lorentz. Bernstein polynomials.
        # Chelsea Publishing Co., New York,second edition, 1986.)
        # (If the slope is not Lipschitz continuous the formula
        # is (3/4)*(1/sqrt(n))*W(1/sqrt(n)), where W(h)
        # is the _modulus of continuity_ of the slope function, that is,
        # the maximum difference between the highest and lowest
        # values of that function in any window of size h inside
        # the interval [0, 1]).
        return (S(3) / 4) * dd / n
    elif kind == &quot;c0&quot;:
        # Use the theoretical offset for C0
        # Lipschitz continuous functions involving a more trivial bound
        # (by Popoviciu)
        return (S(5) / 4) * dd / sqrt(n)
    else:
        raise ValueError

def nminmax(func, x):
    # Find minimum and maximum at [0,1].
    try:
        return [minimum(func, x, Interval(0, 1)), maximum(func, x, Interval(0, 1))]
    except:
        print(&quot;WARNING: Resorting to numerical optimization&quot;)
    cv = [0, 1]
    df = diff(func)
    for i in range(20):
        try:
            ns = nsolve(df, x, (S(i) / 20, S(i + 1) / 20), solver=&quot;bisect&quot;)
            cv.append(ns)
        except:
            cv.append(S(i)/20)
            cv.append(S(i+1)/20)
    # Evaluate at critical points, and
    # remove incomparable values
    cv2 = []
    for c in cv:
        c2=func.subs(x, c)
        # Change complex infinity to infinity
        if c2==zoo: c2=oo
        try:
           Min(c2)
           cv2.append(c2)
        except:
           pass
    cv=cv2
    return [Min(*cv).simplify(), Max(*cv).simplify()]

def buildParam(kind, func, x, lip=None):
    if kind == &quot;c2&quot; or kind == &quot;c1&quot;:
        try:
            # Maximum of second derivative.
            dd = nminmax(diff(diff(func)), x)
            dd = Max(Abs(dd[0]), Abs(dd[1])).simplify()
        except:
            # Unfortunately, SymPy&#39;s maximum and minimum are
            # not powerful enough to handle many common cases
            # of functions (notably piecewise functions), and
            # also has no convenient way to
            # minimize or maximize functions numerically.
            if lip == None:
                raise ValueError
            dd = S(lip)
    elif kind == &quot;lipschitz&quot; or kind == &quot;sikkema&quot; or kind == &quot;c0&quot;:
        try:
            # Maximum of first derivative (Lipschitz constant)
            ff = func.rewrite(Piecewise)
            dd = nminmax(diff(diff(func)), x)
            dd = Max(Abs(dd[0]), Abs(dd[1])).simplify()
        except:
            if lip == None:
                raise ValueError
            dd = S(lip)
    else:
        raise ValueError
    return dd

def consistencyCheckInner(prevcurve, newcurve, ratio=1, diagnose=False, conc=None):
    n, prevcurve, prevoffset = prevcurve
    n2, newcurve, newoffset = newcurve
    degs = n2 - n
    prevoffset *= ratio
    newoffset *= ratio
    # NOTE: For the &#39;above&#39; and &#39;below&#39; cases, bounds ensure that in case of doubt,
    # the approximation is judged to be inconsistent
    # Below
    belowbernconew = [lowerbound(a - newoffset) for a in newcurve]
    maxbernconew = max(belowbernconew)
    if maxbernconew &lt; 0:
        # Fully below 0
        pass  # return &quot;offcurve&quot;
    belowberncoold = degelev([upperbound(b - prevoffset) for b in prevcurve], degs)
    for oldv, newv in zip(belowberncoold, belowbernconew):
        if newv &lt; oldv:
            # Inconsistent approximation from below
            if diagnose:
                print(&quot;Inconsistent from below&quot;)
                print([&quot;n, n2, prevoffset, newoffset&quot;, n, n2, prevoffset, newoffset])
                print([S(c).n() for c in belowberncoold])
                print([S(c).n() for c in belowbernconew])
            return &quot;incons&quot;
    # Above
    bernconew = [upperbound(a + newoffset) for a in newcurve]
    minbernconew = min(bernconew)
    if minbernconew &gt; 1:
        # Fully above 1
        pass  # return &quot;offcurve&quot;
    berncoold = degelev([lowerbound(b + prevoffset) for b in prevcurve], degs)
    for oldv, newv in zip(berncoold, bernconew):
        if oldv &lt; newv:
            # Inconsistent approximation from above
            if diagnose:
                print(&quot;Inconsistent from above&quot;)
                print([&quot;n, n2, prevoffset, newoffset&quot;, n, n2, prevoffset, newoffset])
                print([S(c).n() for c in berncoold])
                print([S(c).n() for c in bernconew])
            return &quot;incons&quot;
    return True

def isinrange(curve, ratio):
    n, curve, offset = curve
    offset *= ratio
    for c in curve:
       lb=lowerbound(c-offset)
       ub=upperbound(c+offset)
       if lb&lt;0 or ub&gt;1: return False
    return True

def concavity(func,x):
   nm=nminmax(diff(diff(func)),x)
   if nm[0]&gt;=0: return &quot;convex&quot;
   if nm[1]&lt;=0: return &quot;concave&quot;
   return None

def consistencyCheckCore(curvedata, ratio, diagnose=False):
    for i in range(len(curvedata) - 1):
        cons = consistencyCheckInner(
            curvedata[i], curvedata[i + 1], ratio=ratio, diagnose=diagnose
        )
        if cons == &quot;incons&quot;:
            return False
    return True

def approxscheme2(func, x, kind=&quot;c2&quot;, lip=None, double=True, levels=9):
    print(func)
    curvedata = []
    if kind==&quot;c1&quot; or kind==&quot;c0&quot; or kind==&quot;sikkema&quot;:
       deg = 2
    else:
       deg = 1
    nmm=nminmax(func, x)
    if nmm[0] &lt; 0 or nmm[1] &gt; 1:
       print(&quot;Function does not admit a Bernoulli factory&quot;)
       return
    conc = concavity(func, x)
    if conc != &quot;concave&quot; and nmm[0]&lt;=0:
       print(&quot;Non-concave functions with minimum of 0 not yet supported&quot;)
       return
    if conc != &quot;convex&quot; and nmm[1]&gt;=1:
       print(&quot;Non-convex functions with maximum of 1 not yet supported&quot;)
       return
    dd = buildParam(kind, func, x, lip)
    if dd==oo or dd==zoo:
       print(&quot;Function not supported for the scheme %s&quot; % (kind))
       return
    if dd==0:
       if lip!=None:
           dd=S(lip)
       else:
           print(&quot;Erroneous parameter calculated for the scheme %s&quot; % (kind))
           return
    for i in range(1, levels + 1):
        offset = buildOffset(kind, dd, deg)
        curvedata.append(
            (deg, [func.subs(x, S(j) / deg) for j in range(deg + 1)], offset)
        )
        if double:
            deg *= 2
        else:
            deg += 1
    offset = buildOffset(kind, dd, 1)
    if not consistencyCheckCore(curvedata, Rational(1)):
        print(
            &quot;INCONSISTENT --&gt; offset=%s [dd=%s, kind=%s]&quot;
            % (S(offset).n(), upperbound(dd.n()).n(), kind)
        )
        consistencyCheckCore(curvedata, Rational(1), diagnose=True)
        return
    for cdlen in range(3, len(curvedata) + 1):
        left = Rational(0, 1)
        right = Rational(1, 1)
        for i in range(0, 6):
            mid = (left + right) / 2
            if consistencyCheckCore(curvedata[0:cdlen], mid):
                right = mid
            else:
                left = mid
        # NOTE: If &#39;ratio&#39; appears to stabilize to much less than 0, then the
        # approximation scheme is highly likely to be correct.
        print(
            &quot;consistent(len=%d) --&gt; offset_deg1=%s [ratio=%s, dd=%s, kind=%s]&quot;
            % (cdlen, S(offset * right).n(), right.n(), upperbound(dd.n()).n(), kind)
        )
    inrangedeg = -1
    for cd in curvedata:
        if isinrange(cd, right):
            inrangedeg=cd[0]
            break
    offsetn = buildOffset(kind, dd, symbols(&#39;n&#39;))
    offsetn *= right
    conc = concavity(func, x)
    data = &quot;* Let _f_(_&amp;lambda;_) = %s.  &quot; % (
        str(func.subs(x,symbols(&#39;lambda&#39;))).replace(&quot;*&quot;,&quot;\*&quot;))
    if double:
        data += &quot;Then, for all _n_ that are powers of 2, starting from 1:\n&quot;
    else:
        data += &quot;Then:\n&quot;
    data += &quot;    * **fbelow**(_n_, _k_) = &quot;
    if conc == &quot;convex&quot; and inrangedeg&gt;=0:
        data += &quot;1 if _n_&amp;lt;%d; otherwise, &quot; % (inrangedeg)
    data += &quot;_f_(_k_/_n_)&quot;
    if conc != &quot;concave&quot;:
       data += &quot; &amp;minus; `%s`&quot; % (str(offsetn.subs(x,symbols(&#39;lambda&#39;))).replace(&quot;*&quot;,&quot;\*&quot;))
    data += &quot;.\n&quot;
    data += &quot;    * **fabove**(_n_, _k_) = &quot;
    if conc == &quot;concave&quot; and inrangedeg&gt;=0:
        data += &quot;1 if _n_&amp;lt;%d; otherwise, &quot; % (inrangedeg)
    data += &quot;_f_(_k_/_n_)&quot;
    if conc != &quot;convex&quot;:
       data += &quot; + `%s`&quot; % (str(offsetn.subs(x,symbols(&#39;lambda&#39;))).replace(&quot;*&quot;,&quot;\*&quot;))
    data += &quot;.\n&quot;
    if inrangedeg&gt;=0:
       if conc == &quot;concave&quot; or conc == &quot;convex&quot;:
         data += (
           &quot;    * **fbound**(_n_) = [0, 1].\n&quot;
         )
       else:
         data += (
           &quot;    * **fbound**(_n_) = [0, 1] if _n_&amp;ge;%d, or [&amp;minus;1, 2] otherwise.\n&quot; % (inrangedeg)
         )
    print(data)
    return

</pre>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<ul>
<li><small><sup id=Note1>(1)</sup> Powell, M.J.D., <em>Approximation Theory and Methods</em>, 1981</small></li>
<li><small><sup id=Note2>(2)</sup> G. G. Lorentz. Bernstein polynomials. 1986.</small></li>
<li><small><sup id=Note3>(3)</sup> Popoviciu, T., &quot;Sur l&#39;approximation des fonctions convexes d&#39;ordre supérieur&quot;, Mathematica (Cluj), 1935.</small></li>
<li><small><sup id=Note4>(4)</sup> Sikkema, P.C., &quot;Der Wert einiger Konstanten in der Theorie der Approximation mit Bernstein-Polynomen&quot;, Numer. Math. 3 (1961).</small></li>
</ul>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
