<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Source: h3du.js</title>
<meta name="viewport" content="width=device-width">
<script src="mathml.js"></script>
<link rel=stylesheet type="text/css" href="/style.css">
</head>
<body style="margin-top:0px">
<div class="header">
<p><a href="#navigation">Menu</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
    <h1>Source: h3du.js</h1>

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* global JSON, Promise */
/**
* @license CC0-1.0
*/
/*
  Polyfills
*/
if(!window.requestAnimationFrame) {
  window.requestAnimationFrame = window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  if(!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(func) {
      "use strict";
      window.setTimeout(function() {
        func(window.performance.now());
      }, 17);
    };
  }
}
if(!window.performance) {
  window.performance = {};
}
if(!window.performance.now) {
  window.performance.now = function() {
    "use strict";
    return new Date().getTime() * 1000 - window.performance._startTime;
  };
  window.performance._startTime = new Date().getTime() * 1000;
}

/**
* The Public Domain HTML 3D Library contains classes and utility
* methods to ease the development of HTML 3D applications, such
* as Web sites, in browsers that support 3D drawing using the HTML5 Canvas.
* See the {@tutorial overview} tutorial.&lt;p>
* This page describes miscellaneous utility methods included in the
* library.
* @namespace
* @alias H3DU
*/
var H3DU = {
/**
* This method will call a function once before returning,
* and queue requests to call that function once per frame,
* using &lt;code>window.requestAnimationFrame&lt;/code>
* or a "polyfill" method.
* @param {Function} func The function to call.  The function
* takes one parameter, "time", which is the number of
* milliseconds since the page was loaded.
*/
  "renderLoop":function(func) {
    "use strict";
    func(window.performance.now());
    var selfRefFunc = function(time) {
      window.requestAnimationFrame(selfRefFunc);
      func(time);
    };
    window.requestAnimationFrame(selfRefFunc);
  },
/**
* Creates an HTML canvas element, optionally appending
* it to an existing HTML element.
* @param {HTMLElement|null} parent If non-null, the parent
* element of the new HTML canvas element. The element will be
* appended as a child of this parent.
* @param {number|null} width Width of the new canvas
* element, or if null, the width a &lt;code>canvas&lt;/code>
* element would ordinarily have
* under the CSS rules currently in effect where the canvas is. The resulting width will be rounded up.
* This parameter can't be a negative number.
* @param {number|null} height Height of the new canvas
* element, or if null, the height a &lt;code>canvas&lt;/code>
* element would ordinarily have
* under the CSS rules currently in effect where the canvas is. The resulting height will be rounded up.
* This parameter can't be a negative number.
* @returns {HTMLCanvasElement} The resulting canvas element.
*/
  "createCanvasElement":function(parent, width, height) {
    "use strict";
    var canvas = document.createElement("canvas");
    if(parent) {
      parent.appendChild(canvas);
    }
    if(width === null || typeof width === "undefined") {
      canvas.width = Math.ceil(canvas.clientWidth) + "";
    } else if(width &lt; 0) {
      throw new Error("width negative");
    } else {
      canvas.width = Math.ceil(width) + "";
    }
    if(height === null || typeof height === "undefined") {
      canvas.height = Math.ceil(canvas.clientHeight) + "";
    } else if(height &lt; 0) {
      throw new Error("height negative");
    } else {
      canvas.height = Math.ceil(height) + "";
    }
    return canvas;
  },
/**
* Creates a 3D rendering context from an HTML canvas element,
* falling back to a 2D context if that fails.
* @param {HTMLCanvasElement} canvasElement An HTML
* canvas element.
* @returns {WebGLRenderingContext} A 3D or 2D rendering context, or null
* if an error occurred in creating the context. Returns null if "canvasElement"
* is null or not an HTML canvas element.
*/
  "get3DOr2DContext":function(canvasElement) {
    "use strict";
    if(!canvasElement)return null;
    if(!canvasElement.getContext)return null;
    var context = null;
    var options = {
      "preserveDrawingBuffer":true,
      "alpha":false
    };
    if(window.devicePixelRatio &amp;&amp; window.devicePixelRatio > 1) {
      options.antialias = false;
    } else {
      options.antialias = true;
    }
    try {
      context = canvasElement.getContext("webgl", options);
    } catch(ex) {
      context = null;
    }
    if(!context) {
      try {
        context = canvasElement.getContext("experimental-webgl", options);
      } catch(ex) {
        context = null;
      }
    }
    if(!context) {
      try {
        context = canvasElement.getContext("moz-webgl", options);
      } catch(ex) {
        context = null;
      }
    }
    if(!context) {
      try {
        context = canvasElement.getContext("webkit-3d", options);
      } catch(ex) {
        context = null;
      }
    }
    if(!context) {
      try {
        context = canvasElement.getContext("2d", options);
      } catch(ex) {
        context = null;
      }
    }
    if(H3DU.is3DContext(context)) {
      context.getExtension("OES_element_index_uint");
      context.getExtension("OES_standard_derivatives");
    }
    return context;
  },
/**
* Creates a 3D rendering context from an HTML canvas element.
* @param {HTMLCanvasElement} canvasElement An HTML
* canvas element.
* @param {function} err A function to call if an error occurs in creating
* the context.  The function takes one parameter consisting of a human-
* readable error message.  If "err" is null, window.alert() will be used instead.
* @returns {WebGLRenderingContext} A 3D rendering context, or null
* if an error occurred in creating the context.  Returns null if "canvasElement"
* is null or not an HTML canvas element.
*/
  "get3DContext":function(canvasElement, err) {
    "use strict";
    var c = H3DU.get3DOr2DContext(canvasElement);
    var errmsg = null;
    if(!c &amp;&amp; window.WebGLShader) {
      errmsg = "Failed to initialize graphics support required by this page.";
    } else if(window.WebGLShader &amp;&amp; !H3DU.is3DContext(c)) {
      errmsg = "This page requires WebGL, but it failed to start. Your computer might not support WebGL.";
    } else if(!c || !H3DU.is3DContext(c)) {
      errmsg = "This page requires a WebGL-supporting browser.";
    }
    if(errmsg) {
      (err || window.alert)(errmsg);
      return null;
    }
    return c;
  },
/**
* Returns whether the given object is a 3D rendering context.
* @returns {Boolean} Return value.*/
  "is3DContext":function(context) {
    "use strict";
    return context &amp;&amp; "compileShader" in context;
  },

/**
* Utility function that returns a promise that
 * resolves or is rejected after the given list of promises finishes
 * its work.
 * @param {Array&lt;Promise>} promises - an array containing promise objects
 *  @param {Function} [progressResolve] - a function called as each
 *   individual promise is resolved; optional
 *  @param {Function} [progressReject] - a function called as each
 *   individual promise is rejected; optional
 * @returns {Promise} A promise that is resolved when
* all of the promises are each resolved; the result will
* be an array of results from those promises,
* in the order in which those promises were listed.
 * Will be rejected if any of the promises is rejected; the result
 * will be an object as specified in {@link H3DU.getPromiseResults}.&lt;/ul>
 */
  "getPromiseResultsAll":function(promises,
   progressResolve, progressReject) {
    "use strict";
    return H3DU.getPromiseResults(promises, progressResolve, progressReject)
     .then(function(results) {
       if(results.failures.length > 0) {
         return Promise.reject(results);
       } else {
         return Promise.resolve(results.successes);
       }
     });
  },
/**
* Utility function that returns a promise that
 * resolves after the given list of promises finishes
 * its work.
 * @param {Array&lt;Promise>} promises - an array containing promise objects
 *  @param {Function} [progressResolve] A function called as each
 *   individual promise is resolved.
 *  @param {Function} [progressReject] A function called as each
 *   individual promise is rejected.
 * @returns {Promise} A promise that is never rejected and resolves when
* all of the promises are each resolved or rejected. The result
 * of the promise will be an object with
 * three keys:&lt;ul>
 *  &lt;li>"successes" - contains a list of results from the
 *  promises that succeeded, in the order in which those promises were listed.
 *  &lt;li>"failures" - contains a list of results from the
 *  promises that failed, in the order in which those promises were listed.
 *  &lt;li>"results" - contains a list of boolean values for each
 * promise, in the order in which the promises were listed.
 * True means success, and false means failure.&lt;/ul>
 */
  "getPromiseResults":function(promises,
   progressResolve, progressReject) {
    "use strict";
    if(!promises || promises.length === 0) {
      return Promise.resolve({
        "successes":[],
        "failures":[],
        "results":[]
      });
    }
    function promiseResolveFunc(pr, ret, index) {
      return function(x) {
        if(pr)pr(x);
        ret.successes[index] = x;
        return true;
      };
    }
    function promiseRejectFunc(pr, ret, index) {
      return function(x) {
        if(pr)pr(x);
        ret.failures[index] = x;
        return true;
      };
    }
    var ret = {
      "successes":[],
      "failures":[],
      "results":[]
    };
    var newPromises = [];
    for(var i = 0;i &lt; promises.length;i++) {
      var index = i;
      newPromises.push(promises[i].then(
    promiseResolveFunc(progressResolve, ret, index),
    promiseRejectFunc(progressReject, ret, index)
  ));
    }
    return Promise.all(newPromises).then(function(results) {
  // compact the successes and failures arrays
      for(var i = 0;i &lt; ret.successes.length;i++) {
        if(typeof ret.successes[i] === "undefined") {
          ret.successes.splice(i, 1);
          i -= 1;
        }
      }
      for(i = 0;i &lt; ret.failures.length;i++) {
        if(typeof ret.failures[i] === "undefined") {
          ret.failures.splice(i, 1);
          i -= 1;
        }
      }
      ret.results = results;
      return Promise.resolve(ret);
    });
  },
/**
* Loads a file from a URL asynchronously, using XMLHttpRequest.
* @param {String} url URL of the file to load.
* @param {string|null} responseType Expected data type of
* the file.  Can be "json", "xml", "text", or "arraybuffer".
* If null or omitted, the default is "text".
* @returns {Promise} A promise that resolves when the data
* file is loaded successfully (the result will be an object with
* two properties: "url", the URL of the file, and "data", the
* file's text or data), as given below, and is rejected when an error occurs (the
* result may be an object with
* one property: "url", the URL of the file).  If the promise resolves,
* the parameter's "data" property will be:&lt;ul>
* &lt;li>For response type "xml", an XML document object.
* &lt;li>For response type "arraybuffer", an ArrayBuffer object.
* &lt;li>For response type "json", the JavaScript object decoded
* from JSON.
* &lt;li>For any other type, a string of the file's text.&lt;/ul>
*/
  "loadFileFromUrl":function(url, responseType) {
    "use strict";
    var urlstr = url;
    var respType = responseType || "text";
    return new Promise(function(resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function(e) {
        var t = e.target;
    // console.log([t.readyState,t.status,urlstr])
        if(t.readyState === 4) {
          if(t.status >= 200 &amp;&amp; t.status &lt; 300) {
            var resp = "";
            if(respType === "xml")resp = t.responseXML;
            else if(respType === "json")
              resp = "response" in t ? t.response : JSON.parse(t.responseText);
            else if(respType === "arraybuffer")
              resp = t.response;
            else resp = t.responseText + "";
            resolve({
              "url": urlstr,
              "data": resp
            });
          } else {
            reject({"url": urlstr});
          }
        }
      };
      xhr.onerror = function(e) {
    // console.log([urlstr,e])
        reject({
          "url": urlstr,
          "error": e
        });
      };
      xhr.open("get", url, true);
      xhr.responseType = respType;
      xhr.send();
    });
  }
};

/**
* Gets the position of a time value within an interval.
* This is useful for doing animation cycles lasting a certain number
* of seconds, such as rotating a shape in a 5-second cycle.
* This method may be called any number of times each frame.
* @param {Object} timer An object that will hold two
* properties:&lt;ul>
* &lt;li>"time" - initial time value, in milliseconds.
* &lt;li>"lastTime" - last known time value, in milliseconds.
* Will be set to the value given in "timeInMs" before returning.
* &lt;/ul>
* The object should be initialized using the idiom &lt;code>{}&lt;/code>
* or &lt;code>new Object()&lt;/code>.
* @param {Number} timeInMs A time value, in milliseconds.
* This could be the parameter received in a
* &lt;code>requestAnimationFrame()&lt;/code> callback method.
* &lt;/code>.
* @param {Number} intervalInMs The length of the interval
* (animation cycle), in milliseconds.
* @returns {Number} A value in the range [0, 1), where closer
* to 0 means "timeInMs" lies
* closer to the start, and closer to 1 means closer
* to the end of the interval.  If an initial time wasn't set, returns 0.
* @example &lt;caption>The following code sets an angle of
* rotation, in degrees, such that an object rotated with the
* angle does a 360-degree turn in 5 seconds (5000 milliseconds).
* The variable &lt;code>time&lt;/code> is assumed to be a time
* value in milliseconds, such as the parameter of a
* &lt;code>requestAnimationFrame()&lt;/code> callback method.
* &lt;/caption>
* var angle = 360 * H3DU.getTimePosition(timer, time, 5000);
*/
H3DU.getTimePosition = function(timer, timeInMs, intervalInMs) {
  "use strict";
  if(typeof timer.time === "undefined" || timer.time === null) {
    timer.time = timeInMs;
    timer.lastTime = timeInMs;
    return 0;
  } else {
    if(typeof timer.lastTime === "undefined" || timer.lastTime === null)timer.lastTime = timeInMs;
    return (timeInMs - timer.time) * 1.0 % intervalInMs / intervalInMs;
  }
};
/**
* Returns the number of frame-length intervals that occurred since
* the last known time, where a frame's length is 1/60 of a second.
* This method should be called only once each frame.
* @param {Object} timer An object described
* in {@link H3DU.getTimePosition}.
* @param {Number} timeInMs A time value, in milliseconds.
* This could be the parameter received in a
* &lt;code>requestAnimationFrame()&lt;/code> callback method.
* &lt;/code>.
* @returns {Number} The number of frame-length intervals relative to
* the last known time held in the parameter "timer".
* The number can include fractional frames.  If an
* initial time or last known time wasn't set, returns 0.
*/
H3DU.newFrames = function(timer, timeInMs) {
  "use strict";
  if(typeof timer.time === "undefined" || timer.time === null) {
    timer.time = timeInMs;
    timer.lastTime = timeInMs;
    return 0;
  } else if(typeof timer.lastTime === "undefined" || timer.lastTime === null) {
    timer.lastTime = timeInMs;
    return 0;
  } else {
    var diff = timeInMs - timer.lastTime;
    timer.lastTime = timeInMs;
    return diff * 60.0 / 1000.0;
  }
};

(function(exports) {
  "use strict";

  var ColorValidator = function() {
    throw new Error();
  };
  (function(constructor) {
    constructor.skipWhite = function(str, index, endIndex) {
      while (index &lt; endIndex) {
        var c = str.charCodeAt(index);
        if (c === 32 || c === 13 || c === 12 || c === 9 || c === 10) {
          ++index;
        } else {
          break;
        }
      }
      return index;
    };

    constructor.parseComma = function(str, index, endIndex) {
      var indexStart = index;
      index = ColorValidator.skipWhite(str, index, endIndex);
      if (index &lt; endIndex &amp;&amp; str.charCodeAt(index) === 44) {
        return ColorValidator.skipWhite(str, index + 1, endIndex);
      } else {
        return indexStart;
      }
    };

    constructor.parseEndparen = function(str, index, endIndex) {
      var indexStart = index;
      index = ColorValidator.skipWhite(str, index, endIndex);
      if (index &lt; endIndex &amp;&amp; str.charCodeAt(index) === 41) {
        return index + 1;
      } else {
        return indexStart;
      }
    };

    constructor.hsl = function(str, index, endIndex, ret) {
      var indexStart, indexTemp, tx2;
      indexStart = index;
      indexTemp = index;
      if ((tx2 = ColorValidator.parseHue(str, index, endIndex, ret, 0)) === index) {
        return indexStart;
      }
      index = tx2;
      if ((tx2 = ColorValidator.sepPct(str, index, endIndex, ret, 1)) === index) {
        return indexStart;
      }
      index = tx2;
      if ((tx2 = ColorValidator.sepPct(str, index, endIndex, ret, 2)) === index) {
        return indexStart;
      }
      index = tx2;
      tx2 = ColorValidator.parseEndparen(str, index, endIndex);
      if (tx2 === index) {
        return indexStart;
      } else {
        index = tx2;
      }
      var rgb = ColorValidator.hlsToRgb(ret[0], ret[2], ret[1]);
      ret[0] = rgb[0];
      ret[1] = rgb[1];
      ret[2] = rgb[2];
      ret[3] = 255.0;
      indexTemp = index;
      return indexTemp;
    };
    constructor.pct = function(str, index, endIndex, ret, retIndex) {
      var tx2 = ColorValidator.parseNumber(str, index, endIndex);
      if (tx2 !== index) {
        if (tx2 >= endIndex || str.charAt(tx2) !== 37)
          return index;
        ret[retIndex] = ColorValidator.stringToPercent(str, index, tx2) * 255.0 / 100.0;
        return tx2 + 1;
      }
      return tx2;
    };
    constructor.parseByte = function(str, index, endIndex, ret, retIndex) {
      var tx2 = ColorValidator.parseInteger(str, index, endIndex, true);
      if (tx2 !== index) {
        ret[retIndex] = ColorValidator.stringToByte(str, index, tx2);
      }
      return tx2;
    };
    constructor.parseHue = function(str, index, endIndex, ret, retIndex) {
      var start = index;
      index = ColorValidator.skipWhite(str, index, endIndex);
      var tx2 = ColorValidator.parseNumber(str, index, endIndex);
      if (tx2 !== index) {
        ret[retIndex] = ColorValidator.stringToHue(str, index, tx2);
        return tx2;
      } else {
        return start;
      }
    };
    constructor.sepByte = function(str, index, endIndex, ret, retIndex) {
      var tx2 = ColorValidator.parseComma(str, index, endIndex);
      return tx2 !== index ? ColorValidator.parseByte(str, tx2, endIndex, ret, retIndex) : tx2;
    };
    constructor.sepPct = function(str, index, endIndex, ret, retIndex) {
      var tx2 = ColorValidator.parseComma(str, index, endIndex);
      return tx2 !== index ? ColorValidator.pct(str, tx2, endIndex, ret, retIndex) : tx2;
    };
    constructor.sepAlpha = function(str, index, endIndex, ret, retIndex) {
      var tx2 = ColorValidator.parseComma(str, index, endIndex);
      if (tx2 !== index) {
        index = tx2;
        tx2 = ColorValidator.parseNumber(str, index, endIndex);
        if (tx2 !== index) {
          ret[retIndex] = ColorValidator.stringToAlpha(str, index, tx2);
        }
      }
      return tx2;
    };

    constructor.hsla = function(str, index, endIndex, ret) {
      var indexStart, indexTemp, tx2;
      indexStart = index;
      indexTemp = index;
      if ((tx2 = ColorValidator.parseHue(str, index, endIndex, ret, 0)) === index) {
        return indexStart;
      }
      index = tx2;
      if ((tx2 = ColorValidator.sepPct(str, index, endIndex, ret, 1)) === index) {
        return indexStart;
      }
      index = tx2;
      if ((tx2 = ColorValidator.sepPct(str, index, endIndex, ret, 2)) === index) {
        return indexStart;
      }
      index = tx2;
      if ((tx2 = ColorValidator.sepAlpha(str, index, endIndex, ret, 3)) === index) {
        return indexStart;
      }
      index = tx2;
      var rgb = ColorValidator.hlsToRgb(ret[0], ret[2], ret[1]);
      ret[0] = rgb[0];
      ret[1] = rgb[1];
      ret[2] = rgb[2];
      tx2 = ColorValidator.parseEndparen(str, index, endIndex);
      if (tx2 === index) {
        return indexStart;
      } else {
        index = tx2;
      }
      indexTemp = index;
      return indexTemp;
    };

    constructor.rgba = function(str, index, endIndex, result) {
      var indexStart, tx2;
      indexStart = index;
      index = ColorValidator.skipWhite(str, index, endIndex);
      var st = index;
      var continuing = true;
      if ((tx2 = ColorValidator.pct(str, index, endIndex, result, 0)) === index) {
        continuing = false;
      } else {
        index = tx2;
      }
      if (continuing &amp;&amp; (tx2 = ColorValidator.sepPct(str, index, endIndex, result, 1)) === index) {
        continuing = false;
      } else {
        index = tx2;
      }
      if (continuing &amp;&amp; (tx2 = ColorValidator.sepPct(str, index, endIndex, result, 2)) === index) {
        continuing = false;
      } else {
        index = tx2;
      }
      if (continuing &amp;&amp; (tx2 = ColorValidator.sepAlpha(str, index, endIndex, result, 3)) === index) {
        continuing = false;
      } else {
        index = tx2;
      }
      if (!continuing) {
        index = st;
        continuing = true;
        if ((tx2 = ColorValidator.parseByte(str, index, endIndex, result, 0)) === index) {
          continuing = false;
        } else {
          index = tx2;
        }
        if (continuing &amp;&amp; (tx2 = ColorValidator.sepByte(str, index, endIndex, result, 1)) === index) {
          continuing = false;
        } else {
          index = tx2;
        }
        if (continuing &amp;&amp; (tx2 = ColorValidator.sepByte(str, index, endIndex, result, 2)) === index) {
          continuing = false;
        } else {
          index = tx2;
        }
        if (continuing &amp;&amp; (tx2 = ColorValidator.sepAlpha(str, index, endIndex, result, 3)) === index) {
          continuing = false;
        } else {
          index = tx2;
        }
      }
      if (!continuing) {
        return indexStart;
      }
      tx2 = ColorValidator.parseEndparen(str, index, endIndex);
      index = tx2 === index ? indexStart : tx2;
      return index;
    };
    constructor.rgb = function(str, index, endIndex, result) {
      var indexStart, tx2;
      indexStart = index;
      index = ColorValidator.skipWhite(str, index, endIndex);
      var st = index;
      var continuing = true;
      if ((tx2 = ColorValidator.pct(str, index, endIndex, result, 0)) === index) {
        continuing = false;
      } else {
        index = tx2;
      }
      if (continuing &amp;&amp; (tx2 = ColorValidator.sepPct(str, index, endIndex, result, 1)) === index) {
        continuing = false;
      } else {
        index = tx2;
      }
      if (continuing &amp;&amp; (tx2 = ColorValidator.sepPct(str, index, endIndex, result, 2)) === index) {
        continuing = false;
      } else {
        index = tx2;
      }
      if (!continuing) {
        index = st;
        continuing = true;
        if ((tx2 = ColorValidator.parseByte(str, index, endIndex, result, 0)) === index) {
          continuing = false;
        } else {
          index = tx2;
        }
        if (continuing &amp;&amp; (tx2 = ColorValidator.sepByte(str, index, endIndex, result, 1)) === index) {
          continuing = false;
        } else {
          index = tx2;
        }
        if (continuing &amp;&amp; (tx2 = ColorValidator.sepByte(str, index, endIndex, result, 2)) === index) {
          continuing = false;
        } else {
          index = tx2;
        }
      }
      if (!continuing) {
        return indexStart;
      }
      result[3] = 255.0;
      tx2 = ColorValidator.parseEndparen(str, index, endIndex);
      if (tx2 === index) {
        return indexStart;
      } else {
        return tx2;
      }
    };
    constructor.stringToNumber = function(str, index, endIndex) {
      var str2 = str.substring(index, index + (endIndex - index));
      return parseFloat(str2);
    };
    constructor.stringToPercent = function(str, index, endIndex) {
      var num = ColorValidator.stringToNumber(str, index, endIndex);
      return Number.isNaN(num) ? -1 : num &lt; 0 ? 0 : num > 100 ? 100 : num;
    };
    constructor.stringToAlpha = function(str, index, endIndex) {
      var num = ColorValidator.stringToNumber(str, index, endIndex);
      return num &lt; 0 ? 0 : num > 1.0 ? 255 : num * 255.0;
    };
    constructor.stringToHue = function(str, index, endIndex) {
      var num = ColorValidator.stringToNumber(str, index, endIndex);
      return Number.isNaN(num) || num === Number.POSITIVE_INFINITY || num === Number.NEGATIVE_INFINITY ? 0 : (num % 360 + 360) % 360;
    };
    constructor.stringToByte = function(str, index, endIndex) {
      var num = ColorValidator.stringToNumber(str, index, endIndex);
      return num &lt; 0 ? 0 : num > 255 ? 255 : num;
    };

    constructor.parseInteger = function(str, index, endIndex, posneg) {
      var digits = false;
      var indexStart = index;
      if (posneg &amp;&amp; index &lt; endIndex &amp;&amp; (str.charCodeAt(index) === 43 || str.charCodeAt(index) === 45)) {
        ++index;
      }
      while (index &lt; endIndex &amp;&amp; (str.charCodeAt(index) >= 48 &amp;&amp; str.charCodeAt(index) &lt;= 57)) {
        ++index;
        digits = true;
      }
      return digits ? index : indexStart;
    };

    constructor.parseNumber = function(str, index, endIndex) {
      var indexStart = index;
      var tmp = index;
      var tmp2 = 0;
      if ((tmp = ColorValidator.parseInteger(str, index, endIndex, true)) !== indexStart) {
        index = tmp;
        if (index &lt; endIndex &amp;&amp; str.charCodeAt(index) === 46) {
          ++index;
          if ((tmp = ColorValidator.parseInteger(str, index, endIndex, false)) !== index) {
            if(index &lt; endIndex &amp;&amp; (str.charCodeAt(index) === 0x45 || str.charCodeAt(index) === 0x65) &amp;&amp;
            (tmp2 = ColorValidator.parseInteger(str, index + 1, endIndex, true)) !== index + 1) {
              return tmp2;
            }
            return tmp;
          } else {
            return index - 1;
          }
        }
        return index;
      } else {
        if (index &lt; endIndex &amp;&amp; (str.charCodeAt(index) === 43 || str.charCodeAt(index) === 45)) {
          ++index;
        }
        if (index &lt; endIndex &amp;&amp; str.charCodeAt(index) === 46) {
          ++index;
          if ((tmp = ColorValidator.parseInteger(str, index, endIndex, false)) !== index) {
            if(index &lt; endIndex &amp;&amp; (str.charCodeAt(index) === 0x45 || str.charCodeAt(index) === 0x65) &amp;&amp;
            (tmp2 = ColorValidator.parseInteger(str, index + 1, endIndex, true)) !== index + 1) {
              return tmp2;
            }
            return tmp;
          } else {
            return indexStart;
          }
        }
        return indexStart;
      }
    };

    constructor.hlsToRgb = constructor.HlsToRgb = function(hueval, lum, sat) {
      lum = lum &lt; 0 ? 0 : lum > 255 ? 255 : lum;
      sat = sat &lt; 0 ? 0 : sat > 255 ? 255 : sat;
      if (sat === 0) {
        return [lum, lum, lum];
      }
      var b = 0;
      if (lum &lt;= 127.5) {
        b = lum * (255.0 + sat) / 255.0;
      } else {
        b = lum * sat;
        b /= 255.0;
        b = lum + sat - b;
      }
      var a = lum * 2 - b;
      var r, g, bl;
      if (hueval &lt; 0 || hueval >= 360) {
        hueval = (hueval % 360 + 360) % 360;
      }
      var hue = hueval + 120;
      if (hue >= 360) {
        hue -= 360;
      }
      r = hue &lt; 60 ? a + (b - a) * hue / 60 : hue &lt; 180 ? b : hue &lt; 240 ? a + (b - a) * (240 - hue) / 60 : a;
      hue = hueval;
      g = hue &lt; 60 ? a + (b - a) * hue / 60 : hue &lt; 180 ? b : hue &lt; 240 ? a + (b - a) * (240 - hue) / 60 : a;
      hue = hueval - 120;
      if (hue &lt; 0) {
        hue += 360;
      }
      bl = hue &lt; 60 ? a + (b - a) * hue / 60 : hue &lt; 180 ? b : hue &lt; 240 ? a + (b - a) * (240 - hue) / 60 : a;
      return [r &lt; 0 ? 0 : r > 255 ? 255 : r, g &lt; 0 ? 0 : g > 255 ? 255 : g, bl &lt; 0 ? 0 : bl > 255 ? 255 : bl];
    };

    constructor.dehexchar = function(c) {
      if (c >= 48 &amp;&amp; c &lt;= 57) {
        return c - 48;
      }
      return c >= 65 &amp;&amp; c &lt;= 70 ? c + 10 - 65 : c >= 97 &amp;&amp; c &lt;= 102 ? c + 10 - 97 : -1;
    };
    constructor.rgbHex = function(str, hexval, hash) {
      if (str === null || typeof str === "undefined" || str.length === 0) {
        return false;
      }
      var slen = str.length;
      var hexes = [0, 0, 0, 0, 0, 0, 0, 0];
      var index = 0;
      var hexIndex = 0;
      if (str.charAt(0) === "#") {
        --slen;
        ++index;
      } else if (hash) {
        return false;
      }
      if (slen !== 3 &amp;&amp; slen !== 4 &amp;&amp; slen !== 6 &amp;&amp; slen !== 8) {
        return false;
      }
      for (var i = index; i &lt; str.length; ++i) {
        var hex = ColorValidator.dehexchar(str.charCodeAt(i));
        if (hex &lt; 0) {
          return false;
        }
        hexes[hexIndex++] = hex;
      }
      if (slen === 4) {
        hexval[3] = hexes[3] | hexes[3] &lt;&lt; 4;
      } else if (slen === 8) {
        hexval[3] = hexes[7] | hexes[6] &lt;&lt; 4;
      } else {
        hexval[3] = 255.0;
      }
      if (slen === 3 || slen === 4) {
        hexval[0] = hexes[0] | hexes[0] &lt;&lt; 4;
        hexval[1] = hexes[1] | hexes[1] &lt;&lt; 4;
        hexval[2] = hexes[2] | hexes[2] &lt;&lt; 4;
      } else if (slen >= 6) {
        hexval[0] = hexes[1] | hexes[0] &lt;&lt; 4;
        hexval[1] = hexes[3] | hexes[2] &lt;&lt; 4;
        hexval[2] = hexes[5] | hexes[4] &lt;&lt; 4;
      }
      return true;
    };

    constructor.colorToRgba = constructor.colorToRgba = function(x) {
      if (x === null || typeof x === "undefined" || x.length === 0) {
        return null;
      }
      x = x.replace(/^[\r\n\t \u000c]+|[\r\n\t \u000c]+$/g, "");
      x = x.toLowerCase();
      if (x === "transparent") {
        return [0, 0, 0, 0];
      }
      if (x === null || typeof x === "undefined" || x.length === 0) {
        return null;
      }
      var ret = [0, 0, 0, 0];
      if (x.charAt(0) === "#") {
        if (ColorValidator.rgbHex(x, ret, true)) {
          return ret;
        }
      }
      if (x.length > 4 &amp;&amp; x.substring(0, 4) === "rgb(") {
        return ColorValidator.rgb(x, 4, x.length, ret) === x.length ? ret : null;
      }
      if (x.length > 5 &amp;&amp; x.substring(0, 5) === "rgba(") {
        return ColorValidator.rgba(x, 5, x.length, ret) === x.length ? ret : null;
      }
      if (x.length > 4 &amp;&amp; x.substring(0, 4) === "hsl(") {
        return ColorValidator.hsl(x, 4, x.length, ret) === x.length ? ret : null;
      }
      if (x.length > 5 &amp;&amp; x.substring(0, 5) === "hsla(") {
        return ColorValidator.hsla(x, 5, x.length, ret) === x.length ? ret : null;
      }
      var colors = ColorValidator.colorToRgbaSetUpNamedColors();
      if (colors[x] !== null &amp;&amp; typeof colors[x] !== "undefined") {
        var colorValue = colors[x];
        ColorValidator.rgbHex(colorValue, ret, false);
        return ret;
      }
      return null;
    };

    constructor.namedColorMap = constructor.namedColorMap = null;

    constructor.nc = ["aliceblue", "f0f8ff", "antiquewhite", "faebd7", "aqua", "00ffff", "aquamarine", "7fffd4", "azure", "f0ffff", "beige", "f5f5dc", "bisque", "ffe4c4", "black", "000000", "blanchedalmond", "ffebcd", "blue", "0000ff", "blueviolet", "8a2be2", "brown", "a52a2a", "burlywood", "deb887", "cadetblue", "5f9ea0", "chartreuse", "7fff00", "chocolate", "d2691e", "coral", "ff7f50", "cornflowerblue", "6495ed", "cornsilk", "fff8dc", "crimson", "dc143c", "cyan", "00ffff", "darkblue", "00008b", "darkcyan", "008b8b", "darkgoldenrod", "b8860b", "darkgray", "a9a9a9", "darkgreen", "006400", "darkkhaki", "bdb76b", "darkmagenta", "8b008b", "darkolivegreen", "556b2f", "darkorange", "ff8c00", "darkorchid", "9932cc", "darkred", "8b0000", "darksalmon", "e9967a", "darkseagreen", "8fbc8f", "darkslateblue", "483d8b", "darkslategray", "2f4f4f", "darkturquoise", "00ced1", "darkviolet", "9400d3", "deeppink", "ff1493", "deepskyblue", "00bfff", "dimgray", "696969", "dodgerblue", "1e90ff", "firebrick", "b22222", "floralwhite", "fffaf0", "forestgreen", "228b22", "fuchsia", "ff00ff", "gainsboro", "dcdcdc", "ghostwhite", "f8f8ff", "gold", "ffd700", "goldenrod", "daa520", "gray", "808080", "green", "008000", "greenyellow", "adff2f", "honeydew", "f0fff0", "hotpink", "ff69b4", "indianred", "cd5c5c", "indigo", "4b0082", "ivory", "fffff0", "khaki", "f0e68c", "lavender", "e6e6fa", "lavenderblush", "fff0f5", "lawngreen", "7cfc00", "lemonchiffon", "fffacd", "lightblue", "add8e6", "lightcoral", "f08080", "lightcyan", "e0ffff", "lightgoldenrodyellow", "fafad2", "lightgray", "d3d3d3", "lightgreen", "90ee90", "lightpink", "ffb6c1", "lightsalmon", "ffa07a", "lightseagreen", "20b2aa", "lightskyblue", "87cefa", "lightslategray", "778899", "lightsteelblue", "b0c4de", "lightyellow", "ffffe0", "lime", "00ff00", "limegreen", "32cd32", "linen", "faf0e6", "magenta", "ff00ff", "maroon", "800000", "mediumaquamarine", "66cdaa", "mediumblue", "0000cd", "mediumorchid", "ba55d3", "mediumpurple", "9370d8", "mediumseagreen", "3cb371", "mediumslateblue", "7b68ee", "mediumspringgreen", "00fa9a", "mediumturquoise", "48d1cc", "mediumvioletred", "c71585", "midnightblue", "191970", "mintcream", "f5fffa", "mistyrose", "ffe4e1", "moccasin", "ffe4b5", "navajowhite", "ffdead", "navy", "000080", "oldlace", "fdf5e6", "olive", "808000", "olivedrab", "6b8e23", "orange", "ffa500", "orangered", "ff4500", "orchid", "da70d6", "palegoldenrod", "eee8aa", "palegreen", "98fb98", "paleturquoise", "afeeee", "palevioletred", "d87093", "papayawhip", "ffefd5", "peachpuff", "ffdab9", "peru", "cd853f", "pink", "ffc0cb", "plum", "dda0dd", "powderblue", "b0e0e6", "purple", "800080", "rebeccapurple", "663399", "red", "ff0000", "rosybrown", "bc8f8f", "royalblue", "4169e1", "saddlebrown", "8b4513", "salmon", "fa8072", "sandybrown", "f4a460", "seagreen", "2e8b57", "seashell", "fff5ee", "sienna", "a0522d", "silver", "c0c0c0", "skyblue", "87ceeb", "slateblue", "6a5acd", "slategray", "708090", "snow", "fffafa", "springgreen", "00ff7f", "steelblue", "4682b4", "tan", "d2b48c", "teal", "008080", "thistle", "d8bfd8", "tomato", "ff6347", "turquoise", "40e0d0", "violet", "ee82ee", "wheat", "f5deb3", "white", "ffffff", "whitesmoke", "f5f5f5", "yellow", "ffff00", "yellowgreen", "9acd32"];

    constructor.colorToRgbaSetUpNamedColors = function() {
      if (typeof ColorValidator.namedColorMap === "undefined" || ColorValidator.namedColorMap === null) {
        var ncm = {};
        for (var i = 0; i &lt; ColorValidator.nc.length; i += 2) {
          ncm[ColorValidator.nc[i]] = ColorValidator.nc[i + 1];
        }
        ncm.grey = ncm.gray;
        ncm.darkgrey = ncm.darkgray;
        ncm.darkslategrey = ncm.darkslategray;
        ncm.dimgrey = ncm.dimgray;
        ncm.lightgrey = ncm.lightgray;
        ncm.lightslategrey = ncm.lightslategray;
        ncm.slategrey = ncm.slategray;
        ColorValidator.namedColorMap = ncm;
      }
      return ColorValidator.namedColorMap;
    };
  }(ColorValidator, ColorValidator.prototype));

  var clampRgba = function(x) {
    x[0] = x[0] &lt; 0 ? 0 : Math.min(x[0], 1);
    x[1] = x[1] &lt; 0 ? 0 : Math.min(x[1], 1);
    x[2] = x[2] &lt; 0 ? 0 : Math.min(x[2], 1);
    x[3] = x[3] &lt; 0 ? 0 : Math.min(x[3], 1);
    return x;
  };
/**
* Creates a 4-element array representing a color.  Each element
* can range from 0 to 1 and specifies the red, green, blue or alpha
* component, respectively.
* This method also converts HTML and CSS colors to 4-element RGB
* colors.  The following lists the kinds of colors accepted:
* &lt;ul>
* &lt;li>HTML colors with the syntax &lt;code>#RRGGBB&lt;/code> or &lt;code>#RRGGBBAA&lt;/code>, where
* RR is the hexadecimal form of the red component (00-FF), GG
* is the hexadecimal green component, BB is the hexadecimal
* blue component, and AA is the hexadecimal alpha component.  Example: #88DFE0.
* &lt;li>HTML colors with the syntax &lt;code>#RGB&lt;/code> or &lt;code>#RGBA&lt;/code>, where
* R is the hexadecimal form of the red component (0-F), G
* is the hexadecimal green component, B is the hexadecimal
* blue component, and A is the hexadecimal alpha component.  Example: #8DE.
* &lt;li>CSS colors with the syntax &lt;code>rgb(red, green, blue)&lt;/code> or
* &lt;code>rgba(red, green, blue, alpha)&lt;/code> where
* &lt;code>red&lt;/code>, &lt;code>green&lt;/code>, and &lt;code>blue&lt;/code>
* are the red, green, and blue components, respectively, either as a
* number (0-255) or as a percent, and &lt;code>alpha&lt;/code> is
* a number from 0-1 specifying the alpha component.
* Examples: &lt;code>rgb(255,0,0)&lt;/code>,
* &lt;code>rgb(100%,50%,0%)&lt;/code>, &lt;code>rgba(20,255,255,0.5)&lt;/code>.
* &lt;li>CSS colors with the syntax &lt;code>hsl(hue, sat, light)&lt;/code> or
* &lt;code>hsla(hue, sat, light, alpha)&lt;/code> where
* &lt;code>hue&lt;/code> is the hue component in degrees (0-360),
* &lt;code>sat&lt;/code> and &lt;code>light&lt;/code>
* are the saturation and lightness components, respectively, as percents,
* and &lt;code>alpha&lt;/code> is
* a number from 0-1 specifying the alpha component.
* Examples: &lt;code>rgb(255,0,0)&lt;/code>,
* &lt;code>hsl(200,50%,50%)&lt;/code>, &lt;code>hsla(20,80%,90%,0.5)&lt;/code>.
* &lt;li>CSS colors such as &lt;code>red&lt;/code>, &lt;code>green&lt;/code>,
* &lt;code>white&lt;/code>, &lt;code>lemonchiffon&lt;/code>, &lt;code>chocolate&lt;/code>,
* and so on, including the newly added &lt;code>rebeccapurple&lt;/code>.
* &lt;li>The value &lt;code>transparent&lt;/code>, meaning transparent black.
* &lt;/ul>
* For more information, see the "{@tutorial colors}" tutorial.
* @alias H3DU.toGLColor
* @param {Array&lt;Number>|number|string} r One of the following:&lt;ul>
* &lt;li>A &lt;b>color vector or string&lt;/b>, which can be one of these:&lt;ul>
* &lt;li>An array of three color components, each of which ranges from 0 to 1.
The three components are red, green, and blue in that order.&lt;/li>
* &lt;li>An array of four color components, each of which ranges from 0 to 1.
The three components are red, green, blue, and alpha in that order.&lt;/li>
* &lt;li>A string specifying an HTML or CSS color, in one of the formats mentioned
* above in the method description.&lt;/li>&lt;/ul>&lt;/li>
* &lt;li>A number specifying the red component.  Must range from 0 to 1.&lt;/li>
* &lt;/ul>
* Returns (0,0,0,0) if this value is null.
* @param {Number} g Green color component (0-1).
* May be null or omitted if a string or array is given as the "r" parameter.
* @param {Number} b Blue color component (0-1).
* May be null or omitted if a string or array is given as the "r" parameter.
* @param {Number} [a] Alpha color component (0-1).
* If the "r" parameter is given and this parameter is null or omitted,
* this value is treated as 1.0.
* @returns the color as a 4-element array; if the color is
* invalid, returns [0,0,0,0] (transparent black). Numbers less
* than 0 are clamped to 0, and numbers greater than 1 are
* clamped to 1.
*/
  exports.toGLColor = function(r, g, b, a) {
    if(r === null || typeof r === "undefined")return [0, 0, 0, 0];
    if(typeof r === "string") {
      var rgba = ColorValidator.colorToRgba(r) || [0, 0, 0, 0];
      var mul = 1.0 / 255;
      rgba[0] *= mul;
      rgba[1] *= mul;
      rgba[2] *= mul;
      rgba[3] *= mul;
      return clampRgba(rgba);
    }
    if(typeof r === "number" &amp;&amp;
     typeof g === "number" &amp;&amp; typeof b === "number") {
      return [r, g, b, typeof a !== "number" ? 1.0 : a];
    } else if(r.constructor === Array) {
      return clampRgba([r[0] || 0, r[1] || 0, r[2] || 0,
        typeof r[3] !== "number" ? 1.0 : r[3]]);
    } else {
      return clampRgba(r || [0, 0, 0, 0]);
    }
  };
}(H3DU));

/** @private */
H3DU._toContext = function(context) {
  "use strict";
  return context &amp;&amp; context.getContext ? context.getContext() : context;
};
/** @private */
H3DU._isPowerOfTwo = function(a) {
  "use strict";
  if(Math.floor(a) !== a || a &lt;= 0)return false;
  while(a > 1 &amp;&amp; (a &amp; 1) === 0) {
    a >>= 1;
  }
  return a === 1;
};
/** @private */
H3DU._isIdentityExceptTranslate = function(mat) {
  "use strict";
  return (
    mat[0] === 1 &amp;&amp; mat[1] === 0 &amp;&amp; mat[2] === 0 &amp;&amp; mat[3] === 0 &amp;&amp;
    mat[4] === 0 &amp;&amp; mat[5] === 1 &amp;&amp; mat[6] === 0 &amp;&amp; mat[7] === 0 &amp;&amp;
    mat[8] === 0 &amp;&amp; mat[9] === 0 &amp;&amp; mat[10] === 1 &amp;&amp; mat[11] === 0 &amp;&amp;
    mat[15] === 1
  );
};
</code></pre>
        </article>
    </section>

</div>
<nav id="navigation">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>upokecenter.dreamhosters.com/articles/donate-now-2</b></p>
<div class=noprint>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHfwYJKoZIhvcNAQcEoIIHcDCCB2wCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYBTEjVSqAfM9cTLwXVwxBqNI8r1Il0SJNqahKnIJrEIZOdmziEnZsYS8kifxxbWCBrNGl1S/eO5kcMG6WO50eBSxFlNpweevNYIs0dIdfQZtiWcRD2yYzaWHBkHu3PmCCLmc3pPT5QaOc949w2dPcg+syabMOSwN94Mk67Wh//7pTELMAkGBSsOAwIaBQAwgfwGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIm7w2yVS0zOeAgdhYAX/keBkbLTGS2k5QcVstRROvRVuMlDL7sy/YUie0YlEJKDFTFE7n6LP15AFfODDattjmqKJ7UZ+6hY9sqJhayUNqdl/rA/RYgPVKGWTM1l68+KFdz2SO3IHvBUJIAwnHFX1JVyNUAofSxWj+3eoN5MnQzskA4cKe/RFWB04oXxZS7/WCOHL3q3mlwFDSK83C3Wcqro7S18YnVxfJ4XGUQ7nlx1C9K0Xq+JbCGEC4D8yjQHzm9w3LqUOogiI3l9VVlXxuqcAdq+iBkAGIt3y4TXABMtXEFG2gggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xMzA4MTAxMzA4NDBaMCMGCSqGSIb3DQEJBDEWBBQImRl0rdSM38l1aTcRhxgiKb7ipTANBgkqhkiG9w0BAQEFAASBgE0IsEWvN+n6QuwDFkBMQO9C4z5uf7wAvoMDgifDKBCyGFmpYZPsKawkYVcS/kASDtyq6aWU3lqP+KweyA+0xfpAyE3R8/7p80uqGGs8bHGicxkl2pEkX95R23HGRa1pEDHFF1XQNkhns558WioFipI2RvmAAEaMgZQ1p+SV/cdu-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
<h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Camera.html">Camera</a></li><li><a href="CurveTube.html">CurveTube</a></li><li><a href="Epitrochoid.html">Epitrochoid</a></li><li><a href="FrameCounter.html">FrameCounter</a></li><li><a href="FrameCounterDiv.html">FrameCounterDiv</a></li><li><a href="GraphicsPath.html">GraphicsPath</a></li><li><a href="H3DU.Batch3D.html">Batch3D</a></li><li><a href="H3DU.BezierCurve.html">BezierCurve</a></li><li><a href="H3DU.BezierSurface.html">BezierSurface</a></li><li><a href="H3DU.BSplineCurve.html">BSplineCurve</a></li><li><a href="H3DU.BSplineSurface.html">BSplineSurface</a></li><li><a href="H3DU.BufferedMesh.html">BufferedMesh</a></li><li><a href="H3DU.CurveEval.html">CurveEval</a></li><li><a href="H3DU.FrameBuffer.html">FrameBuffer</a></li><li><a href="H3DU.FrameBufferInfo.html">FrameBufferInfo</a></li><li><a href="H3DU.Lights.html">Lights</a></li><li><a href="H3DU.LightSource.html">LightSource</a></li><li><a href="H3DU.Material.html">Material</a></li><li><a href="H3DU.Math.html">Math</a></li><li><a href="H3DU.MatrixStack.html">MatrixStack</a></li><li><a href="H3DU.Mesh.html">Mesh</a></li><li><a href="H3DU.MeshBuffer.html">MeshBuffer</a></li><li><a href="H3DU.Meshes.html">Meshes</a></li><li><a href="H3DU.RenderPass3D.html">RenderPass3D</a></li><li><a href="H3DU.Scene3D.html">Scene3D</a></li><li><a href="H3DU.ShaderInfo.html">ShaderInfo</a></li><li><a href="H3DU.ShaderProgram.html">ShaderProgram</a></li><li><a href="H3DU.Shape.html">Shape</a></li><li><a href="H3DU.ShapeGroup.html">ShapeGroup</a></li><li><a href="H3DU.SurfaceEval.html">SurfaceEval</a></li><li><a href="H3DU.TextFont.html">TextFont</a></li><li><a href="H3DU.Texture.html">Texture</a></li><li><a href="H3DU.TextureAtlas.html">TextureAtlas</a></li><li><a href="H3DU.TextureLoader.html">TextureLoader</a></li><li><a href="H3DU.Transform.html">Transform</a></li><li><a href="Hypotrochoid.html">Hypotrochoid</a></li><li><a href="InputTracker.html">InputTracker</a></li><li><a href="MeshJSON.html">MeshJSON</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="PrimitiveCounter.html">PrimitiveCounter</a></li><li><a href="Promise.html">Promise</a></li><li><a href="SurfaceOfRevolution.html">SurfaceOfRevolution</a></li><li><a href="Trochoid.html">Trochoid</a></li></ul><h3>Namespaces</h3><ul><li><a href="H3DU.html">H3DU</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera_.html">The "Camera" and the Projection and View Transforms</a></li><li><a href="tutorial-colors.html">Color Strings</a></li><li><a href="tutorial-filters.html">Graphics Filters</a></li><li><a href="tutorial-glmath.html">H3DU's Math Functions</a></li><li><a href="tutorial-history.html">Older Version History</a></li><li><a href="tutorial-matrixdetails.html">Matrix Details</a></li><li><a href="tutorial-meshexamples.html">Examples of Creating Meshes on the Fly</a></li><li><a href="tutorial-overview.html">Library Overview</a></li><li><a href="tutorial-paths.html">2-Dimensional Graphics Paths</a></li><li><a href="tutorial-shapes.html">Creating Shapes</a></li><li><a href="tutorial-surfaces.html">Parametric Curves and Parametric Surfaces</a></li><li><a href="tutorial-textures.html">Texture Examples</a></li></ul>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
