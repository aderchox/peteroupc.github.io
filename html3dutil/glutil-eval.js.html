<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Source: glutil-eval.js</title>
<script src="mathml.js"></script>
<link rel=stylesheet type="text/css" href="/style.css">
</head>
<body style="margin-top:0px">
<div style="width:75%;float:left;">
    <h1>Source: glutil-eval.js</h1>

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/
/* global GLMath, Mesh */
(function(global){
"use strict";
/**
 * A parametric evaluator for B&amp;eacute;zier curves.&lt;p>
 * A B&amp;eacute;zier curve is defined by a series of control points, where
 * the first and last control points define the endpoints of the curve, and
 * the remaining control points define the curve's shape, though they don't
 * necessarily cross the curve.
 * @class
 * @alias BezierCurve
 * @param {Array&lt;Array&lt;number>>} controlPoints An array of control points.  Each
 * control point is an array with the same length as the other control points.
 * It is assumed that:&lt;ul>
 * &lt;li>The length of this parameter minus 1 represents the degree of the B&amp;eacute;zier
 * curve.  For example, a degree-3 (cubic) curve
 * contains 4 control points.  A degree of 1 results in a straight line segment.
 * &lt;li>The first control point's length represents the size of all the control
 * points.
 * &lt;/ul>
 * @param {number} [u1] Starting point for the purpose of interpolation; it will correspond to 0.
 * May be omitted; default is 0.
 * @param {number} [u2] Ending point for the purpose of interpolation; it will correspond to 1.
 * May be omitted; default is 1.
 */
var BezierCurve=function(cp, u1, u2){
 if(typeof u1==="undefined" &amp;&amp; typeof u2==="undefined"){
  this.uoffset=0;
  this.umul=1;
 } else if(u1===u2){
  throw new Error("u1 and u2 can't be equal");
 } else {
  this.uoffset=u1;
  this.umul=1.0/(u2-u1);
 }
 this.evaluator=BSplineCurve.clamped(cp,cp.length-1);
};
/**
 * Evaluates the curve function based on a point
 * in a B&amp;eacute;zier curve.
 * @param {number} u Point on the curve to evaluate (generally within the range
 * given in the constructor).
 * @return {Array&lt;number>} An array of the result of
 * the evaluation.  Its length will be equal to the
 * length of a control point, as specified in the constructor.
* @example
* // Generate 11 points forming the B&amp;eacute;zier curve.
* // Assumes the curve was created with u1=0 and u2=1 (the default).
* var points=[];
* for(var i=0;i&lt;=10;i++){
*  points.push(curve.evaluate(i/10.0));
* }
 */
BezierCurve.prototype.evaluate=function(u){
 return this.evaluator.evaluate((u-this.uoffset)*this.umul);
};
/**
 * A parametric evaluator for B&amp;eacute;zier surfaces.&lt;p>
 * A B&amp;eacute;zier surface is defined by a series of control points, where
 * the control points on each corner define the endpoints of the surface, and
 * the remaining control points define the surface's shape, though they don't
 * necessarily cross the surface.
 * @class
 * @alias BezierSurface
 * @param {Array&lt;Array&lt;number>>} controlPoints An array of control point
 * arrays, which in turn contain a number of control points.  Each
 * control point is an array with the same length as the other control points.
 * It is assumed that:&lt;ul>
 * &lt;li>The length of this parameter minus 1 represents the degree of the B&amp;eacute;zier
 * surface along the V axis.  For example, a degree-3 (cubic) surface along the V axis
 * contains 4 control points, one in each control point array.  A degree of 1 on
 * both the U and V axes results in a flat surface.
 * &lt;li>The length of the first control point array minus 1 represents the degree of the B&amp;eacute;zier
 * surface along the U axis.
 * &lt;li>The first control point's length represents the size of all the control
 * points.
 * &lt;/ul>
 * @param {number} [u1] Starting point for the purpose of interpolation along the
 * U-axis; it will correspond to 0.
 * May be omitted; default is 0.
 * @param {number} [u2] Ending point for the purpose of interpolation along the
 * U-axis; it will correspond to 1.
 * May be omitted; default is 1.
 * @param {number} [v1] Starting point for the purpose of interpolation along the
 * V-axis; it will correspond to 0.
 * May be omitted; default is 0.
 * @param {number} [v2] Ending point for the purpose of interpolation along the
 * V-axis; it will correspond to 1.
 * May be omitted; default is 1.
 */
var BezierSurface=function(cp, u1, u2, v1, v2){
 if(typeof u1==="undefined" &amp;&amp; typeof u2==="undefined" &amp;&amp;
    typeof v1==="undefined" &amp;&amp; typeof v2==="undefined"){
  this.uoffset=0;
  this.umul=1;
  this.voffset=0;
  this.vmul=1;
 } else if(u1===u2){
  throw new Error("u1 and u2 can't be equal");
 } else if(v1===v2){
  throw new Error("v1 and v2 can't be equal");
 } else {
  this.uoffset=u1;
  this.umul=1.0/(u2-u1);
  this.voffset=v1;
  this.vmul=1.0/(v2-v1);
 }
 this.evaluator=BSplineSurface.clamped(cp,cp[0].length-1,cp.length-1);
};
/**
 * Evaluates the surface function based on a point
 * in a B&amp;eacute;zier surface.
 * @param {number} u U-coordinate of the surface to evaluate (generally within the range
 * given in the constructor).
 * @param {number} v V-coordinate of the surface to evaluate.
 * @return {Array&lt;number>} An array of the result of
 * the evaluation.  Its length will be equal to the
 * length of a control point, as specified in the constructor.
 */
 BezierSurface.prototype.evaluate=function(u,v, output){
 return this.evaluator.evaluate((u-this.uoffset)*this.umul,
   (v-this.voffset)*this.vmul);
};

/**
* A parametric evaluator for B-spline (basis spline) curves.
* @class
* @alias BSplineCurve
 * @param {Array&lt;Array&lt;number>>} controlPoints An array of control points.  Each
 * control point is an array with the same length as the other control points.
 * It is assumed that the first control point's length represents the size of all the control
 * points.
* @param {Array&lt;number>} knots Knot vector of the curve.
* Its size must be at least 2 plus the number of control
* points and not more than twice the number of control points.&lt;p>
* The length of this parameter minus 1, minus the number
* of control points, represents the degree of the B-spline
* curve.  For example, a degree-3 (cubic) B-spline curve contains 4 more
* knots than the number of control points.  A degree of 1
* results in straight line segments.&lt;p>
* The knot vector must be a monotonically nondecreasing sequence and
* the first knot must not equal the last.&lt;p>
* If the difference between one knot and the next isn't the same,
* the curve is considered a &lt;i>non-uniform&lt;/i>
* B-spline curve.&lt;p>
* If there are N times 2 knots with the first N knots equal to 0 and the rest
* equal to 1, where N is the number of control points,
* the control points describe a &lt;i>B&amp;eacute;zier&lt;/i> curve, in which the
* first and last control points match the curve's end points.&lt;p>
* @param {boolean} [bits] Bits for defining input
* and controlling output.  Zero or more of BSplineCurve.WEIGHTED_BIT,
* BSplineCurve.HOMOGENEOUS_BIT,
* and BSplineCurve.DIVIDE_BIT. If null or omitted, no bits are set.
*/
var BSplineCurve=function(controlPoints, knots, bits){
 if(controlPoints.length&lt;=0)throw new Error();
 if(!knots)throw new Error();
 this.bits=bits||0;
 var order=knots.length-controlPoints.length;
 if(order&lt;2 || order>controlPoints.length)
  throw new Error();
 BSplineCurve._checkKnots(knots);
 this.cplen=controlPoints[0].length;
 var cplenNeeded=1;
 if((this.bits&amp;(BSplineCurve.WEIGHTED_BIT|BSplineCurve.DIVIDE_BIT))!==0){
  cplenNeeded=2;
 }
 if((this.bits&amp;(BSplineCurve.WEIGHTED_BIT))!==0){
  this.cplen--;
 }
 if(this.cplen&lt;cplenNeeded)throw new Error();
 this.knots=knots;
 this.buffer=[];
 this.controlPoints=controlPoints;
};

/**
* Indicates whether the last coordinate of each control point is a
* weight.  If some of the weights differ, the curve is
* considered a &lt;i>rational&lt;/i> B-spline curve.
* If this bit is set, the length of each control point must be at least 2,
* and points returned by the curve's &lt;code>evaluate&lt;/code>
* method will be in homogeneous coordinates.
* @const
* @default
*/
BSplineCurve.WEIGHTED_BIT = 1;
/**
* Indicates to divide each other coordinate of the returned point
* by the last coordinate of the point and omit the last
* coordinate.  This is used with WEIGHTED_BIT to convert
* homogeneous coordinates to conventional coordinates.
* If this bit is set, the length of each control point must be at least 2.
* @const
* @default
*/
BSplineCurve.DIVIDE_BIT = 2;
/**
* Indicates that each other coordinate of each control point
* was premultiplied by the last coordinate of the point, that is,
* each control point is in homogeneous coordinates.
* Only used with WEIGHTED_BIT.
* @const
* @default
*/
BSplineCurve.HOMOGENEOUS_BIT = 4;
/**
* Combination of WEIGHTED_BIT and DIVIDE_BIT.
* @const
*/
BSplineCurve.WEIGHTED_DIVIDE_BITS = 3;

BSplineCurve._checkKnots=function(knots){
 for(var i=1;i&lt;knots.length;i++){
  if(knots[i]&lt;knots[i-1])
   throw new Error();
 }
 if(knots[0]===knots[knots.length-1])throw new Error();
};
BSplineCurve._getFactors=function(kn,t,order,numPoints,buffer){
 var c=1;
 for(var i=0;i&lt;numPoints;i++){
   buffer[i]=0;
 }
 if(t===kn[0]){
  buffer[0]=1;
 } else if(t===kn[kn.length-1]){
  buffer[numPoints-1]=1;
 } else {
  var k=-1;
  for(i=0;i&lt;=kn.length;i++){
    if(kn[i]&lt;=t &amp;&amp; t&lt;kn[i+1]){
      k=i;
      break;
    }
  }
  if(k&lt;0)return;
  var tmp=[];
  c=k-1;
  tmp[k]=1;
  for(var kk=2;kk&lt;=order;kk++,c--){
   for(i=c;i&lt;=k;i++){
    var ret=0,divisor=0;
    var prv=(i&lt;=c) ? 0 : tmp[i];
    var nxt=(i>=k) ? 0 : tmp[i+1];
    if(prv!==0){
     divisor=kn[i+kk-1]-kn[i];
     ret+=divisor===0 ? 0 : prv*(t-kn[i])/divisor;
    }
    if(nxt!==0){
     var ikk=kn[i+kk];
     divisor=ikk-kn[i+1];
     ret+=divisor===0 ? 0 : nxt*(ikk-t)/divisor;
    }
    buffer[i]=ret;
   }
   if(kk&lt;order){
    for(i=c;i&lt;=k;i++){
     tmp[i]=buffer[i];
    }
   }
  }
 }
};

/**
 * Evaluates the curve function based on a point
 * in a B-spline curve.
 * @param {number} u Point on the curve to evaluate (from 0 through 1).
 * @return {Array&lt;number>} An array of the result of
 * the evaluation.  Its length will be equal to the
 * length of a control point (minus 1 if DIVIDE_BIT is set), as specified in the constructor.
* @example
* // Generate 11 points forming the B-spline curve.
* var points=[];
* for(var i=0;i&lt;=10;i++){
*  points.push(curve.evaluate(i/10.0));
* }
 */
BSplineCurve.prototype.evaluate=function(u){
  var numPoints=this.controlPoints.length;
  var order=this.knots.length-numPoints;
  var oldu=u;
  u=this.knots[order-1]+u*(this.knots[numPoints]-
    this.knots[order-1]);
  BSplineCurve._getFactors(this.knots, u, order, numPoints,
     this.buffer);
  var ret=[];
  var i,j,point;
  if((this.bits&amp;BSplineCurve.WEIGHTED_BIT)!==0){
  // this is a weighted NURBS
  var weight=0;
  for(j=0;j&lt;numPoints;j++){
   weight+=this.buffer[j]*this.controlPoints[j][this.cplen];
  }
  var homogen=(this.bits&amp;BSplineCurve.HOMOGENEOUS_BIT)!==0;
  for(i=0;i&lt;this.cplen+1;i++){
   point=0;
   for(j=0;j&lt;numPoints;j++){
    var w=this.buffer[j];
    if(!homogen)w*=this.controlPoints[j][this.cplen];
    point+=this.controlPoints[j][i]*w;
   }
   ret[i]=point/weight;
  }
  if((this.bits&amp;BSplineCurve.DIVIDE_BIT)!==0){
   for(i=0;i&lt;this.cplen;i++){
    ret[i]/=ret[this.cplen];
   }
   ret=ret.slice(0,this.cplen);
  }
  return ret;
 } else {
  ret=[];
  for(i=0;i&lt;this.cplen;i++){
   point=0;
   for(j=0;j&lt;numPoints;j++){
    point+=this.controlPoints[j][i]*this.buffer[j];
   }
   ret[i]=point;
  }
  if((this.bits&amp;BSplineCurve.DIVIDE_BIT)!==0){
   for(i=0;i&lt;this.cplen-1;i++){
    ret[i]/=ret[this.cplen-1];
   }
   ret=ret.slice(0,this.cplen-1);
  }
  return ret;
 }
};

/**
* A parametric evaluator for B-spline (basis spline) surfaces.
* @class
* @alias BSplineSurface
 * @param {Array&lt;Array&lt;number>>} controlPoints An array of control point
 * arrays, which in turn contain a number of control points.  Each
 * control point is an array with the same length as the other control points.
 * It is assumed that:&lt;ul>
 * &lt;li>The length of this parameter is the number of control points in each row of
 * the V axis.
 * &lt;li>The length of the first control point array is the number of control points in
* each column of the U axis.
 * &lt;li>The first control point's length represents the size of all the control
 * points.
 * &lt;/ul>
* @param {Array&lt;number>} knotsU Knot vector of the curve, along the U-axis.
* For more information, see {@link glutil.BSplineCurve}.
* @param {Array&lt;number>} knotsV Knot vector of the curve, along the V-axis.
* @param {boolean} [bits] Bits for defining input
* and controlling output.  Zero or more of BSplineCurve.WEIGHTED_BIT,
* BSplineCurve.HOMOGENEOUS_BIT,
* and BSplineCurve.DIVIDE_BIT.  If null or omitted, no bits are set.
*/
var BSplineSurface=function(controlPoints, knotsU, knotsV, bits){
 var vcplen=controlPoints.length;
 if(vcplen&lt;=0)throw new Error();
 var ucplen=controlPoints[0].length;
 if(ucplen&lt;=0)throw new Error();
 var cplen=controlPoints[0][0].length;
 var cplenNeeded=1;
 this.bits=bits||0;
 if((this.bits&amp;(BSplineCurve.WEIGHTED_BIT|BSplineCurve.DIVIDE_BIT))!==0){
  cplenNeeded=2;
 }
 if((this.bits&amp;(BSplineCurve.WEIGHTED_BIT|BSplineCurve.HOMOGENEOUS_BIT))!==0){
  cplen--;
 }
 if(cplen&lt;cplenNeeded)throw new Error();
 if(!knotsU || !knotsV)throw new Error();
 this.orderU=knotsU.length-ucplen;
 this.orderV=knotsV.length-vcplen;
 this.vcplen=vcplen;
 this.ucplen=ucplen;
 this.cplen=cplen;
 if(this.orderU&lt;2 || this.orderU>ucplen)throw new Error();
 if(this.orderV&lt;2 || this.orderV>vcplen)throw new Error();
 BSplineCurve._checkKnots(knotsU);
 BSplineCurve._checkKnots(knotsV);
 this.knotsU=knotsU;
 this.knotsV=knotsV;
 this.bufferU=[];
 this.bufferV=[];
 this.controlPoints=controlPoints;
};
/**
* Creates a B-spline curve with uniform knots, except that
* the curve will start and end at the first and last control points.
* @param {Array&lt;Array&lt;number>>} controlPoints Array of
* control points as specified in the {@link glutil.BSplineCurve} constructor.
* @param {number} [degree] Degree of the B-Spline
* curve.  For example, 3 means a degree-3 (cubic) curve.
* If null or omitted, the default is 3.
* @param {number} [bits] Bits as specified in the {@link glutil.BSplineCurve} constructor.
* @return {BSplineCurve} Return value.*/
BSplineCurve.clamped=function(controlPoints,degree,bits){
 return new BSplineCurve(controlPoints,
   BSplineCurve.clampedKnots(controlPoints.length,degree),bits);
};
/**
* Creates a B-spline curve with uniform knots.
* @param {Array&lt;Array&lt;number>>} controlPoints Array of
* control points as specified in the {@link glutil.BSplineCurve} constructor.
* @param {number} [degree] Degree of the B-Spline
* curve.  For example, 3 means a degree-3 (cubic) curve.
* If null or omitted, the default is 3.
* @param {number} [bits] Bits as specified in the {@link glutil.BSplineCurve} constructor.
* @return {BSplineCurve} Return value.*/
BSplineCurve.uniform=function(controlPoints,degree,bits){
 return new BSplineCurve(controlPoints,
   BSplineCurve.uniformKnots(controlPoints.length,degree),bits);
};
/**
* Creates a B-spline surface with uniform knots, except that
* the surface's edges lie on the edges of the control point array.
* @param {Array&lt;Array&lt;Array&lt;number>>>} controlPoints Array of
* control point arrays as specified in the {@link glutil.BSplineSurface} constructor.
* @param {number} [degreeU] Degree of the B-Spline
* surface along the U-axis.  For example, 3 means a degree-3 (cubic) curve.
* If null or omitted, the default is 3.
* @param {number} [degreeV] Degree of the B-Spline
* surface along the V-axis
* If null or omitted, the default is 3.
* @param {number} [bits] Bits as specified in the {@link glutil.BSplineSurface} constructor.
* @return {BSplineSurface} Return value.*/
BSplineSurface.clamped=function(controlPoints,degreeU,degreeV,bits){
 return new BSplineSurface(controlPoints,
   BSplineCurve.clampedKnots(controlPoints[0].length,degreeU),
   BSplineCurve.clampedKnots(controlPoints.length,degreeV),bits);
};
/**
* Creates a B-spline surface with uniform knots.
* @param {Array&lt;Array&lt;Array&lt;number>>>} controlPoints Array of
* control point arrays as specified in the {@link glutil.BSplineSurface} constructor.
* @param {number} [degreeU] Degree of the B-Spline
* surface along the U-axis.  For example, 3 means a degree-3 (cubic) curve.
* If null or omitted, the default is 3.
* @param {number} [degreeV] Degree of the B-Spline
* surface along the V-axis
* If null or omitted, the default is 3.
* @param {number} [bits] Bits as specified in the {@link glutil.BSplineSurface} constructor.
* @return {BSplineSurface} Return value.*/
BSplineSurface.uniform=function(controlPoints,degreeU,degreeV,bits){
 return new BSplineSurface(controlPoints,
   BSplineCurve.uniformKnots(controlPoints[0].length,degreeU),
   BSplineCurve.uniformKnots(controlPoints.length,degreeV),bits);
};
/**
* Not documented yet.
*/
BSplineCurve.uniformKnots=function(controlPoints,degree){
  if(typeof controlPoints==="object")
   controlPoints=controlPoints.length;
  if((degree===null || typeof degree==="undefined"))degree=3;
  if(controlPoints&lt;degree+1)
   throw new Error("too few control points for degree "+degree+" curve");
  var order=degree+1;
  var ret=[];
  for(var i=0;i&lt;controlPoints+order;i++){
   ret.push(i);
  }
  return ret;
};
/**
* Not documented yet.
*/
BSplineCurve.clampedKnots=function(controlPoints,degree){
  if(typeof controlPoints==="object")
   controlPoints=controlPoints.length;
  if((degree===null || typeof degree==="undefined"))degree=3;
  if(controlPoints&lt;degree+1)
   throw new Error("too few control points for degree "+degree+" curve");
  var order=degree+1;
  var extras=controlPoints-order;
  var ret=[];
  for(var i=0;i&lt;order;i++){
   ret.push(0);
  }
  for(i=0;i&lt;extras;i++){
   ret.push(i+1);
  }
  for(i=0;i&lt;order;i++){
   ret.push(extras+1);
  }
  return ret;
};

/**
 * Evaluates the surface function based on a point
 * in a B-spline surface.
 * @param {number} u U-coordinate of the surface to evaluate (from 0 through 1).
 * @param {number} v V-coordinate of the surface to evaluate.
 * @return {Array&lt;number>} An array of the result of
 * the evaluation.  Its length will be equal to the
 * length of a control point (minus 1 if if DIVIDE_BIT is set), as specified in the constructor.
 */
BSplineSurface.prototype.evaluate=function(u,v){
  u=this.knotsU[this.orderU-1]+u*(this.knotsU[this.ucplen]-
    this.knotsU[this.orderU-1]);
  v=this.knotsV[this.orderV-1]+v*(this.knotsV[this.vcplen]-
    this.knotsV[this.orderV-1]);
  var bu=this.bufferU;
  var bv=this.bufferV;
  var tt,uu,w,i,value;
  if(this.orderU===this.orderV){
   BSplineCurve._getFactors(this.knotsU, u, this.orderU, this.ucplen,
     this.bufferU);
   BSplineCurve._getFactors(this.knotsV, v, this.orderV, this.vcplen,
     this.bufferV);
  } else {
   BSplineCurve._getFactors(this.knotsU, u, this.orderU, this.ucplen,
     this.bufferU);
   BSplineCurve._getFactors(this.knotsV, v, this.orderV, this.vcplen,
     this.bufferV);
  }
 var output=[];
  if((this.bits&amp;BSplineCurve.WEIGHTED_BIT)!==0){
  // this is a weighted NURBS
  var weight=0;
  var homogen=(this.bits&amp;BSplineCurve.HOMOGENEOUS_BIT)!==0;
  for(tt=0;tt&lt;this.ucplen;tt++){
    for(uu=0;uu&lt;this.vcplen;uu++){
     w=bu[tt]*bv[uu]*this.controlPoints[uu][tt][this.cplen];
     weight+=w;
    }
  }
  for(i=0;i&lt;this.cplen+1;i++){
   value=0;
   weight=0;
   for(tt=0;tt&lt;this.ucplen;tt++){
    for(uu=0;uu&lt;this.vcplen;uu++){
     w=bu[tt]*bv[uu];
     if(!homogen)w*=this.controlPoints[uu][tt][this.cplen];
     value+=this.controlPoints[uu][tt][i]*w;
    }
   }
   output[i]=(weight===0) ? value : value/weight;
  }
  if((this.bits&amp;BSplineCurve.DIVIDE_BIT)!==0){
   for(i=0;i&lt;this.cplen;i++){
    output[i]/=output[this.cplen];
   }
   output=output.slice(0,this.cplen);
  }
  return output;
 } else {
  for(i=0;i&lt;this.cplen;i++){
   value=0;
   for(tt=0;tt&lt;this.ucplen;tt++){
    for(uu=0;uu&lt;this.vcplen;uu++){
     value+=this.controlPoints[uu][tt][i]*bu[tt]*bv[uu];
    }
   }
   output[i]=value;
  }
  if((this.bits&amp;BSplineCurve.DIVIDE_BIT)!==0){
   for(i=0;i&lt;this.cplen-1;i++){
    output[i]/=output[this.cplen-1];
   }
   output=output.slice(0,this.cplen-1);
  }
  return output;
 }
};

/**
* An evaluator of parametric curve functions for generating
* vertex positions, normals, colors, and texture coordinates
* of a curve.&lt;p>
* A parametric curve is a curve whose points are based on a
* parametric curve function.  A curve function takes a number
* (U) and returns a point (in 1, 2, 3 or more dimensions, but
* usually 2 or 3) that lies on the curve.  For example, in 3
* dimensions, a curve function has the following form:&lt;p>
* &lt;b>F&lt;/b>(u) = [ x(u), y(u), z(u) ]&lt;p>
* where x(u) returns an X coordinate, y(u) a Y coordinate,
* and z(u) returns a Z coordinate.&lt;p>
* For more information, see the {@tutorial surfaces} tutorial.
* @class
* @alias CurveEval
*/
var CurveEval=function(){
 this.colorCurve=null;
 this.normalCurve=null;
 this.texCoordCurve=null;
 this.vertexCurve=null;
};

/**
* Specifies a parametric curve function for generating vertex positions.
* @param {object} evaluator An object that must contain a function
* named "evaluate".  It takes the following parameter:&lt;ul>
* &lt;li>&lt;code>u&lt;/code> - A curve coordinate, generally from 0 to 1.
* &lt;/ul>
* The evaluator function returns an array of the result of the evaluation.
* @return {CurveEval} This object.
* @example &lt;caption>The following function sets a circle as the curve
* to use for generating vertex positions.&lt;/caption>
* // "u" can range from 0 to 2*Math.PI
* curveEval.vertex({"evaluate":function(u){
*  return [Math.cos(u),Math.sin(u),0]
* }});
*/
CurveEval.prototype.vertex=function(evaluator){
 this.vertexCurve=evaluator;
 return this;
};
/**
* Specifies a parametric curve function for generating normals.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link CurveEval#vertex}.
* &lt;/ul>
* @return {CurveEval} This object.
*/
CurveEval.prototype.normal=function(evaluator){
 this.normalCurve=evaluator;
 return this;
};
/**
* Specifies a parametric curve function for generating color values.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link CurveEval#vertex}.
* &lt;/ul>
* @return {CurveEval} This object.
*/
CurveEval.prototype.color=function(evaluator){
 this.colorCurve=evaluator;
 return this;
};
/**
* Specifies a parametric curve function for generating texture coordinates.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 2 values as a result.  See {@link CurveEval#vertex}.
* &lt;/ul>
* @return {CurveEval} This object.
*/
CurveEval.prototype.texCoord=function(evaluator){
 this.texCoordCurve=evaluator;
 return this;
};
/**
 * Generates vertex positions and attributes based on a point
 * in a parametric curve.
 * @param {glutil.Mesh} mesh Mesh where vertex positions and attributes
 * will be generated.  When this method returns, the current color, normal,
 * and texture coordinates will be the same as they were before the method
 * started.
 * @param {number} u Point of the curve to evaluate.
 * @return {CurveEval} This object.
 */
CurveEval.prototype.evalOne=function(mesh,u){
 var color=null;
 var normal=null;
 var texcoord=null;
 if(this.colorCurve){
  color=this.colorCurve.evaluate(u);
 }
 if(this.texCoordCurve){
  texcoord=this.texCoordCurve.evaluate(u);
  if(texcoord.length === 1)texcoord.push(0);
 }
 if(this.normalCurve){
  normal=this.normalCurve.evaluate(u);
 }
 if(this.vertexCurve){
  var oldColor=(color) ? mesh.color.slice(0,3) : null;
  var oldNormal=(normal) ? mesh.normal.slice(0,3) : null;
  var oldTexCoord=(texcoord) ? mesh.texCoord.slice(0,2) : null;
  if(color)mesh.color3(color[0],color[1],color[2]);
  if(normal)mesh.normal3(normal[0],normal[1],normal[2]);
  if(texcoord)mesh.texCoord2(texcoord[0],texcoord[1]);
  var vertex=this.vertexCurve.evaluate(u);
  if(vertex.length === 2)
   mesh.vertex3(vertex[0],vertex[1],0.0);
  else
   mesh.vertex3(vertex[0],vertex[1],vertex[2]);
  if(oldColor)mesh.color3(oldColor[0],oldColor[1],oldColor[2]);
  if(oldNormal)mesh.normal3(oldNormal[0],oldNormal[1],oldNormal[2]);
  if(oldTexCoord)mesh.texCoord2(oldTexCoord[0],oldTexCoord[1]);
 }
 return this;
};
/**
 * Generates vertices and attribute values that follow a parametric curve
 * function.
 * @param {glutil.Mesh} mesh A geometric mesh where the vertices will be
 * generated.
 * @param {number} [mode] If this value is Mesh.LINES, or is null
* or omitted, generates
 * a series of lines defining the curve. If this value is Mesh.POINTS,
 * generates a series of points along the curve.  For any other value,
 * this method has no effect.
 * @param {number} [n] Number of subdivisions of the curve to be drawn.
 * May be omitted; default is 24.
 * @param {number} [u1] Starting point of the curve (within the range
 * given in the &lt;code>vector&lt;/code>, &lt;code>normal&lt;/code>,
 * &lt;code>color&lt;/code>, and &lt;code>texCoord&lt;/code> methods).
 *May be omitted; default is 0.
 * @param {number} [u2] Ending point of the curve (within the range
 * given in the &lt;code>vector&lt;/code>, normal&lt;/code>,
 * &lt;code>color&lt;/code>, and &lt;code>texCoord&lt;/code> methods).
 *May be omitted; default is 1.
 * @return {CurveEval} This object.
 */
CurveEval.prototype.evalCurve=function(mesh,mode,n,u1,u2){
 if(typeof n==="undefined")n=24;
 if(n&lt;=0)throw new Error("invalid n");
 if(typeof u1==="undefined" &amp;&amp; typeof u2==="undefined"){
  u1=0.0;
  u2=1.0;
 }
 if((mode===null || typeof mode==="undefined"))mode=Mesh.LINES;
 if(mode===Mesh.POINTS)
  mesh.mode(Mesh.POINTS);
 else if(mode===Mesh.LINES)
  mesh.mode(Mesh.LINE_STRIP);
 else return this;
 var uv=(u2-u1)/n;
 for(var i=0; i&lt;=n; i++){
  this.evalOne(mesh, u1+i*uv);
 }
 return this;
};
/**
* An evaluator of parametric functions for generating
* vertex positions, normals, colors, and texture coordinates
* of a surface.&lt;p>
* A parametric surface is a surface whose points are based on a
* parametric surface function.  A surface function takes two numbers
* (U and V) and returns a point (in 1, 2, 3 or more dimensions, but
* usually 2 or 3) that lies on the surface.  For example, in 3
* dimensions, a surface function has the following form:&lt;p>
* &lt;b>F&lt;/b>(u, v) = [ x(u, v), y(u, v), z(u, v) ]&lt;p>
* where x(u, v) returns an X coordinate, y(u, v) a Y coordinate,
* and z(u, v) returns a Z coordinate.&lt;p>
* For more information, see the {@tutorial surfaces} tutorial.
* @class
* See the {@tutorial surfaces} tutorial for more information.
* @class
* @alias glutil.SurfaceEval
*/
var SurfaceEval=function(){
 this.colorSurface=null;
 this.normalSurface=null;
 this.texCoordSurface=null;
 this.vertexSurface=null;
 this.autoNormal=false;
};
/**
 * Sets whether this object will automatically generate
 * normals rather than use the parametric evaluator
 * specified for normal generation, if any.
 * By default, normals won't be generated automatically.
 * @param {boolean} value Either true or false.  True means normals
 * will automatically be generated; false means they won't.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.setAutoNormal=function(value){
 this.autoNormal=!!value;
 return this;
};
/**
* Specifies a parametric surface function for generating vertex positions.
* @param {object} evaluator An object that must contain a function
* named "evaluate".  It takes the following parameters in this order:&lt;ul>
* &lt;li>&lt;code>u&lt;/code> - Horizontal-axis coordinate, generally from 0 to 1.
* &lt;li>&lt;code>v&lt;/code> - Vertical-axis coordinate, generally from 0 to 1.
* &lt;/ul>
* The evaluator function returns an array of the result of the evaluation.
* @return {SurfaceEval} This object.
*/
SurfaceEval.prototype.vertex=function(evaluator){
 this.vertexSurface=evaluator;
 return this;
};
/**
* Specifies a parametric surface function for generating normals.
* &lt;p>
* To generate normals for a function for a regular surface (usually
* a continuous, unbroken surface such as a sphere, disk, or open
* cylinder), find the &lt;a href="http://en.wikipedia.org/wiki/Partial_derivative">partial derivative&lt;/a> of
* the function used for vertex calculation (we'll call it &lt;b>F&lt;/b>) with
* respect to u, then find the partial derivative of &lt;b>F&lt;/b> with respect to
* v, then take their &lt;a href="http://en.wikipedia.org/wiki/Cross_product">cross
* product&lt;/a>, then normalize the result to unit length.
* In mathematical notation, this looks like:
* &lt;b>c&lt;/b> = &amp;#x2202;&lt;b>F&lt;/b>/&amp;#x2202&lt;i>u&lt;/i> &amp;times;
* &amp;#x2202;&lt;b>F&lt;/b>/&amp;#x2202&lt;i>v&lt;/i>; &lt;b>n&lt;/b> = &lt;b>c&lt;/b> / |&lt;b>c&lt;/b>|.&lt;p>
* If autonormal is enabled (see setAutoNormal()), SurfaceEval uses an approximation to this approach,
* as the SurfaceEval class doesn't know the implementation of the method used
* for vertex calculation.&lt;p>
* (Note: &amp;#x2202;&lt;b>F&lt;/b>/&amp;#x2202&lt;i>u&lt;/i> is also called the &lt;i>bitangent&lt;/i>
* or &lt;i>binormal vector&lt;/i>, and &amp;#x2202;&lt;b>F&lt;/b>/&amp;#x2202&lt;i>v&lt;/i> is also
* called the &lt;i>tangent vector&lt;/i>.)
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link SurfaceEval#vertex}.
* &lt;/ul>
* @return {SurfaceEval} This object.
* @example &lt;caption>The following example sets the normal generation
* function for a parametric surface.  To illustrate how the method is derived
* from the vector calculation method, that method is also given below.  To
* derive the normal calculation, first look at the vector function:&lt;p>
* &lt;b>F&lt;/b>(u, v) = (cos(u), sin(u), sin(u)*cos(v))&lt;p>
* Then, find the partial derivatives with respect to u and v:&lt;p>
* &amp;#x2202;&lt;b>F&lt;/b>/&amp;#x2202;&lt;i>u&lt;/i> = (-sin(u), cos(u), cos(u)*cos(v))&lt;br>
* &amp;#x2202;&lt;b>F&lt;/b>/&amp;#x2202;&lt;i>v&lt;/i> = (0, 0, -sin(v)*sin(u))&lt;p>
* Next, take their cross product:&lt;p>
* &lt;b>c&lt;/b>(u, v) = (-sin(v)*cos(u)*sin(u), -sin(v)*sin(u)*sin(u), 0)&lt;br>&lt;p>
* And finally, normalize the result:&lt;p>
* &lt;b>n&lt;/b>(u, v) = &lt;b>c&lt;/b>(u, v)/|&lt;b>c&lt;/b>(u, v)|&lt;p>
*&lt;/caption>
* surfaceEval.vertex({"evaluate":function(u,v){
*  return [Math.cos(u),Math.sin(u),Math.sin(u)*Math.cos(v)];
* }})
* .normal({"evaluate":function(u,v){
*  return GLMath.vec3normInPlace([
*   Math.cos(u)*-Math.sin(v)*Math.sin(u),
*   Math.sin(u)*-Math.sin(v)*Math.sin(u),
*   0]);
* }})
*/
SurfaceEval.prototype.normal=function(evaluator){
 this.normalSurface=evaluator;
 return this;
};
/**
* Specifies a parametric surface function for generating color values.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link SurfaceEval#vertex}.
* &lt;/ul>
* @return {SurfaceEval} This object.
*/
SurfaceEval.prototype.color=function(evaluator){
 this.colorSurface=evaluator;
 return this;
};
/**
* Specifies a parametric surface function for generating texture coordinates.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 2 values as a result.  See {@link SurfaceEval#vertex}.
* &lt;/ul>
* @return {SurfaceEval} This object.
* @example &lt;caption>The following example sets the surface
* function to a linear evaluator. Thus, coordinates passed to the
* evalOne and evalSurface methods will be interpolated as direct
* texture coordinates.&lt;/caption>
* surface.texCoord({"evaluate":function(u,v){ return [u,v] }});
*/
SurfaceEval.prototype.texCoord=function(evaluator){
 this.texCoordSurface=evaluator;
 return this;
};
/**
 * Generates vertex positions and attributes based on a point
 * in a parametric surface.
 * @param {glutil.Mesh} mesh Mesh where vertex positions and attributes
 * will be generated.  When this method returns, the current color, normal,
 * and texture coordinates will be the same as they were before the method
 * started.
 * @param {number} u U-coordinate of the curve to evaluate
 * @param {number} v V-coordinate of the curve to evaluate.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.evalOne=function(mesh,u,v){
 var values=[];
 this._saveValues(mesh,values,0);
 this._record(u,v,values,_OLD_VALUES_SIZE);
 this._playBack(mesh,values,_OLD_VALUES_SIZE);
 this._restoreValues(mesh,values,0);
 return this;
};
/** @private
 @const
*/
var _OLD_VALUES_SIZE = 8;
/** @private
 @const
*/
var _RECORDED_VALUES_SIZE = 11;
/** @private */
SurfaceEval.prototype._recordAndPlayBack=function(mesh,u,v,buffer,index){
 this._record(u,v,buffer,index);
 this._playBack(mesh,buffer,index);
};
/** @private */
SurfaceEval.prototype._saveValues=function(mesh,buffer,index){
 if(this.colorSurface){
  buffer[index+3]=mesh.color[0];
  buffer[index+4]=mesh.color[1];
  buffer[index+5]=mesh.color[2];
 }
 if(this.normalSurface || this.autoNormal){
  buffer[index+0]=mesh.normal[0];
  buffer[index+1]=mesh.normal[1];
  buffer[index+2]=mesh.normal[2];
 }
 if(this.texCoordSurface){
  buffer[index+6]=mesh.texCoord[0];
  buffer[index+7]=mesh.texCoord[1];
 }
};
/** @private */
SurfaceEval.prototype._restoreValues=function(mesh,buffer,index){
 if(this.colorSurface){
  mesh.color3(buffer[index+3],buffer[index+4],buffer[index+5]);
 }
 if(this.normalSurface || this.autoNormal){
  mesh.normal3(buffer[index+0],buffer[index+1],buffer[index+2]);
 }
 if(this.texCoordSurface){
  mesh.texCoord2(buffer[index+6],buffer[index+7]);
 }
};
/** @private */
SurfaceEval.prototype._record=function(u,v,buffer,index){
 var normal=null;
 if(this.colorSurface){
  var color=this.colorSurface.evaluate(u,v);
  buffer[index+6]=color[0];
  buffer[index+7]=color[1];
  buffer[index+8]=color[2];
 }
 if(this.texCoordSurface){
  var texcoord=this.texCoordSurface.evaluate(u,v);
  buffer[index+9]=texcoord[0];
  buffer[index+10]=(texcoord.length&lt;=1) ? 0 : texcoord[1];
 }
 if(this.normalSurface &amp;&amp; !this.autoNormal){
  normal=this.normalSurface.evaluate(u,v);
  buffer[index+3]=normal[0];
  buffer[index+4]=normal[1];
  buffer[index+5]=normal[2];
 }
 if(this.vertexSurface){
  var vertex=this.vertexSurface.evaluate(u,v);
  buffer[index]=vertex[0];
  buffer[index+1]=vertex[1];
  buffer[index+2]=vertex[2];
  if(this.autoNormal){
   var du=0.00001;
   var dv=0.00001;
   // Find the partial derivatives of u and v
   var vu=this.vertexSurface.evaluate(u+du,v);
   if(vu[0] === 0 &amp;&amp; vu[1] === 0 &amp;&amp; vu[2] === 0){
    // too abrupt, try the other direction
    du=-du;
    vu=this.vertexSurface.evaluate(u+du,v);
   }
   var vuz=vu[2];
   var vv=this.vertexSurface.evaluate(u,v+dv);
   if(vv[0] === 0 &amp;&amp; vv[1] === 0 &amp;&amp; vv[2] === 0){
    // too abrupt, try the other direction
    dv=-dv;
    vv=this.vertexSurface.evaluate(u,v+dv);
   }
   GLMath.vec3subInPlace(vv,vertex);
   GLMath.vec3subInPlace(vu,vertex);
   // Divide by the deltas of u and v
   GLMath.vec3scaleInPlace(vu,1.0/du);
   GLMath.vec3scaleInPlace(vv,1.0/dv);
   GLMath.vec3normInPlace(vu);
   GLMath.vec3normInPlace(vv);
   if(GLMath.vec3length(vu) === 0){
    // partial derivative of u is degenerate
    //console.log([vu,vv,u,v]+" u degen")
    vu=vv;
   } else if(GLMath.vec3length(vv)!==0){
    vu=GLMath.vec3cross(vu,vv);
    GLMath.vec3normInPlace(vu);
   } else {
    // partial derivative of v is degenerate
    //console.log([vu,vv,u,v]+" v degen")
    if(vu[2]===vertex[2]){
      // the close evaluation returns the same
      // z as this evaluation
      vu=[0,0,1];
    }
   }
   buffer[index+3]=vu[0];
   buffer[index+4]=vu[1];
   buffer[index+5]=vu[2];
  }
 }
};
/** @private */
SurfaceEval.prototype._playBack=function(mesh,buffer,index){
 if(this.vertexSurface){
  if(this.colorSurface){
   mesh.color3(buffer[index+6],buffer[index+7],buffer[index+8]);
  }
  if(this.normalSurface || this.autoNormal){
   mesh.normal3(buffer[index+3],buffer[index+4],buffer[index+5]);
  }
  if(this.texCoordSurface){
   mesh.texCoord2(buffer[index+9],buffer[index+10]);
  }
  mesh.vertex3(buffer[index+0],buffer[index+1],buffer[index+2]);
 }
};

/**
 * Generates the vertex positions and attributes of a parametric
 * surface.
 * @param {glutil.Mesh} mesh Mesh where vertex positions and attributes
 * will be generated.  When this method returns, the current color, normal,
 * and texture coordinates will be the same as they were before the method
 * started.
 * @param {number} [mode] If this value is Mesh.TRIANGLES, or is null
 * or omitted, generates a series of triangles defining the surface.  If
 * this value is Mesh.LINES, generates
 * a series of lines defining the curve. If this value is Mesh.POINTS,
 * generates a series of points along the curve.  For any other value,
 * this method has no effect.
 * @param {number} [un] Number of subdivisions along the U-axis.
 * Default is 24.
 * @param {number} [vn] Number of subdivisions along the V-axis.
 * Default is 24.
 * @param {number} [u1] Starting U-coordinate of the surface to evaluate.
 * Default is 0.
 * @param {number} [u2] Ending U-coordinate of the surface to evaluate.
 * Default is 1.
 * @param {number} [v1] Starting U-coordinate of the surface to evaluate.
 * Default is 0.
 * @param {number} [v2] Ending U-coordinate of the surface to evaluate.
 * Default is 1.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.evalSurface=function(mesh,mode,un,vn,u1,u2,v1,v2){
 if(typeof un==="undefined")un=24;
 if(typeof vn==="undefined")vn=24;
 if(un&lt;=0)throw new Error("invalid un");
 if(vn&lt;=0)throw new Error("invalid vn");
 if((mode===null || typeof mode==="undefined"))mode=Mesh.TRIANGLES;
 if(typeof v1==="undefined" &amp;&amp; typeof v2==="undefined"){
  v1=0.0;
  v2=1.0;
 }
 if(typeof u1==="undefined" &amp;&amp; typeof u2==="undefined"){
  u1=0.0;
  u2=1.0;
 }
 var du=(u2-u1)/un;
 var dv=(v2-v1)/vn;
 var i,j,jx,prevIndex;
 if(mode===Mesh.TRIANGLES){
  var oldValues=[];
  var previousValues=[];
  this._saveValues(mesh,oldValues,0);
  for(i=0;i&lt;vn;i++){
   mesh.mode(Mesh.TRIANGLE_STRIP);
   for(j=0,prevIndex=0;j&lt;=un;
      j++,prevIndex+=_RECORDED_VALUES_SIZE){
    jx=j*du+u1;
    if(i === 0){
     this._recordAndPlayBack(mesh,jx,i*dv+v1,oldValues,_OLD_VALUES_SIZE);
    } else {
     this._playBack(mesh,previousValues,prevIndex);
    }
    if(i===vn-1){
     this._recordAndPlayBack(mesh,jx,(i+1)*dv+v1,oldValues,_OLD_VALUES_SIZE);
    } else {
     this._recordAndPlayBack(mesh,jx,(i+1)*dv+v1,previousValues,prevIndex);
    }
   }
  }
  this._restoreValues(mesh,oldValues,0);
 } else if(mode===Mesh.POINTS){
  mesh.mode(Mesh.POINTS);
  for(i=0;i&lt;=vn;i++){
   for(j=0;j&lt;=un;j++){
    jx=j*du+u1;
    this.evalOne(mesh,jx,i*dv+v1);
   }
  }
 } else if(mode===Mesh.LINES){
  for(i=0;i&lt;=vn;i++){
   mesh.mode(Mesh.LINE_STRIP);
   for(j=0;j&lt;=un;j++){
    jx=j*du+u1;
    this.evalOne(mesh,jx,i*dv+v1);
   }
  }
  for(i=0;i&lt;=un;i++){
   mesh.mode(Mesh.LINE_STRIP);
   for(j=0;j&lt;=vn;j++){
    this.evalOne(mesh,i*du+u1,j*dv+v1);
   }
  }
 }
 return this;
};
global.SurfaceEval=SurfaceEval;
global.CurveEval=CurveEval;
global.BezierCurve=BezierCurve;
global.BezierSurface=BezierSurface;
global.BSplineCurve=BSplineCurve;
global.BSplineSurface=BSplineSurface;
})(this);
</code></pre>
        </article>
    </section>

</div>
<nav style="float: right;width: 25%;border-left: 1px solid;margin-top:0px;box-sizing: border-box;padding-left: 1em;">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHfwYJKoZIhvcNAQcEoIIHcDCCB2wCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYBTEjVSqAfM9cTLwXVwxBqNI8r1Il0SJNqahKnIJrEIZOdmziEnZsYS8kifxxbWCBrNGl1S/eO5kcMG6WO50eBSxFlNpweevNYIs0dIdfQZtiWcRD2yYzaWHBkHu3PmCCLmc3pPT5QaOc949w2dPcg+syabMOSwN94Mk67Wh//7pTELMAkGBSsOAwIaBQAwgfwGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIm7w2yVS0zOeAgdhYAX/keBkbLTGS2k5QcVstRROvRVuMlDL7sy/YUie0YlEJKDFTFE7n6LP15AFfODDattjmqKJ7UZ+6hY9sqJhayUNqdl/rA/RYgPVKGWTM1l68+KFdz2SO3IHvBUJIAwnHFX1JVyNUAofSxWj+3eoN5MnQzskA4cKe/RFWB04oXxZS7/WCOHL3q3mlwFDSK83C3Wcqro7S18YnVxfJ4XGUQ7nlx1C9K0Xq+JbCGEC4D8yjQHzm9w3LqUOogiI3l9VVlXxuqcAdq+iBkAGIt3y4TXABMtXEFG2gggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xMzA4MTAxMzA4NDBaMCMGCSqGSIb3DQEJBDEWBBQImRl0rdSM38l1aTcRhxgiKb7ipTANBgkqhkiG9w0BAQEFAASBgE0IsEWvN+n6QuwDFkBMQO9C4z5uf7wAvoMDgifDKBCyGFmpYZPsKawkYVcS/kASDtyq6aWU3lqP+KweyA+0xfpAyE3R8/7p80uqGGs8bHGicxkl2pEkX95R23HGRa1pEDHFF1XQNkhns558WioFipI2RvmAAEaMgZQ1p+SV/cdu-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
<h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glmath.html">glmath</a></li><li><a href="module-glutil.html">glutil</a></li></ul><h3>Classes</h3><ul><li><a href="BezierCurve.html">BezierCurve</a></li><li><a href="BezierSurface.html">BezierSurface</a></li><li><a href="BSplineCurve.html">BSplineCurve</a></li><li><a href="BSplineSurface.html">BSplineSurface</a></li><li><a href="Camera.html">Camera</a></li><li><a href="CurveEval.html">CurveEval</a></li><li><a href="CurveTube.html">CurveTube</a></li><li><a href="Epitrochoid.html">Epitrochoid</a></li><li><a href="glmath.GLMath.html">GLMath</a></li><li><a href="glutil.GLUtil.html">GLUtil</a></li><li><a href="glutil.Lights.html">Lights</a></li><li><a href="glutil.LightSource.html">LightSource</a></li><li><a href="glutil.Material.html">Material</a></li><li><a href="glutil.Mesh.html">Mesh</a></li><li><a href="glutil.Meshes.html">Meshes</a></li><li><a href="glutil.Scene3D.html">Scene3D</a></li><li><a href="glutil.ShaderProgram.html">ShaderProgram</a></li><li><a href="glutil.Shape.html">Shape</a></li><li><a href="glutil.ShapeGroup.html">ShapeGroup</a></li><li><a href="glutil.SurfaceEval.html">SurfaceEval</a></li><li><a href="glutil.Texture.html">Texture</a></li><li><a href="glutil.Transform.html">Transform</a></li><li><a href="Hypotrochoid.html">Hypotrochoid</a></li><li><a href="MatrixStack.html">MatrixStack</a></li><li><a href="MeshJSON.html">MeshJSON</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="Promise.html">Promise</a></li><li><a href="SurfaceOfRevolution.html">SurfaceOfRevolution</a></li><li><a href="Trochoid.html">Trochoid</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera_.html">The "Camera" and the Projection and View Transforms</a></li><li><a href="tutorial-filters.html">Graphics Filters</a></li><li><a href="tutorial-glmath.html">GLMath Math Library</a></li><li><a href="tutorial-history.html">Older Version History</a></li><li><a href="tutorial-matrixdetails.html">Matrix Details</a></li><li><a href="tutorial-meshexamples.html">Examples of Creating Meshes on the Fly</a></li><li><a href="tutorial-overview.html">Library Overview</a></li><li><a href="tutorial-paths.html">2-Dimensional Graphics Paths</a></li><li><a href="tutorial-shapes.html">Creating Shapes</a></li><li><a href="tutorial-surfaces.html">Parametric Curves and Parametric Surfaces</a></li><li><a href="tutorial-textures.html">Texture Examples</a></li></ul>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
