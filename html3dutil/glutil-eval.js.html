<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Source: glutil-eval.js</title>
<script src="mathml.js"></script>
</head>
<body style="margin-top:0px">
<div style="width:75%;float:left;">
    <h1>Source: glutil-eval.js</h1>

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/
(function(global){
/** @private */
function BernsteinEval(order){
 this.order=order;
 this.n=this.order-1;
}
/** @private */
BernsteinEval._binomial=[ [1],
  [1,1],
  [1,2,1],
  [1,3,3,1],
  [1,4,6,4,1],
  [1,5,10,10,5,1],
  [1,6,15,20,15,6,1],
  [1,7,21,35,35,21,7,1],
  [1,8,28,56,70,56,28,8,1],
  [1,9,36,84,126,126,84,36,9,1],
  [1,10,45,120,210,252,210,120,45,10,1],
  [1,11,55,165,330,462,462,330,165,55,11,1],
  [1,12,66,220,495,792,924,792,495,220,66,12,1],
  [1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],
  [1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],
  [1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,
  455,105,15,1],
  [1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,
  1820,560,120,16,1],
  [1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,
  6188,2380,680,136,17,1],
  [1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,
  18564,8568,3060,816,153,18,1],
  [1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,
  50388,27132,11628,3876,969,171,19,1],
  [1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,
  125970,77520,38760,15504,4845,1140,190,20,1] ];
/** @private */
BernsteinEval._factorial=function(n) {
  var result = 1;
  for (var i = n; i > 1; i--)result *= i;
  return result;
}
/** @private */
BernsteinEval.prototype.getFactor=function(t, i){
 var bino;
 if(i==0){
  return Math.pow(1-u,this.n-i);
 } else if(i==this.n-1){
  return Math.pow(u,i)*Math.pow(1-u,this.n-i);
 } else if(this.n&lt;BernsteinEval._binomial.length){
  var fac=Math.pow(u,i)*Math.pow(1-u,this.n-i);
  return fac * BernsteinEval._factorial(this.n) /
     (BernsteinEval._factorial(i) * BernsteinEval._factorial(this.n-i));
 } else {
  var fac=Math.pow(u,i)*Math.pow(1-u,this.n-i);
  return fac * BernsteinEval._binomial[this.n][i];
 }
}
/** @private */
BernsteinEval.prototype.getFactors=function(t, output){
 for(var i=0;i&lt;this.order;i++){
  output[i]=this.getFactor(t, i);
 }
}
/** @private */
function BernsteinEvalSpline(controlPoints){
 this.order=controlPoints.length;
 if(this.order&lt;=0)throw new Error("no control points")
 this.k=controlPoints[0].length;
 this.points=controlPoints;
 this.evaluator=new BernsteinEval(this.order);
}
/** @private */
BernsteinEvalSpline.prototype.evaluate=function(t, output){
 for(var i=0;i&lt;this.k;i++){
  var value=0;
  for(var j=0;j&lt;this.order;j++){
   value+=this.points[j][i]*this.evaluator.getFactor(t, j);
  }
  output[i]=value;
 }
}
/** @private */
function BernsteinEvalSurface(controlPoints){
 if(!this.controlPoints||this.controlPoints.length==0)
  throw new Error("no control points")
 this.uorder=controlPoints.length;
 this.torder=controlPoints[0].length;
 this.k=controlPoints[0][0].length;
 this.points=controlPoints;
 this.evaluator=new BernsteinEval(this.order);
 this.bufferT=[];
 this.bufferU=[];
}
/** @private */
BernsteinEvalSurface.prototype.evaluate=function(t, u, output){
 var bt=bufferT;
 var bu=bufferU;
 if(t==u){
  bu=bufferT;
  this.evaluator.getFactors(t, bufferT);
 } else {
  this.evaluator.getFactors(t, bufferT);
  this.evaluator.getFactors(u, bufferU);
 }
 for(var i=0;i&lt;this.k;i++){
  var value=0;
  for(var tt=0;tt&lt;this.torder;tt++){
   for(var uu=0;uu&lt;this.uorder;uu++){
    value+=this.points[uu][tt][i]*bt[tt]*bu[uu];
   }
  }
  output[i]=value;
 }
}
/**
 * A parametric evaluator for B&amp;eacute;zier curves.&lt;p>
 * A B&amp;eacute;zier curve is defined by a series of control points, where
 * the first and last control points define the endpoints of the curve, and
 * the remaining control points define the curve's shape, though they don't
 * necessarily cross the curve.
 * @class
 * @alias BezierCurve
 * @param {Array&lt;Array&lt;number>>} controlPoints An array of control points.  Each
 * control point is an array with the same length as the other control points.
 * It is assumed that:&lt;ul>
 * &lt;li>The length of this parameter minus 1 represents the degree of the B&amp;eacute;zier
 * curve.  For example, a degree-3 (cubic) curve
 * contains 4 control points.  A degree of 1 results in a straight line segment.
 * &lt;li>The first control point's length represents the size of all the control
 * points.
 * &lt;/ul>
 * @param {number} [u1] Starting point for the purpose of interpolation; it will correspond to 0.
 * May be omitted; default is 0.
 * @param {number} [u2] Ending point for the purpose of interpolation; it will correspond to 1.
 * May be omitted; default is 1.
 */
function BezierCurve(cp, u1, u2){
 if(typeof u1=="undefined" &amp;&amp; typeof u2=="undefined"){
  this.uoffset=0;
  this.umul=1;
 } else if(u1==u2){
  throw new Error("u1 and u2 can't be equal")
 } else {
  this.uoffset=u1;
  this.umul=1.0/(u2-u1);
 }
 this.evaluator=new BernsteinEvalSpline(cp);
 this.k=this.evaluator.k;
}
/**
 * Evaluates the curve function based on a point
 * in a B&amp;eacute;zier curve.
 * @param {number} u Point on the curve to evaluate (generally within the range
 * given in the constructor).
 * @return {Array&lt;number>} An array of the result of
 * the evaluation.  Its length will be equal to the
 * length of a control point, as specified in the constructor.
* @example
* // Generate 11 points forming the B&amp;eacute;zier curve.
* // Assumes the curve was created with u1=0 and u2=1 (the default).
* var points=[];
* for(var i=0;i&lt;=10;i++){
*  points.push(curve.evaluate(i/10.0));
* }
 */
BezierCurve.prototype.evaluate=function(u){
 var output=[];
 this.evaluator.evaluate((u-this.uoffset)*this.umul,output);
 return output;
}
/**
 * A parametric evaluator for B&amp;eacute;zier surfaces.&lt;p>
 * A B&amp;eacute;zier surface is defined by a series of control points, where
 * the control points on each corner define the endpoints of the surface, and
 * the remaining control points define the surface's shape, though they don't
 * necessarily cross the surface.
 * @class
 * @alias BezierSurface
 * @param {Array&lt;Array&lt;number>>} controlPoints An array of control point
 * arrays, which in turn contain a number of control points.  Each
 * control point is an array with the same length as the other control points.
 * It is assumed that:&lt;ul>
 * &lt;li>The length of this parameter minus 1 represents the degree of the B&amp;eacute;zier
 * surface along the V axis.  For example, a degree-3 (cubic) surface along the V axis
 * contains 4 control points, one in each control point array.  A degree of 1 on
 * both the U and V axes results in a flat surface.
 * &lt;li>The length of the first control point array minus 1 represents the degree of the B&amp;eacute;zier
 * surface along the U axis.
 * &lt;li>The first control point's length represents the size of all the control
 * points.
 * &lt;/ul>
 * @param {number} [u1] Starting point for the purpose of interpolation along the
 * U-axis; it will correspond to 0.
 * May be omitted; default is 0.
 * @param {number} [u2] Ending point for the purpose of interpolation along the
 * U-axis; it will correspond to 1.
 * May be omitted; default is 1.
 * @param {number} [v1] Starting point for the purpose of interpolation along the
 * V-axis; it will correspond to 0.
 * May be omitted; default is 0.
 * @param {number} [v2] Ending point for the purpose of interpolation along the
 * V-axis; it will correspond to 1.
 * May be omitted; default is 1.
 */
function BezierSurface(cp, u1, u2, v1, v2){
 if(typeof u1=="undefined" &amp;&amp; typeof u2=="undefined" &amp;&amp;
    typeof v1=="undefined" &amp;&amp; typeof v2=="undefined"){
  this.uoffset=0;
  this.umul=1;
  this.voffset=0;
  this.vmul=1;
 } else if(u1==u2){
  throw new Error("u1 and u2 can't be equal")
 } else if(v1==v2){
  throw new Error("v1 and v2 can't be equal")
 } else {
  this.uoffset=u1;
  this.umul=1.0/(u2-u1);
  this.voffset=v1;
  this.vmul=1.0/(v2-v1);
 }
 this.evaluator=new BernsteinEvalSpline(cp);
 this.k=this.evaluator.k;
}
/**
 * Evaluates the surface function based on a point
 * in a B&amp;eacute;zier surface.
 * @param {number} u U-coordinate of the surface to evaluate (generally within the range
 * given in the constructor).
 * @param {number} v V-coordinate of the surface to evaluate.
 * @return {Array&lt;number>} An array of the result of
 * the evaluation.  Its length will be equal to the
 * length of a control point, as specified in the constructor.
 */
 BezierSurface.prototype.evaluate=function(u,v, output){
 var output=[];
 this.evaluator.evaluate((u-this.uoffset)*this.umul,
   (v-this.voffset)*this.vmul,output);
 return output;
}

/**
* An evaluator of parametric curve functions for generating
* vertex positions, normals, colors, and texture coordinates
* of a curve.
* @class
* @alias CurveEval
*/
var CurveEval=function(){
 this.colorCurve=null;
 this.normalCurve=null;
 this.texCoordCurve=null;
 this.vertexCurve=null;
}

/**
* Specifies a parametric curve function for generating vertex positions.
* @param {object} evaluator An object that must contain a function
* named "evaluate".  It takes the following parameter:&lt;ul>
* &lt;li>&lt;code>u&lt;/code> - A curve coordinate, generally from 0 to 1.
* &lt;/ul>
* The evaluator function returns an array of the result of the evaluation.
* @return {CurveEval} This object.
*/
CurveEval.prototype.vertex=function(evaluator){
 this.vertexCurve=evaluator;
 return this;
}
/**
* Specifies a parametric curve function for generating normals.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link CurveEval#vertex}.
* &lt;/ul>
* @return {CurveEval} This object.
*/
CurveEval.prototype.normal=function(evaluator){
 this.normalCurve=evaluator;
 return this;
}
/**
* Specifies a parametric curve function for generating color values.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link CurveEval#vertex}.
* &lt;/ul>
* @return {CurveEval} This object.
*/
CurveEval.prototype.color=function(evaluator){
 this.colorCurve=evaluator;
 return this;
}
/**
* Specifies a parametric curve function for generating texture coordinates.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 2 values as a result.  See {@link CurveEval#vertex}.
* &lt;/ul>
* @return {CurveEval} This object.
*/
CurveEval.prototype.texCoord=function(evaluator){
 this.texCoordCurve=evaluator;
 return this;
}
/**
 * Specifies a B&amp;eacute;zier curve used for generating vertex positions.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierCurve},
 * where each point is a 3-element array giving the x, y, and z coordinates of a vertex
 * position.
 * @param {number} [u1] Starting point; see {@link BezierCurve}.
 * @param {number} [u2] Ending point; see {@link BezierCurve}.
 * @return {CurveEval} This object.
 */
CurveEval.prototype.vertexBezier=function(controlPoints,u1,u2){
 this.vertexCurve=new BezierCurve(controlPoints,u1,u2);
 if(this.vertexCurve.k!=3)
   throw new Error("unsupported vertex length")
 return this;
}
/**
 * Specifies a B&amp;eacute;zier curve used for generating normals.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierCurve},
 * where each point is a 3-element array giving the x, y, and z coordinates of a normal.
 * @param {number} [u1] Starting point; see {@link BezierCurve}.
 * @param {number} [u2] Ending point; see {@link BezierCurve}.
 * @return {CurveEval} This object.
*/
CurveEval.prototype.normalBezier=function(controlPoints,u1,u2){
 this.normalCurve=new BezierCurve(controlPoints,u1,u2);
 if(this.normalCurve.k!=3)
   throw new Error("invalid normal length")
 return this;
}
/**
 * Specifies a B&amp;eacute;zier curve used for generating texture coordinates.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierCurve},
 * where each point is a 1- or 2-element array giving the u and v texture coordinates.
 * @param {number} [u1] Starting point; see {@link BezierCurve}.
 * @param {number} [u2] Ending point; see {@link BezierCurve}.
 * @return {CurveEval} This object.
 */
CurveEval.prototype.texCoordBezier=function(controlPoints,u1,u2){
 this.texCoordCurve=new BezierCurve(controlPoints,u1,u2);
 if(this.texCoordCurve.k!=1 &amp;&amp; this.texCoordCurve.k!=2)
   throw new Error("unsupported texcoord length")
 return this;
}
/**
 * Specifies a B&amp;eacute;zier curve used for generating color values.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierCurve},
 * where each point is a 3-element array giving the red, green, and blue
 * values of a color.
 * @param {number} [u1] Starting point; see {@link BezierCurve}.
 * @param {number} [u2] Ending point; see {@link BezierCurve}.
 * @return {CurveEval} This object.
 */
CurveEval.prototype.colorBezier=function(controlPoints,u1,u2){
 this.colorCurve=new BezierCurve(controlPoints,u1,u2);
 if(this.colorCurve.k!=3)
   throw new Error("unsupported color length")
 return this;
}
/**
 * Generates vertex positions and attributes based on a point
 * in a parametric curve.
 * @param {glutil.Mesh} mesh Mesh where vertex positions and attributes
 * will be generated.  When this method returns, the current color, normal,
 * and texture coordinates will be the same as they were before the method
 * started.
 * @param {number} u Point of the curve to evaluate (for
 * B&amp;eacute;zier curves, generally within the range
 * given in the &lt;code>vectorBezier&lt;/code>, &lt;code>normalBezier&lt;/code>,
 * &lt;code>colorBezier&lt;/code>, and &lt;code>texCoordBezier&lt;/code> methods).
 * @return {CurveEval} This object.
 */
CurveEval.prototype.evalOne=function(mesh,u){
 var color=null;
 var normal=null;
 var texcoord=null;
 if(this.colorCurve){
  color=this.colorCurve.evaluate(u);
 }
 if(this.texCoordCurve){
  texcoord=this.texCoordCurve.evaluate(u);
  if(texcoord.length==1)texcoord.push(0);
 }
 if(this.normalCurve){
  normal=this.normalCurve.evaluate(u);
 }
 if(this.vertexCurve){
  var oldColor=(color) ? mesh.color.slice(0,3) : null;
  var oldNormal=(normal) ? mesh.normal.slice(0,3) : null;
  var oldTexCoord=(texcoord) ? mesh.texCoord.slice(0,3) : null;
  if(color)mesh.color3(color[0],color[1],color[2]);
  if(normal)mesh.normal3(normal[0],normal[1],normal[2]);
  if(texcoord)mesh.texCoord3(texcoord[0],texcoord[1],texcoord[2]);
  var vertex=this.vertexCurve.evaluate(u);
  mesh.vertex3(vertex[0],vertex[1],vertex[2]);
  if(oldColor)mesh.color3(oldColor[0],oldColor[1],oldColor[2]);
  if(oldNormal)mesh.normal3(oldNormal[0],oldNormal[1],oldNormal[2]);
  if(oldTexCoord)mesh.texCoord3(oldTexCoord[0],oldTexCoord[1],oldTexCoord[2]);
 }
 return this;
}
/**
 * Generates vertices and attribute values that follow a parametric curve
 * function.
 * @param {glutil.Mesh} mesh A geometric mesh where the vertices will be
 * generated.
 * @param {number} [mode] If this value is Mesh.LINES, or is null
* or omitted, generates
 * a series of lines defining the curve. If this value is Mesh.POINTS,
 * generates a series of points along the curve.  For any other value,
 * this method has no effect.
 * @param {number} [n] Number of subdivisions of the curve to be drawn.
 * May be omitted; default is 24.
 * @param {number} [u1] Starting point of the curve (within the range
 * given in the &lt;code>vector&lt;/code>, &lt;code>normal&lt;/code>,
 * &lt;code>color&lt;/code>, and &lt;code>texCoord&lt;/code> methods).
 *May be omitted; default is 0.
 * @param {number} [u2] Ending point of the curve (within the range
 * given in the &lt;code>vector&lt;/code>, normal&lt;/code>,
 * &lt;code>color&lt;/code>, and &lt;code>texCoord&lt;/code> methods).
 *May be omitted; default is 1.
 * @return {CurveEval} This object.
 */
CurveEval.prototype.evalCurve=function(mesh,mode,n,u1,u2){
 if(typeof n=="undefined")n=24;
 if(n&lt;=0)throw new Error("invalid n")
 if(typeof u1=="undefined" &amp;&amp; typeof u2=="undefined"){
  u1=0.0;
  u2=1.0;
 }
 if(mode==null)mode=Mesh.LINES;
 var uv=(u2-u1)/n;
 if(mode==Mesh.POINTS)
  mesh.mode(Mesh.POINTS)
 else if(mode==Mesh.LINES)
  mesh.mode(Mesh.LINE_STRIP)
 else return this;
 for(var i=0; i&lt;=n; i++){
  this.evalOne(mesh, u1+i*uv);
 }
 return this;
}
/**
* An evaluator of parametric functions for generating
* vertex positions, normals, colors, and texture coordinates
* of a surface.&lt;p>
* See the {@tutorial surfaces} tutorial for more information.
* @class
* @alias glutil.SurfaceEval
*/
var SurfaceEval=function(){
 this.colorSurface=null;
 this.normalSurface=null;
 this.texCoordSurface=null;
 this.vertexSurface=null;
 this.autoNormal=false;
}
/**
 * Sets whether this object will automatically generate
 * normals rather than use the parametric evaluator
 * specified for normal generation, if any.
 * By default, normals won't be generated automatically.
 * @param {boolean} value Either true or false.  True means normals
 * will automatically be generated; false means they won't.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.setAutoNormal=function(value){
 this.autoNormal=!!value;
 return this;
}
/**
* Specifies a parametric surface function for generating vertex positions.
* @param {object} evaluator An object that must contain a function
* named "evaluate".  It takes the following parameters in this order:&lt;ul>
* &lt;li>&lt;code>u&lt;/code> - Horizontal-axis coordinate, generally from 0 to 1.
* &lt;li>&lt;code>v&lt;/code> - Vertical-axis coordinate, generally from 0 to 1.
* &lt;/ul>
* The evaluator function returns an array of the result of the evaluation.
* @return {SurfaceEval} This object.
*/
SurfaceEval.prototype.vertex=function(evaluator){
 this.vertexSurface=evaluator;
 return this;
}
/**
* Specifies a parametric surface function for generating normals.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link SurfaceEval#vertex}.
* &lt;/ul>
* @return {SurfaceEval} This object.
*/
SurfaceEval.prototype.normal=function(evaluator){
 this.normalSurface=evaluator;
 return this;
}
/**
* Specifies a parametric surface function for generating color values.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 3 values as a result.  See {@link SurfaceEval#vertex}.
* &lt;/ul>
* @return {SurfaceEval} This object.
*/
SurfaceEval.prototype.color=function(evaluator){
 this.colorSurface=evaluator;
 return this;
}
/**
* Specifies a parametric surface function for generating texture coordinates.
* @param {object} evaluator An object that must contain a function
* named "evaluate", giving 2 values as a result.  See {@link SurfaceEvals#vertex}.
* &lt;/ul>
* @return {SurfaceEval} This object.
*/
SurfaceEval.prototype.texCoord=function(evaluator){
 this.texCoordSurface=evaluator;
 return this;
}
/**
 * Specifies a B&amp;eacute;zier surface used for generating vertex positions.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierSurface},
 * where each point is a 3-element array giving the x, y, and z coordinates of a vertex
 * position.
 * @param {number} [u1] Starting point along the U axis; see {@link BezierSurface}.
 * @param {number} [u2] Ending point along the U axis; see {@link BezierSurface}.
 * @param {number} [v1] Starting point along the V axis; see {@link BezierSurface}.
 * @param {number} [v2] Ending point along the V axis; see {@link BezierSurface}.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.vertexBezier=function(controlPoints,u1,u2,v1,v2){
 this.vertexSurface=new BezierSurface(controlPoints,u1,u2,v1,v2);
 if(this.vertexSurface.k!=3)
   throw new Error("unsupported vertex length")
 return this;
}
/**
 * Specifies a B&amp;eacute;zier surface used for generating normals.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierSurface},
 * where each point is a 3-element array giving the x, y, and z coordinates of a normal.
 * @param {number} [u1] Starting point along the U axis; see {@link BezierSurface}.
 * @param {number} [u2] Ending point along the U axis; see {@link BezierSurface}.
 * @param {number} [v1] Starting point along the V axis; see {@link BezierSurface}.
 * @param {number} [v2] Ending point along the V axis; see {@link BezierSurface}.
 * @return {SurfaceEval} This object.
*/
SurfaceEval.prototype.normalBezier=function(controlPoints,u1,u2,v1,v2){
 this.normalSurface=new BezierSurface(controlPoints,u1,u2,v1,v2);
 if(this.normalSurface.k!=3)
   throw new Error("invalid normal length")
 return this;
}
/**
 * Specifies a B&amp;eacute;zier surface used for generating texture coordinates.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierSurface},
 * where each point is a 1- or 2-element array giving the u and v texture coordinates.
 * @param {number} [u1] Starting point along the U axis; see {@link BezierSurface}.
 * @param {number} [u2] Ending point along the U axis; see {@link BezierSurface}.
 * @param {number} [v1] Starting point along the V axis; see {@link BezierSurface}.
 * @param {number} [v2] Ending point along the V axis; see {@link BezierSurface}.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.texCoordBezier=function(controlPoints,u1,u2,v1,v2){
 this.texCoordSurface=new BezierSurface(controlPoints,u1,u2,v1,v2);
 if(this.texCoordSurface.k!=1 &amp;&amp; this.texCoordSurface.k!=2)
   throw new Error("unsupported texcoord length")
 return this;
}
/**
 * Specifies a B&amp;eacute;zier surface used for generating color values.
 * @param {Array&lt;Array&lt;number>>} controlPoints Control points as specified in {@link BezierSurface},
 * where each point is a 3-element array giving the red, green, and blue
 * values of a color.
 * @param {number} [u1] Starting point along the U axis; see {@link BezierSurface}.
 * @param {number} [u2] Ending point along the U axis; see {@link BezierSurface}.
 * @param {number} [v1] Starting point along the V axis; see {@link BezierSurface}.
 * @param {number} [v2] Ending point along the V axis; see {@link BezierSurface}.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.colorBezier=function(controlPoints,u1,u2,v1,v2){
 this.colorSurface=new BezierSurface(controlPoints,u1,u2,v1,v2);
 if(this.colorSurface.k!=3)
   throw new Error("unsupported color length")
 return this;
}
/**
 * Generates vertex positions and attributes based on a point
 * in a parametric surface.
 * @param {glutil.Mesh} mesh Mesh where vertex positions and attributes
 * will be generated.  When this method returns, the current color, normal,
 * and texture coordinates will be the same as they were before the method
 * started.
 * @param {number} u U-coordinate of the curve to evaluate (for
 * B&amp;eacute;zier surfaces, generally within the range
 * given in the &lt;code>vectorBezier&lt;/code>, &lt;code>normalBezier&lt;/code>,
 * &lt;code>colorBezier&lt;/code>, and &lt;code>texCoordBezier&lt;/code> methods).
 * @param {number} v V-coordinate of the curve to evaluate.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.evalOne=function(mesh,u,v){
 var color=null;
 var normal=null;
 var texcoord=null;
 if(this.colorSurface){
  color=this.colorSurface.evaluate(u,v);
 }
 if(this.texCoordSurface){
  texcoord=this.texCoordSurface.evaluate(u,v);
  if(texcoord.length==1)texcoord.push(0);
 }
 if(this.normalSurface &amp;&amp; !this.autoNormal){
  normal=this.normalSurface.evaluate(u,v);
 }
 if(this.vertexSurface){
  var vertex;
  var oldColor=(color) ? mesh.color.slice(0,3) : null;
  var oldNormal=(normal || this.autoNormal) ? mesh.normal.slice(0,3) : null;
  var oldTexCoord=(texcoord) ? mesh.texCoord.slice(0,3) : null;
  if(color)mesh.color3(color[0],color[1],color[2]);
  vertex=this.vertexSurface.evaluate(u,v);
  if(this.autoNormal){
   var du=0.001
   var dv=0.001
   // Find the partial derivatives of u and v
   var vu=this.vertexSurface.evaluate(u+du,v);
   var vuz=vu[2];
   var vv=this.vertexSurface.evaluate(u,v+dv);
   GLMath.vec3subInPlace(vv,vertex);
   GLMath.vec3subInPlace(vu,vertex);
   // Divide by the deltas of u and v
   GLMath.vec3scaleInPlace(vu,1.0/du);
   GLMath.vec3scaleInPlace(vv,1.0/dv);
   GLMath.vec3normInPlace(vu);
   GLMath.vec3normInPlace(vv);
   if(GLMath.vec3length(vu)==0){
    // partial derivative of u is degenerate
    //console.log([vu,vv,u,v]+" u degen")
    vu=vv;
   } else if(GLMath.vec3length(vv)!=0){
    vu=GLMath.vec3cross(vu,vv);
    GLMath.vec3normInPlace(vu);
   } else {
    // partial derivative of v is degenerate
    //console.log([vu,vv,u,v]+" v degen")
    if(vu[2]==vertex[2]){
      // the close evaluation returns the same
      // z as this evaluation
      vu=[0,0,1];
    }
   }
   mesh.normal3(vu[0],vu[1],vu[2]);
  } else if(normal){
   mesh.normal3(normal[0],normal[1],normal[2]);
  }
  if(texcoord)mesh.texCoord3(texcoord[0],texcoord[1],texcoord[2]);
  mesh.vertex3(vertex[0],vertex[1],vertex[2]);
  if(oldColor)mesh.color3(oldColor[0],oldColor[1],oldColor[2]);
  if(oldNormal)mesh.normal3(oldNormal[0],oldNormal[1],oldNormal[2]);
  if(oldTexCoord)mesh.texCoord3(oldTexCoord[0],oldTexCoord[1],oldTexCoord[2]);
 }
 return this;
}

/**
 * Generates the vertex positions and attributes of a parametric
 * surface.
 * @param {glutil.Mesh} mesh Mesh where vertex positions and attributes
 * will be generated.  When this method returns, the current color, normal,
 * and texture coordinates will be the same as they were before the method
 * started.
 * @param {number} [mode] If this value is Mesh.TRIANGLES, or is null
 * or omitted, generates a series of triangles defining the surface.  If
 * this value is Mesh.LINES, generates
 * a series of lines defining the curve. If this value is Mesh.POINTS,
 * generates a series of points along the curve.  For any other value,
 * this method has no effect.
 * @param {number} [un] Number of subdivisions along the U-axis.
 * Default is 24.
 * @param {number} [vn] Number of subdivisions along the V-axis.
 * Default is 24.
 * @param {number} [u1] Starting U-coordinate of the surface to evaluate.
 * Default is 0.
 * @param {number} [u2] Ending U-coordinate of the surface to evaluate.
 * Default is 1.
 * @param {number} [v1] Starting U-coordinate of the surface to evaluate.
 * Default is 0.
 * @param {number} [v2] Ending U-coordinate of the surface to evaluate.
 * Default is 1.
 * @return {SurfaceEval} This object.
 */
SurfaceEval.prototype.evalSurface=function(mesh,mode,un,vn,u1,u2,v1,v2){
 if(typeof un=="undefined")un=24;
 if(typeof vn=="undefined")vn=24;
 if(un&lt;=0)throw new Error("invalid un")
 if(vn&lt;=0)throw new Error("invalid vn")
 if(mode==null)mode=Mesh.TRIANGLES;
 if(typeof v1=="undefined" &amp;&amp; typeof v2=="undefined"){
  v1=0.0;
  v2=1.0;
 }
 if(typeof u1=="undefined" &amp;&amp; typeof u2=="undefined"){
  u1=0.0;
  u2=1.0;
 }
 var du=(u2-u1)/un;
 var dv=(v2-v1)/vn;
 if(mode==Mesh.TRIANGLES){
  for(var i=0;i&lt;vn;i++){
   mesh.mode(Mesh.TRIANGLE_STRIP);
   for(var j=0;j&lt;=un;j++){
    var jx=j*du+u1;
    this.evalOne(mesh,jx,i*dv+v1);
    this.evalOne(mesh,jx,(i+1)*dv+v1);
  }
  }
 } else if(mode==Mesh.POINTS){
  mesh.mode(Mesh.POINTS);
  for(var i=0;i&lt;=vn;i++){
   for(var j=0;j&lt;=un;j++){
    var jx=j*du+u1;
    this.evalOne(mesh,jx,i*dv+v1);
   }
  }
 } else if(mode==Mesh.LINES){
  for(var i=0;i&lt;=vn;i++){
   mesh.mode(Mesh.LINE_STRIP);
   for(var j=0;j&lt;=un;j++){
    var jx=j*du+u1;
    this.evalOne(mesh,jx,i*dv+v1);
   }
  }
  for(var i=0;i&lt;=un;i++){
   mesh.mode(Mesh.LINE_STRIP);
   for(var j=0;j&lt;=vn;j++){
    this.evalOne(mesh,i*du+u1,j*dv+v1);
   }
  }
 }
 return this;
}
global.SurfaceEval=SurfaceEval;
global.CurveEval=CurveEval;
})(this);
</code></pre>
        </article>
    </section>

</div>
<nav style="float: right;width: 25%;border-left: 1px solid;margin-top:0px;box-sizing: border-box;padding-left: 1em;">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="http://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
<h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glmath.html">glmath</a></li><li><a href="module-glutil.html">glutil</a></li></ul><h3>Classes</h3><ul><li><a href="BezierCurve.html">BezierCurve</a></li><li><a href="BezierSurface.html">BezierSurface</a></li><li><a href="CurveEval.html">CurveEval</a></li><li><a href="glmath.GLMath.html">GLMath</a></li><li><a href="glutil.BufferedMesh.html">BufferedMesh</a></li><li><a href="glutil.FrameBuffer.html">FrameBuffer</a></li><li><a href="glutil.GLUtil.html">GLUtil</a></li><li><a href="glutil.Lights.html">Lights</a></li><li><a href="glutil.LightSource.html">LightSource</a></li><li><a href="glutil.Material.html">Material</a></li><li><a href="glutil.Mesh.html">Mesh</a></li><li><a href="glutil.Meshes.html">Meshes</a></li><li><a href="glutil.Scene3D.html">Scene3D</a></li><li><a href="glutil.ShaderProgram.html">ShaderProgram</a></li><li><a href="glutil.Shape.html">Shape</a></li><li><a href="glutil.ShapeGroup.html">ShapeGroup</a></li><li><a href="glutil.SurfaceEval.html">SurfaceEval</a></li><li><a href="glutil.Texture.html">Texture</a></li><li><a href="glutil.Transform.html">Transform</a></li><li><a href="MatrixStack.html">MatrixStack</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="Promise.html">Promise</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera.html">camera</a></li><li><a href="tutorial-glmath.html">glmath</a></li><li><a href="tutorial-overview.html">overview</a></li><li><a href="tutorial-shapes.html">shapes</a></li><li><a href="tutorial-surfaces.html">surfaces</a></li><li><a href="tutorial-textures.html">textures</a></li></ul>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
