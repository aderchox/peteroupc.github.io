<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Tutorial: shapes</title>
<script src="mathml.js"></script>
</head>
<body style="margin-top:0px">
<div style="width:75%;float:left;">
    <h1>Tutorial: shapes</h1>
    <section>

<header>

    <h2>shapes</h2>
</header>

<article>
    <h2>Introduction</h2><p>This article explains how my <a href="http://peteroupc.github.io/html3dutil">HTML 3D Library</a>
supports 3D shapes and how to use the library to create shapes, both built-in and custom
shapes.</p>
<p><strong>Visit the <a href="https://github.com/peteroupc/html3dutil/releases">library's Releases page</a>
for the latest version.</strong> As of version 1.2.1, it includes
the shapes.html and platonic.html demos mentioned in this article.</p>
<h2>Creating Shapes</h2><p>The HTML 3D library contains several methods for creating 3D shapes such
as cubes, cylinders, spheres, and custom shapes.</p>
<p><img src="shapes.png" alt="An assortment of shapes: a red box, a blue sphere, a bright green 2D ring, and an
orange partial ring on the first row; and a yellow 3D ring, a brown cylinder, a dark
green square, and a purple cone on the second row."></p>
<p>Demos:</p>
<ul>
<li><a href="https://peteroupc.github.io/html3dutil/demos/shapes.html">shapes.html</a> - Demonstrates
the built-in shapes.</li>
<li><a href="https://peteroupc.github.io/html3dutil/demos/platonic.html">platonic.html</a> - A demo featuring the five
platonic solids.  Demonstrates how vertex and index arrays are built up to create geometric meshes.</li>
</ul>
<h3>Built-In Shapes</h3><p>The <a href="glutil.Meshes.html"><code>Meshes</code></a> class includes several handy methods for creating built-in shapes.
All methods described below return a <code>Mesh</code> object that describes the triangles they
are composed of.  See &quot;Custom Shapes&quot; below for more on meshes.</p>
<p><strong>3D Figures:</strong></p>
<ul>
<li><a href="glutil.Meshes.html#.createBox">Meshes.createBox()</a> - Creates a cube or box.</li>
<li><a href="glutil.Meshes.html#.createCylinder">Meshes.createCylinder()</a> - Creates a cylinder or cone, not including the base
or top.</li>
<li><a href="glutil.Meshes.html#.createClosedCylinder">Meshes.createClosedCylinder()</a> - Creates a cylinder or cone, including the base or top.</li>
<li><a href="glutil.Meshes.html#.createTorus">Meshes.createTorus()</a> - Creates a torus (doughnut shape).</li>
<li><a href="glutil.Meshes.html#.createSphere">Meshes.createSphere()</a> - Creates a sphere.</li>
<li><a href="glutil.Meshes.html#.createCapsule">Meshes.createCapsule()</a> - Creates a capsule shape.</li>
</ul>
<p><strong>2D Figures:</strong></p>
<ul>
<li><a href="glutil.Meshes.html#.createDisk">Meshes.createDisk()</a> - Creates a circular disk or a regular polygon, possibly
with a hole in the middle.</li>
<li><a href="glutil.Meshes.html#.createPartialDisk">Meshes.createPartialDisk()</a> - Creates a portion of a circular disk, possibly
with a hole where the middle of the complete disk would be.</li>
<li><a href="glutil.Meshes.html#.createPlane">Meshes.createPlane()</a> - Creates a rectangle.</li>
</ul>
<h3>Custom Shapes</h3><p>Also included is a <code>Mesh</code> class for defining shapes not given among the built-in ones.
Shapes can consist of triangles, lines, or points.</p>
<p>There are two ways for specifying shapes:  through the Mesh constructor, or through
methods that specify the mesh's data vertex by vertex.</p>
<h3>The Mesh Constructor</h3><p>The Mesh constructor lets you define a shape from a predefined array of vertex data.
Here's how.</p>
<p>(1) Create an array of numbers giving the X, Y, and Z coordinate for each vertex:</p>
<pre class="prettyprint source"><code>var vertices = [x1, y1, z1, x2, y2, z2, ... ];</code></pre><p>If you also specify normals, colors, or texture coordinates for each vertex, you must add
them after each vertex position in this order: normals first, colors second, and texture
coordinates last.  If you don't specify normals, colors, and/or texture coordinates per
vertex, you can omit them.  The following are examples of this:</p>
<pre class="prettyprint source"><code>// An array of vertices each with a set of normals
var vertices = [
 x1, y1, z1, nx1, ny1, nz1,
 x2, y2, z2, nx2, ny2, nz2,
 ...
];
// An array of vertices each with a set of colors
// and texture coordinates
var vertices = [
 x1, y1, z1, cr1, cg1, cb1, u1, v1,
 x2, y2, z2, cr2, cg2, cb2, u2, v2,
 ...
];</code></pre><p>(2) Create a second array of numbers giving the indices to vertices defined in the
previous step:</p>
<pre class="prettyprint source"><code>var indices = [0, 1, 2, 1, 2, 3, ... ];</code></pre><p>Each index refers to the (n+1)th vertex, no matter how many array elements each vertex
consists of (a vertex with just coordinates will use 3 array elements).</p>
<p>If you are defining a set of triangles, there should be 3 indices for each triangle,
and if you are defining a set of line segments, there should be 2 indices for each
line segment.</p>
<p>(3) Call the mesh constructor with the vertex and index arrays.</p>
<pre class="prettyprint source"><code>var bits = Mesh.NORMALS_BIT; // Assumes we used the vertex array with normals
var mesh = new Mesh(vertices, indices, bits);</code></pre><p>Note that you must include a set of bits indicating what kind of data the vertex
array contains.  (If none of the bits apply, use 0 or omit the &quot;bits&quot; parameter.) The bits are:</p>
<ul>
<li><code>Mesh.NORMALS_BIT</code> - if you included normals for each vertex (3 elements)</li>
<li><code>Mesh.COLORS_BIT</code> - if you included colors for each vertex (3 elements)</li>
<li><code>Mesh.TEXCOORDS_BIT</code> - if you included texture coordinates for each vertex (2 elements)</li>
<li><code>Mesh.LINES_BIT</code> - if the mesh defines a set of lines rather than triangles</li>
<li><code>Mesh.POINTS_BIT</code> - if the mesh defines a set of points (you can't set both <code>LINES_BIT</code> and
<code>POINTS_BIT</code>).</li>
</ul>
<p>The bits may be combined as in the following example:</p>
<pre class="prettyprint source"><code>var bits = Mesh.NORMALS_BIT | Mesh.COLORS_BIT;</code></pre><p>Alternatively, you can call the Mesh constructor with no arguments:</p>
<pre class="prettyprint source"><code>var mesh = new Mesh();</code></pre><p>Doing so will create a mesh with no vertices.</p>
<h3>Vertex Methods</h3><p>Alternatively, or in addition, to the method described above,
you can specify the mesh's shape by calling methods that give each vertex's position and parameters:</p>
<p>(1) Call the <code>mode()</code> method and choose a primitive mode, such as <code>Mesh.TRIANGLES</code>
or <code>Mesh.QUAD_STRIP</code>:</p>
<pre class="prettyprint source"><code>mesh.mode(Mesh.TRIANGLES);</code></pre><p>The mesh will build up the shape from the vertices you give it depending on the mesh's
primitive mode.  For example, <code>QUAD_STRIP</code> defines a strip of connecting quadrilaterals,
and <code>TRIANGLES</code> defines a set of triangles that are not necessarily connected:</p>
<ul>
<li><code>Mesh.TRIANGLES</code> - Set of triangles, 3 vertices each.</li>
<li><code>Mesh.LINES</code> - Set of line segments, 2 vertices each.</li>
<li><code>Mesh.QUADS</code> - Set of quadrilaterals, 4 vertices each.</li>
<li><code>Mesh.TRIANGLE_STRIP</code> - A triangle strip.  The first 3
vertices make up the first triangle, and each additional
triangle is made up of the last 2 vertices and 1
new vertex.</li>
<li><code>Mesh.TRIANGLE_FAN</code> - A triangle fan. The first 3
vertices make up the first triangle, and each additional
triangle is made up of the last vertex, the first vertex of
the first trangle, and 1 new vertex.</li>
<li><code>Mesh.QUAD_STRIP</code> - A strip of quadrilaterals (quads).
The first 4 vertices make up the first quad, and each additional
quad is made up of the last 2 vertices of the previous quad and
2 new vertices.</li>
<li><code>Mesh.LINE_STRIP</code> - A series of points making up a connected line segment path.</li>
<li><code>Mesh.POINTS</code> - A series of points.</li>
</ul>
<p>(2) Call the <code>normal3()</code>, <code>color3()</code>, and <code>texCoord2()</code> methods, as needed, to set the
next vertex's parameters.  You don't need to do this for each vertex if multiple
consecutive vertices will share the same normal, color, or texture coordinates.</p>
<pre class="prettyprint source"><code>mesh.normal3(2, 3, 4); // Set the x, y, and z of the normal.
mesh.color3(0.1,0.6,1); // Set the red, green, and blue of the color.
mesh.color3(&quot;red&quot;); // Set a CSS color.
mesh.color3(&quot;#123FE8&quot;); // Set an HTML color.
mesh.texCoord3(0.5,0.5); // Set the texture coordinates.</code></pre><p>(3) Call the <code>vertex3()</code> method to add a new vertex and set its position.  The vertex will
have the last normal, color, and texture coordinates defined on the mesh, if any
were given:</p>
<pre class="prettyprint source"><code>mesh.vertex3(x, y, z);</code></pre><p>You can also call the <code>mode()</code> method any time to change the primitive mode, even to
the same mode.  What this does is reset the state of the primitive so that future vertices
won't depend on previous vertices.  For example, if you define a <code>TRIANGLE_FAN</code>, and
you call <code>mesh.mode(Mesh.TRIANGLE_FAN)</code>, the newly defined <code>TRIANGLE_FAN</code> will be
&quot;disconnected&quot; from the previous one as far as the mesh object is concerned.</p>
<h3>Transforming the Mesh</h3><p>Once you've created the mesh, you can use the <code>transform()</code> method to transform
all the vertices in the mesh with a <a href="tutorial-glmath.html">4x4 matrix</a>.  The
<a href="https://peteroupc.github.io/html3dutil/demos/shapes.html">shapes.html</a> demo uses
this method to adjust some of the meshes to make them look better on the screen.
Example:</p>
<pre class="prettyprint source"><code>var matrix = GLMath.mat4scaled(2,2,2);
// Use the transform to double the mesh's size
mesh = mesh.transform(matrix);</code></pre><h3>Normals</h3><p>For lighting and shading to work correctly, you must specify normals for all the
vertices in the mesh.</p>
<h4>What Are Normals?</h4><p>A normal is a set of 3 numbers describing a particular direction.  Generally,
a normal's direction is perpendicular to a surface's edges, and points
away from the surface.</p>
<p>Normals are important in the lighting and shading model.  When light
hits an object's surface, the surface will shine depending on how directly the
light points to the surface.  It will shine the most if the light
is directly opposite to its normal, and not at all if the light is perpendicular to the
normal or in the same direction as the normal.</p>
<h4>Normals on Built-in Shapes</h4><p>The <code>Meshes</code> class includes built-in methods that will automatically
specify the proper normals.</p>
<h4>recalcNormals()</h4><p>You can use the <code>recalcNormals()</code> method to recalculate the mesh's normals,
in order to give the shape a flat or smooth appearance or to shade the shape from
the inside or the outside.  This method takes two parameters:</p>
<ul>
<li>The first parameter is true if the normals will be calculated such that the shape
will have a flat appearance; otherwise, false (giving the shape a smooth appearance).
This works by either giving each triangle the same normal (flat shading) or giving
each unique vertex its own normal (smooth shading).</li>
<li>The second parameter is true if the normals will be calculated such that the shape
is shaded from the inside; otherwise, false.</li>
</ul>
<p>Remember, for normal calculation to properly affect shading, each triangle in
the mesh must have its vertices defined in counterclockwise order.</p>
<p>Example:</p>
<pre class="prettyprint source"><code>// Use flat shading, and shape is shaded from the outside
mesh = mesh.recalcNormals(true, false);
// Both parameters can be omitted, setting both to false
mesh = mesh.recalcNormals();</code></pre><h2>Binding Shapes</h2><p>Once you have a mesh of a 3D shape, you still need to bind it to the 3D scene
in order to have it drawn.  This is where the <a href="glutil.Shape.html"><code>Shape</code></a> class comes into
play; this class associates a 3D mesh with its location and orientation in the scene,
as well as its color and appearance.  To attach a mesh to a 3D scene:</p>
<p>(1) Create a <code>Shape</code> object by passing the mesh to the 3D scene's <code>makeShape()</code> method:</p>
<pre class="prettyprint source"><code>var shape = scene3d.makeShape(mesh);</code></pre><p>(2) You may also set the <code>Shape</code>'s color, appearance, and position, using the examples below:</p>
<p>Examples for setting appearance:</p>
<pre class="prettyprint source"><code>shape.setColor(&quot;red&quot;); // set the color to a CSS color
shape.setColor(&quot;#338845&quot;); // set the color to an HTML color
shape.setColor(0.2,0.5,1); // set the color to its RGB values, each from 0 to 1
// set material parameters: ambient, diffuse,
// specular, shininess (NOTE: if the mesh defines its own colors they
// will override ambient and diffuse reflection given below)
shape.setMaterial(new Material(&quot;blue&quot;,&quot;blue&quot;,&quot;white&quot;,30));
// set material parameters: ambient, diffuse,
// specular, shininess, emission
shape.setMaterial(new Material(&quot;lime&quot;,&quot;lime&quot;,&quot;white&quot;,30,[0.2,0.2,0.2]));
// set a texture; this requires the mesh to have texture
// coordinates assigned to each vertex
shape.setMaterial(new TextureMaterial(&quot;texture.png&quot;));</code></pre><p>Examples for setting position:</p>
<pre class="prettyprint source"><code>// move the shape 2 units along X axis, 4 units along Y axis,
// and 5 units along Z axis
shape.setPosition(2,4,5);
// same, but passing an array
shape.setPosition([2,4,5]);
// rotate the shape 40 units about X axis, 20 units about Y axis,
// and 50 units about Z axis
shape.setQuaternion(GLMath.quatFromTaitBryan(40,20,50));
// rotate the shape 20 units about Y axis
shape.setQuaternion(GLMath.quatFromAxisAngle(20,0,1,0));
// scale the shape by 2x in all axes
shape.setScale(2,2,2);
// same, but passing an array
shape.setScale([2,2,2]);</code></pre><p>If setMatrix wasn't called, then when the shape is rendered, it will generate
a transformation matrix that has the effect of scaling, then rotating,
then translating (shifting) the shape in 3D space.</p>
<p>(3) Add the shape to the 3D scene:</p>
<pre class="prettyprint source"><code>scene3d.addShape(shape);</code></pre><p>Now, the next time <code>scene3d.render()</code> is called, the <a href="glutil.Scene3D.html"><code>Scene3D</code></a> will render the
given shape to the scene.</p>
</article>

</section>

</div>
<nav style="float: right;width: 25%;border-left: 1px solid;margin-top:0px;box-sizing: border-box;padding-left: 1em;">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHfwYJKoZIhvcNAQcEoIIHcDCCB2wCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYBTEjVSqAfM9cTLwXVwxBqNI8r1Il0SJNqahKnIJrEIZOdmziEnZsYS8kifxxbWCBrNGl1S/eO5kcMG6WO50eBSxFlNpweevNYIs0dIdfQZtiWcRD2yYzaWHBkHu3PmCCLmc3pPT5QaOc949w2dPcg+syabMOSwN94Mk67Wh//7pTELMAkGBSsOAwIaBQAwgfwGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIm7w2yVS0zOeAgdhYAX/keBkbLTGS2k5QcVstRROvRVuMlDL7sy/YUie0YlEJKDFTFE7n6LP15AFfODDattjmqKJ7UZ+6hY9sqJhayUNqdl/rA/RYgPVKGWTM1l68+KFdz2SO3IHvBUJIAwnHFX1JVyNUAofSxWj+3eoN5MnQzskA4cKe/RFWB04oXxZS7/WCOHL3q3mlwFDSK83C3Wcqro7S18YnVxfJ4XGUQ7nlx1C9K0Xq+JbCGEC4D8yjQHzm9w3LqUOogiI3l9VVlXxuqcAdq+iBkAGIt3y4TXABMtXEFG2gggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xMzA4MTAxMzA4NDBaMCMGCSqGSIb3DQEJBDEWBBQImRl0rdSM38l1aTcRhxgiKb7ipTANBgkqhkiG9w0BAQEFAASBgE0IsEWvN+n6QuwDFkBMQO9C4z5uf7wAvoMDgifDKBCyGFmpYZPsKawkYVcS/kASDtyq6aWU3lqP+KweyA+0xfpAyE3R8/7p80uqGGs8bHGicxkl2pEkX95R23HGRa1pEDHFF1XQNkhns558WioFipI2RvmAAEaMgZQ1p+SV/cdu-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="http://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
<h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glmath.html">glmath</a></li><li><a href="module-glutil.html">glutil</a></li></ul><h3>Classes</h3><ul><li><a href="BezierCurve.html">BezierCurve</a></li><li><a href="BezierSurface.html">BezierSurface</a></li><li><a href="CurveEval.html">CurveEval</a></li><li><a href="glmath.GLMath.html">GLMath</a></li><li><a href="glutil.BufferedMesh.html">BufferedMesh</a></li><li><a href="glutil.FrameBuffer.html">FrameBuffer</a></li><li><a href="glutil.GLUtil.html">GLUtil</a></li><li><a href="glutil.Lights.html">Lights</a></li><li><a href="glutil.LightSource.html">LightSource</a></li><li><a href="glutil.Material.html">Material</a></li><li><a href="glutil.Mesh.html">Mesh</a></li><li><a href="glutil.Meshes.html">Meshes</a></li><li><a href="glutil.Scene3D.html">Scene3D</a></li><li><a href="glutil.ShaderProgram.html">ShaderProgram</a></li><li><a href="glutil.Shape.html">Shape</a></li><li><a href="glutil.ShapeGroup.html">ShapeGroup</a></li><li><a href="glutil.Texture.html">Texture</a></li><li><a href="glutil.Transform.html">Transform</a></li><li><a href="MatrixStack.html">MatrixStack</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="Promise.html">Promise</a></li><li><a href="SurfaceEval.html">SurfaceEval</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera.html">camera</a></li><li><a href="tutorial-glmath.html">glmath</a></li><li><a href="tutorial-overview.html">overview</a></li><li><a href="tutorial-shapes.html">shapes</a></li><li><a href="tutorial-textures.html">textures</a></li></ul>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
