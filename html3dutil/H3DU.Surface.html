<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>H3DU.Surface</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>H3DU.Surface</h1>

<p><a href="index.html">Back to documentation index.</a></p>

<p><a name='H3DU.Surface'></a></p>

<h3>H3DU.Surface(surface)</h3>

<p>A surface evaluator object for a parametric surface.</p>

<p>A parametric surface is a surface whose points are based on a
parametric surface function. A surface function takes two numbers
(U and V) and returns a point (in 1, 2, 3 or more dimensions, but
usually 2 or 3) that lies on the surface. For example, in 3
dimensions, a surface function has the following form:</p>

<p><b>F</b>(u, v) = [ x(u, v), y(u, v), z(u, v) ]</p>

<p>where x(u, v) returns an X coordinate, y(u, v) a Y coordinate,
and z(u, v) returns a Z coordinate.</p>

<p>Specialized surfaces should <a href="tutorial-subclass.html">subclass</a> this class and implement
the <code>evaluate</code> method and, optionally, the other methods mentioned in the &quot;surface&quot; parameter below.</p>

<h4>Parameters</h4>

<ul>
<li><code>surface</code> (Type: Object)<br>A <b>surface evaluator object</b>, which is an object that must contain an <code>evaluate</code> method and may contain an <code>endPoints</code>, <code>tangent</code>, <code>bitangent</code>, and/or <code>gradient</code> method, as described in the corresponding methods of this class.</li>
</ul>

<h4>Example</h4>

<p>The following example creates a surface evaluator
object for a parametric surface. To illustrate how the gradient method is derived
from the vector calculation method, that method is also given below. To
derive the normal calculation, first look at the vector function:</p>

<p><b>F</b>(u, v) = (cos(u), sin(u), sin(u)*cos(v))</p>

<p>Then, find the partial derivatives with respect to <i>u</i> and to <i>v</i>:</p>

<p>&#x2202;<b>F</b>/&#x2202;<i>u</i> = (-sin(u), cos(u), cos(u)*cos(v))<br>
&#x2202;<b>F</b>/&#x2202;<i>v</i> = (0, 0, -sin(v)*sin(u))</p>

<p>Next, take their cross product:</p>

<p><b>c</b>(u, v) = (-sin(v)*cos(u)*sin(u), -sin(v)*sin(u)*sin(u), 0)<br></p>

<p>The result is the gradient, which will be normal to the surface.</p>

<pre><code>var surface=new H3DU.Surface({&quot;evaluate&quot;:function(u,v) {
&quot;use strict&quot;;
return [Math.cos(u),Math.sin(u),Math.sin(u)*Math.cos(v)];
},
&quot;gradient&quot;:function(u,v) {
&quot;use strict&quot;;
return [
Math.cos(u)*-Math.sin(v)*Math.sin(u),
Math.sin(u)*-Math.sin(v)*Math.sin(u),
0];
}})
</code></pre>

<h3>Methods</h3>

<ul>
<li><a href="#H3DU.Surface_bitangent">bitangent</a><br>Finds an approximate bitangent vector of this surface at the given U and V coordinates.</li>
<li><a href="#H3DU.Surface_endPoints">endPoints</a><br>Returns the starting and ending U and V coordinates of this surface.</li>
<li><a href="#H3DU.Surface_evaluate">evaluate</a><br>Finds the position of this surface at the given U and V coordinates.</li>
<li><a href="#H3DU.Surface_gradient">gradient</a><br>Finds an approximate gradient vector of this surface at the given U and V coordinates.</li>
<li><a href="#H3DU.Surface_normal">normal</a><br>Convenience method for finding an approximate normal vector of this surface at the given U and V coordinates.</li>
<li><a href="#H3DU.Surface_tangent">tangent</a><br>Finds an approximate tangent vector of this surface at the given U and V coordinates.</li>
</ul>

<p><a name='H3DU.Surface_bitangent'></a></p>

<h3>H3DU.Surface#bitangent(u, v)</h3>

<p>Finds an approximate bitangent vector of this surface at the given U and V coordinates.</p>

<p>The implementation in <a href="H3DU.Surface.html">H3DU.Surface</a> calls the evaluator&#39;s <code>bitangent</code>
method if it implements it; otherwise, does a numerical differentiation
with respect to the V axis using the <code>evaluate</code> method.</p>

<p>The <b>bitangent vector</b> is the vector pointing in the direction of the V axis, or alternatively,
the partial derivative of the <code>evaluate</code> method with respect to <code>v</code>. The bitangent vector returned by this method <i>should not</i> be &quot;normalized&quot; to a <a href="tutorial-glmath.html">unit vector</a>.</p>

<h4>Parameters</h4>

<ul>
<li><code>u</code> (Type: number)<br>U coordinate of a point on the surface.</li>
<li><code>v</code> (Type: number)<br>V coordinate of a point on the surface.</li>
</ul>

<h4>Return Value</h4>

<p>An array describing a bitangent vector. It should have at least as many
elements as the number of dimensions of the underlying surface. (Type: Array.&lt;number&gt;)</p>

<p><a name='H3DU.Surface_endPoints'></a></p>

<h3>H3DU.Surface#endPoints()</h3>

<p>Returns the starting and ending U and V coordinates of this surface.
This method calls the evaluator&#39;s <code>endPoints</code>
method if it implements it; otherwise, returns <code>[0, 1, 0, 1]</code></p>

<h4>Return Value</h4>

<p>A four-element array. The first and second
elements are the starting and ending U coordinates, respectively, of the surface, and the third
and fourth elements are its starting and ending V coordinates.
Returns <code>[0, 1, 0, 1]</code> if the evaluator doesn&#39;t implement an <code>endPoints</code>
method.</p>

<p><a name='H3DU.Surface_evaluate'></a></p>

<h3>H3DU.Surface#evaluate(u, v)</h3>

<p>Finds the position of this surface at the given U and V coordinates.</p>

<h4>Parameters</h4>

<ul>
<li><code>u</code> (Type: number)<br>U coordinate of a point on the surface.</li>
<li><code>v</code> (Type: number)<br>V coordinate of a point on the surface.</li>
</ul>

<h4>Return Value</h4>

<p>An array describing a position. It should have at least as many
elements as the number of dimensions of the underlying surface. (Type: Array.&lt;number&gt;)</p>

<p><a name='H3DU.Surface_gradient'></a></p>

<h3>H3DU.Surface#gradient(u, v)</h3>

<p>Finds an approximate gradient vector of this surface at the given U and V coordinates.</p>

<p>The implementation in <a href="H3DU.Surface.html">H3DU.Surface</a> calls the evaluator&#39;s <code>gradient</code>
method if it implements it; otherwise uses the surface&#39;s tangent and bitangent vectors to implement the gradient
(however, this approach is generally only meaningful for a three-dimensional surface).</p>

<p>The <b>gradient</b> is a vector pointing up and away from the surface.
If the evaluator describes a regular three-dimensional surface (usually
a continuous, unbroken surface such as a sphere, an open
cylinder, or a disk rotated in three dimensions), this can be the cross product
of the <a href="H3DU.Surface.html#H3DU.Surface_tangent">tangent vector</a>
and <a href="H3DU.Surface.html#H3DU.Surface_bitangent">bitangent vector</a>,
in that order. The gradient returned by this method <i>should not</i> be &quot;normalized&quot; to a <a href="tutorial-glmath.html">unit vector</a>.</p>

<h4>Parameters</h4>

<ul>
<li><code>u</code> (Type: number)<br>U coordinate of a point on the surface.</li>
<li><code>v</code> (Type: number)<br>V coordinate of a point on the surface.</li>
</ul>

<h4>Return Value</h4>

<p>An array describing a gradient vector. It should have at least as many
elements as the number of dimensions of the underlying surface. (Type: Array.&lt;number&gt;)</p>

<p><a name='H3DU.Surface_normal'></a></p>

<h3>H3DU.Surface#normal(u, v)</h3>

<p>Convenience method for finding an approximate normal vector of this surface at the given U and V coordinates.
The <b>normal vector</b> is the same as the gradient vector, but &quot;normalized&quot; to a unit vector.</p>

<h4>Parameters</h4>

<ul>
<li><code>u</code> (Type: number)<br>U coordinate of a point on the surface.</li>
<li><code>v</code> (Type: number)<br>V coordinate of a point on the surface.</li>
</ul>

<h4>Return Value</h4>

<p>An array describing a normal vector. It should have at least as many
elements as the number of dimensions of the underlying surface. (Type: Array.&lt;number&gt;)</p>

<p><a name='H3DU.Surface_tangent'></a></p>

<h3>H3DU.Surface#tangent(u, v)</h3>

<p>Finds an approximate tangent vector of this surface at the given U and V coordinates.
The implementation in <a href="H3DU.Surface.html">H3DU.Surface</a> calls the evaluator&#39;s <code>tangent</code>
method if it implements it; otherwise, does a numerical differentiation
with respect to the U axis using the <code>evaluate</code> method.</p>

<p>The <b>tangent vector</b> is the vector pointing in the direction of the U axis,
or alternatively, the partial derivative of the <code>evaluate</code> method with respect to <code>u</code>.
The tangent vector returned by this method <i>should not</i> be &quot;normalized&quot; to a <a href="tutorial-glmath.html">unit vector</a>.</p>

<h4>Parameters</h4>

<ul>
<li><code>u</code> (Type: number)<br>U coordinate of a point on the surface.</li>
<li><code>v</code> (Type: number)<br>V coordinate of a point on the surface.</li>
</ul>

<h4>Return Value</h4>

<p>An array describing a tangent vector. It should have at least as many
elements as the number of dimensions of the underlying surface. (Type: Array.&lt;number&gt;)</p>

<p><a href="index.html">Back to documentation index.</a></p>
</div><nav id="navigation"><p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHfwYJKoZIhvcNAQcEoIIHcDCCB2wCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYBTEjVSqAfM9cTLwXVwxBqNI8r1Il0SJNqahKnIJrEIZOdmziEnZsYS8kifxxbWCBrNGl1S/eO5kcMG6WO50eBSxFlNpweevNYIs0dIdfQZtiWcRD2yYzaWHBkHu3PmCCLmc3pPT5QaOc949w2dPcg+syabMOSwN94Mk67Wh//7pTELMAkGBSsOAwIaBQAwgfwGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIm7w2yVS0zOeAgdhYAX/keBkbLTGS2k5QcVstRROvRVuMlDL7sy/YUie0YlEJKDFTFE7n6LP15AFfODDattjmqKJ7UZ+6hY9sqJhayUNqdl/rA/RYgPVKGWTM1l68+KFdz2SO3IHvBUJIAwnHFX1JVyNUAofSxWj+3eoN5MnQzskA4cKe/RFWB04oXxZS7/WCOHL3q3mlwFDSK83C3Wcqro7S18YnVxfJ4XGUQ7nlx1C9K0Xq+JbCGEC4D8yjQHzm9w3LqUOogiI3l9VVlXxuqcAdq+iBkAGIt3y4TXABMtXEFG2gggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xMzA4MTAxMzA4NDBaMCMGCSqGSIb3DQEJBDEWBBQImRl0rdSM38l1aTcRhxgiKb7ipTANBgkqhkiG9w0BAQEFAASBgE0IsEWvN+n6QuwDFkBMQO9C4z5uf7wAvoMDgifDKBCyGFmpYZPsKawkYVcS/kASDtyq6aWU3lqP+KweyA+0xfpAyE3R8/7p80uqGGs8bHGicxkl2pEkX95R23HGRa1pEDHFF1XQNkhns558WioFipI2RvmAAEaMgZQ1p+SV/cdu-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
<h3>Navigation</h3>

<ul>
<li><a href="Camera.html">Camera</a></li>
<li><a href="CurveTube.html">CurveTube</a></li>
<li><a href="Epitrochoid.html">Epitrochoid</a></li>
<li><a href="FrameCounter.html">FrameCounter</a></li>
<li><a href="FrameCounterDiv.html">FrameCounterDiv</a></li>
<li><a href="GraphicsPath.html">GraphicsPath</a></li>
<li><a href="H3DU.html">H3DU</a></li>
<li><a href="H3DU.BSplineCurve.html">H3DU.BSplineCurve</a></li>
<li><a href="H3DU.BSplineSurface.html">H3DU.BSplineSurface</a></li>
<li><a href="H3DU.Batch3D.html">H3DU.Batch3D</a></li>
<li><a href="H3DU.BezierCurve.html">H3DU.BezierCurve</a></li>
<li><a href="H3DU.BezierSurface.html">H3DU.BezierSurface</a></li>
<li><a href="H3DU.BufferHelper.html">H3DU.BufferHelper</a></li>
<li><a href="H3DU.BufferedMesh.html">H3DU.BufferedMesh</a></li>
<li><a href="H3DU.Camera.html">H3DU.Camera</a></li>
<li><a href="H3DU.CubeMap.html">H3DU.CubeMap</a></li>
<li><a href="H3DU.Curve.html">H3DU.Curve</a></li>
<li><a href="H3DU.CurveBuilder.html">H3DU.CurveBuilder</a></li>
<li><a href="H3DU.CurveEval.html">H3DU.CurveEval</a></li>
<li><a href="H3DU.CurveTube.html">H3DU.CurveTube</a></li>
<li><a href="H3DU.Epitrochoid.html">H3DU.Epitrochoid</a></li>
<li><a href="H3DU.FrameBuffer.html">H3DU.FrameBuffer</a></li>
<li><a href="H3DU.FrameBufferInfo.html">H3DU.FrameBufferInfo</a></li>
<li><a href="H3DU.FrameCounter.html">H3DU.FrameCounter</a></li>
<li><a href="H3DU.FrameCounterDiv.html">H3DU.FrameCounterDiv</a></li>
<li><a href="H3DU.GraphicsPath.html">H3DU.GraphicsPath</a></li>
<li><a href="H3DU.Hypotrochoid.html">H3DU.Hypotrochoid</a></li>
<li><a href="H3DU.InputTracker.html">H3DU.InputTracker</a></li>
<li><a href="H3DU.LightSource.html">H3DU.LightSource</a></li>
<li><a href="H3DU.Lights.html">H3DU.Lights</a></li>
<li><a href="H3DU.Material.html">H3DU.Material</a></li>
<li><a href="H3DU.Math.html">H3DU.Math</a></li>
<li><a href="H3DU.MatrixStack.html">H3DU.MatrixStack</a></li>
<li><a href="H3DU.Mesh.html">H3DU.Mesh</a></li>
<li><a href="H3DU.MeshBuffer.html">H3DU.MeshBuffer</a></li>
<li><a href="H3DU.MeshJSON.html">H3DU.MeshJSON</a></li>
<li><a href="H3DU.Meshes.html">H3DU.Meshes</a></li>
<li><a href="H3DU.ObjData.html">H3DU.ObjData</a></li>
<li><a href="H3DU.PbrMaterial.html">H3DU.PbrMaterial</a></li>
<li><a href="H3DU.PiecewiseCurve.html">H3DU.PiecewiseCurve</a></li>
<li><a href="H3DU.Polyhedra.html">H3DU.Polyhedra</a></li>
<li><a href="H3DU.RenderPass.html">H3DU.RenderPass</a></li>
<li><a href="H3DU.Scene3D.html">H3DU.Scene3D</a></li>
<li><a href="H3DU.Semantic.html">H3DU.Semantic</a></li>
<li><a href="H3DU.ShaderInfo.html">H3DU.ShaderInfo</a></li>
<li><a href="H3DU.ShaderProgram.html">H3DU.ShaderProgram</a></li>
<li><a href="H3DU.Shape.html">H3DU.Shape</a></li>
<li><a href="H3DU.ShapeGroup.html">H3DU.ShapeGroup</a></li>
<li><a href="H3DU.Surface.html">H3DU.Surface</a></li>
<li><a href="H3DU.SurfaceBuilder.html">H3DU.SurfaceBuilder</a></li>
<li><a href="H3DU.SurfaceEval.html">H3DU.SurfaceEval</a></li>
<li><a href="H3DU.SurfaceOfRevolution.html">H3DU.SurfaceOfRevolution</a></li>
<li><a href="H3DU.TextFont.html">H3DU.TextFont</a></li>
<li><a href="H3DU.Texture.html">H3DU.Texture</a></li>
<li><a href="H3DU.TextureAtlas.html">H3DU.TextureAtlas</a></li>
<li><a href="H3DU.TextureInfo.html">H3DU.TextureInfo</a></li>
<li><a href="H3DU.TextureLoader.html">H3DU.TextureLoader</a></li>
<li><a href="H3DU.Transform.html">H3DU.Transform</a></li>
<li><a href="H3DU.Trochoid.html">H3DU.Trochoid</a></li>
<li><a href="Hypotrochoid.html">Hypotrochoid</a></li>
<li><a href="InputTracker.html">InputTracker</a></li>
<li><a href="MatrixStack.html">MatrixStack</a></li>
<li><a href="MeshJSON.html">MeshJSON</a></li>
<li><a href="ObjData.html">ObjData</a></li>
<li><a href="PrimitiveCounter.html">PrimitiveCounter</a></li>
<li><a href="Promise.html">Promise</a></li>
<li><a href="SurfaceOfRevolution.html">SurfaceOfRevolution</a></li>
<li><a href="Trochoid.html">Trochoid</a></li>
</ul>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body></html>
