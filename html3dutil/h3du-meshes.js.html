<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Source: h3du-meshes.js</title>
<meta name="viewport" content="width=device-width">
<script src="mathml.js"></script>
<link rel=stylesheet type="text/css" href="/style.css">
</head>
<body style="margin-top:0px">
<div class="header">
<p><a href="#navigation">Menu</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
    <h1>Source: h3du-meshes.js</h1>

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://peteroupc.github.io/
*/
/* global H3DU.Math, H3DU.Mesh */
/**
* Contains methods that create meshes
* of various geometric shapes.
* @class
* @alias H3DU.Meshes
*/
H3DU.Meshes={};

/**
* Creates a mesh of a box (rectangular prism), which
* will be centered at the origin.
* See the "{@tutorial shapes}" tutorial.
* Will create texture coordinates such that the same texture
* is used on each face of the box.
* @param {Number} xSize Width of the box.
* @param {Number} ySize Height of the box.
* @param {Number} xSize Depth of the box.
* @param {Boolean} inward If true, the normals generated by this
* method will point inward; otherwise, outward.  Should normally be false
* unless the box will be viewed from the inside.
* @returns {H3DU.Mesh} The generated mesh.
*/
H3DU.Meshes.createBox=function(xSize,ySize,zSize,inward){
 // Position X, Y, Z, normal NX, NY, NZ, texture U, V
 "use strict";
xSize*=0.5;
 ySize*=0.5;
 zSize*=0.5;
 var vertices=[
-xSize,-ySize,zSize,-1.0,0.0,0.0,1.0,0.0,
-xSize,ySize,zSize,-1.0,0.0,0.0,1.0,1.0,
-xSize,ySize,-zSize,-1.0,0.0,0.0,0.0,1.0,
-xSize,-ySize,-zSize,-1.0,0.0,0.0,0.0,0.0,
xSize,-ySize,-zSize,1.0,0.0,0.0,1.0,0.0,
xSize,ySize,-zSize,1.0,0.0,0.0,1.0,1.0,
xSize,ySize,zSize,1.0,0.0,0.0,0.0,1.0,
xSize,-ySize,zSize,1.0,0.0,0.0,0.0,0.0,
xSize,-ySize,-zSize,0.0,-1.0,0.0,1.0,0.0,
xSize,-ySize,zSize,0.0,-1.0,0.0,1.0,1.0,
-xSize,-ySize,zSize,0.0,-1.0,0.0,0.0,1.0,
-xSize,-ySize,-zSize,0.0,-1.0,0.0,0.0,0.0,
xSize,ySize,zSize,0.0,1.0,0.0,1.0,0.0,
xSize,ySize,-zSize,0.0,1.0,0.0,1.0,1.0,
-xSize,ySize,-zSize,0.0,1.0,0.0,0.0,1.0,
-xSize,ySize,zSize,0.0,1.0,0.0,0.0,0.0,
-xSize,-ySize,-zSize,0.0,0.0,-1.0,1.0,0.0,
-xSize,ySize,-zSize,0.0,0.0,-1.0,1.0,1.0,
xSize,ySize,-zSize,0.0,0.0,-1.0,0.0,1.0,
xSize,-ySize,-zSize,0.0,0.0,-1.0,0.0,0.0,
xSize,-ySize,zSize,0.0,0.0,1.0,1.0,0.0,
xSize,ySize,zSize,0.0,0.0,1.0,1.0,1.0,
-xSize,ySize,zSize,0.0,0.0,1.0,0.0,1.0,
-xSize,-ySize,zSize,0.0,0.0,1.0,0.0,0.0];
 if(inward){
  for(var i=0;i&lt;vertices.length;i+=8){
   vertices[i+3]=-vertices[i+3];
   vertices[i+4]=-vertices[i+4];
   vertices[i+5]=-vertices[i+5];
  }
 }
 var faces=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,
 13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];
 return new H3DU.Mesh(vertices,faces,H3DU.Mesh.NORMALS_BIT | H3DU.Mesh.TEXCOORDS_BIT);
};

/**
* Creates a mesh of a cylinder.  The cylinder's base will
* be centered at the origin and its height will run along the
* positive z-axis.  The base and top themselves will not be
* included in the mesh.
* See the "{@tutorial shapes}" tutorial.
* @param {Number} baseRad Radius of the base of the cylinder. If 0,
* this function will create an approximation to a downward pointing cone.
* @param {Number} topRad Radius of the top of the cylinder. If 0,
* this function will create an approximation to an upward pointing cone.
* @param {Number} height Height of the cylinder.
* @param {Number} slices Number of lengthwise "slices" the cylinder consists
* of, each slice going through the center of the cylinder.  This function will
* create a triangular prism if "slices" is 3
* and both radiuses are the same; a triangular pyramid if "slices" is
* 3 and either radius is zero; a rectangular prism if "slices" is 4
* and both radiuses are the same; and a rectangular pyramid if "slices"
* is 4 and either radius is zero. Must be 3 or greater.
* May be null or omitted, in which case the default is 32.
* @param {Number} stacks Number of vertical stacks the cylinder consists of.
* May be null or omitted, in which case the default is 1.
* @param {Boolean} flat If true, will generate normals such that the
* cylinder will be flat shaded; otherwise, will generate normals such that the
* cylinder will be smooth shaded.
* @param {Boolean} inside If true, the normals generated by this
* method will point inward; otherwise, outward.  Should normally be false
* unless the cylinder will be viewed from the inside.
* @returns {H3DU.Mesh} The generated mesh.
*/
H3DU.Meshes.createCylinder=function(baseRad, topRad, height, slices, stacks, flat, inside){
 "use strict";
var mesh=new H3DU.Mesh();
 if((slices===null || typeof slices==="undefined"))slices=32;
 if((stacks===null || typeof stacks==="undefined"))stacks=1;
 if(slices&lt;=2)throw new Error("too few slices");
 if(stacks&lt;1)throw new Error("too few stacks");
 if(height&lt;0)throw new Error("negative height");
 if((baseRad&lt;=0 &amp;&amp; topRad&lt;=0) || height===0){
  // both baseRad and topRad are zero or negative,
  // or height is zero
  return mesh;
 }
 var normDir=(inside) ? -1 : 1;
 var sc=[0,1]; // sin(0), cos(0)
 var tc=[0];
 var twopi=H3DU.Math.PiTimes2;
 for(var i=1;i&lt;slices;i++){
  var t=i*1.0/slices;
  var angle=twopi*t;
  var cangle = Math.cos(angle);
  var sangle = (angle>=0 &amp;&amp; angle&lt;6.283185307179586) ? (angle&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(angle);
  sc.push(sangle,cangle);
  tc.push(t);
 }
 sc.push(0,1);
 tc.push(1);
 var slicesTimes2=slices*2;
 if(height>0){
  var lastZ=0;
  var lastRad=baseRad;
  var slopeAngle=0,sinSlopeNorm,cosSlopeNorm;
  if(baseRad===topRad){
   sinSlopeNorm=0;
   cosSlopeNorm=normDir;
  } else {
   slopeAngle=Math.atan2(baseRad-topRad,height);
   cosSlopeNorm = Math.cos(slopeAngle);
   sinSlopeNorm = (slopeAngle>=0 &amp;&amp; slopeAngle&lt;6.283185307179586) ? (slopeAngle&lt;=3.141592653589793 ? Math.sqrt(1.0-cosSlopeNorm*cosSlopeNorm) : -Math.sqrt(1.0-cosSlopeNorm*cosSlopeNorm)) : Math.sin(slopeAngle);
   sinSlopeNorm*=normDir;
   cosSlopeNorm*=normDir;
  }
  var recipstacks=1.0/(stacks);
  for(i=0;i&lt;stacks;i++){
   var zStart=lastZ;
   var zEnd=(i+1==stacks) ? 1.0 : (i+1)*recipstacks;
   var zStartHeight=height*zStart;
   var zEndHeight=height*zEnd;
   var radiusStart=lastRad;
   var radiusEnd=baseRad+(topRad-baseRad)*zEnd;
   lastZ=zEnd;
   lastRad=radiusEnd;
   mesh.mode(H3DU.Mesh.TRIANGLE_STRIP);
   mesh.texCoord2(1,zStart);
   mesh.normal3(0,cosSlopeNorm,sinSlopeNorm);
   mesh.vertex3(0,radiusStart,zStartHeight);
   mesh.texCoord2(1,zEnd);
   mesh.normal3(0,cosSlopeNorm,sinSlopeNorm);
   mesh.vertex3(0,radiusEnd,zEndHeight);
   for(var k=2,j=1;k&lt;=slicesTimes2;k+=2,j++){
    var tx=tc[j];
    var x,y;
    x=sc[k];
    y=sc[k+1];
     mesh.texCoord2(1-tx,zStart);
     mesh.normal3(x*cosSlopeNorm,y*cosSlopeNorm,sinSlopeNorm);
     mesh.vertex3(x*radiusStart,y*radiusStart,zStartHeight);
     mesh.texCoord2(1-tx,zEnd);
     mesh.normal3(x*cosSlopeNorm,y*cosSlopeNorm,sinSlopeNorm);
     mesh.vertex3(x*radiusEnd,y*radiusEnd,zEndHeight);
   }
  }
 }
 return flat ? mesh.recalcNormals(flat,inside) : mesh;
};
/**
 * Not documented yet.
 * @param {*} points
 * @param {*} slices
 * @param {*} flat
 * @param {*} inside
 */
H3DU.Meshes.createLathe=function(points,slices,flat,inside){
 "use strict";
 // NOTE: Y-coordinate should not be the same from one point to the next
 var mesh=new H3DU.Mesh();
 if(points.length&lt;4)throw new Error("too few points");
 if((slices===null || typeof slices==="undefined"))slices=32;
 if(slices&lt;=2)throw new Error("too few slices");
 if((points.length%1)!=0)throw new Error("points array length is not an even number");
for(var i=0;i&lt;points.length;i+=2){
 if(points[i&lt;&lt;1]&lt;0)throw new Error("point's x is less than 0")
}
 var sc=[0,1]; // sin(0), cos(0)
 var tc=[0];
 var i;
 var twopi=H3DU.Math.PiTimes2;
 for(i=1;i&lt;slices;i++){
  var t=i*1.0/slices;
  var angle=twopi*t;
  var cangle = Math.cos(angle);
  var sangle = (angle>=0 &amp;&amp; angle&lt;6.283185307179586) ? (angle&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(angle);
  sc.push(sangle,cangle);
  tc.push(t);
 }
 sc.push(0,1);
 tc.push(1);
 var slicesTimes2=slices*2;
  var lastZ=0;
  var lastRad=baseRad;
  var stacks=(points.length/2)-1;
  var recipstacks=1.0/stacks;
  for(i=0;i&lt;stacks;i++){
   var zStart=lastZ;
   var zEnd=(i+1==stacks) ? 1.0 : (i+1)*recipstacks;
   var index=i&lt;&lt;1;
   var zsh=points[index+1];
   var zeh=points[index+3];
   var zStartHeight=Math.min(zsh,zeh);
   var zEndHeight=Math.max(zsh,zeh);
   var radiusStart=points[index];
   var radiusEnd=points[index+2];
   lastZ=zEnd;
   lastRad=radiusEnd;
   mesh.mode(H3DU.Mesh.TRIANGLE_STRIP);
   mesh.texCoord2(1,zStart);
   mesh.vertex3(0,radiusStart,zStartHeight);
   mesh.texCoord2(1,zEnd);
   mesh.vertex3(0,radiusEnd,zEndHeight);
   for(var k=2,j=1;k&lt;=slicesTimes2;k+=2,j++){
    var tx=tc[j];
    var x,y;
    x=sc[k];
    y=sc[k+1];
     mesh.texCoord2(1-tx,zStart);
     mesh.vertex3(x*radiusStart,y*radiusStart,zStartHeight);
     mesh.texCoord2(1-tx,zEnd);
     mesh.vertex3(x*radiusEnd,y*radiusEnd,zEndHeight);
   }
  }
 return mesh.recalcNormals(flat,inside);
};

/**
* Creates a mesh of a closed cylinder.  The cylinder's base will
* be centered at the origin and its height will run along the
* positive z-axis.  The base and top will be included in the mesh if
* their radius is greater than 0.
* See the "{@tutorial shapes}" tutorial.
* @param {Number} baseRad Radius of the base of the cylinder.
* See {@link H3DU.Meshes.createCylinder}.
* @param {Number} topRad Radius of the top of the cylinder.
* See {@link H3DU.Meshes.createCylinder}.
* @param {Number} height Height of the cylinder.
* @param {Number} slices    Number of lengthwise "slices" the cylinder consists
* of. See {@link H3DU.Meshes.createCylinder}.
* @param {Number} stacks Number of vertical stacks the cylinder consists of.
* May be null or omitted, in which case the default is 1.
* @param {Boolean} flat If true, will generate normals such that the
* cylinder will be flat shaded; otherwise, will generate normals such that the
* cylinder will be smooth shaded.
* @param {Boolean} inside If true, the normals generated by this
* method will point inward; otherwise, outward.  Should normally be false
* unless the cylinder will be viewed from the inside.
* @returns {H3DU.Mesh} The generated mesh.
*/
H3DU.Meshes.createClosedCylinder=function(baseRad,topRad,height,slices,stacks,flat, inside){
 "use strict";
var cylinder=H3DU.Meshes.createCylinder(baseRad,topRad,height,slices,stacks,flat, inside);
 var base=H3DU.Meshes.createDisk(0,baseRad,slices,2,!inside).reverseWinding();
 var top=H3DU.Meshes.createDisk(0,topRad,slices,2,inside);
 // move the top disk to the top of the cylinder
 top.transform(H3DU.Math.mat4translated(0,0,height));
 // merge the base and the top
 return cylinder.merge(base).merge(top);
};

/**
* Creates a mesh of a 2D disk.
* Assuming the Y axis points up, the X axis right,
* and the Z axis toward the viewer, the first vertex in the outer edge
* of the 2D disk will be at the 12 o'clock position.
* See the "{@tutorial shapes}" tutorial.
* @param {Number} inner Radius of the hole in the middle of the
* disk.  If 0, no hole is created and the method will generate a regular
* polygon with n sides, where n is the value of "slices".  For example,
* if "inner" is 0 and "slices" is 3, the result will be an equilateral triangle;
* a square for 4 "slices", a regular pentagon for 5 "slices", and so on.
* @param {Number} outer Outer radius of the disk.
* @param {Number} slices Number of slices going around the disk.
* May be null or omitted; default is 16.
* @param {Number} loops Number of concentric rings the disk makes up.
* May be null or omitted; default is 1.
* @param {Boolean} inward If true, the normals generated by this
* method will point in the opposite direction of the positive z-axis; otherwise,
* in the same direction of the positive z-axis.  Default is false.
* @returns The generated mesh.
*/
H3DU.Meshes.createDisk=function(inner, outer, slices, loops, inward){
 "use strict";
return H3DU.Meshes.createPartialDisk(inner,outer,slices,loops,0,360,inward);
};

/**
* Creates a mesh of a 2D disk or an arc of a 2D disk.
* See the "{@tutorial shapes}" tutorial.
* @param {Number} inner Radius of the hole where the middle of the
* complete disk would be.  If 0, no hole is created.
* @param {Number} outer Outer radius of the disk.
* @param {Number} slices Number of slices going around the partial disk.
* May be null or omitted; default is 32.
* @param {Number} loops Number of concentric rings the partial disk makes up.
* May be null or omitted; default is 1.
* @param {Number} start Starting angle of the partial disk, in degrees.
* May be null or omitted; default is 0.
* 0 degrees is at the positive y-axis,
* and 90 degrees at the positive x-axis.
* Assuming the Y axis points up, the X axis right,
* and the Z axis toward the viewer, 0 degrees is at the 12 o'clock position,
* and 90 degrees at the 3 o'clock position.
* @param {Number} sweep Arc length of the partial disk, in degrees.
* May be null or omitted; default is 360. May be negative.
* @param {Boolean} inward If true, the normals generated by this
* method will point in the opposite direction of the positive z-axis; otherwise,
* in the same direction of the positive z-axis.  Default is false.
* @returns The generated mesh.
*/
H3DU.Meshes.createPartialDisk=function(inner, outer, slices, loops, start, sweep, inward){
 "use strict";
var mesh=new H3DU.Mesh();
 if((slices===null || typeof slices==="undefined"))slices=32;
 if((loops===null || typeof loops==="undefined"))loops=1;
 if((start===null || typeof start==="undefined"))start=0;
 if((sweep===null || typeof sweep==="undefined"))sweep=360;
 if(slices&lt;=2)throw new Error("too few slices");
 if(loops&lt;1)throw new Error("too few loops");
 if(inner>outer)throw new Error("inner greater than outer");
 if(inner&lt;0)inner=0;
 if(outer&lt;0)outer=0;
 if(outer===0 || sweep === 0)return mesh;
 var fullCircle=(sweep===360 &amp;&amp; start === 0);
 var sweepDir=sweep&lt;0 ? -1 : 1;
 if(sweep&lt;0)sweep=-sweep;
 sweep%=360;
 if(sweep===0)sweep=360;
 var sc=[];
 var tc=[];
 var i;
 var twopi=H3DU.Math.PiTimes2;
 var arcLength=(sweep===360) ? twopi : sweep*H3DU.Math.PiDividedBy180;
 start=start*H3DU.Math.PiDividedBy180;
 if(sweepDir&lt;0){
  arcLength=-arcLength;
 }
 for(var i=0;i&lt;=slices;i++){
  var t=i*1.0/slices;
  var angle=(t===1 &amp;&amp; arcLength===twopi) ? start : start+arcLength*t;
  angle=(angle&lt;0) ? twopi-(-angle)%twopi : angle%twopi;
  var cangle = Math.cos(angle);
  var sangle = (angle>=0 &amp;&amp; angle&lt;6.283185307179586) ? (angle&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(angle);
  sc.push(sangle,cangle);
  tc.push(t);
 }
 if(fullCircle){
  sc[0]=0;
  sc[1]=1;
  sc[sc.length-1]=1;
  sc[sc.length-2]=0;
  tc[0]=0;
  tc[tc.length-1]=1;
 }
 var slicesTimes2=slices*2;
 var height=outer-inner;
  var lastZ=0;
  var lastRad=inner;
  if(inward){
   mesh.normal3(0,0,-1);
  } else {
   mesh.normal3(0,0,1);
  }
  for(i=0;i&lt;loops;i++){
   var zStart=lastZ;
   var zEnd=(i+1)/loops;
   var radiusStart=lastRad;
   var radiusEnd=inner+height*zEnd;
   var rso=radiusStart/outer;
   var reo=radiusEnd/outer;
   lastZ=zEnd;
   lastRad=radiusEnd;
   var triangleFanBase=(i===0 &amp;&amp; inner === 0);
   mesh.mode((triangleFanBase) ?
     H3DU.Mesh.TRIANGLE_FAN : H3DU.Mesh.TRIANGLE_STRIP);
   var x,y,j,k,tx;
   if(triangleFanBase){
    var jStart=slicesTimes2/2;
    for(k=slicesTimes2,j=jStart;k>=0;k-=2,j--){
     tx=tc[j];
     x=sc[k];
     y=sc[k+1];
     if(k===slicesTimes2){
      mesh.texCoord2((1+(x*rso))*0.5,(1+(y*rso))*0.5);
      mesh.vertex3(x*radiusStart,y*radiusStart,0);
     }
     mesh.texCoord2((1+(x*reo))*0.5,(1+(y*reo))*0.5);
     mesh.vertex3(x*radiusEnd,y*radiusEnd,0);
    }
   } else {
    for(k=0,j=0;k&lt;=slicesTimes2;k+=2,j++){
     tx=tc[j];
     x=sc[k];
     y=sc[k+1];
     mesh.texCoord2((1+(x*reo))*0.5,(1+(y*reo))*0.5);
     mesh.vertex3(x*radiusEnd,y*radiusEnd,0);
     mesh.texCoord2((1+(x*rso))*0.5,(1+(y*rso))*0.5);
     mesh.vertex3(x*radiusStart,y*radiusStart,0);
    }
   }
  }
  return mesh;
};

/**
* Creates a mesh of a torus (donut), centered at the origin.
* See the "{@tutorial shapes}" tutorial.
* @param {Number} inner Inner radius (thickness) of the torus.
* @param {Number} outer Outer radius of the torus (distance from the
* center to the innermost part of the torus).
* @param {Number} lengthwise Number of lengthwise subdivisions.
* May be null or omitted; default is 16.
* @param {Number} crosswise Number of crosswise subdivisions.
* May be null or omitted; default is 16.
* @param {Boolean} flat If true, will generate normals such that the
* torus will be flat shaded; otherwise, will generate normals such that it
* will be smooth shaded.
* @param {Boolean} inward If true, the normals generated by this
* method will point inward; otherwise, outward.  Default is false.
* @returns {H3DU.Mesh} The generated mesh.
*/
H3DU.Meshes.createTorus=function(inner, outer, lengthwise, crosswise,flat,inward){
 "use strict";
var mesh=new H3DU.Mesh();
 if((crosswise===null || typeof crosswise==="undefined"))crosswise=16;
 if((lengthwise===null || typeof lengthwise==="undefined"))lengthwise=16;
 if(crosswise&lt;3)throw new Error("crosswise is less than 3");
 if(lengthwise&lt;3)throw new Error("lengthwise is less than 3");
 if(inner&lt;0||outer&lt;0)throw new Error("inner or outer is less than 0");
 if(outer===0)return mesh;
 if(inner===0)return mesh;
 var tubeRadius=inner;
 var circleRad=outer;
 var twopi=H3DU.Math.PiTimes2;
 var sci=[];
 var scj=[];
 var cangle,sangle,u;
 for(var i = 0; i &lt; crosswise; i++){
  u = i*twopi/crosswise;
  cangle = Math.cos(u);
  sangle = (u>=0 &amp;&amp; u&lt;6.283185307179586) ? (u&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(u);
  sci.push(sangle,cangle);
 }
 sci.push(sci[0]);
 sci.push(sci[1]);
 for(i = 0; i &lt; lengthwise; i++){
  u = i*twopi/lengthwise;
  cangle = Math.cos(u);
  sangle = (u>=0 &amp;&amp; u&lt;6.283185307179586) ? (u&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(u);
  scj.push(sangle,cangle);
 }
 scj.push(scj[0]);
 scj.push(scj[1]);
 for(var j = 0; j &lt; lengthwise; j++){
  var v0 = (j)/lengthwise;
  var v1 = (j+1.0)/lengthwise;
  var sinr0=scj[j*2];
  var cosr0=scj[j*2+1];
  var sinr1=scj[j*2+2];
  var cosr1=scj[j*2+3];
  mesh.mode(H3DU.Mesh.TRIANGLE_STRIP);
  for(i = 0; i &lt;= crosswise; i++){
   u = i/crosswise;
   var sint=sci[i*2];
   var cost=sci[i*2+1];
   var x = (cost * (circleRad + cosr1 * tubeRadius));
   var y = (sint * (circleRad + cosr1 * tubeRadius));
   var z = (sinr1 * tubeRadius);
   var nx = (cosr1 * cost);
   var ny = (cosr1 * sint);
   var nz = (sinr1);
   mesh.normal3(nx, ny, nz);
   mesh.texCoord2(u, v1);
   mesh.vertex3(x, y, z);
   x = (cost * (circleRad + cosr0 * tubeRadius));
   y = (sint * (circleRad + cosr0 * tubeRadius));
   z = (sinr0 * tubeRadius);
   nx = (cosr0 * cost);
   ny = (cosr0 * sint);
   nz = (sinr0);
   mesh.normal3(nx, ny, nz);
   mesh.texCoord2(u, v0);
   mesh.vertex3(x, y, z);
  }
 }
 return flat ? mesh.recalcNormals(flat, inward) : mesh;
};

/**
* Creates a mesh of a 2D rectangle, centered at the origin.
* See the "{@tutorial shapes}" tutorial.
* @param {Number} width Width of the rectangle.
* May be null or omitted; default is 1.
* @param {Number} height Height of the rectangle.
* May be null or omitted; default is 1.
* @param {Number} widthDiv Number of horizontal subdivisions.
* May be null or omitted; default is 1.
* @param {Number} heightDiv Number of vertical subdivisions.
* May be null or omitted; default is 1.
* @param {Boolean} inward If true, the normals generated by this
* method will point in the opposite direction of the positive z-axis; otherwise,
* in the same direction of the positive z-axis.  Default is false.
* @returns {H3DU.Mesh} The generated mesh.
*/
H3DU.Meshes.createPlane=function(width, height, widthDiv, heightDiv,inward){
 "use strict";
var mesh=new H3DU.Mesh();
 if((width===null || typeof width==="undefined"))width=1;
 if((height===null || typeof height==="undefined"))height=1;
 if((widthDiv===null || typeof widthDiv==="undefined"))widthDiv=1;
 if((heightDiv===null || typeof heightDiv==="undefined"))heightDiv=1;
 if(width&lt;0||height&lt;0)throw new Error("width or height is less than 0");
 if(heightDiv&lt;=0 || widthDiv&lt;=0)
  throw new Error("widthDiv or heightDiv is 0 or less");
 if(width===0 || height === 0)return mesh;
 var xStart=-width*0.5;
 var yStart=-height*0.5;
  if(inward){
   mesh.normal3(0,0,-1);
  } else {
   mesh.normal3(0,0,1);
  }
 for(var i=0;i&lt;heightDiv;i++){
  mesh.mode(H3DU.Mesh.TRIANGLE_STRIP);
  var iStart=i/heightDiv;
  var iNext=(i+1)/heightDiv;
  var y=yStart+height*iStart;
  var yNext=yStart+height*iNext;
  mesh.texCoord2(0,iNext);
  mesh.vertex3(xStart,yNext,0);
  mesh.texCoord2(0,iStart);
  mesh.vertex3(xStart,y,0);
  for(var j=0;j&lt;widthDiv;j++){
   var jx=(j+1)/widthDiv;
   var x=xStart+width*jx;
   mesh.texCoord2(jx,iNext);
   mesh.vertex3(x,yNext,0);
   mesh.texCoord2(jx,iStart);
   mesh.vertex3(x,y,0);
  }
 }
 return mesh;
};
/**
* Creates a mesh of a sphere, centered at the origin.
* See the "{@tutorial shapes}" tutorial.
* @param {Number} radius Radius of the sphere.
* May be null or omitted, in which case the default is 1.
* @param {Number} slices Number of vertical sections the sphere consists
* of.  This function will create an octahedron if "slices" is 4 and "stacks" is 2.
* Must be 3 or greater. May be null or omitted, in which case the default is 16.
* @param {Number} stacks Number of horizontal sections the sphere consists of.
* May be null or omitted, in which case the default is 16.
* @param {Boolean} flat If true, will generate normals such that the
* sphere will be flat shaded; otherwise, will generate normals such that the
* sphere will be smooth shaded.
* @param {Boolean} inside If true, the normals generated by this
* method will point inward; otherwise, outward.  Should normally be false
* unless the sphere will be viewed from the inside.
* @returns {H3DU.Mesh} The generated mesh.
*/
H3DU.Meshes.createSphere=function(radius, slices, stacks, flat, inside){
 "use strict";
return H3DU.Meshes._createCapsule(radius,0,slices,stacks,1,flat,inside);
};

/**
* Creates a mesh of a capsule, centered at the origin.
* The length of the capsule will run along the z-axis. (If the capsule
* has a high length and a very low radius, it will resemble a 3D line
* with rounded corners.)
* See the "{@tutorial shapes}" tutorial.
* @param {Number} radius Radius of each spherical
* end of the capsule.
* May be null or omitted, in which case the default is 1.
* @param {Number} length Length of the middle section.
* May be null or omitted, in which case the default is 1.
* If this value is 0, an approximation to a sphere will be generated.
* @param {Number} slices Number of vertical sections the capsule consists
* of.  This function will create an octahedron if "slices" is 4 and "stacks" is 2.
* Must be 3 or greater. May be null or omitted, in which case the default is 16.
* @param {Number} stacks Number of horizontal sections
* each spherical half consists of.
* May be null or omitted, in which case the default is 8.
* @param {Number} middleStacks Number of vertical sections
* the middle of the capsule consists of.
* May be null or omitted, in which case the default is 1.
* @param {Boolean} flat If true, will generate normals such that the
* capsule will be flat shaded; otherwise, will generate normals such that the
* capsule will be smooth shaded.
* @param {Boolean} inside If true, the normals generated by this
* method will point inward; otherwise, outward.  Should normally be false
* unless the capsule will be viewed from the inside.
* @returns {H3DU.Mesh} The generated mesh.
*/
H3DU.Meshes.createCapsule=function(radius, length, slices, stacks, middleStacks, flat, inside){
 "use strict";
if((stacks===null || typeof stacks==="undefined"))stacks=8;
 if(stacks&lt;1)throw new Error("too few stacks");
 return H3DU.Meshes._createCapsule(radius,length,slices,stacks*2,middleStacks,flat,inside);
};
/** @private */
H3DU.Meshes._createCapsule=function(radius,length,slices,stacks,middleStacks,flat,inside){
 "use strict";
var mesh=new H3DU.Mesh();
 if((slices===null || typeof slices==="undefined"))slices=16;
 if((stacks===null || typeof stacks==="undefined"))stacks=16;
 if((middleStacks===null || typeof middleStacks==="undefined"))middleStacks=1;
 if((radius===null || typeof radius==="undefined"))radius=1;
 if((length===null || typeof length==="undefined"))length=1;
 if(stacks&lt;2)throw new Error("too few stacks");
 if(slices&lt;=2)throw new Error("too few slices");
 if(middleStacks&lt;1 &amp;&amp; length>0)throw new Error("too few middle stacks");
 if(length&lt;0)throw new Error("negative length");
 if(radius&lt;0)throw new Error("negative radius");
 if(radius===0){
  // radius is zero
  return mesh;
 }
 var halfLength=length*0.5;
 var halfStacks=stacks/2;
 var normDir=(inside) ? -1 : 1;
 var sc=[0,1]; // sin(0), cos(0)
 var scStack=[];
 var texc=[];
 var tc=[0];
 var angle,s;
 var twopi=H3DU.Math.PiTimes2;
 var pidiv2=H3DU.Math.HalfPi;
 for(var i=1;i&lt;slices;i++){
  var t=i*1.0/slices;
  angle=twopi*t;
  var cangle = Math.cos(angle);
  var sangle = (angle>=0 &amp;&amp; angle&lt;6.283185307179586) ? (angle&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(angle);
  sc.push(sangle,cangle);
  tc.push(t);
 }
 sc.push(0,1);
 tc.push(1);
 var sphereRatio=(radius*2);
 sphereRatio/=sphereRatio+length;
 var zEnd=[];
 for(i=1;i&lt;stacks;i++){
   var origt=i*1.0/stacks;
   angle=Math.PI*origt;
   var cangle = Math.cos(angle);
   var sangle = (angle>=0 &amp;&amp; angle&lt;6.283185307179586) ? (angle&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(angle);
   scStack.push(sangle);
   zEnd.push(-cangle);
   var tex=origt;
   texc.push(tex);
 }
 scStack.push(0); // south pole
 texc.push(1); // south pole
 zEnd.push(1); // south pole
 var slicesTimes2=slices*2;
  var lastZeCen=-1;
  var lastRad=0;
  var lastRadNorm=0;
  var lastTex=0;
  function normAndVertex(m,normDir,x,y,z,offset){
   m.normal3(x*normDir,y*normDir,z*normDir);
   m.vertex3(x,y,z+offset);
  }
  for(i=0;i&lt;stacks;i++){
   var zsCen=lastZeCen;
   var zeCen=zEnd[i];
   var texStart=lastTex;
   var texEnd=texc[i];
   var zStartHeight=radius*zsCen;
   var zEndHeight=radius*zeCen;
   var offset=(i&lt;halfStacks) ? -halfLength : halfLength;
   var zStartNorm=normDir*zsCen;
   var zEndNorm=normDir*zeCen;
   var radiusStart=lastRad;
   var radiusStartNorm=lastRadNorm;
   var radiusEnd=radius*scStack[i];
   var radiusEndNorm=normDir*scStack[i];
   var txs=texStart;
   var txe=texEnd;
   if(length>0){
    txs=(i&lt;halfStacks) ? texStart*sphereRatio :
     (1.0-(1.0-texStart)*sphereRatio);
    txe=(i&lt;halfStacks) ? texEnd*sphereRatio :
     (1.0-(1.0-texEnd)*sphereRatio);
   }
   lastZeCen=zeCen;
   lastTex=texEnd;
   lastRadNorm=radiusEndNorm;
   lastRad=radiusEnd;
   if((i===stacks-1 || i === 0)){
    mesh.mode(H3DU.Mesh.TRIANGLES);
   } else {
    mesh.mode(H3DU.Mesh.TRIANGLE_STRIP);
    mesh.texCoord2(1,txs);
    normAndVertex(mesh,normDir,0,radiusStart,zStartHeight,offset);
    mesh.texCoord2(1,txe);
    normAndVertex(mesh,normDir,0,radiusEnd,zEndHeight,offset);
   }
   var lastTx=0;
   var lastX=0;
   var lastY=1;
   var txMiddle,tx,x,y;
   for(var k=2,j=1;k&lt;=slicesTimes2;k+=2,j++){
    tx=tc[j];
    if(i===stacks-1){
     txMiddle=lastTx+(tx-lastTx)*0.5;
     mesh.texCoord2(1-lastTx,txs);
     normAndVertex(mesh,normDir,lastX*radiusStart,lastY*radiusStart,zStartHeight,offset);
     // point at south pole
     mesh.texCoord2(1-txMiddle,txe);
     normAndVertex(mesh,normDir,0,radiusEnd,zEndHeight,offset);
     x=sc[k];
     y=sc[k+1];
     mesh.texCoord2(1-tx,txs);
     normAndVertex(mesh,normDir,x*radiusStart,y*radiusStart,zStartHeight,offset);
     lastX=x;
     lastY=y;
     lastTx=tx;
    } else if(i===0){
     txMiddle=lastTx+(tx-lastTx)*0.5;
     // point at north pole
     mesh.texCoord2(1-txMiddle,txs);
     normAndVertex(mesh,normDir,0,radiusStart,zStartHeight,offset);
     mesh.texCoord2(1-lastTx,txe);
     normAndVertex(mesh,normDir,lastX*radiusEnd,lastY*radiusEnd,zEndHeight,offset);
     x=sc[k];
     y=sc[k+1];
     mesh.texCoord2(1-tx,txe);
     normAndVertex(mesh,normDir,x*radiusEnd,y*radiusEnd,zEndHeight,offset);
     lastX=x;
     lastY=y;
     lastTx=tx;
    } else {
     x=sc[k];
     y=sc[k+1];
     mesh.texCoord2(1-tx,txs);
     normAndVertex(mesh,normDir,x*radiusStart,y*radiusStart,zStartHeight,offset);
     mesh.texCoord2(1-tx,txe);
     normAndVertex(mesh,normDir,x*radiusEnd,y*radiusEnd,zEndHeight,offset);
    }
   }
   if(i+1===halfStacks &amp;&amp; length>0){
    var sr2=sphereRatio*0.5;
    var hl=halfLength*2;
    var endr2=1.0-sr2;
    var he=1.0-sphereRatio;
    for(var m=0;m&lt;middleStacks;m++){
     s=-halfLength+(m===0 ? 0 : (hl*m/middleStacks));
     var e=(m===middleStacks-1) ? halfLength : (-halfLength+hl*(m+1)/middleStacks);
     txs=sr2+(m===0 ? 0 : (he*m/middleStacks));
     txe=(m===middleStacks-1) ? endr2 : (sr2+he*(m+1)/middleStacks);
     mesh.mode(H3DU.Mesh.TRIANGLE_STRIP);
     mesh.texCoord2(1,txs);
     normAndVertex(mesh,normDir,0,radiusEnd,zEndHeight,s);
     mesh.texCoord2(1,txe);
     normAndVertex(mesh,normDir,0,radiusEnd,zEndHeight,e);
     for(k=2,j=1;k&lt;=slicesTimes2;k+=2,j++){
      tx=tc[j];
      x=sc[k];
      y=sc[k+1];
      mesh.texCoord2(1-tx,txs);
      normAndVertex(mesh,normDir,x*radiusEnd,y*radiusEnd,zEndHeight,s);
      mesh.texCoord2(1-tx,txe);
      normAndVertex(mesh,normDir,x*radiusEnd,y*radiusEnd,zEndHeight,e);
     }
    }
   }
  }
 return flat ? mesh.recalcNormals(flat,inside) : mesh.normalizeNormals();
};

    /**
    * Creates a mesh in the form of a two-dimensional n-pointed star.
    * @param {Number} points Number of points in the star.
    * Must be 2 or greater.
    * @param {Number} firstRadius First radius of the star.
    * Must be 0 or greater; this parameter and secondRadius
    * can't both be 0.
    * @param {Number} secondRadius Second radius of the star.
    * Must be 0 or greater; this parameter and firstRadius
    * can't both be 0.
* @param {Boolean} inward If true, the normals generated by this
* method will point in the opposite direction of the positive z-axis; otherwise,
* in the same direction of the positive z-axis.  Default is false.
    * @returns {H3DU.Mesh} The generated mesh.
    */
    H3DU.Meshes.createPointedStar=function(points, firstRadius, secondRadius,inward){
     var mesh=new H3DU.Mesh();
     if(points&lt;2 || firstRadius&lt;0 || secondRadius&lt;0)return mesh;
     if(firstRadius&lt;=0 &amp;&amp; secondRadius&lt;=0)return mesh;
     mesh.mode(H3DU.Mesh.TRIANGLE_FAN);
     var outer=true;
     var startX=0;
     var startY=0;
     var deg360=H3DU.Math.PiTimes2;
     var recipPts2=1.0/(points*2);
     var recipRadius=1.0/Math.max(firstRadius,secondRadius);
     mesh.normal3(0,0,inward ? -1 : 1).texCoord2(0.5,0.5).vertex2(0,0);
     for(var i=0;i&lt;points*2;i++){
      var angle=deg360*i*recipPts2;
      var cangle = Math.cos(angle);
      var sangle = (angle>=0 &amp;&amp; angle&lt;6.283185307179586) ? (angle&lt;=3.141592653589793 ? Math.sqrt(1.0-cangle*cangle) : -Math.sqrt(1.0-cangle*cangle)) : Math.sin(angle);
      var radius=(i&amp;1) === 0 ? firstRadius : secondRadius;
      var x=-sangle*radius;
      var y=cangle*radius;
      var tcx=(1+x*recipRadius)*0.5;
      var tcy=(1+y*recipRadius)*0.5;
      if(i === 0){
       startX=x;
       startY=y;
      }
      mesh.texCoord2(tcx,tcy)
        .vertex2(x,y);
     }
     mesh.texCoord2(0.5*(1+startX*recipRadius),
        0.5*(1+startY*recipRadius))
       .vertex2(startX,startY);
     return mesh;
    }

this.H3DU.Meshes=H3DU.Meshes;
</code></pre>
        </article>
    </section>

</div>
<nav id="navigation">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>upokecenter.dreamhosters.com/articles/donate-now-2</b></p>
<div class=noprint>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
<h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glutil.html">glutil</a></li></ul><h3>Classes</h3><ul><li><a href="Camera.html">Camera</a></li><li><a href="global.html#CurveTube">CurveTube</a></li><li><a href="Epitrochoid.html">Epitrochoid</a></li><li><a href="GraphicsPath.html">GraphicsPath</a></li><li><a href="H3DU.Batch3D.html">Batch3D</a></li><li><a href="H3DU.BezierCurve.html">BezierCurve</a></li><li><a href="H3DU.BezierSurface.html">BezierSurface</a></li><li><a href="H3DU.BSplineCurve.html">BSplineCurve</a></li><li><a href="H3DU.BSplineSurface.html">BSplineSurface</a></li><li><a href="H3DU.BufferedMesh.html">BufferedMesh</a></li><li><a href="H3DU.CurveEval.html">CurveEval</a></li><li><a href="H3DU.FrameBuffer.html">FrameBuffer</a></li><li><a href="H3DU.Lights.html">Lights</a></li><li><a href="H3DU.LightSource.html">LightSource</a></li><li><a href="H3DU.Material.html">Material</a></li><li><a href="H3DU.Math.html">Math</a></li><li><a href="H3DU.Mesh.html">Mesh</a></li><li><a href="H3DU.MeshBuffer.html">MeshBuffer</a></li><li><a href="H3DU.Meshes.html">Meshes</a></li><li><a href="H3DU.RenderPass3D.html">RenderPass3D</a></li><li><a href="H3DU.Scene3D.html">Scene3D</a></li><li><a href="H3DU.ShaderInfo.html">ShaderInfo</a></li><li><a href="H3DU.ShaderProgram.html">ShaderProgram</a></li><li><a href="H3DU.Shape.html">Shape</a></li><li><a href="H3DU.ShapeGroup.html">ShapeGroup</a></li><li><a href="H3DU.SurfaceEval.html">SurfaceEval</a></li><li><a href="H3DU.TextFont.html">TextFont</a></li><li><a href="H3DU.Texture.html">Texture</a></li><li><a href="H3DU.TextureLoader.html">TextureLoader</a></li><li><a href="H3DU.Transform.html">Transform</a></li><li><a href="Hypotrochoid.html">Hypotrochoid</a></li><li><a href="MeshJSON.html">MeshJSON</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="Promise.html">Promise</a></li><li><a href="SurfaceOfRevolution.html">SurfaceOfRevolution</a></li><li><a href="Trochoid.html">Trochoid</a></li></ul><h3>Namespaces</h3><ul><li><a href="H3DU.html">H3DU</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera_.html">The "Camera" and the Projection and View Transforms</a></li><li><a href="tutorial-filters.html">Graphics Filters</a></li><li><a href="tutorial-glmath.html">GLMath Math Library</a></li><li><a href="tutorial-history.html">Older Version History</a></li><li><a href="tutorial-matrixdetails.html">Matrix Details</a></li><li><a href="tutorial-meshexamples.html">Examples of Creating Meshes on the Fly</a></li><li><a href="tutorial-overview.html">Library Overview</a></li><li><a href="tutorial-paths.html">2-Dimensional Graphics Paths</a></li><li><a href="tutorial-shapes.html">Creating Shapes</a></li><li><a href="tutorial-surfaces.html">Parametric Curves and Parametric Surfaces</a></li><li><a href="tutorial-textures.html">Texture Examples</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
