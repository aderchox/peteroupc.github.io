<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Source: extras/objmtl.js</title>
<meta name="viewport" content="width=device-width">
<script src="mathml.js"></script>
<link rel=stylesheet type="text/css" href="/style.css">
</head>
<body style="margin-top:0px">
<div class="header">
<p><a href="#navigation">Menu</a> - <a href="/">Home</a> -
<a href="http://upokecenter.dreamhosters.com/articles/donate-now-2/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
    <h1>Source: extras/objmtl.js</h1>

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/
/* global GLUtil, Material, Mesh, Promise, ShapeGroup */
/**
OBJ file.&lt;p>
* &lt;p>This class is considered a supplementary class to the
* Public Domain HTML 3D Library and is not considered part of that
* library. &lt;p>
* To use this class, you must include the script "extras/objmtl.js"; the
 * class is not included in the "glutil_min.js" file which makes up
 * the HTML 3D Library.  Example:&lt;pre>
 * &amp;lt;script type="text/javascript" src="extras/objmtl.js">&amp;lt;/script>&lt;/pre>
@class */
function ObjData(){
  /** URL of the OBJ file */
  "use strict";
this.url=null;
  /** An array of meshes.  Two or more meshes may have
the same name (the "name" property in each mesh).  The "data"
property holds data for each mesh. */
  this.mtllib=null;
  this.mtl=null;
  this.meshes=[];
}
function MtlData(){
  "use strict";
this.url=null;
  this.list=[];
}
/**
 * Creates one or more 3D shapes from the data
 * in this OBJ file.
 * @param {Scene3D} scene 3D scene to load the shape with.
 * @return {glutil.ShapeGroup} Group of shapes.
 */
ObjData.prototype.toShape=function(scene){
 "use strict";
var multi=new ShapeGroup();
 for(var i=0;i&lt;this.meshes.length;i++){
  var shape=scene.makeShape(this.meshes[i].data);
  var mat=this._getMaterial(this.meshes[i]);
  shape.setMaterial(mat);
  multi.addShape(shape);
 }
 return multi;
};
/**
 * Not documented yet.
 * @param {*} scene
 * @param {*} resolved
 * @param {*} rejected
 */
ObjData.prototype.loadTextures=function(scene,resolved,rejected){
 "use strict";
var textures=[];
 if(this.mtl){
  for(var i=0;i&lt;this.mtl.list.length;i++){
    var mtl=this.mtl.list[i].data;
    if(mtl.texture){
      textures.push(mtl.texture);
    }
  }
 }
 return scene.loadAndMapTextures(textures,resolved,rejected);
};
/**
 * Creates one or more 3D shapes from the named portion
 * of the data in this OBJ file.
 * @param {Scene3D} scene 3D scene to load the shape with.
 * @param {string} name Name from the OBJ file of the portion
 * of the model to use.
 * @return {glutil.ShapeGroup} Group of shapes. The group
 * will be empty if no shapes with the given name exist.
 */
ObjData.prototype.toShapeFromName=function(scene, name){
 "use strict";
var multi=new ShapeGroup();
 for(var i=0;i&lt;this.meshes.length;i++){
  if(this.meshes[i].name!==name)continue;
  var shape=scene.makeShape(this.meshes[i].data);
  var mat=this._getMaterial(this.meshes[i]);
  shape.setMaterial(mat);
  multi.addShape(shape);
 }
 return multi;
};
ObjData._resolvePath=function(path, name){
 // Relatively dumb for a relative path
 // resolver, but sufficient here, as it will
 // only be used with relative "mtllib"/"map_Kd"
 // strings
 "use strict";
var ret=path;
 var lastSlash=ret.lastIndexOf("/");
 if(lastSlash>=0){
  ret=ret.substr(0,lastSlash+1)+name.replace(/\\/g,"/");
 } else {
  ret=name.replace(/\\/g,"/");
 }
 return ret;
};

/** @private */
ObjData.prototype._getMaterial=function(mesh){
 "use strict";
if(!this.mtl || !mesh){
  return new Material();
 } else {
  if(mesh.usemtl){
   var mtl=this.mtl.getMaterial(mesh.usemtl);
   if(!mtl)return new Material();
   return mtl;
  } else {
   return new Material();
  }
 }
};

/** @private */
MtlData.prototype._resolveTextures=function(){
  "use strict";
for(var i=0;i&lt;this.list.length;i++){
    var mtl=this.list[i].data;
    if(mtl.texture){
     var resolvedName=ObjData._resolvePath(
       this.url,mtl.texture.name);
     this.list[i].data=mtl.copy()
       .setParams({"texture":resolvedName});
    }
  }
};
/**
 * Not documented yet.
 * @param {*} name
 */
MtlData.prototype.getMaterial=function(name){
  "use strict";
for(var i=0;i&lt;this.list.length;i++){
    if(this.list[i].name===name){
      return this.list[i].data;
    }
  }
  return null;
};
MtlData._getMaterial=function(mtl){
 "use strict";
var shininess=1.0;
 var ambient=null;
 var diffuse=null;
 var specular=null;
 var emission=null;
 var specularName=null;
 var normalName=null;
 var textureName=null;
 if(mtl.hasOwnProperty("Ns")){
  shininess=mtl.Ns;
 }
 if(mtl.hasOwnProperty("Kd")){
  diffuse=(mtl.Kd);
 }
 if(mtl.hasOwnProperty("map_Kd")){
  textureName=mtl.map_Kd;
 }
 if(mtl.hasOwnProperty("map_Ks")){
  specularName=mtl.map_Ks;
 }
 if(mtl.hasOwnProperty("map_Bump")){
  normalName=mtl.map_Bump;
 }
 if(mtl.hasOwnProperty("map_bump")){
  normalName=mtl.map_bump;
 }
 if(mtl.hasOwnProperty("bump")){
  normalName=mtl.bump;
 }
 if(mtl.hasOwnProperty("Ka")){
  ambient=(mtl.Ka);
 }
 if(mtl.hasOwnProperty("Ke")){
  var ke=mtl.Ke;
  if(ke.length===1){
   emission=[ke,ke,ke];
  } else {
   emission=(ke);
  }
 }
 if(mtl.hasOwnProperty("Ks")){
  specular=(mtl.Ks);
 }
 // NOTE: illum must be checked last
 if(mtl.hasOwnProperty("illum")){
  if(mtl.illum===0){
   ambient=diffuse;
   diffuse=[0,0,0];
   specular=[0,0,0];
  } else if(mtl.illum===1){
   specular=[0,0,0];
  }
 }
 var ret=new Material(ambient,diffuse,specular,shininess,
   emission);
 if(textureName){
  ret=ret.setParams({
   "texture":textureName
  });
 }
 if(specularName){
  ret=ret.setParams({
   "specularMap":specularName
  });
 }
 if(normalName){
  ret=ret.setParams({
   "normalMap":normalName
  });
 }
 return ret;
};
ObjData.loadMtlFromUrl=function(url){
 "use strict";
return GLUtil.loadFileFromUrl(url).then(
   function(e){
     var mtl=MtlData._loadMtl(e.data);
     if(mtl.error)return Promise.reject({"url":e.url, "error": mtl.error});
     var mtldata=mtl.success;
     mtldata.url=e.url;
     mtldata._resolveTextures();
     return Promise.resolve(mtldata);
   },
   function(e){
     return Promise.reject(e);
   });
};
/**
Loads a WaveFront OBJ file (along with its associated MTL, or
material file, if available) asynchronously.
@param {string} url The URL to load.
@return {Promise} A promise that resolves when
the OBJ file is loaded successfully, whether or not its associated
MTL is also loaded successfully (the result is an ObjData object),
and is rejected when an error occurs when loading the OBJ file.
*/
ObjData.loadObjFromUrl=function(url){
 "use strict";
return GLUtil.loadFileFromUrl(url).then(
   function(e){
     var obj;
     obj=ObjData._loadObj(e.data);
     if(obj.error)return Promise.reject({"url":e.url, "error":obj.error});
     obj=obj.success;
     obj.url=e.url;
     if(obj.mtllib){
       // load the material file if available
       var mtlURL=ObjData._resolvePath(e.url,obj.mtllib);
       return ObjData.loadMtlFromUrl(mtlURL).then(
        function(result){
          obj.mtl=result;
          return Promise.resolve(obj);
        }, function(result){
          // MTL not loaded successfully, ignore
          obj.mtl=null;
          return Promise.resolve(obj);
        });
     } else {
       // otherwise just return the object
       return Promise.resolve(obj);
     }
   },
   function(e){
     return Promise.reject(e);
   });
};
MtlData._loadMtl=function(str){
 "use strict";
function xyzToRgb(xyz){
  // convert CIE XYZ to RGB
  var x=xyz[0];
  var y=xyz[1];
  var z=xyz[2];
  var rgb=[2.2878384873407613*x-0.8333676778352163*y-0.4544707958714208*z,
    -0.5116513807438615*x+1.4227583763217775*y+0.08889300175529392*z,
    0.005720409831409596*x-0.01590684851040362*y+1.0101864083734013*z];
  // ensure RGB value fits in 0..1
  var w=-Math.min(0,rgb[0],rgb[1],rgb[2]);
  if(w>0){
    rgb[0]+=w; rgb[1]+=w; rgb[2]+=w;
  }
  w=Math.max(rgb[0],rgb[1],rgb[2]);
  if(w>1){
    rgb[0]/=w; rgb[1]/=w; rgb[2]/=w;
  }
  return rgb;
 }
 var number="(-?(?:\\d+\\.?\\d*|\\d*\\.\\d+)(?:[Ee][\\+\\-]?\\d+)?)";
 var nonnegInteger="(\\d+)";
 var oneNumLine=new RegExp("^[ \\t]*(Ns|d|Tr|Ni)\\s+"+number+"\\s*$");
 var oneIntLine=new RegExp("^[ \\t]*(illum)\\s+"+nonnegInteger+"\\s*$");
 var threeNumLine=new RegExp("^[ \\t]*(Tf)\\s+"+number+"\\s+"+number+
   "\\s+"+number+"\\s*$");
 var oneOrThreeNumLine=new RegExp("^[ \\t]*(Ke)\\s+"+number+"(?:\\s+"+number+
   "\\s+"+number+")?\\s*$");
 var threeOrFourNumLine=new RegExp("^[ \\t]*(Kd|Ka|Ks)\\s+"+number+"\\s+"+number+
   "\\s+"+number+"(?:\\s+"+number+")?\\s*$");
 var threeOrFourNumLineXYZ=new RegExp("^[ \\t]*(Kd|Ka|Ks)\\s+xyz\\s+"+number+"\\s+"+number+
   "\\s+"+number+"(?:\\s+"+number+")?\\s*$");
 var mapLine=new RegExp("^[ \\t]*(map_Kd|bump|map_[Bb]ump|map_Ka|map_Ks)\\s+(.*?)\\s*$");
 var newmtlLine=new RegExp("^newmtl\\s+([^\\s]*)$");
 var faceStart=new RegExp("^f\\s+");
 var lines=str.split(/\r?\n/);
 var firstLine=true;
 var materials=[];
 var currentMat=null;
 for(var i=0;i&lt;lines.length;i++){
  var line=lines[i];
  // skip empty lines
  if(line.length===0)continue;
  // skip comments
  if(line.charAt(0)==="#")continue;
  while(line.charAt(line.length-1)==="\\" &amp;&amp;
    i+1&lt;line.length){
    // The line continues on the next line
   line=line.substr(0,line.length-1);
   line+=" "+lines[i+1];
   i++;
  }
  if(line.charAt(line.length-1)==="\\"){
   line=line.substr(0,line.length-1);
  }
  if(firstLine &amp;&amp; !(/^newmtl\s+/)){
   return {"error": "newmtl not the first line in MTL file"};
  }
  firstLine=false;
  var e=newmtlLine.exec(line);
  if(e){
    var name=e[1];
    currentMat={};
    materials.push({name:name, data: currentMat});
    continue;
  }
  e=threeOrFourNumLine.exec(line);
  if(e){
    if(e[5]){
      currentMat[e[1]]=[parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5])];
    } else {
      currentMat[e[1]]=[parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])];
    }
    continue;
  }
  e=threeOrFourNumLineXYZ.exec(line);
  if(e){
    if(e[5]){
      currentMat[e[1]]=xyzToRgb([parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])]);
      currentMat[e[1]][3]=parseFloat(e[5]);
    } else {
      currentMat[e[1]]=xyzToRgb([parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])]);
    }
    continue;
  }
  e=threeNumLine.exec(line);
  if(e){
    currentMat[e[1]]=[parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])];
    continue;
  }
  e=oneOrThreeNumLine.exec(line);
  if(e){
    if(e[3]){
      currentMat[e[1]]=[parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])];
    } else {
      currentMat[e[1]]=[parseFloat(e[2]),parseFloat(e[2]),parseFloat(e[2])];
    }
    continue;
  }
  e=oneNumLine.exec(line);
  if(e){
    currentMat[e[1]]=parseFloat(e[2]);
    continue;
  }
  e=mapLine.exec(line);
  if(e){
     // only allow relative paths
    if((/^(?![\/\\])([^\:\?\#\s]+)$/).test(e[2])){
     currentMat[e[1]]=e[2];
    }
    continue;
  }
  e=oneIntLine.exec(line);
  if(e){
    currentMat[e[1]]=[parseInt(e[2],10)];
    continue;
  }
  return {"error": new Error("unsupported line: "+line)};
 }
 var mtl=new MtlData();
 mtl.list=materials;
 for(i=0;i&lt;mtl.list.length;i++){
  mtl.list[i].data=MtlData._getMaterial(mtl.list[i].data);
 }
 return {success: mtl};
};
ObjData._refIndex=function(idxstr,arr){
 "use strict";
var ret=parseInt(idxstr,10);
 ret=(ret&lt;0) ? arr.length-ret : ret-1;
 if(ret&lt;0 || ret>=arr.length)ret=0;
 return ret;
};
ObjData._loadObj=function(str){
 "use strict";
var number="(-?(?:\\d+\\.?\\d*|\\d*\\.\\d+)(?:[Ee][\\+\\-]?\\d+)?)";
 var signedInteger="(-?\\d+)";
 var vertexOnly=new RegExp("^"+signedInteger+"($|\\s+)");
 var vertexNormalOnly=new RegExp("^"+signedInteger+"\\/\\/"+signedInteger+"($|\\s+)");
 var vertexUVOnly=new RegExp("^"+signedInteger+"\\/"+
   signedInteger+"($|\\s+)");
 var vertexUVNormal=new RegExp("^"+signedInteger+"\\/"+signedInteger+
   "\\/"+signedInteger+"($|\\s+)");
 var vertexLine=new RegExp("^v\\s+"+number+"\\s+"+number+"\\s+"+number+"\\s*$");
 var uvLine=new RegExp("^vt\\s+"+number+"\\s+"+number+"(\\s+"+number+")?\\s*$");
 var smoothLine=new RegExp("^(s)\\s+(.*)$");
 var usemtlLine=new RegExp("^(usemtl|o|g)\\s+([^\\s]*)\\s*$");
 var mtllibLine=new RegExp("^(mtllib)\\s+(?![\\/\\\\])([^\\:\\?\\#\\t\\r\\n]+)\\s*$");
 var normalLine=new RegExp("^vn\\s+"+number+"\\s+"+number+"\\s+"+number+"\\s*");
 var faceStart=new RegExp("^f\\s+");
 var lineStart=new RegExp("^l\\s+");
 var pointStart=new RegExp("^p\\s+");
 var lines=str.split(/\r?\n/);
 var vertices=[];
 var currentMesh=new Mesh();
 var normals=[];
 var uvs=[];
 var faces=[];
 var meshName=name;
 var usemtl=null;
 var currentFaces=[];
 var ret=new ObjData();
 var lastPrimitiveSeen=-1;
 var haveNormals=false;
 var vertexKind=-1;
 var mesh=new Mesh();
 var objName="";
 var oldObjName="";
 var seenFacesAfterObjName=false;
 var flat=false;
 for(var i=0;i&lt;lines.length;i++){
  var line=lines[i];
  // skip empty lines
  if(line.length === 0)continue;
  // skip comments
  if(line.charAt(0)==="#")continue;
  while(line.charAt(line.length-1)==="\\" &amp;&amp;
    i+1&lt;line.length){
    // The line continues on the next line
   line=line.substr(0,line.length-1);
   line+=" "+lines[i+1];
   i++;
  }
  if(line.charAt(line.length-1)==="\\"){
   line=line.substr(0,line.length-1);
  }
  var e=vertexLine.exec(line);
  if(e){
    vertices.push([parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])]);
    continue;
  }
  e=normalLine.exec(line);
  if(e){
    normals.push([parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])]);
    continue;
  }
  e=uvLine.exec(line);
  if(e){
    uvs.push([parseFloat(e[1]),parseFloat(e[2])]);
    continue;
  }
  var prim=-1;
  e=faceStart.exec(line);
  if(e){
   prim=Mesh.TRIANGLES;
  } else {
   e=lineStart.exec(line);
   if(e){
    prim=Mesh.LINES;
   } else {
    e=pointStart.exec(line);
    if(e){
     prim=Mesh.POINTS;
    }
   }
  }
  var vtx,uv,norm;
  if(e &amp;&amp; prim!==-1){
    var oldline=line;
    seenFacesAfterObjName=true;
    line=line.substr(e[0].length);
    if(lastPrimitiveSeen!==-1 &amp;&amp; lastPrimitiveSeen!==prim &amp;&amp;
        mesh.vertexCount()>0){
       if(!haveNormals){
         // No normals in this mesh, so calculate them
         mesh.recalcNormals(flat);
      }
      ret.meshes.push({
          "name": seenFacesAfterObjName ? objName : oldObjName,
          "usemtl": usemtl, "data": mesh});
      vertexKind=-1;
      lastPrimitiveSeen=-1;
      haveNormals=false;
      mesh=new Mesh();
    }
    mesh.mode(prim===Mesh.TRIANGLES ?
      Mesh.TRIANGLE_FAN :
      (prim===Mesh.LINES ? Mesh.LINE_STRIP : Mesh.POINTS));
    while(line.length>0){
     e=vertexOnly.exec(line);
     if(e){
      if(vertexKind!==0 || lastPrimitiveSeen!==prim){
       vertexKind=0; // position only
      }
      vtx=ObjData._refIndex(e[1],vertices);
      mesh.normal3(0,0,0).texCoord2(0,0)
        .vertex3(vertices[vtx][0],vertices[vtx][1],vertices[vtx][2]);
        line=line.substr(e[0].length);
      continue;
     }
     e=vertexNormalOnly.exec(line);
     if(e){
      if(vertexKind!==1){
       vertexKind=1; // position/normal
      }
      vtx=ObjData._refIndex(e[1],vertices);
      norm=ObjData._refIndex(e[2],normals);
      haveNormals=true;
      mesh.normal3(normals[norm][0],normals[norm][1],
         normals[norm][2])
        .texCoord2(0,0)
        .vertex3(vertices[vtx][0],vertices[vtx][1],vertices[vtx][2]);
        line=line.substr(e[0].length);
      continue;
     }
     e=vertexUVOnly.exec(line);
     if(e){
      if(vertexKind!==2 || lastPrimitiveSeen!==prim){
       vertexKind=2; // position/UV
      }
      vtx=ObjData._refIndex(e[1],vertices);
      uv=ObjData._refIndex(e[2],uvs);
      mesh.normal3(0,0,0)
        .texCoord2(uvs[uv][0],uvs[uv][1])
        .vertex3(vertices[vtx][0],vertices[vtx][1],vertices[vtx][2]);
        line=line.substr(e[0].length);
      continue;
     }
     e=vertexUVNormal.exec(line);
     if(e){
      if(vertexKind!==3 || lastPrimitiveSeen!==prim){
       vertexKind=3; // position/UV/normal
      }
      vtx=ObjData._refIndex(e[1],vertices);
      uv=ObjData._refIndex(e[2],uvs);
      norm=ObjData._refIndex(e[3],normals);
      haveNormals=true;
      mesh.normal3(normals[norm][0],normals[norm][1],
         normals[norm][2])
        .texCoord2(uvs[uv][0],uvs[uv][1])
        .vertex3(vertices[vtx][0],vertices[vtx][1],vertices[vtx][2]);
        line=line.substr(e[0].length);
      continue;
     }
     return {"error": new Error("unsupported face: "+oldline)};
    }
    continue;
  }
  e=usemtlLine.exec(line);
  if(e){
    if(e[1]==="usemtl"){
      // Changes the material used
      if(mesh.vertexCount()>0){
        if(!haveNormals){
         // No normals in this mesh, so calculate them
         mesh.recalcNormals(flat);
        }
        ret.meshes.push({
          "name": seenFacesAfterObjName ? objName : oldObjName,
          "usemtl": usemtl, "data": mesh});
        vertexKind=-1;
        lastPrimitiveSeen=-1;
        haveNormals=false;
        mesh=new Mesh();
      }
      usemtl=e[2];
    } else if(e[1]==="g"){
      // Starts a new group
      if(mesh.vertexCount()>0){
        if(!haveNormals){
         // No normals in this mesh, so calculate them
         mesh.recalcNormals(flat);
        }
        ret.meshes.push({
          "name": seenFacesAfterObjName ? objName : oldObjName,
          "usemtl": usemtl, "data": mesh});
        vertexKind=-1;
        lastPrimitiveSeen=-1;
        haveNormals=false;
        usemtl=null;
        mesh=new Mesh();
      }
      meshName=e[2];
    } else if(e[1]==="o"){
      oldObjName=objName;
      objName=e[2];
      seenFacesAfterObjName=false;
    }
    continue;
  }
  e=mtllibLine.exec(line);
  if(e){
    if(e[1]==="mtllib"){
      ret.mtllib=e[2];
    }
    continue;
  }
  e=smoothLine.exec(line);
  if(e){
    flat=(e[2]==="off");
    continue;
  }
  return {"error": new Error("unsupported line: "+line)};
 }
 if(!haveNormals){
   // No normals in this mesh, so calculate them
   mesh.recalcNormals(flat);
 }
 ret.meshes.push({
          "name": seenFacesAfterObjName ? objName : oldObjName,
          "usemtl": usemtl, "data": mesh});
 return {"success": ret};
};
</code></pre>
        </article>
    </section>

</div>
<nav id="navigation">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>upokecenter.dreamhosters.com/articles/donate-now-2</b></p>
<div class=noprint>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
<h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glmath.html">glmath</a></li><li><a href="module-glutil.html">glutil</a></li></ul><h3>Classes</h3><ul><li><a href="BezierCurve.html">BezierCurve</a></li><li><a href="BezierSurface.html">BezierSurface</a></li><li><a href="BSplineCurve.html">BSplineCurve</a></li><li><a href="BSplineSurface.html">BSplineSurface</a></li><li><a href="Camera.html">Camera</a></li><li><a href="CurveEval.html">CurveEval</a></li><li><a href="CurveTube.html">CurveTube</a></li><li><a href="Epitrochoid.html">Epitrochoid</a></li><li><a href="glmath.GLMath.html">GLMath</a></li><li><a href="glutil.GLUtil.html">GLUtil</a></li><li><a href="glutil.Lights.html">Lights</a></li><li><a href="glutil.LightSource.html">LightSource</a></li><li><a href="glutil.Material.html">Material</a></li><li><a href="glutil.Mesh.html">Mesh</a></li><li><a href="glutil.Meshes.html">Meshes</a></li><li><a href="glutil.Scene3D.html">Scene3D</a></li><li><a href="glutil.ShaderProgram.html">ShaderProgram</a></li><li><a href="glutil.Shape.html">Shape</a></li><li><a href="glutil.ShapeGroup.html">ShapeGroup</a></li><li><a href="glutil.SurfaceEval.html">SurfaceEval</a></li><li><a href="glutil.Texture.html">Texture</a></li><li><a href="glutil.Transform.html">Transform</a></li><li><a href="GraphicsPath.html">GraphicsPath</a></li><li><a href="Hypotrochoid.html">Hypotrochoid</a></li><li><a href="MatrixStack.html">MatrixStack</a></li><li><a href="MeshJSON.html">MeshJSON</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="Promise.html">Promise</a></li><li><a href="SurfaceOfRevolution.html">SurfaceOfRevolution</a></li><li><a href="Trochoid.html">Trochoid</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera_.html">The "Camera" and the Projection and View Transforms</a></li><li><a href="tutorial-filters.html">Graphics Filters</a></li><li><a href="tutorial-glmath.html">GLMath Math Library</a></li><li><a href="tutorial-history.html">Older Version History</a></li><li><a href="tutorial-matrixdetails.html">Matrix Details</a></li><li><a href="tutorial-meshexamples.html">Examples of Creating Meshes on the Fly</a></li><li><a href="tutorial-overview.html">Library Overview</a></li><li><a href="tutorial-paths.html">2-Dimensional Graphics Paths</a></li><li><a href="tutorial-shapes.html">Creating Shapes</a></li><li><a href="tutorial-surfaces.html">Parametric Curves and Parametric Surfaces</a></li><li><a href="tutorial-textures.html">Texture Examples</a></li></ul>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
